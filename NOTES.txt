config/database.js:
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error connecting to MongoDB: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;

config/gemini.js:
// config/gemini.js
const { GoogleGenerativeAI } = require("@google/generative-ai");

// Access your API key as an environment variable
if (!process.env.GEMINI_API_KEY) {
    console.warn("GEMINI_API_KEY is not set in .env file. Gemini features will be disabled.");
}

const genAI = process.env.GEMINI_API_KEY ? new GoogleGenerativeAI(process.env.GEMINI_API_KEY) : null;

const textModel = genAI ? genAI.getGenerativeModel({ model: "gemini-2.0-flash"}) : null; // Use appropriate model

if (genAI && textModel) {
    console.log("Gemini AI SDK Initialized successfully.");
} else {
     console.log("Gemini AI SDK could not be initialized (API Key missing?).");
}

module.exports = { textModel }; // Export the model instance

config/mailer.js:
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
  host: process.env.MAIL_HOST,
  port: parseInt(process.env.MAIL_PORT, 10),
  secure: parseInt(process.env.MAIL_PORT, 10) === 465,
  auth: {
    user: process.env.MAIL_USER,
    pass: process.env.MAIL_PASS,
  },
});

transporter.verify((error, success) => {
  if (error) {
    console.error('Error with Nodemailer transporter configuration:', error);
  } else {
    console.log('Nodemailer transporter is ready to send emails');
  }
});

const sendEmail = async (to, subject, text, html) => {
  try {
    await transporter.sendMail({
      from: process.env.MAIL_FROM,
      to: to,
      subject: subject,
      text: text,
      html: html,
    });
    console.log(`Email sent successfully to ${to}`);
    return true;
  } catch (error) {
    console.error(`Error sending email to ${to}:`, error);
    return false;
  }
};

module.exports = { sendEmail };


controllers/adminController.js:
// controllers/adminController.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const BannerConfig = require('../models/BannerConfig'); // *** ADDED THIS LINE ***
const { sendEmail } = require('../config/mailer');
const { reviewProductWithGemini } = require('../services/geminiService');
const {
    generateAndSendDirectDeliveryOTPByAdmin,
    confirmDirectDeliveryByAdmin,
} = require('./orderController'); // Assuming these functions handle OTP logic correctly
const mongoose = require('mongoose');

const cancellationReasons = [
    "ðŸ“ž Unable to contact the customer",
    "â— Out of stock/unavailable item",
    "ðŸ—ºï¸ Address incorrect/incomplete",
    "ðŸš« Customer requested cancellation",
    "â“ Other (Admin)",
];

// --- Admin Dashboard ---
exports.getAdminDashboard = (req, res) => {
    res.render('admin/dashboard', { title: 'Admin Dashboard' });
};

// --- Admin Product Upload Page ---
exports.getUploadProductPage = (req, res) => {
    res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: {} });
};

// --- Admin Product Upload Action ---
exports.uploadProduct = async (req, res, next) => {
    const { name, category, price, stock, imageUrl, specifications } = req.body;
    const adminUserId = req.session.user._id;
    const adminUserEmail = req.session.user.email;

    // Basic Validation (keep existing)
    if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields (Name, Category, Price, Stock, Image URL).');
        return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body });
    }
    if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
        req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
        return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body });
    }

    try {
        const newProduct = new Product({
            name: name.trim(),
            category: category.trim(),
            price: Number(price),
            stock: Number(stock),
            imageUrl: imageUrl.trim(),
            specifications: specifications ? specifications.trim() : '',
            sellerId: adminUserId,
            sellerEmail: adminUserEmail,
            reviewStatus: 'pending'
        });

        await newProduct.save();
        console.log(`Product ${newProduct._id} saved initially by ADMIN ${adminUserEmail}.`);

        // Send for Gemini Review (Asynchronous - keep existing)
        reviewProductWithGemini(newProduct).then(async reviewResult => {
            try {
                const productToUpdate = await Product.findById(newProduct._id);
                if (productToUpdate) {
                    productToUpdate.reviewStatus = reviewResult.status;
                    productToUpdate.rejectionReason = reviewResult.reason;
                    await productToUpdate.save();
                    console.log(`Product ${newProduct._id} (Admin Upload) review status updated to ${reviewResult.status}.`);
                }
            } catch (updateError) {
                console.error(`Error updating product ${newProduct._id} (Admin Upload) after Gemini review:`, updateError);
            }
        }).catch(reviewError => {
            console.error(`Error in Gemini review promise chain for product ${newProduct._id} (Admin Upload):`, reviewError);
            Product.findByIdAndUpdate(newProduct._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed.' }).catch(err => console.error("Failed to mark admin-uploaded product as pending after review error:", err));
        });

        req.flash('success_msg', `Product "${newProduct.name}" uploaded and submitted for review.`);
        res.redirect('/admin/manage-products');

    } catch (error) {
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
           return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body });
       }
        console.error("Error uploading product by Admin:", error);
        next(error);
    }
};


// --- Manage Products (Admin sees ALL - keep existing) ---
exports.getManageProductsPage = async (req, res, next) => {
    try {
        const products = await Product.find({})
                                    .populate('sellerId', 'name email')
                                    .sort({ createdAt: -1 })
                                    .lean();
        res.render('admin/manage-products', {
            title: 'Manage All Products',
            products: products
        });
    } catch (error) {
        next(error);
    }
};

// --- Edit Product (Admin edits ANY - keep existing) ---
exports.getEditProductPage = async (req, res, next) => {
    try {
        const product = await Product.findById(req.params.id)
                                     .populate('sellerId', 'name email')
                                     .lean();
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.redirect('/admin/manage-products');
        }
        res.render('admin/edit-product', {
            title: `Admin Edit: ${product.name}`,
            product: product,
            isAdminView: true
        });
    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.redirect('/admin/manage-products');
        }
        next(error);
    }
};

// --- Update Product (Admin updates ANY - keep existing) ---
exports.updateProduct = async (req, res, next) => {
    const productId = req.params.id;
    const { name, category, price, stock, imageUrl, specifications, reviewStatus, rejectionReason } = req.body;

    // Validation (keep existing)
    if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields.');
        return res.redirect(`/admin/manage-products/edit/${productId}`);
    }
    if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
        req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
        return res.redirect(`/admin/manage-products/edit/${productId}`);
    }
    const allowedStatus = ['pending', 'approved', 'rejected'];
    if (reviewStatus && !allowedStatus.includes(reviewStatus)) {
        req.flash('error_msg', 'Invalid review status selected.');
        return res.redirect(`/admin/manage-products/edit/${productId}`);
    }
    if (reviewStatus === 'rejected' && !rejectionReason?.trim()) {
        req.flash('error_msg', 'Rejection reason is required when setting status to Rejected.');
        return res.redirect(`/admin/manage-products/edit/${productId}`);
    }

    try {
        const product = await Product.findById(productId);
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('/admin/manage-products');
        }

        product.name = name.trim();
        product.category = category.trim();
        product.price = Number(price);
        product.stock = Number(stock);
        product.imageUrl = imageUrl.trim();
        product.specifications = specifications ? specifications.trim() : '';

        if (reviewStatus && allowedStatus.includes(reviewStatus)) {
            product.reviewStatus = reviewStatus;
            product.rejectionReason = (reviewStatus === 'rejected') ? rejectionReason.trim() : undefined;
        }

        await product.save();
        req.flash('success_msg', `Product "${product.name}" updated successfully by admin.`);
        res.redirect('/admin/manage-products');

    } catch (error) {
        if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
            return res.redirect(`/admin/manage-products/edit/${productId}`);
        }
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.status(400).redirect('/admin/manage-products');
        }
        console.error("Error updating product by Admin:", error);
        next(error);
    }
};


// --- Remove Product (Admin removes ANY - keep existing) ---
exports.removeProduct = async (req, res, next) => {
    const productId = req.params.id;
    try {
        const product = await Product.findByIdAndDelete(productId);
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('/admin/manage-products');
        }
        req.flash('success_msg', `Product "${product.name}" removed successfully by admin.`);
        res.redirect('/admin/manage-products');
    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.status(400).redirect('/admin/manage-products');
        }
        console.error("Error removing product by Admin:", error);
        next(error);
    }
};


// --- Manage Orders (Admin sees ALL - keep existing) ---
exports.getManageOrdersPage = async (req, res, next) => {
    try {
        const orders = await Order.find({})
                                   .sort({ orderDate: -1 })
                                   .select('-__v -products.__v -shippingAddress._id')
                                   .populate('products.productId', 'name imageUrl _id price sellerId')
                                   .populate('userId', 'name email')
                                   .lean();

        const now = Date.now();

        orders.forEach(order => {
            order.canBeCancelledByAdmin = order.status === 'Pending';
            order.canBeDirectlyDeliveredByAdmin = order.status === 'Pending';
            order.showDeliveryOtp = order.status === 'Pending' && !!order.orderOTP && !!order.orderOTPExpires && new Date(order.orderOTPExpires).getTime() > now;

            if (order.products && order.products.length > 0) {
                order.itemsSummary = order.products.map(p => {
                    const productName = p.productId?.name || p.name || '[Product Missing]';
                    const price = p.priceAtOrder ?? 0;
                    return `${productName} (Qty: ${p.quantity}) @ â‚¹${price.toFixed(2)}`;
                }).join('<br>');
            } else {
                order.itemsSummary = 'No items found';
            }
        });

        res.render('admin/manage-orders', {
            title: 'Manage All Orders',
            orders: orders,
            cancellationReasons: cancellationReasons
        });
    } catch (error) {
        next(error);
    }
};

// --- Admin Order Actions (keep existing) ---
exports.sendDirectDeliveryOtpByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    try {
        const result = await generateAndSendDirectDeliveryOTPByAdmin(orderId);
        req.flash('success_msg', result.message + ' Ask customer for OTP.');
    } catch (error) {
        req.flash('error_msg', `Admin OTP Send Failed: ${error.message}`);
    }
    res.redirect('/admin/manage-orders');
};

exports.confirmDirectDeliveryByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { otp } = req.body;
    const adminUserId = req.session.user._id;

    if (!otp || !/^\d{6}$/.test(otp.trim())) {
        req.flash('error_msg', 'Please enter the 6-digit OTP.');
        return res.redirect('/admin/manage-orders');
    }

    try {
        const { order } = await confirmDirectDeliveryByAdmin(orderId, adminUserId, otp.trim(), res);
        req.flash('success_msg', `Order ${orderId} confirmed delivered by Admin.`);
    } catch (error) {
        req.flash('error_msg', `Admin Delivery Confirm Failed: ${error.message}`);
    }
    res.redirect('/admin/manage-orders');
};

exports.cancelOrderByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const adminUserId = req.session.user._id;

    if (!reason || !cancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid admin reason for cancellation.');
        return res.redirect('/admin/manage-orders');
    }

    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction();
    try {
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'name _id')
                                .populate('userId', 'email')
                                .session(sessionDB);

        if (!order) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/admin/manage-orders');
        }
        if (order.status !== 'Pending') {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', `Order status is '${order.status}'. Only 'Pending' orders can be cancelled.`);
            return res.redirect('/admin/manage-orders');
        }

        // Restore Stock
        const productStockRestorePromises = order.products.map(item => {
            const quantityToRestore = Number(item.quantity);
            if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                console.warn(`Admin Cancel: Invalid item P.ID ${item.productId?._id} or Qty ${item.quantity} in O.ID ${orderId}. Skipping restore.`);
                return Promise.resolve();
            }
            return Product.updateOne(
                { _id: item.productId._id },
                { $inc: { stock: quantityToRestore, orderCount: -1 } },
                { session: sessionDB }
            ).catch(err => {
               console.error(`Admin Cancel: Failed stock/count restore P.ID ${item.productId._id} O.ID ${orderId}: ${err.message}`);
            });
        });
        await Promise.allSettled(productStockRestorePromises);

        order.status = 'Cancelled';
        order.cancellationReason = reason;
        await order.save({ session: sessionDB });

        await sessionDB.commitTransaction();

        // Send Email Notification
        try {
            const customerEmail = order.userEmail || order.userId?.email;
            if(customerEmail) {
                const subjectCust = `Your Order (${order._id}) Has Been Cancelled`;
                const htmlCust = `<p>Your order (${order._id}) has been cancelled by administration.</p><p><strong>Reason:</strong> ${order.cancellationReason}</p><p>Contact support for questions.</p>`;
                await sendEmail(customerEmail, subjectCust, `Order ${order._id} cancelled. Reason: ${order.cancellationReason}`, htmlCust);
            }
        } catch (emailError) {
            console.error(`Failed sending cancellation email for order ${order._id}:`, emailError);
        }

        req.flash('success_msg', `Order ${orderId} cancelled by admin. Reason: ${reason}.`);
        res.redirect('/admin/manage-orders');

    } catch (error) {
        await sessionDB.abortTransaction();
        console.error(`Error cancelling order ${orderId} by admin ${adminUserId}:`, error);
        req.flash('error_msg', 'Failed to cancel order due to an internal error.');
        res.redirect('/admin/manage-orders');
    } finally {
        sessionDB.endSession();
    }
};


// --- Manage Users (Admin - keep existing) ---
exports.getManageUsersPage = async (req, res, next) => {
    try {
        const users = await User.find({ _id: { $ne: req.session.user._id } })
                                  .select('name email role createdAt isVerified address.phone')
                                  .sort({ createdAt: -1 })
                                  .lean();
        res.render('admin/manage-users', {
            title: 'Manage Registered Users',
            users: users
        });
    } catch (error) {
        next(error);
    }
};

// --- Update User Role (Admin - keep existing) ---
exports.updateUserRole = async (req, res, next) => {
    const userId = req.params.id;
    const { role } = req.body;
    const allowedRoles = ['user', 'admin', 'seller'];

    if (!role || !allowedRoles.includes(role)) {
        req.flash('error_msg', 'Invalid role selected.');
        return res.status(400).redirect('/admin/manage-users');
    }
    if (userId === req.session.user._id.toString()) {
         req.flash('error_msg', 'You cannot change your own role.');
         return res.redirect('/admin/manage-users');
    }

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return res.status(404).redirect('/admin/manage-users');
        }
        user.role = role;
        await user.save();
        req.flash('success_msg', `User ${user.email}'s role updated to ${role}.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid user ID format.');
            return res.status(400).redirect('/admin/manage-users');
        }
        console.error(`Error updating role for user ${userId}:`, error);
        req.flash('error_msg', 'Error updating user role.');
        res.redirect('/admin/manage-users');
    }
};

// --- Remove User (Admin - keep existing) ---
exports.removeUser = async (req, res, next) => {
    const userId = req.params.id;

    if (userId === req.session.user._id.toString()) {
        req.flash('error_msg', 'You cannot remove yourself.');
        return res.redirect('/admin/manage-users');
    }

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return res.status(404).redirect('/admin/manage-users');
        }

        if (user.role === 'admin') {
            const adminCount = await User.countDocuments({ role: 'admin' });
            if (adminCount <= 1) {
                req.flash('error_msg', 'Cannot remove the last admin account.');
                return res.redirect('/admin/manage-users');
            }
        }

        await User.deleteOne({ _id: userId });
        req.flash('success_msg', `User ${user.email} removed successfully.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid user ID format.');
            return res.status(400).redirect('/admin/manage-users');
        }
        console.error(`Error removing user ${userId}:`, error);
        req.flash('error_msg', 'Error removing user.');
        res.redirect('/admin/manage-users');
    }
};

// --- *** NEW: Banner Management Controllers *** ---

// GET request to render the banner management page
exports.getManageBannersPage = async (req, res, next) => {
    try {
        // Find the single banner configuration document (using the known key)
        let bannerConfig = await BannerConfig.findOne({ configKey: 'mainBanners' }).lean();

        // If no config exists yet, create a default structure for the view
        if (!bannerConfig) {
            bannerConfig = {
                configKey: 'mainBanners',
                banners: [] // Start with an empty array
            };
        }

        // Ensure the banners array always has 4 potential slots for the form
        const displayBanners = Array.from({ length: 4 }).map((_, index) => {
             return bannerConfig.banners[index] || { imageUrl: '', linkUrl: '', title: '' }; // Provide default empty values
         });

        res.render('admin/manage-banners', {
            title: 'Manage Homepage Banners',
            bannerConfig: { ...bannerConfig, banners: displayBanners } // Pass the structured data
        });
    } catch (error) {
        console.error("Error fetching banner configuration:", error);
        next(error);
    }
};

// POST request to update the banner URLs
exports.updateBanners = async (req, res, next) => {
    const { imageUrl1, linkUrl1, title1, imageUrl2, linkUrl2, title2, imageUrl3, linkUrl3, title3, imageUrl4, linkUrl4, title4 } = req.body;
    const adminUserId = req.session.user._id;

    // Basic validation: Ensure at least one URL is somewhat valid-looking if provided
    const urlPattern = /^https?:\/\/.+/; // Very basic check for http/https
    const bannerInputs = [
        { imageUrl: imageUrl1, linkUrl: linkUrl1, title: title1 },
        { imageUrl: imageUrl2, linkUrl: linkUrl2, title: title2 },
        { imageUrl: imageUrl3, linkUrl: linkUrl3, title: title3 },
        { imageUrl: imageUrl4, linkUrl: linkUrl4, title: title4 }
    ];

    const newBanners = [];
    let validationError = false;
    for (let i = 0; i < bannerInputs.length; i++) {
        const input = bannerInputs[i];
        const trimmedImageUrl = input.imageUrl?.trim();
        const trimmedLinkUrl = input.linkUrl?.trim();
        const trimmedTitle = input.title?.trim();

        // Only add banner if image URL is provided
        if (trimmedImageUrl) {
            if (!urlPattern.test(trimmedImageUrl)) {
                req.flash('error_msg', `Banner ${i + 1}: Image URL format is invalid.`);
                validationError = true;
                // You might choose to break or continue collecting errors
            }
            // Also validate link URL if provided
            if (trimmedLinkUrl && !urlPattern.test(trimmedLinkUrl)) {
                 req.flash('error_msg', `Banner ${i + 1}: Link URL format is invalid.`);
                 validationError = true;
             }
             if (!validationError) {
                newBanners.push({
                     imageUrl: trimmedImageUrl,
                     linkUrl: trimmedLinkUrl || undefined, // Store undefined if empty
                     title: trimmedTitle || undefined    // Store undefined if empty
                 });
             }
        }
    }

    if (validationError) {
         // Need to reconstruct the state for the view if validation fails
         const displayBannersForError = Array.from({ length: 4 }).map((_, index) => bannerInputs[index]);
         return res.render('admin/manage-banners', {
             title: 'Manage Homepage Banners',
             bannerConfig: { banners: displayBannersForError } // Pass back submitted data
             // Flash message is already set
         });
    }

    try {
        // Find and update (or create if doesn't exist) the banner config document
        await BannerConfig.findOneAndUpdate(
            { configKey: 'mainBanners' }, // Find by the key
            {
                banners: newBanners, // Set the new array of banners
                lastUpdatedBy: adminUserId // Track the update
            },
            {
                new: true, // Return the updated document
                upsert: true, // Create if document doesn't exist
                runValidators: true // Ensure arrayLimit validator runs
            }
        );

        req.flash('success_msg', 'Homepage banners updated successfully.');
        res.redirect('/admin/manage-banners');

    } catch (error) {
        if (error.name === 'ValidationError') {
             // Handle Mongoose validation errors (like array limit)
            let errors = Object.values(error.errors).map(el => el.message);
             req.flash('error_msg', `Validation Error: ${errors.join(', ')}`);
             const displayBannersForError = Array.from({ length: 4 }).map((_, index) => bannerInputs[index]);
             return res.render('admin/manage-banners', {
                  title: 'Manage Homepage Banners',
                 bannerConfig: { banners: displayBannersForError } // Pass back submitted data
             });
         }
        console.error("Error updating banners:", error);
        req.flash('error_msg', 'Failed to update banners due to a server error.');
        res.redirect('/admin/manage-banners'); // Redirect back even on other errors
    }
};

controllers/authController.js:
// controllers/authController.js
const User = require('../models/User');
const Product = require('../models/Product');
const BannerConfig = require('../models/BannerConfig'); // *** <<< ADD THIS LINE ***
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { generateOTP, setOTPExpiration } = require('../services/otpService');
const { sendEmail } = require('../config/mailer');

// --- getLoginPage, getRegisterPage, getVerifyOtpPage, etc. (No changes needed) ---
exports.getLoginPage = (req, res) => {
    if (req.session.user) {
         return res.redirect('/'); // Redirect if already logged in
    }
    res.render('auth/login', { title: 'Login' });
};

exports.getRegisterPage = (req, res) => {
    if (req.session.user) {
        return res.redirect('/'); // Redirect if already logged in
   }
    res.render('auth/register', { title: 'Register' });
};

exports.getVerifyOtpPage = (req, res) => {
    const email = req.query.email;
    if (!email) {
        req.flash('error_msg', 'Email required for OTP verification.');
        return res.redirect('/auth/register');
    }
     if (req.session.user) { // Redirect if already logged in, even on OTP page? Controversial but prevents odd states.
        return res.redirect('/');
   }
    res.render('auth/verify-otp', { title: 'Verify Email', email });
};

exports.getForgotPasswordPage = (req, res) => {
     if (req.session.user) {
         return res.redirect('/'); // Redirect if already logged in
    }
    res.render('auth/forgot-password', { title: 'Forgot Password' });
};

exports.getResetPasswordPage = async (req, res, next) => {
     if (req.session.user) { // Should logged-in users be able to reset password this way? Probably redirect.
         req.flash('info_msg', 'You are already logged in.');
         return res.redirect('/');
    }
    try {
        // Find user by token and check expiration
        const user = await User.findOne({
            resetPasswordToken: req.params.token,
            resetPasswordExpires: { $gt: Date.now() }, // Ensure token is not expired
        });

        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired.');
            return res.redirect('/auth/forgot-password');
        }
        // Token is valid, render the reset form
        res.render('auth/reset-password', { title: 'Reset Password', token: req.params.token });
    } catch (error) {
        next(error); // Pass errors to the error handler
    }
};

// --- registerUser, verifyOtp, resendOtp, loginUser (No changes needed from previous version) ---
exports.registerUser = async (req, res, next) => {
     if (req.session.user) {
        return res.redirect('/'); // Redirect if already logged in
    }
    const { name, email, password, confirmPassword } = req.body;

    // --- Input Validation ---
    let errors = [];
    if (!name || !email || !password || !confirmPassword) {
        errors.push('Please fill in all fields.');
    }
    if (password !== confirmPassword) {
        errors.push('Passwords do not match.');
    }
    if (password && password.length < 6) {
        errors.push('Password must be at least 6 characters.');
    }
    // Basic email format check (consider using a library for more robust validation)
    if (email && !/^\S+@\S+\.\S+$/.test(email)) {
        errors.push('Please enter a valid email address.');
    }

    if (errors.length > 0) {
        req.flash('error_msg', errors.join(' '));
        // Render the form again with entered values (except passwords)
        return res.render('auth/register', {
            title: 'Register',
            name: name,
            email: email, // Pass back email and name
            error_msg: req.flash('error_msg') // Ensure message is passed to view context
        });
    }

    // --- Registration Logic ---
    try {
        const lowerCaseEmail = email.toLowerCase();
        let user = await User.findOne({ email: lowerCaseEmail });

        // Handle existing users (verified or not)
        if (user && user.isVerified) {
            req.flash('error_msg', 'Email is already registered and verified. Please login.');
            return res.redirect('/auth/login');
        }

        // Generate OTP and Expiration
        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10); // 10 minutes expiry

        // Update unverified existing user or create new one
        if (user && !user.isVerified) {
            // Update existing unverified user record
            user.name = name;
            if (password) { user.password = password; } // Hash happens on save via pre-hook
            user.otp = otp;
            user.otpExpires = otpExpires;
            user.isVerified = false; // Ensure it's false
            // Skip validation if just updating OTP fields on existing unverified doc
            await user.save({ validateBeforeSave: false });
            console.log(`Updating existing unverified user: ${user.email}`);
        } else {
            // Create a new user instance
            user = new User({
                name,
                email: lowerCaseEmail,
                password, // Hash happens on save via pre-hook
                otp,
                otpExpires,
                isVerified: false,
                // Role defaults to 'user' as defined in schema
            });
            await user.save(); // This will trigger pre-save hooks (password hashing)
            console.log(`New user created: ${user.email}`);
        }

        // --- Send Verification Email ---
        const subject = 'Verify Your Email Address';
        const text = `Your verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
        const html = `<p>Welcome to our store!</p><p>Your verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;

        const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
            req.flash('success_msg', `An OTP has been sent to ${user.email}. Please check your inbox and verify.`);
            // Redirect to OTP verification page with email pre-filled
            res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
        } else {
             // If email fails, consider cleanup for newly created, unverified users to prevent orphans
             if(!user.createdAt || (Date.now() - user.createdAt.getTime()) < 5000) { // Basic check for very new user
                try {
                    // Only delete if not verified AND potentially newly created
                    await User.deleteOne({ _id: user._id, isVerified: false });
                    console.log(`Cleaned up unverified user ${user.email} due to failed email send.`);
                } catch (deleteError) {
                    console.error(`Error cleaning up unverified user ${user.email}:`, deleteError);
                }
             }
            req.flash('error_msg', 'Could not send OTP email. Please try registering again or contact support.');
            // Redirect back to registration page
            res.redirect('/auth/register');
        }

    } catch (error) {
        // Handle potential database errors
        if (error.code === 11000) { // Duplicate key error (email)
            req.flash('error_msg', 'Email already exists. Please login or use a different email.');
            // Render form again with entered values
            return res.render('auth/register', { title: 'Register', name: name, email: email });
        }
        if (error.name === 'ValidationError') { // Mongoose validation errors
           let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', validationErrors.join(' '));
            // Render form again with entered values
            return res.render('auth/register', { title: 'Register', name: name, email: email });
       }
        // For other errors, pass to the central error handler
        next(error);
    }
};

exports.verifyOtp = async (req, res, next) => {
    const { email, otp } = req.body;

     // Redirect logged-in users
     if (req.session.user) {
        return res.redirect('/');
    }

    if (!email || !otp) {
        req.flash('error_msg', 'Email and OTP are required.');
         // Redirect back to verify page, keeping email in query param if possible
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email || '')}`);
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        // Find user matching email, OTP, and non-expired OTP
        const user = await User.findOne({
            email: lowerCaseEmail,
            otp: otp.trim(), // Trim OTP input
            otpExpires: { $gt: Date.now() }, // Check expiry
        }).select('+password'); // Include password for potential immediate login

        // --- Handle User Not Found or Invalid OTP ---
        if (!user) {
            const existingUser = await User.findOne({ email: lowerCaseEmail });
            let errorMessage = 'Invalid or expired OTP. Please try again or resend.'; // Default message

            if (existingUser && existingUser.isVerified) {
                 errorMessage = 'This account is already verified. Please login.';
                 req.flash('error_msg', errorMessage);
                 return res.redirect('/auth/login');
            } else if (!existingUser) {
                 // If user doesn't exist at all (perhaps deleted during retry?)
                 errorMessage = 'Verification failed. Account not found. Please register again.';
                 req.flash('error_msg', errorMessage);
                 return res.redirect('/auth/register');
            }
            // If user exists but OTP is wrong/expired
             req.flash('error_msg', errorMessage);
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email)}`); // Keep email in query
        }

        // --- Handle Successful OTP Verification ---

         // Check if this OTP verification is part of a password reset flow
         const isPasswordReset = user.resetPasswordToken && user.resetPasswordExpires && user.resetPasswordExpires > Date.now();

         // Update user status
         user.isVerified = true;
         user.otp = undefined; // Clear OTP fields
         user.otpExpires = undefined;

         // --- Password Reset Flow ---
         if (isPasswordReset) {
             // Save user without validating (password not being changed here)
             await user.save({ validateBeforeSave: false });

             req.flash('success_msg', 'OTP Verified. Please set your new password.');
             // Redirect to the reset password form using the token
             return res.redirect(`/auth/reset-password/${user.resetPasswordToken}`);
         }
         // --- Standard Registration Flow ---
         else {
            // Save updated user (password validation not needed here either)
            await user.save({ validateBeforeSave: false });

            // --- Log the user in automatically ---
             req.session.regenerate(err => { // Regenerate session to prevent fixation
                if (err) {
                     console.error("Session regeneration error after OTP verify:", err);
                     req.flash('error_msg', 'Verification successful, but auto-login failed. Please login manually.');
                     return res.redirect('/auth/login'); // Redirect to login on session error
                 }

                // Populate session with user data (excluding sensitive fields)
                req.session.user = {
                    _id: user._id,
                    name: user.name,
                    email: user.email,
                    role: user.role,
                    address: user.address, // Include address if available
                    cart: user.cart || []   // Include cart if available
                 };

                // Save the session before redirecting
                req.session.save(err => {
                   if (err) {
                        console.error("Session save error after OTP verify login:", err);
                         req.flash('error_msg', 'Verification successful, but auto-login failed. Please login manually.');
                        return res.redirect('/auth/login');
                    }
                    // Redirect to intended page or home
                    req.flash('success_msg', 'Email verified successfully! You are now logged in.');
                    const returnTo = req.session.returnTo || '/'; // Use stored return path or default to home
                    delete req.session.returnTo; // Clear stored path
                    res.redirect(returnTo);
                 });
             });
         }

    } catch (error) {
        next(error); // Pass errors to central handler
    }
};

exports.resendOtp = async (req, res, next) => {
    const { email } = req.body;

    // Redirect logged-in users
     if (req.session.user) {
        return res.redirect('/');
    }

    if (!email) {
        req.flash('error_msg', 'Email is required to resend OTP.');
        // Try to redirect back to verify page with email if possible from query
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(req.query.email || '')}`);
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail });

        // User not found case - send generic message to avoid user enumeration
        if (!user) {
            // Log the attempt for monitoring if needed
            console.log(`Resend OTP attempt for non-existent email: ${lowerCaseEmail}`);
            req.flash('info_msg', 'If your email is registered, a new OTP will be sent. Please check your inbox.'); // Use info message
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email)}`); // Redirect back to OTP page
        }

        // Determine context: Password Reset or Initial Verification
        const isForReset = user.resetPasswordToken && user.resetPasswordExpires && user.resetPasswordExpires > Date.now();

        // Account already verified (and not for password reset)
        if(user.isVerified && !isForReset) {
             req.flash('error_msg', 'This account is already verified. Please login.');
            return res.redirect('/auth/login');
        }

        // Generate new OTP and expiry
        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10); // 10 minutes

        user.otp = otp;
        user.otpExpires = otpExpires;
        // If it's a reset request, maybe don't save immediately if email fails?
        // But for verification, saving first is generally fine.
        await user.save({ validateBeforeSave: false }); // Save new OTP

        // Prepare email content based on context
        let subject, text, html;
        if (isForReset) {
            subject = 'Your New Password Reset OTP';
             text = `Your new password reset OTP is: ${otp}\nIt will expire in 10 minutes.\nIf you did not request this, please ignore this email.`;
            html = `<p>Your new password reset OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;
        } else { // Initial verification
             subject = 'Your New Verification OTP';
             text = `Your new verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
            html = `<p>Your new verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;
        }

        // Send the email
        const emailSent = await sendEmail(user.email, subject, text, html);

        // Redirect back to the verify OTP page, potentially adding reason query param
        const redirectUrl = `/auth/verify-otp?email=${encodeURIComponent(user.email)}${isForReset ? '&reason=reset' : ''}`;

        if (emailSent) {
            req.flash('success_msg', `A new OTP has been sent to ${user.email}. Please check your inbox.`);
        } else {
            // Consider if OTP should be rolled back if email fails, complex. Let's just inform user.
            console.error(`Failed to resend OTP email to ${user.email}`);
            req.flash('error_msg', 'Could not resend OTP email. Please try again later or contact support.');
        }
        res.redirect(redirectUrl);

    } catch (error) {
        next(error); // Pass errors to central handler
    }
};

exports.loginUser = async (req, res, next) => {
     if (req.session.user) {
        return res.redirect('/'); // Redirect if already logged in
    }
    const { email, password } = req.body;

    if (!email || !password) {
        req.flash('error_msg', 'Please provide both email and password.');
        // Render login page again, passing back email
        return res.render('auth/login', { title: 'Login', email: email });
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        // Find user by email, include password, and populate cart for session
        const user = await User.findOne({ email: lowerCaseEmail })
                             .select('+password') // Explicitly select password
                             .populate('cart.productId', 'name price imageUrl'); // Populate basic cart details needed for session/badge

        // User not found
        if (!user) {
            req.flash('error_msg', 'Invalid credentials. Please check your email and password.');
            return res.render('auth/login', { title: 'Login', email: email });
        }

        // User found but not verified
         if (!user.isVerified) {
            // Guide user to verify
            req.flash('error_msg', 'Your email is not verified. Please check your inbox for the verification OTP or request a new one.');
            // Redirect to verify page with email pre-filled
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
         }

        // Check password match
        const isMatch = await user.matchPassword(password);

        if (!isMatch) {
            req.flash('error_msg', 'Invalid credentials. Please check your email and password.');
            return res.render('auth/login', { title: 'Login', email: email });
        }

        // --- Password is Correct - Login User ---
         req.session.regenerate(err => { // Prevent session fixation
            if (err) {
                 console.error("Session regeneration error during login:", err);
                 req.flash('error_msg', 'Login failed due to a session error. Please try again.');
                 return res.render('auth/login', { title: 'Login', email: email });
             }

            // Populate session (exclude password!)
            req.session.user = {
                _id: user._id,
                name: user.name,
                email: user.email,
                role: user.role,
                address: user.address ? user.address.toObject() : undefined, // Store plain address object
                // Store only essential cart info (productId, quantity) in session
                cart: user.cart ? user.cart.map(item => ({
                    productId: item.productId?._id, // Store only ID
                    quantity: item.quantity
                })) : []
             };


            // Save session before redirect
             req.session.save(err => {
                 if (err) {
                     console.error("Session save error after login:", err);
                     req.flash('error_msg', 'Login successful, but session could not be saved. Please try again.');
                      return res.render('auth/login', { title: 'Login', email: email });
                 }
                 req.flash('success_msg', 'You are now logged in successfully.');
                 // Redirect to originally requested URL or home
                 const returnTo = req.session.returnTo || '/';
                 delete req.session.returnTo; // Clean up returnTo
                 res.redirect(returnTo);
            });
        });

    } catch (error) {
        next(error); // Pass to error handler
    }
};


// --- UPDATED logoutUser ---
exports.logoutUser = (req, res, next) => {
    // --- Step 1: Set the flash message BEFORE destroying the session ---
    req.flash('success_msg', 'You have been logged out successfully.');

    // --- Step 2: Destroy the session ---
    req.session.destroy(err => {
        if (err) {
            // Log the error, but don't try to flash another message.
            console.error('Session destruction error:', err);
             return res.redirect('/auth/login');
        }

        // --- Step 3: Clear the session cookie from the browser ---
        res.clearCookie(req.app.get('session cookie name') || 'connect.sid'); // Safely get name or use default

        // --- Step 4: Redirect ---
        res.redirect('/auth/login');
    });
};


// --- forgotPassword, resetPassword, getHomePage (No changes needed from previous version, except getHomePage) ---
exports.forgotPassword = async (req, res, next) => {
    const { email } = req.body;
    if (!email) {
        req.flash('error_msg', 'Please provide an email address.');
        return res.redirect('/auth/forgot-password');
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        // Find user by email
        const user = await User.findOne({ email: lowerCaseEmail });

        // Generic message to prevent user enumeration attacks
        const genericMessage = 'If an account with that email exists and is verified, a password reset OTP will be sent. Please check your inbox.';
        req.flash('info_msg', genericMessage); // Use info or success flash

        // Only proceed if user exists AND is verified
        if (!user || !user.isVerified) {
            console.log(`Password reset request for ${lowerCaseEmail}: User ${!user ? 'not found' : 'found but not verified'}. Sending generic response.`);
            return res.redirect('/auth/forgot-password'); // Redirect back
        }

        // Generate OTP and Reset Token with Expirations
         const otp = generateOTP();
         const resetToken = crypto.randomBytes(20).toString('hex'); // For the actual reset link/form later
        const otpExpires = setOTPExpiration(10); // OTP expires in 10 minutes
        const resetExpires = setOTPExpiration(60); // Reset capability expires in 60 minutes

        // Set fields on user document
        user.otp = otp;
        user.otpExpires = otpExpires;
        user.resetPasswordToken = resetToken;
        user.resetPasswordExpires = resetExpires;
        await user.save({ validateBeforeSave: false }); // Save OTP and token info

        // Send OTP email
        const subject = 'Password Reset Request - Verify OTP';
        const text = `You requested a password reset.\n\nPlease use the following OTP to verify your request: ${otp}\n\nThis OTP will expire in 10 minutes.\n\nIf you did not request this, please ignore this email.`;
        const html = `<p>You requested a password reset.</p><p>Please use the following OTP to verify your request: <strong>${otp}</strong></p><p>This OTP will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;

         const emailSent = await sendEmail(user.email, subject, text, html);

        // Handle Email Sending Result
        if (emailSent) {
             console.log(`Password reset OTP sent to verified user: ${user.email}`);
             // Redirect to OTP verification page, marking it as reset context
             res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}&reason=reset`);
        } else {
            // If email failed, consider rolling back the OTP/token? Or just log and rely on expiry?
            console.error(`Failed to send password reset OTP email to ${user.email}`);
            res.redirect('/auth/forgot-password');
        }

    } catch (error) {
        console.error("Error in forgotPassword:", error);
        req.flash('error_msg', 'An error occurred while processing your request. Please try again later.');
        res.redirect('/auth/forgot-password');
    }
};

exports.resetPassword = async (req, res, next) => {
    const { password, confirmPassword } = req.body;
    const token = req.params.token;

    // --- Input Validation ---
    let errors = [];
    if (!password || !confirmPassword) {
        errors.push('Please enter and confirm your new password.');
    }
    if (password !== confirmPassword) {
        errors.push('Passwords do not match.');
    }
     if (password && password.length < 6) {
         errors.push('Password must be at least 6 characters.');
    }
    if (errors.length > 0) {
         req.flash('error_msg', errors.join(' '));
         return res.redirect(`/auth/reset-password/${token}`);
    }

    // --- Password Reset Logic ---
    try {
        // Find user by token and ensure it's still valid
        const user = await User.findOne({
            resetPasswordToken: token,
            resetPasswordExpires: { $gt: Date.now() },
         }).select('+password');

        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired. Please request a new reset link.');
            return res.redirect('/auth/forgot-password');
        }

        // Update password and clear reset/OTP fields
        user.password = password; // Pre-save hook will hash it
        user.resetPasswordToken = undefined;
        user.resetPasswordExpires = undefined;
        user.otp = undefined; // Also clear OTP fields used for verification step
        user.otpExpires = undefined;
        user.isVerified = true; // Ensure user is marked verified

        await user.save(); // This triggers password hashing

        // --- Log the user in automatically after successful reset ---
        req.session.regenerate(err => {
             if (err) {
                console.error("Session regeneration error after password reset:", err);
                req.flash('success_msg', 'Password reset successful. Please log in with your new password.');
                return res.redirect('/auth/login');
             }
             // Populate session
              req.session.user = {
                  _id: user._id, name: user.name, email: user.email, role: user.role,
                  address: user.address ? user.address.toObject() : undefined,
                  cart: user.cart ? user.cart.map(item => ({ productId: item.productId, quantity: item.quantity })) : []
              };

            // Save session
            req.session.save(err => {
                if(err) {
                    console.error("Session save error after password reset login:", err);
                     req.flash('success_msg', 'Password reset successful. Please log in with your new password.');
                    return res.redirect('/auth/login');
                 }
                 // Success: Password reset and logged in
                 req.flash('success_msg', 'Password has been reset successfully. You are now logged in.');
                res.redirect('/');
             });
         });

    } catch (error) {
        // Handle validation errors during save
        if (error.name === 'ValidationError') {
           let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', validationErrors.join(' '));
            return res.redirect(`/auth/reset-password/${token}`);
       }
        next(error); // Pass other errors to handler
    }
};


// --- Modified getHomePage ---
exports.getHomePage = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || '';
    let query = {
        reviewStatus: 'approved',
        stock: { $gt: 0 }
    };

    if (searchTerm) {
         query.$text = { $search: searchTerm };
    }

     const projection = searchTerm ? { score: { $meta: "textScore" } } : {};
     const sort = searchTerm ? { score: { $meta: "textScore" } } : { createdAt: -1 };

    // Fetch Products and Banners concurrently
    const [products, bannerConfig] = await Promise.all([
        Product.find(query, projection).sort(sort).lean(),
        BannerConfig.findOne({ configKey: 'mainBanners' }).lean() // Fetch banners using the imported model
    ]);

    // Extract banner URLs (provide empty array if none found)
    const banners = bannerConfig?.banners || [];
    // Filter out any banners that might somehow be saved without an imageUrl
    const validBanners = banners.filter(banner => banner.imageUrl);


    res.render('products/index', {
      title: searchTerm ? `Search Results for "${searchTerm}"` : 'Home',
      products: products,
      searchTerm: searchTerm,
      homepageBanners: validBanners // Pass banners to the view
      // currentUser is available via res.locals
    });
  } catch (error) {
    console.error("Error fetching products/banners for home page:", error);
    next(error);
  }
};

controllers/orderController.js:
// controllers/orderController.js
const Order = require('../models/Order');
const User = require('../models/User');
const Product = require('../models/Product');
const { sendEmail } = require('../config/mailer');
const mongoose = require('mongoose');
const { generateOTP, setOTPExpiration } = require('../services/otpService');

// --- UPDATE placeOrder to include sellerId and check approval/stock within transaction ---
exports.placeOrder = async (req, res, next) => {
    const userId = req.session.user._id;
    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction({ readConcern: { level: 'snapshot' }, writeConcern: { w: 'majority' } }); // Use snapshot isolation if possible

    try {
        const user = await User.findById(userId)
                              // Populate necessary cart product fields including status and seller
                              .populate('cart.productId', 'name price imageUrl stock reviewStatus sellerId')
                              .session(sessionDB); // Use session

        if (!user) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'User session not found. Please log in again.');
            return res.redirect('/auth/login');
        }
        if (!user.cart || user.cart.length === 0) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Your cart is empty.');
            return res.redirect('/user/cart');
        }
        // Ensure address exists
        if (!user.address || !user.address.name || !user.address.phone || !user.address.pincode || !user.address.cityVillage) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Please complete your shipping address before placing the order.');
            return res.redirect('/user/checkout');
        }

        let orderProducts = [];
        let totalAmount = 0;
        const productStockUpdates = [];
        let validationFailed = false;
        let validationErrorMessage = 'An issue occurred with your cart. Please review and try again.';
        const itemsToRemoveFromCart = []; // Track items to remove due to issues

        // --- Validate Cart Items Within Transaction ---
        for (const item of user.cart) {
            // Basic checks
            const itemQuantity = Number(item.quantity);
            if (isNaN(itemQuantity) || !Number.isInteger(itemQuantity) || itemQuantity <= 0) {
                validationErrorMessage = `Invalid quantity found for an item. It has been removed.`;
                itemsToRemoveFromCart.push(item._id);
                validationFailed = true; continue; // Continue checking other items
            }
            if (!item.productId || !item.productId._id) {
                 validationErrorMessage = `An invalid product reference was found and removed.`;
                 itemsToRemoveFromCart.push(item._id);
                 validationFailed = true; continue;
            }

            const currentProduct = item.productId; // Already populated

            // *** Check Approval Status ***
             if (currentProduct.reviewStatus !== 'approved') {
                validationErrorMessage = `Product "${currentProduct.name}" is not available and has been removed from your cart.`;
                itemsToRemoveFromCart.push(item._id);
                validationFailed = true; continue;
            }
            // *** Check Stock Availability ***
            if (currentProduct.stock < itemQuantity) {
                // If stock issue, fail the whole order immediately, don't just remove item
                validationErrorMessage = `Insufficient stock for "${currentProduct.name}". Available: ${currentProduct.stock}. Please update your cart quantity.`;
                validationFailed = true;
                break; // Stop processing on critical stock issue
            }

            // If valid, add to order and prepare update
            orderProducts.push({
                productId: currentProduct._id,
                name: currentProduct.name,
                priceAtOrder: currentProduct.price, // Price at the time of order
                quantity: itemQuantity,
                imageUrl: currentProduct.imageUrl,
                sellerId: currentProduct.sellerId // *** Include Seller ID ***
            });
            totalAmount += currentProduct.price * itemQuantity;
            productStockUpdates.push({
                 productId: currentProduct._id,
                 quantityToDecrement: itemQuantity
             });
        } // End cart loop

        // --- Handle Validation Failures ---
        if (validationFailed) {
             // If items needed removal, perform the removal update
             if (itemsToRemoveFromCart.length > 0) {
                 await User.updateOne(
                    { _id: userId },
                    { $pull: { cart: { _id: { $in: itemsToRemoveFromCart } } } }
                 ).session(sessionDB); // Perform removal within session
                 console.log(`Removed ${itemsToRemoveFromCart.length} invalid items from cart for user ${userId}`);
             }
            await sessionDB.abortTransaction(); sessionDB.endSession(); // Abort the transaction

             // Refresh session cart AFTER DB update
             const updatedUser = await User.findById(userId).select('cart').populate('cart.productId').lean();
             req.session.user.cart = updatedUser ? updatedUser.cart.filter(i => i.productId) : [];
             await req.session.save();

             req.flash('error_msg', validationErrorMessage);
             return res.redirect('/user/cart');
         }

        // --- Proceed with DB Updates if Validation Passed ---

        // Decrement Stock and Increment Order Count
        for (const update of productStockUpdates) {
            const updateResult = await Product.updateOne(
                { _id: update.productId, stock: { $gte: update.quantityToDecrement } }, // Check stock again
                { $inc: { stock: -update.quantityToDecrement, orderCount: 1 } },
                { session: sessionDB }
            );
            if (updateResult.modifiedCount === 0) { // Handle concurrent update failure
                 await sessionDB.abortTransaction(); sessionDB.endSession();
                 req.flash('error_msg', `Checkout failed: Stock changed for a product during checkout. Please try again.`);
                 // Don't remove items here, let user review cart again
                 return res.redirect('/user/cart');
             }
        }

        // Create the Order document
        const order = new Order({
            userId: userId,
            userEmail: user.email,
            products: orderProducts, // Includes sellerId
            totalAmount: totalAmount,
            shippingAddress: user.address,
            paymentMethod: 'COD', // Or from request body if multiple methods allowed
            status: 'Pending',
            // cancellationAllowedUntil is set by pre-save hook
        });
        await order.save({ session: sessionDB });

        // Clear User's Cart
        user.cart = [];
        await user.save({ session: sessionDB });

        // --- Commit Transaction ---
        await sessionDB.commitTransaction();

        // Update session cart AFTER successful commit
        req.session.user.cart = [];
        await req.session.save();

        // --- Send Confirmation Email (Outside Transaction) ---
        try {
            const subject = 'Your Order Has Been Placed!';
            let productListHTML = order.products.map(p => `<li>${p.name} (Qty: ${p.quantity}) - â‚¹${p.priceAtOrder.toFixed(2)}</li>`).join('');
            const formattedOrderDate = res.locals.formatDateIST(order.orderDate);
            const html = `<h2>Thank you for your order!</h2><p>Your Order ID: ${order._id}</p><p>Order Placed: ${formattedOrderDate}</p><p>Total Amount: â‚¹${order.totalAmount.toFixed(2)}</p><p>Shipping To: ${order.shippingAddress.name}, ${order.shippingAddress.cityVillage}</p><h3>Items:</h3><ul>${productListHTML}</ul><p>You can track your order status in the 'My Orders' section.</p>`;
            await sendEmail(user.email, subject, `Your order ${order._id} has been placed. Total: â‚¹${totalAmount.toFixed(2)}`, html);
        } catch (emailError) {
            console.error(`Failed sending order confirmation email for order ${order._id}:`, emailError);
            // Don't fail the request if email fails
        }

        req.flash('success_msg', 'Order placed successfully!');
        res.redirect('/orders/my-orders'); // Redirect to user's order history

    } catch (error) {
        // Ensure transaction is aborted on any unexpected error
        if (sessionDB.inTransaction()) {
             await sessionDB.abortTransaction();
        }
        console.error("Order Placement Transaction Error:", error);
        req.flash('error_msg', `Order placement failed due to a server error. Please review your cart and try again.`);
        res.redirect('/user/cart'); // Redirect to cart
    } finally {
        // Always end the session
        if (sessionDB.id) { // Check if session exists before ending
             await sessionDB.endSession();
        }
    }
};

// --- UPDATE cancelOrder (Uses Transaction) ---
exports.cancelOrder = async (req, res, next) => {
    const orderId = req.params.id;
    const userId = req.session.user._id;
    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction({ writeConcern: { w: 'majority' }}); // Ensure durability

    try {
        // Find the order: Must belong to the user, be 'Pending', and within cancellation window
        const order = await Order.findOne({
             _id: orderId,
             userId: userId, // Belongs to logged-in user
             status: 'Pending', // Only pending orders
             cancellationAllowedUntil: { $gt: Date.now() } // Within allowed time
        })
        .populate('products.productId', '_id name') // Need _id for update
        .session(sessionDB); // Use the transaction session

        if (!order) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
             req.flash('error_msg', 'Order not found, already processed/cancelled, or cancellation period expired.');
            return res.redirect('/orders/my-orders');
        }

        console.log(`User Cancellation: Restoring stock/orderCount for order ${orderId}.`);
        // Restore stock and decrement orderCount for each valid product item
        const productUpdatePromises = order.products.map(item => {
            const quantityToRestore = Number(item.quantity);
            if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                 console.warn(`User Cancel: Invalid item P.ID ${item.productId?._id} or Qty ${item.quantity} in O.ID ${orderId}. Skipping stock restore.`);
                return Promise.resolve(); // Skip invalid items gracefully
             }
            // Update the Product: Increment stock, decrement orderCount
             return Product.updateOne(
                 { _id: item.productId._id },
                 { $inc: { stock: quantityToRestore, orderCount: -1 } },
                 { session: sessionDB } // Use transaction session
             ).catch(err => {
                // Log error, but allow cancellation to continue for the order itself
                console.error(`User Cancel: Failed stock/orderCount restore for P.ID ${item.productId._id} on O.ID ${orderId}: ${err.message}`);
             });
        });
        // Wait for all stock updates to attempt (use allSettled)
        const results = await Promise.allSettled(productUpdatePromises);
        results.forEach((result, index) => {
            if (result.status === 'rejected') {
                console.error(`Failed promise during stock restore for item index ${index} in order ${orderId}: ${result.reason}`);
            }
        });
        console.log(`User Cancel: Stock/OrderCount restoration process completed for order ${orderId}.`);


        // Update the Order status
        order.status = 'Cancelled';
        order.cancellationReason = "Cancelled by customer";
        // OTP fields etc., should be cleared by the pre-save hook in Order model
        await order.save({ session: sessionDB });

        // --- Commit Transaction ---
        await sessionDB.commitTransaction();

        // Send email confirmation (outside transaction)
         try{
             const subject = 'Your Order Has Been Cancelled';
             const html = `<p>Your order (${order._id}) has been successfully cancelled as requested.</p>`;
            await sendEmail(order.userEmail, subject, `Order ${order._id} cancelled.`, html);
         } catch (emailError){
             console.error(`Failed sending cancellation confirmation email for order ${order._id}:`, emailError);
         }

        req.flash('success_msg', 'Order cancelled successfully.');
        res.redirect('/orders/my-orders');

    } catch (error) {
         // Abort transaction on error
         if (sessionDB.inTransaction()) {
             await sessionDB.abortTransaction();
         }
         console.error("Order Cancellation Error:", error);
         req.flash('error_msg', 'Failed to cancel the order due to an internal error.');
         res.redirect('/orders/my-orders');
    } finally {
        // Always end the session
        if (sessionDB.id) { await sessionDB.endSession(); }
    }
};

// --- Get My Orders (Includes OTP display logic) ---
exports.getMyOrders = async (req, res, next) => {
    try {
        const orders = await Order.find({ userId: req.session.user._id })
                                   .select('-__v') // Exclude version key for cleaner output
                                   .sort({ orderDate: -1 })
                                   // Populate products for display
                                   .populate('products.productId', 'name imageUrl _id price')
                                   .lean(); // Use lean for read-only access

        const now = Date.now();
        orders.forEach(order => {
            // Determine if customer can cancel
            order.isCancellable = order.status === 'Pending' && order.cancellationAllowedUntil && now < new Date(order.cancellationAllowedUntil).getTime();

            // Determine if Delivery OTP should be shown
            order.showDeliveryOtp = order.status === 'Pending' &&
                                    !!order.orderOTP &&          // OTP must exist
                                    !!order.orderOTPExpires &&   // Expiry must exist
                                    new Date(order.orderOTPExpires).getTime() > now; // Must not be expired

            // Dates will be formatted in EJS using the formatDateIST helper
        });

        res.render('user/my-orders', {
            title: 'My Orders',
            orders: orders // Pass orders to the view
            // formatDateIST helper is available via res.locals
        });
    } catch (error) {
        console.error("Error fetching user orders:", error);
        next(error); // Pass error to central handler
    }
};

// --- Admin OTP Generation Logic (Remains Largely the Same) ---
exports.generateAndSendDirectDeliveryOTPByAdmin = async (orderId) => {
    try {
        const order = await Order.findById(orderId);
        if (!order) throw new Error('Order not found.');
        if (order.status !== 'Pending') throw new Error(`Cannot generate OTP for order status '${order.status}'. Must be 'Pending'.`);

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(5); // 5 minutes validity
        order.orderOTP = otp;
        order.orderOTPExpires = otpExpires;
        await order.save();

        const user = await User.findById(order.userId).select('email'); // Get user email for logging/potential notification
        const userEmail = user ? user.email : '[User Account Missing]';

        console.log(`ADMIN generated Direct Delivery OTP for O.ID ${orderId}. OTP: ${otp}. (User: ${userEmail})`);
        // Optional: Send email/SMS to user.email here if needed

        return { success: true, message: `OTP generated for order ${orderId}. It is visible on the customer's 'My Orders' page.` };
    } catch (error) {
        console.error(`Error in generateAndSendDirectDeliveryOTPByAdmin for O.ID ${orderId}:`, error);
        throw error; // Re-throw for the calling controller
    }
};

// --- Seller OTP Generation Logic (NEW) ---
exports.generateAndSendDirectDeliveryOTPBySeller = async (orderId, sellerId) => {
    try {
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'sellerId'); // Populate sellerId for verification

        if (!order) throw new Error('Order not found.');
        if (order.status !== 'Pending') throw new Error(`Cannot generate OTP for order status '${order.status}'. Must be 'Pending'.`);

        // Security Check: Ensure the order contains at least one product from this seller
        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
            console.warn(`Seller ${sellerId} attempted OTP generation for unrelated order ${orderId}.`);
            throw new Error('Permission Denied: Order does not contain your products.');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(5); // 5 minutes validity
        order.orderOTP = otp;
        order.orderOTPExpires = otpExpires;
        await order.save();

        const user = await User.findById(order.userId).select('email');
        const userEmail = user ? user.email : '[User Account Missing]';

        console.log(`SELLER (${sellerId}) generated OTP for O.ID ${orderId}. OTP: ${otp}. (User: ${userEmail})`);
        // Optional: Send email/SMS notification

        return { success: true, message: `OTP generated for order ${orderId}. It is visible on the customer's 'My Orders' page.` };
    } catch (error) {
        console.error(`Error in generateAndSendDirectDeliveryOTPBySeller for O.ID ${orderId} by Seller ${sellerId}:`, error);
        throw error; // Re-throw for the calling controller
    }
};

// --- Admin Confirm Delivery Logic (Remains Largely the Same) ---
exports.confirmDirectDeliveryByAdmin = async (orderId, adminUserId, providedOtp, resForHelper = null) => {
    try {
        const order = await Order.findOne({
           _id: orderId,
           status: 'Pending',
           orderOTP: providedOtp,
           orderOTPExpires: { $gt: Date.now() }
        });

        if (!order) {
           // Check specific failure reason
           const checkOrder = await Order.findById(orderId).select('status orderOTP orderOTPExpires');
           if (!checkOrder) throw new Error('Order not found.');
           if (checkOrder.status !== 'Pending') throw new Error(`Order status is '${checkOrder.status}', cannot confirm delivery.`);
           if (checkOrder.orderOTP !== providedOtp) throw new Error('Invalid OTP.');
           if (!checkOrder.orderOTPExpires || checkOrder.orderOTPExpires <= Date.now()) throw new Error('Expired OTP.');
           throw new Error('OTP verification failed.'); // Generic fallback
        }

        // Update Order
        order.status = 'Delivered';
        order.receivedByDate = new Date();
        // Clear OTP fields - Pre-save hook in Order model should handle this, but explicit clear is safe
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined; // Disable cancellation
        await order.save();

        console.log(`Order ${orderId} confirmed delivered by ADMIN ${adminUserId}`);

        // Send Confirmation Email
        try {
            const subject = `Your Order Has Been Delivered!`;
            const formattedDeliveryDate = resForHelper?.locals?.formatDateIST(order.receivedByDate) || new Date(order.receivedByDate).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
            const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed by administration.</p><p>Received Date: ${formattedDeliveryDate}</p><p>Thank you for shopping with us!</p>`;
           await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
        } catch (emailError){
            console.error(`Admin Confirm: Failed sending delivery confirmation email for O.ID ${order._id}:`, emailError);
        }

        return { success: true, order: order };
    } catch (error) {
        console.error(`Error verifying ADMIN Direct Delivery OTP for O.ID ${orderId} by Admin ${adminUserId}:`, error);
        throw error; // Re-throw
   }
};

// --- Seller Confirm Delivery Logic (NEW) ---
exports.confirmDirectDeliveryBySeller = async (orderId, sellerId, providedOtp, resForHelper = null) => {
    try {
        const order = await Order.findOne({
            _id: orderId,
            status: 'Pending',
            orderOTP: providedOtp,
            orderOTPExpires: { $gt: Date.now() }
        }).populate('products.productId', 'sellerId'); // Need sellerId for verification

        if (!order) {
           // Check specific failure reason
           const checkOrder = await Order.findById(orderId).select('status orderOTP orderOTPExpires');
           if (!checkOrder) throw new Error('Order not found.');
           if (checkOrder.status !== 'Pending') throw new Error(`Order status is '${checkOrder.status}'.`);
           if (checkOrder.orderOTP !== providedOtp) throw new Error('Invalid OTP.');
           if (!checkOrder.orderOTPExpires || checkOrder.orderOTPExpires <= Date.now()) throw new Error('Expired OTP.');
           throw new Error('OTP verification failed.');
        }

        // Security Check: Verify order relevance to this seller
        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
           console.warn(`Seller ${sellerId} attempted to confirm unrelated order ${orderId}.`);
           throw new Error('Permission Denied: Order does not contain your products.');
        }

        // Update Order
        order.status = 'Delivered';
        order.receivedByDate = new Date();
        // Clear OTP fields
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined;
        await order.save();

        console.log(`Order ${orderId} confirmed delivered by SELLER ${sellerId}`);

        // Send Confirmation Email
        try {
           const subject = `Your Order Has Been Delivered!`;
           const formattedDeliveryDate = resForHelper?.locals?.formatDateIST(order.receivedByDate) || new Date(order.receivedByDate).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
           const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed by the seller.</p><p>Received Date: ${formattedDeliveryDate}</p><p>Thank you for shopping with us!</p>`;
           await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
        } catch (emailError){
            console.error(`Seller Confirm: Failed sending delivery confirmation email for O.ID ${order._id}:`, emailError);
        }

        return { success: true, order: order };
    } catch (error) {
        console.error(`Error verifying SELLER Direct Delivery OTP for O.ID ${orderId} by Seller ${sellerId}:`, error);
        throw error; // Re-throw
   }
};

controllers/productController.js:
// controllers/productController.js
const Product = require('../models/Product');
const User = require('../models/User'); // Keep for user rating logic

/**
 * Escapes special characters in a string for use in a regular expression.
 * @param {string} string - The input string.
 * @returns {string} The escaped string.
 */
function escapeRegex(string) {
  return string.replace(/[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

// --- Get Products (Handles both listing and search results with sequential matching) ---
exports.getProducts = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || ''; // Get search term from query param 'search'
    let query = {
        reviewStatus: 'approved', // Always filter by approved
        stock: { $gt: 0 }         // Always filter by in-stock
    };
    let sort = { createdAt: -1 }; // Default sort
    const projection = {}; // No text score projection needed for regex

    // --- NEW: Use Regex for sequential matching if searchTerm exists ---
    if (searchTerm) {
      const escapedSearchTerm = escapeRegex(searchTerm); // Escape special characters
      const regex = new RegExp(escapedSearchTerm, 'i'); // 'i' for case-insensitive sequential match

      query.$or = [ // Match name OR category sequentially
        { name: regex },
        { category: regex }
        // Add { specifications: regex } here if you want to search specs sequentially too
      ];
      // Optional: Change sort for search results, e.g., alphabetical
      // sort = { name: 1 };
      console.log(`Regex Search Query: ${JSON.stringify(query)}`); // Log the query
    }
    // --- End Regex modification ---

    const products = await Product.find(query, projection) // Projection is now empty
                                    .sort(sort)
                                    .lean(); // Use lean for read-only performance

    // Render the same index page, passing search term for display
    res.render('products/index', {
      title: searchTerm ? `Search Results for "${searchTerm}"` : 'Home', // Dynamic title
      products: products,
      searchTerm: searchTerm // Pass term back to view
      // currentUser is available via res.locals
    });
  } catch (error) {
    console.error("Error fetching products:", error);
    next(error); // Pass error to central handler
  }
};


// --- Get Product Details (No changes needed) ---
exports.getProductDetails = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id)
                                    .populate('sellerId', 'name email') // Populate seller
                                    .lean(); // Use lean()

    if (!product) {
       const error = new Error('Product not found');
       error.status = 404;
       return next(error); // Use central error handler
    }

    // Check if product is viewable
    const isApproved = product.reviewStatus === 'approved';
    const user = req.session.user;
    const isAdmin = user?.role === 'admin';
    const isOwner = user && product.sellerId?._id && user._id.toString() === product.sellerId._id.toString();


    if (!isApproved && !isAdmin && !isOwner) {
        // If product isn't approved, only admin or owner can see it
         const error = new Error('Product not available');
         error.status = 404; // Or 403 Forbidden, but 404 is less revealing
         return next(error);
    }

    // User rating logic
    let userRating = null;
    if (user) {
       const ratingData = product.ratings?.find(r => r.userId?.toString() === user._id.toString());
       userRating = ratingData ? ratingData.rating : null;
    }

    // Rating stats calculation
    const ratingCounts = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
    let totalRatings = 0;
    if (product.ratings && product.ratings.length > 0) {
        totalRatings = product.ratings.length;
        product.ratings.forEach(r => {
            if (r.rating && ratingCounts.hasOwnProperty(r.rating)) {
                ratingCounts[r.rating]++;
            }
        });
    }
    const displayTotalRatings = product.numReviews || totalRatings;


    res.render('products/detail', {
      title: product.name,
      product: product,
      isApproved: isApproved,
      isAdminView: isAdmin,
      isOwnerView: isOwner,
      userRating: userRating,
      userCanRate: user ? true : false,
      ratingCounts: ratingCounts,
      totalRatings: displayTotalRatings
      // Add other necessary variables like fullUrl etc. if needed by header partial
    });
  } catch (error) {
       if (error.name === 'CastError') {
           const notFoundError = new Error('Product not found (Invalid ID)');
           notFoundError.status = 404;
           return next(notFoundError);
       }
    next(error); // Pass other errors to central handler
  }
};


// --- Rate Product (No changes needed) ---
 exports.rateProduct = async (req, res, next) => {
     const { rating } = req.body;
    const productId = req.params.id;
    const userId = req.session.user._id;

     if (!rating || isNaN(Number(rating)) || rating < 1 || rating > 5) {
         req.flash('error_msg', 'Please provide a valid rating between 1 and 5.');
        return res.redirect('back'); // Redirect to previous page
     }

    try {
        const product = await Product.findById(productId); // Not lean()

         if (!product) {
             req.flash('error_msg', 'Product not found.');
             return res.status(404).redirect('/');
         }

         const existingRatingIndex = product.ratings.findIndex(r => r.userId?.toString() === userId.toString());

         if (existingRatingIndex > -1) {
            product.ratings[existingRatingIndex].rating = Number(rating);
         } else {
            product.ratings.push({ userId, rating: Number(rating) });
         }

        await product.save(); // Triggers pre-save hook for averageRating/numReviews

         req.flash('success_msg', 'Thank you for your rating!');
         res.redirect(`/products/${productId}`); // Redirect back to product page

     } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID.');
            return res.status(400).redirect('/');
        }
        console.error("Error rating product:", error);
        next(error); // Central error handler
     }
 };

 // --- Get Product Suggestions (Updated for sequential matching) ---
 exports.getProductSuggestions = async (req, res, next) => {
    const searchTerm = req.query.q; // Get query from 'q' parameter
    const limit = 8; // Max number of suggestions

    if (!searchTerm || searchTerm.trim().length < 2) {
        return res.json([]); // Return empty if no/short query
    }

    try {
        // --- NEW: Use Regex for sequential matching ---
        const escapedSearchTerm = escapeRegex(searchTerm); // Escape special chars
        const regex = new RegExp(escapedSearchTerm, 'i'); // 'i' for case-insensitive sequential match

        const query = {
            $or: [ // Match name OR category sequentially
                { name: regex },
                { category: regex }
            ],
            reviewStatus: 'approved', // Only suggest approved products
            stock: { $gt: 0 }         // Only suggest products in stock
        };
        // --- End Regex modification ---

        const suggestions = await Product.find(query)
            .select('_id name imageUrl') // Select only needed fields
            .limit(limit)
            .sort({ name: 1 }) // Sort suggestions alphabetically
            .lean(); // Use lean for performance

        res.json(suggestions); // Send results as JSON

    } catch (error) {
        console.error("Error fetching product suggestions:", error);
        // Avoid sending full error details to client
        res.status(500).json({ error: 'Failed to fetch suggestions' });
    }
 };

controllers/userController.js:
// controllers/userController.js
const User = require('../models/User');
const Product = require('../models/Product');
const mongoose = require('mongoose'); // Import mongoose for ID validation

exports.getUserProfilePage = async (req, res, next) => {
    try {
        const userId = req.session.user._id;
        // Select only necessary fields for profile display
        const user = await User.findById(userId)
                            .select('name email role address createdAt') // Added createdAt for info if needed
                            .lean(); // Use lean for read-only

        if (!user) {
            // This case should ideally be handled by isAuthenticated middleware
            console.warn(`User not found in DB despite active session: ${userId}`);
            req.flash('error_msg', 'User session invalid. Please log in again.');
            return req.session.destroy(err => {
                if (err) return next(err);
                res.redirect('/auth/login');
            });
        }

        res.render('user/profile', {
            title: 'My Profile',
            user: user // Pass user data to the view
            // currentUser is available via res.locals
        });

    } catch (error) {
        next(error); // Pass error to handler
    }
};

// --- NEW: Function to update user's name ---
exports.updateUserName = async (req, res, next) => {
    const { name } = req.body;
    const userId = req.session.user._id;

    // --- Input Validation ---
    if (!name || typeof name !== 'string' || name.trim().length < 2) {
        req.flash('error_msg', 'Please enter a valid name (at least 2 characters).');
        return res.redirect('/user/profile');
    }

    const trimmedName = name.trim();

    try {
        // Find user (not lean, need to save)
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found. Please log in again.');
            return res.redirect('/auth/login');
        }

        // Update the name
        user.name = trimmedName;
        await user.save();

        // --- Update Session ---
        req.session.user.name = user.name; // Update name in session

        // Note: User initials are recalculated in the middleware on the *next* request
        // based on the updated session name. No need to recalculate here unless
        // you need the *new* initials immediately before the redirect (unlikely).

        await req.session.save(); // Wait for session save to complete

        req.flash('success_msg', 'Name updated successfully.');
        res.redirect('/user/profile'); // Redirect back to profile

    } catch (error) {
        // Handle Mongoose validation errors specifically
        if (error.name === 'ValidationError') {
            let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', `Validation Error: ${validationErrors.join(' ')}`);
            return res.redirect('/user/profile');
        }
        // Pass other errors to the central handler
        console.error("Error updating user name:", error);
        next(error);
    }
};


exports.saveAddress = async (req, res, next) => {
    const { name, phone, pincode, cityVillage, landmarkNearby, source } = req.body;
    const userId = req.session.user._id;

    // Determine redirect path based on where the form was submitted from
    const redirectPath = (source === 'profile') ? '/user/profile' : '/user/checkout';

    // --- Input Validation ---
    let errors = [];
    if (!name || !phone || !pincode || !cityVillage) {
        errors.push('Please provide Name, Phone, Pincode, and City/Village.');
    }
    // Validate phone format (10-15 digits)
    if (phone && !/^\d{10,15}$/.test(phone.trim())) {
        errors.push('Please enter a valid phone number (10-15 digits, numbers only).');
    }
    // Validate pincode format (6 digits)
     if (pincode && !/^\d{6}$/.test(pincode.trim())) {
        errors.push('Please enter a valid 6-digit pincode.');
    }
    if (errors.length > 0) {
         req.flash('error_msg', errors.join(' '));
        return res.redirect(redirectPath); // Redirect back to the form page
    }

    // --- Save Address Logic ---
    try {
        // Find user by ID (not lean, need to save)
        const user = await User.findById(userId);
        if (!user) {
            // Should be caught by auth middleware, but good to check
            req.flash('error_msg', 'User not found.');
            return res.redirect('/auth/login');
        }
        // Update or create address sub-document
        user.address = {
            name: name.trim(),
            phone: phone.trim(),
            pincode: pincode.trim(),
            cityVillage: cityVillage.trim(),
            landmarkNearby: landmarkNearby ? landmarkNearby.trim() : undefined // Store as undefined if empty
        };
        // Save the user document (this will trigger Mongoose validation if any on AddressSchema)
        await user.save();

        // --- Update Session ---
        // Ensure session reflects the saved address
        req.session.user.address = user.address.toObject(); // Convert Mongoose sub-doc to plain object for session
        await req.session.save(); // Wait for session save to complete

        req.flash('success_msg', 'Address saved successfully.');
        res.redirect(redirectPath); // Redirect to the appropriate page

    } catch (error) {
        // Handle Mongoose validation errors specifically
        if (error.name === 'ValidationError') {
            let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', `Validation Error: ${validationErrors.join(' ')}`);
            return res.redirect(redirectPath);
        }
        // Pass other errors to the central handler
        next(error);
    }
};

exports.getCart = async (req, res, next) => {
    try {
        const userId = req.session.user._id;
        const user = await User.findById(userId)
                                    // Populate products in cart - select fields needed for display & calculation
                                    .populate('cart.productId', 'name price imageUrl stock _id reviewStatus')
                                    .lean(); // Use lean for reading

        if (!user) {
           // Should be caught by auth middleware
           console.warn(`User not found in getCart despite session: ${userId}`);
           req.flash('error_msg', 'User not found.');
           return req.session.destroy(err => {
                if(err) return next(err);
                res.redirect('/auth/login');
           });
         }

        let cartTotal = 0;
        let populatedCart = [];
        let cartUpdated = false; // Flag to check if session cart needs updating

        if (user.cart && user.cart.length > 0) {
             populatedCart = user.cart.map(item => {
                 // Check if product was populated and is approved
                 if (!item.productId || !item.productId._id) {
                     console.warn(`Cart item ${item._id} refers to a non-existent product ID for user: ${user.email}. Will filter.`);
                     cartUpdated = true; // Mark that session cart needs update
                     return null; // Filter this item out
                 }
                 // *** Check if product is approved - remove if not ***
                 if (item.productId.reviewStatus !== 'approved') {
                      console.warn(`Product ${item.productId.name} (${item.productId._id}) in cart is not approved. Will filter.`);
                      cartUpdated = true;
                      return null; // Filter this out
                 }

                // Calculate subtotal if valid
                const itemSubtotal = item.productId.price * item.quantity;
                cartTotal += itemSubtotal;

                return {
                    // Cart Item ID itself, useful for forms? Not really needed for display.
                    // _id: item._id,
                    productId: item.productId._id, // Use product's ID
                    name: item.productId.name,
                    price: item.productId.price,
                    imageUrl: item.productId.imageUrl,
                    stock: item.productId.stock,
                    quantity: item.quantity,
                    subtotal: itemSubtotal
                };
             }).filter(item => item !== null); // Remove null entries

            // If items were filtered out, update the session cart
             if (cartUpdated) {
                 const validCartItems = populatedCart.map(item => ({ productId: item.productId, quantity: item.quantity }));
                 req.session.user.cart = validCartItems;
                 // No need to save user DB here, just update session representation
                 // Let user manually remove or proceed to checkout where it gets filtered again.
                  // TODO: Consider triggering an async background task to clean DB cart? Or wait for next cart action?
                  console.log(`Session cart updated for user ${user.email} due to invalid/unapproved items found.`);
             }
         } // End if user.cart


        res.render('user/cart', {
          title: 'Your Shopping Cart',
          cart: populatedCart,
          cartTotal: cartTotal
          // currentUser is available via res.locals
        });
      } catch (error) {
        next(error); // Pass errors to central handler
      }
};

// --- UPDATE addToCart (Check Approval) ---
exports.addToCart = async (req, res, next) => {
    const { productId, quantity = 1 } = req.body;
    const userId = req.session.user._id;
    const numQuantity = parseInt(quantity, 10);

     // Validate Product ID and Quantity
     if (!productId || !mongoose.Types.ObjectId.isValid(productId) || isNaN(numQuantity) || numQuantity < 1) {
         req.flash('error_msg', 'Invalid product or quantity.');
         return res.redirect(req.headers.referer || '/'); // Redirect back
     }

    try {
        // Find user and product concurrently
        const [user, product] = await Promise.all([
            User.findById(userId),
            // Fetch product including reviewStatus and stock
            Product.findById(productId).select('name stock reviewStatus') // Minimal fields needed
        ]);

        // Handle User/Product Not Found
        if (!user) {
            req.flash('error_msg', 'User session error. Please log in again.');
            return res.redirect('/auth/login');
        }
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.redirect(req.headers.referer || '/');
        }

        // *** NEW CHECK: Only allow adding approved products ***
        if (product.reviewStatus !== 'approved') {
             req.flash('error_msg', `Sorry, "${product.name}" is currently unavailable.`);
             return res.redirect(req.headers.referer || '/'); // Redirect back
        }

       // Check stock (before potentially adding more)
       if (product.stock <= 0) { // Explicitly check for 0 stock too
            req.flash('error_msg', `${product.name} is currently out of stock.`);
            return res.redirect(req.headers.referer || '/');
        }

       // Find existing cart item index
       const existingCartItemIndex = user.cart.findIndex(item => item.productId.toString() === productId.toString());

       if (existingCartItemIndex > -1) {
           // Update existing item quantity
           const existingQuantity = user.cart[existingCartItemIndex].quantity;
           const newQuantity = existingQuantity + numQuantity;
           // Check combined stock
            if (product.stock < newQuantity) {
               req.flash('error_msg', `Cannot add ${numQuantity} more ${product.name}. Only ${product.stock} available in total (you have ${existingQuantity} in cart).`);
                return res.redirect(req.headers.referer?.includes(`/products/${productId}`) ? `/products/${productId}` : '/');
           }
            user.cart[existingCartItemIndex].quantity = newQuantity;
       } else {
           // Add new item - check stock for the requested quantity first
           if (product.stock < numQuantity) {
               req.flash('error_msg', `Insufficient stock for ${product.name}. Only ${product.stock} available.`);
                return res.redirect(req.headers.referer?.includes(`/products/${productId}`) ? `/products/${productId}` : '/');
           }
           user.cart.push({ productId, quantity: numQuantity });
       }

        await user.save(); // Save the updated user cart to DB

       // Update session cart reliably after saving DB
       req.session.user.cart = user.cart.map(item => ({ productId: item.productId, quantity: item.quantity })); // Use simplified format
       await req.session.save(); // Wait for session to save

        req.flash('success_msg', `${product.name} added to cart!`);

       // Redirect based on query parameter or default to cart
        if(req.query.redirectTo === 'checkout') {
           return res.redirect('/user/checkout');
       }
        res.redirect('/user/cart');

    } catch (error) {
         if (error.name === 'CastError') { // Handle potential ID format error during findById
            req.flash('error_msg', 'Invalid product ID format.');
             return res.redirect('/');
         }
         console.error("Add to Cart Error:", error);
        next(error);
    }
};

exports.updateCartQuantity = async (req, res, next) => {
         const { productId, quantity } = req.body;
         const userId = req.session.user._id;
         const numQuantity = parseInt(quantity, 10);

         // Validation
         if (!productId || !mongoose.Types.ObjectId.isValid(productId) || isNaN(numQuantity) || numQuantity < 0) {
              return res.status(400).json({ success: false, message: 'Invalid product ID or quantity.' });
         }

        try {
            // Fetch user and product simultaneously
            const [user, product] = await Promise.all([
                 User.findById(userId), // Find user to modify cart
                 // Fetch product to check stock and price (minimal fields)
                 Product.findById(productId).select('stock price reviewStatus name')
            ]);

            if (!user) { // Should not happen if authenticated
               return res.status(404).json({ success: false, message: 'User not found.' });
            }
            if (!product) {
               return res.status(404).json({ success: false, message: 'Product not found.' });
            }

            // *** Check if product is approved ***
            if (product.reviewStatus !== 'approved') {
                // If product isn't approved anymore, remove it from cart via this update
                const itemIndexToRemove = user.cart.findIndex(item => item.productId.toString() === productId.toString());
                if (itemIndexToRemove > -1) {
                    user.cart.splice(itemIndexToRemove, 1); // Remove from user cart array
                    await user.save(); // Save the user
                    req.session.user.cart = user.cart.map(i => ({ productId: i.productId, quantity: i.quantity })); // Update session
                    await req.session.save();
                }
                return res.status(400).json({ success: false, message: `Product "${product.name}" is unavailable and has been removed.`, removal: true }); // Indicate removal
            }

            // Find the cart item
            const cartItemIndex = user.cart.findIndex(item => item.productId.toString() === productId.toString());

           // Handle removing the item (quantity = 0)
            if (numQuantity === 0) {
                if (cartItemIndex > -1) {
                    user.cart.splice(cartItemIndex, 1); // Remove item from array
                }
                // If item wasn't found, do nothing for quantity 0
            }
            // Handle updating or adding the item
            else {
                // Check stock for the NEW quantity
               if (product.stock < numQuantity) {
                   // Respond with error, don't change cart
                  return res.status(400).json({ success: false, message: `Insufficient stock for ${product.name}. Only ${product.stock} available.` });
                 }
                // Update existing item or add if it wasn't in cart (shouldn't happen for update > 0?)
                if (cartItemIndex > -1) {
                    user.cart[cartItemIndex].quantity = numQuantity;
                } else {
                    // Add item if trying to update a non-existent item to > 0? Or return error? Let's add.
                    user.cart.push({ productId, quantity: numQuantity });
                 }
            }

            // Save user cart changes to DB
            await user.save();

            // Update session cart
            req.session.user.cart = user.cart.map(item => ({ productId: item.productId, quantity: item.quantity }));

            // --- Recalculate cart total AFTER updating DB cart ---
            // Refetch user with populated cart for accurate total OR calculate manually from current cart
            let cartTotal = 0;
            let itemSubtotal = 0;
            // Use the updated user.cart array for calculation
             for (const item of user.cart) {
                 // Need product price. Could fetch all prices again, or use stored price if reliable?
                 // Fetching price again is safer.
                 const relatedProduct = await Product.findById(item.productId).select('price').lean(); // Fetch price minimally
                 if (relatedProduct) {
                    const currentItemSubtotal = relatedProduct.price * item.quantity;
                    cartTotal += currentItemSubtotal;
                    // Set subtotal for the item being updated
                    if (item.productId.toString() === productId.toString()) {
                         itemSubtotal = currentItemSubtotal;
                     }
                 }
            }


             await req.session.save(); // Save session with updated cart array

            // Send JSON response
            res.json({
                 success: true,
                 message: 'Cart updated successfully.',
                 // Provide updated quantity (might be 0 if removed)
                 newQuantity: user.cart.find(item => item.productId.toString() === productId.toString())?.quantity ?? 0,
                 itemSubtotal: itemSubtotal,
                 cartTotal: cartTotal,
                 itemId: productId // Send back item ID for frontend reference
             });

        } catch (error) {
            console.error("Cart Update Error:", error);
            res.status(500).json({ success: false, message: 'Error updating cart quantity.' });
        }
};

exports.removeFromCart = async (req, res, next) => {
    const { productId } = req.params;
    const userId = req.session.user._id;

    if (!productId || !mongoose.Types.ObjectId.isValid(productId)) { // Validate ID format
       req.flash('error_msg', 'Invalid Product ID.');
       return res.redirect('/user/cart');
     }

    try {
        // Use findOneAndUpdate to pull the item directly from DB cart
        const user = await User.findOneAndUpdate(
            { _id: userId }, // Find the user
            { $pull: { cart: { productId: productId } } }, // Pull item matching productId
            { new: true } // Return the updated user document
        );

         if (!user) { // Should not happen if authenticated
             req.flash('error_msg', 'User not found.');
            return res.redirect('/auth/login');
         }

         // Check if item was actually removed (might have already been gone)
         // This requires comparing cart before/after, findOneAndUpdate doesn't easily tell if $pull removed something.
         // Alternative: Find user, filter cart manually, save user. Less atomic but gives more info.

         // Let's stick with atomic $pull and assume it worked if no error.

         // Update session cart
         req.session.user.cart = user.cart.map(item => ({ productId: item.productId, quantity: item.quantity }));
         await req.session.save(); // Save updated session

         req.flash('success_msg', 'Item removed from cart.');
         res.redirect('/user/cart'); // Redirect back to cart

    } catch (error) {
       console.error("Remove From Cart Error:", error);
       next(error); // Pass to central error handler
    }
};

// --- UPDATE getCheckoutPage (Check Approval and Stock) ---
exports.getCheckoutPage = async (req, res, next) => {
    try {
       const userId = req.session.user._id;
       const user = await User.findById(userId)
                              // Populate product fields needed for checkout validation & display
                              .populate('cart.productId', 'name price imageUrl stock reviewStatus sellerId _id')
                              .lean(); // Use lean for read-only

       // Basic checks
       if (!user) {
           req.flash('error_msg', 'User session expired. Please login.');
           return res.redirect('/auth/login');
       }
       if (!user.cart || user.cart.length === 0) {
           req.flash('error_msg', 'Your cart is empty.');
           return res.redirect('/user/cart');
       }

       let subTotal = 0;
        let checkoutItems = [];
        let issuesFound = false;
        let issueMessages = []; // Collect all issues

       // --- Validate items for checkout ---
       for (const item of user.cart) {
           if (!item.productId || !item.productId._id) {
               issueMessages.push('An invalid item reference was detected.');
               issuesFound = true;
               continue; // Skip processing this item
           }

           // *** CHECK: Product Approval Status ***
            if(item.productId.reviewStatus !== 'approved'){
                issueMessages.push(`"${item.productId.name}" is unavailable.`);
                issuesFound = true;
                continue; // Skip this item
            }

            // *** CHECK: Stock Availability ***
            if(item.productId.stock < item.quantity){
                issueMessages.push(`Insufficient stock for "${item.productId.name}" (Only ${item.productId.stock} left).`);
                issuesFound = true;
                // Don't break here, collect all messages first
                 continue; // Skip adding to checkout list if stock issue
            }

            // If all checks pass, add to checkout summary
            const itemTotal = item.productId.price * item.quantity;
            subTotal += itemTotal;

           checkoutItems.push({
               productId: item.productId._id,
               name: item.productId.name,
               price: item.productId.price,
               imageUrl: item.productId.imageUrl,
               quantity: item.quantity,
               stock: item.productId.stock, // Pass stock for display if needed
               itemTotal: itemTotal
               // sellerId: item.productId.sellerId // Pass if needed
            });
       } // End loop

        // If any validation issues were found, redirect to cart with messages
        if (issuesFound) {
            // Optionally: Trigger removal of problematic items from user's DB cart here
            // await User.updateOne(...)
             req.flash('error_msg', "Please resolve the following issues in your cart: " + issueMessages.join(' '));
             return res.redirect('/user/cart');
        }

        // Proceed to render checkout page if cart is valid
        const totalAmount = subTotal; // Apply shipping costs if any

       res.render('user/checkout', {
           title: 'Checkout',
           userAddress: user.address,    // Pass user's address
           items: checkoutItems,        // Pass validated items
           subTotal: subTotal,
           totalAmount: totalAmount,
           paymentMethod: 'COD'         // Default payment method
       });

   } catch (error) {
       next(error); // Pass errors to handler
   }
};

controllers/sellerController.js:
// controllers/sellerController.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const { sendEmail } = require('../config/mailer'); // Import sendEmail
const { reviewProductWithGemini } = require('../services/geminiService');
const {
    generateAndSendDirectDeliveryOTPBySeller,
    confirmDirectDeliveryBySeller
} = require('./orderController');
const mongoose = require('mongoose');

// --- NEW: Seller Cancellation Reasons ---
const sellerCancellationReasons = [
    "â— Item Out of Stock",
    "ðŸšš Unable to Fulfill/Ship",
    "ðŸ‘¤ Customer Requested Cancellation",
    "â“ Other Reason",
];

// Seller Dashboard
exports.getSellerDashboard = (req, res) => {
    res.render('seller/dashboard', { title: 'Seller Dashboard' });
};

// Product Management Pages
exports.getUploadProductPage = (req, res) => {
    // Pass an empty product object or defaults if needed for rendering sticky form
    res.render('seller/upload-product', { title: 'Upload New Product', product: {} });
};

exports.getManageProductsPage = async (req, res, next) => {
    try {
        const sellerId = req.session.user._id;
        const products = await Product.find({ sellerId: sellerId })
                                    .sort({ createdAt: -1 })
                                    .lean();

        res.render('seller/manage-products', {
            title: 'Manage Your Products',
            products: products
        });
    } catch (error) {
        next(error);
    }
};

exports.getEditProductPage = async (req, res, next) => {
     try {
        // isProductOwner middleware ensures ownership
        const product = await Product.findById(req.params.id).lean(); // Use lean here
        if (!product) {
           req.flash('error_msg', 'Product not found.');
           return res.redirect('/seller/products');
       }
       // Ownership check already done by middleware

       res.render('seller/edit-product', {
           title: `Edit Product: ${product.name}`,
           product: product // Pass lean object
       });
   } catch (error) {
        if (error.name === 'CastError') {
          req.flash('error_msg', 'Invalid product ID format.');
           return res.redirect('/seller/products');
      }
       next(error);
    }
};

// Product Management Actions
exports.uploadProduct = async (req, res, next) => {
    const { name, category, price, stock, imageUrl, specifications } = req.body;
    const sellerId = req.session.user._id;
    const sellerEmail = req.session.user.email;

     if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields (Name, Category, Price, Stock, Image URL).');
        return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body });
    }
     if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
        req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
        return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body });
     }

    try {
        const newProduct = new Product({
            name: name.trim(),
            category: category.trim(),
            price: Number(price),
            stock: Number(stock),
            imageUrl: imageUrl.trim(),
            specifications: specifications ? specifications.trim() : '',
            sellerId: sellerId,
            sellerEmail: sellerEmail,
            reviewStatus: 'pending' // Start as pending
        });

        await newProduct.save();
        console.log(`Product ${newProduct._id} saved initially by seller ${sellerEmail}.`);

        // Trigger Gemini review asynchronously
        reviewProductWithGemini(newProduct).then(async reviewResult => {
             try {
                 // Fetch the latest version of the product to update
                 const productToUpdate = await Product.findById(newProduct._id);
                 if (productToUpdate) {
                    productToUpdate.reviewStatus = reviewResult.status;
                    productToUpdate.rejectionReason = reviewResult.reason; // Might be null/undefined
                    await productToUpdate.save();
                    console.log(`Product ${newProduct._id} review status updated to ${reviewResult.status}.`);
                 } else {
                     console.warn(`Product ${newProduct._id} not found for status update after Gemini review.`);
                 }
             } catch (updateError) {
                console.error(`Error updating product ${newProduct._id} after Gemini review:`, updateError);
             }
        }).catch(reviewError => {
             console.error(`Error in Gemini review promise chain for product ${newProduct._id}:`, reviewError);
             // Consider setting status back to 'pending' or a specific 'error' state
             // Example: Mark as pending with a reason if review fails completely
              Product.findByIdAndUpdate(newProduct._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed.' }).catch(err => console.error("Failed to mark product as pending after review error:", err));
        });

        req.flash('success_msg', `Product "${newProduct.name}" submitted for review.`);
        res.redirect('/seller/products');

    } catch (error) {
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
           return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body });
       }
        console.error("Error uploading product:", error);
        next(error);
    }
};

exports.updateProduct = async (req, res, next) => {
    const productId = req.params.id;
    const sellerId = req.session.user._id; // For validation, though middleware handles access
    const { name, category, price, stock, imageUrl, specifications } = req.body;

     if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields.');
        // Need to fetch product again to render edit page correctly
        try { const product = await Product.findOne({ _id: productId, sellerId: sellerId }).lean(); return res.render('seller/edit-product', { title: `Edit Product: ${product?.name || 'Error'}`, product: product || { _id: productId, ...req.body } }); } catch { return res.redirect(`/seller/products/edit/${productId}`); }
    }
     if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
         req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
         try { const product = await Product.findOne({ _id: productId, sellerId: sellerId }).lean(); return res.render('seller/edit-product', { title: `Edit Product: ${product?.name || 'Error'}`, product: product || { _id: productId, ...req.body } }); } catch { return res.redirect(`/seller/products/edit/${productId}`); }
     }

    try {
        // Find product ensuring it belongs to the seller (redundant with middleware, but safe)
        const product = await Product.findOne({ _id: productId, sellerId: sellerId });

        if (!product) {
            req.flash('error_msg', 'Product not found or access denied.');
            return res.status(404).redirect('/seller/products');
         }

         product.name = name.trim();
         product.category = category.trim();
         product.price = Number(price);
         product.stock = Number(stock);
         product.imageUrl = imageUrl.trim();
         product.specifications = specifications ? specifications.trim() : '';
         product.reviewStatus = 'pending'; // Reset status on update
         product.rejectionReason = undefined;

         await product.save();
         console.log(`Product ${productId} updated by seller, set to pending review.`);

        // Trigger Gemini review asynchronously
        reviewProductWithGemini(product).then(async reviewResult => {
             try {
                 const productToUpdate = await Product.findById(product._id); // Fetch again to update
                 if (productToUpdate) {
                    productToUpdate.reviewStatus = reviewResult.status;
                    productToUpdate.rejectionReason = reviewResult.reason;
                    await productToUpdate.save();
                    console.log(`Product ${product._id} review status updated to ${reviewResult.status} after edit.`);
                 }
             } catch (updateError) {
                console.error(`Error updating product ${product._id} after Gemini review (post-edit):`, updateError);
             }
        }).catch(reviewError => {
             console.error(`Error in Gemini review promise chain for edited product ${product._id}:`, reviewError);
              Product.findByIdAndUpdate(product._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed after edit.' }).catch(err => console.error("Failed to mark edited product as pending after review error:", err));
         });

         req.flash('success_msg', `Product "${product.name}" updated and resubmitted for review.`);
         res.redirect('/seller/products');

    } catch (error) {
         if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
             req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
             try { const product = await Product.findOne({ _id: productId, sellerId: sellerId }).lean(); return res.render('seller/edit-product', { title: `Edit Product: ${product?.name || 'Error'}`, product: product || { _id: productId, ...req.body } }); } catch { return res.redirect(`/seller/products/edit/${productId}`); }
         }
         console.error("Error updating product:", error);
         next(error);
     }
 };

exports.removeProduct = async (req, res, next) => {
    const productId = req.params.id;
    const sellerId = req.session.user._id;

    try {
         // Middleware verifies ownership, find and delete in one step
         const product = await Product.findOneAndDelete({ _id: productId, sellerId: sellerId });

        if (!product) {
             req.flash('error_msg', 'Product not found or already removed.');
             return res.status(404).redirect('/seller/products');
         }
         req.flash('success_msg', `Product "${product.name}" removed successfully.`);
         res.redirect('/seller/products');
    } catch (error) {
        if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid product ID format.');
            return res.status(400).redirect('/seller/products');
        }
        console.error("Error removing product:", error);
        req.flash('error_msg', 'Error removing product.');
        res.redirect('/seller/products');
    }
};

// --- CORRECTED Seller Order Management Page ---
exports.getManageOrdersPage = async (req, res, next) => {
    try {
        const sellerId = req.session.user._id;

        // 1. Find product IDs sold by this seller
        const sellerProductRefs = await Product.find({ sellerId: sellerId }).select('_id').lean();
        const sellerProductIds = sellerProductRefs.map(p => p._id);

        // Handle case where seller has no products
        if (sellerProductIds.length === 0) {
             return res.render('seller/manage-orders', {
                 title: 'Manage Your Orders',
                 orders: [],
                 message: 'You have no products listed, so no orders to manage yet.',
                 sellerCancellationReasons: sellerCancellationReasons // Pass reasons even if no orders
             });
        }

        // 2. Find orders containing any of these products
        const orders = await Order.find({ 'products.productId': { $in: sellerProductIds } })
                                   .sort({ orderDate: -1 })
                                   .populate('products.productId', 'name imageUrl _id price sellerId')
                                   .populate('userId', 'name email') // Populate user for display if needed
                                   .lean();

        // 3. Add flags specific to seller actions and format items summary
        const now = Date.now();
        orders.forEach(order => {
             order.isRelevantToSeller = true;
             order.canBeDirectlyDeliveredBySeller = order.status === 'Pending';
             // *** NEW: Seller Cancellation Logic ***
             order.canBeCancelledBySeller = order.status === 'Pending'; // Simple check for now

             order.showDeliveryOtp = order.status === 'Pending' &&
                                     !!order.orderOTP &&
                                     !!order.orderOTPExpires &&
                                     new Date(order.orderOTPExpires).getTime() > now;

            // Format Items Summary (Highlight seller's items)
            if (order.products && order.products.length > 0) {
                order.itemsSummary = order.products.map(p => {
                    // Ensure productId and sellerId exist before comparing
                    const isSellerItem = p.productId?.sellerId?.toString() === sellerId.toString();
                    const price = (p.priceAtOrder !== undefined && p.priceAtOrder !== null) ? p.priceAtOrder : (p.productId?.price ?? 0);
                    const productName = p.productId?.name || p.name || '[Product Name Missing]';

                    // Highlight seller's item clearly
                    return `${isSellerItem ? '<strong class="text-success">' : ''}${productName} (Qty: ${p.quantity}) @ â‚¹${price.toFixed(2)}${isSellerItem ? ' (Your Item)</strong>' : ''}`;
                }).join('<br>');
            } else {
                 order.itemsSummary = 'No items found';
            }
        });

        // *** Render the template, PASSING message as null and reasons ***
        res.render('seller/manage-orders', {
            title: 'Manage Your Orders',
            orders: orders,
            message: null, // Pass null when orders exist
            sellerCancellationReasons: sellerCancellationReasons // Pass reasons to the view
        });
    } catch (error) {
        next(error);
    }
};


// --- Seller Order Actions ---
exports.sendDirectDeliveryOtpBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const sellerId = req.session.user._id;

    try {
        // isOrderRelevantToSeller middleware should have already checked relevance
        const order = await Order.findById(orderId); // Fetch order again if needed
        if (!order) throw new Error("Order not found.");
        if (order.status !== 'Pending') throw new Error(`Cannot send OTP for order status ${order.status}.`);

        const result = await generateAndSendDirectDeliveryOTPBySeller(orderId, sellerId);
        req.flash('success_msg', result.message + ' Ask customer for OTP.');
    } catch (error) {
        req.flash('error_msg', `Failed to send delivery OTP: ${error.message}`);
    }
    res.redirect('/seller/orders');
};

exports.confirmDirectDeliveryBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const { otp } = req.body;
    const sellerId = req.session.user._id;

    if (!otp || !/^\d{6}$/.test(otp.trim())) {
        req.flash('error_msg', 'Please enter the 6-digit OTP.');
        return res.redirect('/seller/orders');
    }

    try {
         // isOrderRelevantToSeller middleware checks relevance
         const { order } = await confirmDirectDeliveryBySeller(orderId, sellerId, otp.trim(), res);
        req.flash('success_msg', `Order ${orderId} confirmed delivered by you.`);
    } catch (error) {
        req.flash('error_msg', `Delivery confirmation failed: ${error.message}`);
    }
    res.redirect('/seller/orders');
};

// --- NEW: Seller Cancel Order ---
exports.cancelOrderBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const sellerId = req.session.user._id;
    const sellerEmail = req.session.user.email; // For logging

    // Validate reason
    if (!reason || !sellerCancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid seller reason for cancellation.');
        return res.redirect('/seller/orders');
    }

    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction();
    try {
        // Find the order and populate product sellerId
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'sellerId name _id') // Need sellerId and _id
                                .populate('userId', 'email') // For notification
                                .session(sessionDB);

        if (!order) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/seller/orders');
        }

        // Check if order status is Pending
        if (order.status !== 'Pending') {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', `Order status is '${order.status}'. Only 'Pending' orders can be cancelled by seller.`);
            return res.redirect('/seller/orders');
        }

        // Double check relevance (middleware should handle this, but good practice)
        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
             console.warn(`Seller ${sellerEmail} (${sellerId}) attempted cancellation for non-relevant order ${orderId}.`);
             req.flash('error_msg', 'Permission Denied: Order does not contain your products.');
             return res.status(403).redirect('/seller/orders');
        }


        // --- Restore Stock ONLY for the seller's items ---
        console.log(`Seller Cancel: Restoring stock for seller ${sellerId}'s items in order ${orderId}.`);
        const productStockRestorePromises = order.products
            .filter(item => item.productId?.sellerId?.toString() === sellerId.toString()) // Filter only seller's items
            .map(item => {
                const quantityToRestore = Number(item.quantity);
                 if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                    console.warn(`Seller Cancel: Invalid P.ID ${item.productId?._id} or Qty ${item.quantity} for seller's item in O.ID ${orderId}. Skipping restore.`);
                    return Promise.resolve();
                }
                console.log(`Seller Cancel: Restoring ${quantityToRestore} stock for P.ID ${item.productId._id}`);
                 return Product.updateOne(
                     { _id: item.productId._id },
                     { $inc: { stock: quantityToRestore, orderCount: -1 } }, // Restore stock, decrement order count
                     { session: sessionDB }
                 ).catch(err => {
                    console.error(`Seller Cancel: Failed stock/count restore P.ID ${item.productId._id} O.ID ${orderId}: ${err.message}`);
                 });
            });

        await Promise.allSettled(productStockRestorePromises);
        console.log(`Seller Cancel: Stock restoration attempts completed for seller ${sellerId} in order ${orderId}.`);

        // Update Order Status and Reason
        order.status = 'Cancelled';
        order.cancellationReason = `Cancelled by Seller: ${reason}`; // Add prefix
        // Clear OTP fields etc. (pre-save hook might also do this)
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined; // Remove cancellation window

        await order.save({ session: sessionDB });

        await sessionDB.commitTransaction();

        // --- Send Email Notification (Outside Transaction) ---
        try {
            const customerEmail = order.userEmail || order.userId?.email;
            if(customerEmail) {
                const subjectCust = `Update on Your Order (${order._id})`;
                const htmlCust = `<p>Unfortunately, your order (${order._id}) has been cancelled by the seller.</p>
                                <p><strong>Reason:</strong> ${reason}</p>
                                <p>Any payment made (if applicable) will be refunded according to policy.</p>
                                <p>We apologize for any inconvenience. Please contact support if you have questions.</p>`;
                const textCust = `Your order ${order._id} was cancelled by the seller. Reason: ${reason}. Contact support for questions.`;
                await sendEmail(customerEmail, subjectCust, textCust, htmlCust);
            } else {
                console.warn(`Seller Cancel: Could not find customer email for order ${orderId} notification.`);
            }
        } catch (emailError) {
            console.error(`Seller Cancel: Failed sending cancellation email for order ${order._id}:`, emailError);
        }

        req.flash('success_msg', `Order ${orderId} cancelled successfully. Reason: ${reason}. Customer notified.`);
        res.redirect('/seller/orders');

    } catch (error) {
        await sessionDB.abortTransaction();
        console.error(`Error cancelling order ${orderId} by seller ${sellerEmail} (${sellerId}):`, error);
        req.flash('error_msg', 'Failed to cancel order due to an internal error.');
        res.redirect('/seller/orders');
    } finally {
        sessionDB.endSession();
    }
};

middleware/authMiddleware.js:
const User = require('../models/User');

const isAuthenticated = (req, res, next) => {
    if (req.session && req.session.user) {
        User.findById(req.session.user._id).then(user => {
            if (!user) {
                req.session.destroy(err => {
                    if (err) {
                        console.error('Session destruction error:', err);
                        return next(err);
                    }
                    req.flash('error_msg', 'Session expired or user not found. Please login again.');
                    res.redirect('/auth/login');
                });
            } else {
                req.user = user;
                res.locals.currentUser = user;
                next();
            }
        }).catch(err => {
            console.error("Error checking user authentication:", err);
            req.flash('error_msg', 'An error occurred during authentication.');
            res.redirect('/auth/login');
        });
    } else {
        req.flash('error_msg', 'You must be logged in to view this page.');
        req.session.returnTo = req.originalUrl;
        res.redirect('/auth/login');
    }
};

module.exports = { isAuthenticated };


middleware/errorMiddleware.js:
const notFound = (req, res, next) => {
  const error = new Error(`Not Found - ${req.originalUrl}`);
  res.status(404);
  next(error);
};

const errorHandler = (err, req, res, next) => {
  let statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  let message = err.message;

  if (err.name === 'CastError' && err.kind === 'ObjectId') {
    statusCode = 404;
    message = 'Resource not found';
  }
   if (err.name === 'ValidationError') {
       statusCode = 400;
       const errors = Object.values(err.errors).map(el => el.message);
       message = `Validation Error: ${errors.join(', ')}`;
   }
    if (err.code === 11000) {
       statusCode = 400;
       message = `Duplicate field value entered: ${Object.keys(err.keyValue)} already exists.`;
    }


  console.error("ERROR STACK: ", err.stack);

  if (req.accepts('html')) {
      res.status(statusCode).render('error', {
          title: 'Error',
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
          statusCode: statusCode
      });
  } else {
      res.status(statusCode).json({
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
      });
  }
};

module.exports = { notFound, errorHandler };


middleware/roleMiddleware.js:
// middleware/roleMiddleware.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const mongoose = require('mongoose');

const isAdmin = (req, res, next) => {
  // Ensure user exists and has the 'admin' role
  if (req.session.user && req.session.user.role === 'admin') {
    return next(); // Use return to avoid executing further code
  } else {
    req.flash('error_msg', 'Access Denied: Admin privileges required.');
    return res.status(403).redirect('/'); // Use return
  }
};

// *** NEW: Middleware to check if user is a seller ***
const isSeller = (req, res, next) => {
  if (req.session.user && req.session.user.role === 'seller') {
    return next();
  } else {
    req.flash('error_msg', 'Access Denied: Seller privileges required.');
    return res.status(403).redirect('/');
  }
};

// *** NEW: Middleware to check if user is admin OR seller ***
const isAdminOrSeller = (req, res, next) => {
   if (req.session.user && (req.session.user.role === 'admin' || req.session.user.role === 'seller')) {
     return next();
   } else {
     req.flash('error_msg', 'Access Denied: Admin or Seller privileges required.');
     return res.status(403).redirect('/');
   }
};


// *** NEW: Middleware to check if the product belongs to the logged-in seller ***
// Apply this AFTER isAuthenticated and isSeller
const isProductOwner = async (req, res, next) => {
    const productId = req.params.id || req.params.productId; // Check common param names
    const sellerId = req.session.user._id;

    if (!mongoose.Types.ObjectId.isValid(productId)) {
         req.flash('error_msg', 'Invalid Product ID format.');
         return res.status(400).redirect('back'); // Redirect back if possible
    }

    try {
        const product = await Product.findById(productId).select('sellerId').lean(); // Only fetch sellerId

        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('back');
        }

        if (product.sellerId.toString() !== sellerId.toString()) {
            req.flash('error_msg', 'Access Denied: You do not own this product.');
            return res.status(403).redirect('/seller/products'); // Redirect to their products page
        }

        // Attach product briefly for potential use later? Maybe not necessary.
        // req.product = product;
        next();
    } catch (error) {
         console.error("Error in isProductOwner middleware:", error);
         // Handle CastError specifically if lean() is removed or select changes
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid Product ID format.');
             return res.status(400).redirect('back');
         }
         req.flash('error_msg', 'An error occurred while verifying product ownership.');
         return res.status(500).redirect('back');
    }
};


// *** NEW: Middleware to check if an order contains products relevant to the logged-in seller ***
// Apply this AFTER isAuthenticated and isSeller
const isOrderRelevantToSeller = async (req, res, next) => {
    const orderId = req.params.orderId || req.params.id;
    const sellerId = req.session.user._id;

     if (!mongoose.Types.ObjectId.isValid(orderId)) {
         req.flash('error_msg', 'Invalid Order ID format.');
         return res.status(400).redirect('back');
    }

    try {
        // 1. Find products sold by this seller
        const sellerProductIds = await Product.find({ sellerId: sellerId }, '_id').lean();
        const sellerProductIdStrings = sellerProductIds.map(p => p._id.toString());

        if (sellerProductIdStrings.length === 0) {
             req.flash('error_msg', 'Access Denied: You have no products listed.');
             return res.status(403).redirect('/seller/orders');
        }

        // 2. Find the order and check if any product matches the seller's products
        // We only need to know IF there's a match, not the full order details yet
        const order = await Order.findOne({
            _id: orderId,
            'products.productId': { $in: sellerProductIdStrings.map(id => new mongoose.Types.ObjectId(id)) } // Convert back to ObjectId for query
        }).select('_id').lean(); // Select minimal field

        if (!order) {
            req.flash('error_msg', 'Order not found or does not contain your products.');
            return res.status(404).redirect('/seller/orders');
        }

        // Order is relevant
        next();

    } catch (error) {
        console.error("Error in isOrderRelevantToSeller middleware:", error);
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid ID format encountered.');
             return res.status(400).redirect('back');
         }
        req.flash('error_msg', 'An error occurred while verifying order relevance.');
        return res.status(500).redirect('back');
    }
};

module.exports = {
    isAdmin,
    isSeller,         // Export new middleware
    isAdminOrSeller,  // Export new middleware
    isProductOwner,   // Export new middleware
    isOrderRelevantToSeller // Export new middleware
};

models/BannerConfig.js:
// models/BannerConfig.js
const mongoose = require('mongoose');

const BannerSchema = new mongoose.Schema({
  imageUrl: { type: String, trim: true, required: true },
  linkUrl: { type: String, trim: true }, // Optional: URL to navigate to when banner is clicked
  title: { type: String, trim: true }, // Optional: Title/Alt text for the banner
}, { _id: false }); // Don't need separate IDs for each banner item in the array

const BannerConfigSchema = new mongoose.Schema({
  // Using a known key to ensure we only have one document (singleton pattern)
  configKey: {
    type: String,
    default: 'mainBanners',
    unique: true, // Enforces only one banner config document
    required: true,
  },
  banners: {
    type: [BannerSchema],
    validate: [arrayLimit, '{PATH} exceeds the limit of 4 banners'] // Custom validator
  },
  lastUpdatedBy: { // Track who last updated it
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true // Adds createdAt and updatedAt
});

// Custom validator function for array limit
function arrayLimit(val) {
  return val.length <= 4;
}

const BannerConfig = mongoose.model('BannerConfig', BannerConfigSchema);

module.exports = BannerConfig;

models/Order.js:
// models/Order.js
const mongoose = require('mongoose');

const OrderProductSchema = new mongoose.Schema({
    productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
    name: { type: String, required: true },
    priceAtOrder: { type: Number, required: true },
    quantity: { type: Number, required: true, min: 1 },
    imageUrl: { type: String }
}, { _id: false });

const OrderAddressSchema = new mongoose.Schema({
    name: { type: String, trim: true, required: true },
    phone: { type: String, trim: true, required: true },
    pincode: { type: String, trim: true, required: true },
    cityVillage: { type: String, trim: true, required: true },
    landmarkNearby: { type: String, trim: true },
}, { _id: false });


const OrderSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
    },
    userEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    products: [OrderProductSchema],
    totalAmount: {
        type: Number,
        required: true,
        min: 0,
    },
    shippingAddress: {
        type: OrderAddressSchema,
        required: true
    },
    paymentMethod: {
        type: String,
        enum: ['COD'],
        required: true,
        default: 'COD',
    },
    status: {
        type: String,
        enum: ['Pending', 'Delivered', 'Cancelled'],
        default: 'Pending',
    },
    orderDate: {
        type: Date,
        default: Date.now,
    },
    receivedByDate: {
        type: Date,
    },

    orderOTP: String,
    orderOTPExpires: Date,

    cancellationAllowedUntil: {
        type: Date,
    },
    cancellationReason: {
        type: String,
        trim: true,
    }
}, {
    timestamps: true
});

OrderSchema.pre('save', function(next) {
    if (this.isNew && !this.cancellationAllowedUntil) {
        const now = this.orderDate || Date.now();
        this.cancellationAllowedUntil = new Date(now.getTime() + 60 * 60 * 1000);
    }

    if (this.isModified('status') && this.status === 'Cancelled') {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
        this.receivedByDate = undefined;
        this.cancellationAllowedUntil = undefined;
    }

    if (this.isModified('status') && this.status !== 'Pending') {
         this.orderOTP = undefined;
         this.orderOTPExpires = undefined;
    }
    if (this.status === 'Delivered' || this.status === 'Cancelled') {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
    }

    next();
});

const Order = mongoose.model('Order', OrderSchema);

module.exports = Order;

models/Product.js:
// models/Product.js
const mongoose = require('mongoose');

const RatingSchema = new mongoose.Schema({
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    rating: { type: Number, required: true, min: 1, max: 5 },
    comment: { type: String, trim: true },
}, { _id: false, timestamps: true });


const ProductSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide a product name'],
        trim: true,
        index: true // Added index for searching
    },
    category: {
        type: String,
        required: [true, 'Please provide a product category'],
        trim: true,
        index: true // Added index for searching
    },
    price: {
        type: Number,
        required: [true, 'Please provide a product price'],
        min: 0,
    },
    stock: {
        type: Number,
        required: [true, 'Please provide product stock quantity'],
        min: 0,
        default: 0,
    },
    imageUrl: {
        type: String,
        required: [true, 'Please provide a product image URL'],
        trim: true,
    },
    specifications: {
        type: String,
        trim: true,
    },
    // *** UPDATED: Added sellerId reference ***
    sellerId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true
    },
    // Keep sellerEmail for potential display/legacy reasons, but sellerId is primary
    sellerEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    ratings: [RatingSchema],
    averageRating: {
      type: Number,
      default: 0,
    },
    numReviews: {
        type: Number,
        default: 0,
    },
    orderCount: { // Tracks how many times item appeared in orders
        type: Number,
        default: 0,
    },
    // *** NEW: Fields for Review Status ***
    reviewStatus: {
        type: String,
        enum: ['pending', 'approved', 'rejected'],
        default: 'pending',
        index: true // Index for filtering visible products
    },
    rejectionReason: {
        type: String,
        trim: true
    }
}, {
    timestamps: true // Automatically adds createdAt and updatedAt
});

// Calculate average rating and numReviews before saving
ProductSchema.pre('save', function(next) {
    if (this.isModified('ratings')) { // Only recalculate if ratings changed
        if (this.ratings && this.ratings.length > 0) {
            this.numReviews = this.ratings.length;
            this.averageRating = this.ratings.reduce((acc, item) => item.rating + acc, 0) / this.ratings.length;
        } else {
            this.numReviews = 0;
            this.averageRating = 0;
        }
    }

    // Ensure rejectionReason is cleared if status is not 'rejected'
    if (this.isModified('reviewStatus') && this.reviewStatus !== 'rejected') {
        this.rejectionReason = undefined;
    }

    next();
});

// Define text index for searching multiple fields
ProductSchema.index({ name: 'text', category: 'text', specifications: 'text' });


const Product = mongoose.model('Product', ProductSchema);

module.exports = Product;

models/User.js:
// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const AddressSchema = new mongoose.Schema({
    name: { type: String, trim: true },
    phone: { type: String, trim: true },
    pincode: { type: String, trim: true },
    cityVillage: { type: String, trim: true },
    landmarkNearby: { type: String, trim: true },
}, { _id: false });

const CartItemSchema = new mongoose.Schema({
    productId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Product',
        required: true,
    },
    quantity: {
        type: Number,
        required: true,
        min: 1,
        default: 1,
    }
}, { _id: false }); // Changed _id back to false as per original

const UserSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide your name'],
        trim: true,
    },
    email: {
        type: String,
        required: [true, 'Please provide your email'],
        unique: true,
        match: [
            /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            'Please provide a valid email address',
        ],
        lowercase: true,
        trim: true,
    },
    password: {
        type: String,
        required: [true, 'Please provide a password'],
        minlength: 6,
        select: false, // Keep password hidden by default
    },
    role: {
        type: String,
        // *** UPDATED: Added 'seller' role ***
        enum: ['user', 'admin', 'seller'],
        default: 'user',
    },
    isVerified: {
        type: Boolean,
        default: false,
    },
    otp: { type: String },
    otpExpires: { type: Date },
    address: AddressSchema,
    cart: [CartItemSchema],

    resetPasswordToken: String,
    resetPasswordExpires: Date,
}, {
    timestamps: true
});

// Hash password before saving
UserSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();

    try {
        const salt = await bcrypt.genSalt(10);
        this.password = await bcrypt.hash(this.password, salt);
        next();
    } catch (error) {
        next(error); // Pass error to mongoose error handling
    }
});

// Method to compare entered password with hashed password
UserSchema.methods.matchPassword = async function(enteredPassword) {
    // Need to explicitly select password if it was excluded in the query
    // If the user instance was fetched without `+password`, this.password will be undefined.
    // It's safer to fetch the user with password when matching is needed.
    if (!this.password) {
        const userWithPassword = await mongoose.model('User').findById(this._id).select('+password').exec();
        if (!userWithPassword) return false; // Should not happen if instance exists
        return await bcrypt.compare(enteredPassword, userWithPassword.password);
    }
    return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', UserSchema);

module.exports = User;

public/css/style.css:
/* public/css/style.css */

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* Core Color Palette */
  --primary-color: #007bff;
  --primary-hover: #0056b3;
  --secondary-color: #6c757d;
  --secondary-hover: #5a6268;
  --success-color: #28a745;
  --success-hover: #218838;
  --danger-color: #dc3545;
  --danger-hover: #c82333;
  --warning-color: #ffc107;
  --warning-hover: #e0a800;
  --info-color: #17a2b8;
  --info-hover: #138496;
  --light-color: #f8f9fa;
  --dark-color: #343a40;

  /* Text & Links */
  --text-color: #333;
  --link-color: var(--primary-color);

  /* Layout & Components */
  --card-bg: #ffffff;
  --card-shadow: 0 2px 5px rgba(0, 0, 0, 0.12);
  --border-color: #dee2e6;
  --border-radius: 0.6rem; /* Smoother corners */
  --spacing-unit: 1rem;

  /* Gradient Background Colors */
  --gradient-start: #e9f1ff;
  --gradient-mid1: #d0e0ff;
  --gradient-mid2: #e0ebf7;
  --gradient-end: #f0f5fd;
}

html {
  font-size: 16px;
  scroll-behavior: smooth;
}

body {
  font-family: 'Roboto', sans-serif;
  line-height: 1.6;
  color: var(--text-color);
  background: linear-gradient(135deg,
      var(--gradient-start) 0%,
      var(--gradient-mid1) 25%,
      var(--gradient-mid2) 55%,
      var(--gradient-end) 100%
    );
  background-attachment: fixed;
  background-size: cover;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

a {
  color: var(--link-color);
  text-decoration: none;
  transition: color 0.2s ease-in-out;
}

a:hover {
  color: var(--primary-hover);
  text-decoration: underline;
}

img {
  max-width: 100%;
  height: auto;
  display: block;
}

h1, h2, h3, h4, h5, h6 {
  margin-bottom: calc(var(--spacing-unit) * 0.75);
  line-height: 1.3;
  font-weight: 500;
}

p {
  margin-bottom: var(--spacing-unit);
}

ul, ol {
    margin-bottom: var(--spacing-unit);
    padding-left: calc(var(--spacing-unit) * 1.5);
}

/* Utility Classes */
.hidden { display: none !important; }
.hide { display: none !important; } /* Alias */
.text-center { text-align: center; }
.text-danger { color: var(--danger-color) !important; }
.text-success { color: var(--success-color) !important; }
.text-warning { color: var(--warning-color) !important; }
.text-info { color: var(--info-color) !important; }
.text-muted { color: var(--secondary-color) !important; }
.mb-1 { margin-bottom: calc(var(--spacing-unit) * 0.25) !important; }
.mb-2 { margin-bottom: calc(var(--spacing-unit) * 0.5) !important; }
.mb-3 { margin-bottom: var(--spacing-unit) !important; }
.mb-4 { margin-bottom: calc(var(--spacing-unit) * 1.5) !important; }
.mt-1 { margin-top: calc(var(--spacing-unit) * 0.25) !important; }
.mt-2 { margin-top: calc(var(--spacing-unit) * 0.5) !important; }
.mt-3 { margin-top: var(--spacing-unit) !important; }
.mt-4 { margin-top: calc(var(--spacing-unit) * 1.5) !important; }
.ms-1 { margin-left: calc(var(--spacing-unit) * 0.25) !important; } /* Margin start */
.ms-2 { margin-left: calc(var(--spacing-unit) * 0.5) !important; }
.me-1 { margin-right: calc(var(--spacing-unit) * 0.25) !important; }
.me-2 { margin-right: calc(var(--spacing-unit) * 0.5) !important; } /* Margin end */
.me-3 { margin-right: var(--spacing-unit) !important; }
.p-1 { padding: calc(var(--spacing-unit) * 0.25) !important; }
.p-2 { padding: calc(var(--spacing-unit) * 0.5) !important; }
.p-3 { padding: var(--spacing-unit) !important; }
.pt-1 { padding-top: calc(var(--spacing-unit) * 0.25) !important; }
.pt-2 { padding-top: calc(var(--spacing-unit) * 0.5) !important; }
.pt-3 { padding-top: var(--spacing-unit) !important; }
.pb-1 { padding-bottom: calc(var(--spacing-unit) * 0.25) !important; }
.pb-2 { padding-bottom: calc(var(--spacing-unit) * 0.5) !important; }
.pb-3 { padding-bottom: var(--spacing-unit) !important; }
.d-flex { display: flex !important; }
.d-inline-flex { display: inline-flex !important; }
.d-block { display: block !important; }
.d-inline-block { display: inline-block !important; }
.align-items-center { align-items: center !important; }
.justify-content-between { justify-content: space-between !important; }
.justify-content-center { justify-content: center !important; }
.flex-wrap { flex-wrap: wrap !important; }
.flex-grow-1 { flex-grow: 1 !important; }
.gap-1 { gap: calc(var(--spacing-unit) * 0.25) !important; }
.gap-2 { gap: calc(var(--spacing-unit) * 0.5) !important; }
.gap-3 { gap: var(--spacing-unit) !important; }
.small { font-size: 0.875em; }
.fs-5 { font-size: 1.25rem !important; }
.w-100 { width: 100% !important; }
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
.fw-bold { font-weight: bold !important; }
.fw-normal { font-weight: normal !important; }
.fw-light { font-weight: lighter !important; }
.text-capitalize { text-transform: capitalize !important; }
.border { border: 1px solid var(--border-color) !important; }
.border-top { border-top: 1px solid var(--border-color) !important; }
.border-bottom { border-bottom: 1px solid var(--border-color) !important; }
.rounded { border-radius: var(--border-radius) !important; }


/* Forms */
.inline-form {
    display: inline-block; /* Changed to inline-block for better flow with text buttons */
    margin-bottom: 0; /* Removed default bottom margin */
    vertical-align: middle; /* Align forms vertically */
}
.inline-form > * {
    margin-bottom: 0; /* Remove bottom margin from elements inside */
    vertical-align: middle; /* Align elements inside vertically */
}
.inline-form + .inline-form {
    margin-left: calc(var(--spacing-unit) * 0.3); /* Add space between inline forms */
}


.form-group {
  margin-bottom: calc(var(--spacing-unit) * 0.8);
}

label:not(.form-label-inline) { /* Exclude inline labels */
  display: block;
  margin-bottom: calc(var(--spacing-unit) * 0.3);
  font-weight: 500;
}
label.form-label-inline {
    margin-bottom: 0; /* No margin for inline labels */
    margin-right: calc(var(--spacing-unit) * 0.4);
    font-weight: normal;
}

input[type="text"],
input[type="email"],
input[type="password"],
input[type="tel"],
input[type="url"],
input[type="number"],
input[type="search"],
textarea,
select {
  width: 100%;
  padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.75);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  font-size: 1rem;
  line-height: 1.5;
  background-color: #fff;
  color: var(--text-color); /* Ensure text color is applied */
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}
/* Alias class for consistency */
.form-control {
    display: block; /* Ensure block level */
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.75);
    font-size: 1rem;
    font-weight: 400;
    line-height: 1.5;
    color: var(--text-color);
    background-color: #fff;
    background-clip: padding-box;
    border: 1px solid var(--border-color);
    appearance: none; /* Remove default vendor styling */
    border-radius: var(--border-radius);
    transition: border-color .15s ease-in-out,box-shadow .15s ease-in-out;
}


input[type="number"] {
    appearance: textfield;
    -moz-appearance: textfield;
}
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

textarea {
  resize: vertical;
  min-height: 80px;
}

input:focus,
textarea:focus,
select:focus,
.form-control:focus {
  border-color: var(--primary-color);
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.form-control-sm {
  min-height: calc(1.5em + 0.5rem + 2px); /* Use min-height */
  height: auto; /* Allow height to adjust */
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: calc(var(--border-radius) * 0.75);
}
select.form-control-sm {
  height: calc(1.8125rem + 2px); /* Keep height for select */
}

/* Buttons */
.btn {
  display: inline-block;
  font-weight: 400;
  color: #fff;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  user-select: none;
  background-color: var(--primary-color);
  border: 1px solid var(--primary-color);
  padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
  font-size: 1rem;
  line-height: 1.5;
  border-radius: var(--border-radius);
  transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
  text-transform: capitalize;
}

.btn:hover {
  color: #fff;
  text-decoration: none;
  background-color: var(--primary-hover);
  border-color: var(--primary-hover);
}

.btn:focus {
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.5);
}

.btn:disabled {
  opacity: 0.65;
  cursor: not-allowed;
  pointer-events: none; /* Add this */
}
/* Style for loading state */
.btn.loading {
    opacity: 0.75;
    cursor: wait;
    pointer-events: none;
}


.btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: #fff;}
.btn-primary:hover { background-color: var(--primary-hover); border-color: var(--primary-hover); }
.btn-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: #fff; }
.btn-secondary:hover { background-color: var(--secondary-hover); border-color: var(--secondary-hover); }
.btn-success { background-color: var(--success-color); border-color: var(--success-color); color: #fff;}
.btn-success:hover { background-color: var(--success-hover); border-color: var(--success-hover); }
.btn-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: #fff;}
.btn-danger:hover { background-color: var(--danger-hover); border-color: var(--danger-hover); }
.btn-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: #212529;}
.btn-warning:hover { background-color: var(--warning-hover); border-color: var(--warning-hover); }
.btn-info { background-color: var(--info-color); border-color: var(--info-color); color: #fff;}
.btn-info:hover { background-color: var(--info-hover); border-color: var(--info-hover); }
.btn-light { background-color: var(--light-color); border-color: var(--light-color); color: #212529;}
.btn-light:hover { background-color: #e2e6ea; border-color: #dae0e5; }
.btn-dark { background-color: var(--dark-color); border-color: var(--dark-color); color: #fff;}
.btn-dark:hover { background-color: #23272b; border-color: #1d2124; }

.btn-outline-secondary { color: var(--secondary-color); border-color: var(--secondary-color); background-color: transparent;}
.btn-outline-secondary:hover { color: #fff; background-color: var(--secondary-color); }
.btn-outline-primary { color: var(--primary-color); border-color: var(--primary-color); background-color: transparent;}
.btn-outline-primary:hover { color: #fff; background-color: var(--primary-color); }

.btn-text {
    background-color: transparent;
    border-color: transparent;
    color: var(--link-color);
    padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.4);
    border-radius: var(--border-radius);
    vertical-align: middle; /* Align with other inline elements */
}
.btn-text:hover,
.btn-text:focus {
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--primary-hover);
    text-decoration: none;
    outline: none;
    box-shadow: none;
}
.btn-text.btn-danger { color: var(--danger-color); }
.btn-text.btn-danger:hover,
.btn-text.btn-danger:focus { color: var(--danger-hover); background-color: rgba(220, 53, 69, 0.1); }

.btn-sm {
  padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.5);
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: calc(var(--border-radius) * 0.8);
}
.btn-lg {
    padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.25);
    font-size: 1.1rem;
}

.btn-block {
    display: block;
    width: 100%;
}

.btn .fa-spinner {
    margin-right: calc(var(--spacing-unit) * 0.25);
    animation: fa-spin 1s infinite linear;
}
@keyframes fa-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Alerts */
.alert {
  padding: calc(var(--spacing-unit) * 0.8) var(--spacing-unit);
  margin-bottom: var(--spacing-unit);
  border: 1px solid transparent;
  border-radius: var(--border-radius);
  position: relative;
}
.alert-success { color: #155724; background-color: #d4edda; border-color: #c3e6cb; }
.alert-danger { color: #721c24; background-color: #f8d7da; border-color: #f5c6cb; }
.alert-warning { color: #856404; background-color: #fff3cd; border-color: #ffeeba; }
.alert-info { color: #0c5460; background-color: #d1ecf1; border-color: #bee5eb; }
.alert-link { font-weight: bold; color: inherit; text-decoration: underline; }

.close-alert {
  position: absolute;
  top: 50%;
  right: 10px;
  transform: translateY(-50%);
  font-size: 1.2rem;
  line-height: 1;
  background: none;
  border: none;
  color: inherit;
  opacity: 0.7;
  cursor: pointer;
  padding: 0.2rem 0.4rem;
}
.close-alert:hover { opacity: 1; }

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1055;
  width: auto;
  max-width: 350px;
  pointer-events: none;
}

.toast {
  background-color: var(--card-bg);
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-radius: var(--border-radius);
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  margin-bottom: var(--spacing-unit);
  padding: calc(var(--spacing-unit) * 0.75);
  padding-right: calc(var(--spacing-unit) * 2.5);
  position: relative;
  opacity: 0;
  transform: translateX(110%);
  transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
  width: 100%;
  pointer-events: auto;
  min-height: 50px;
  display: flex;
  align-items: center;
  overflow: hidden;
}

.toast.show {
  opacity: 1;
  transform: translateX(0);
}

.toast.hide {
    opacity: 0;
    transition: opacity 0.3s ease-in, transform 0.3s ease-in;
}

.toast-body {
  flex-grow: 1;
  font-size: 0.9rem;
  line-height: 1.4;
}

.toast-close-btn {
  position: absolute;
  top: 50%;
  right: 15px;
  transform: translateY(-50%);
  background: transparent;
  border: none;
  font-size: 1.4rem;
  line-height: 1;
  font-weight: bold;
  color: inherit;
  opacity: 0.6;
  cursor: pointer;
  padding: 0.1rem 0.4rem;
}
.toast-close-btn:hover {
  opacity: 1;
  text-decoration: none;
}

.toast-success { background-color: #d4edda; color: #155724; border-left: 5px solid var(--success-color); }
.toast-success .toast-close-btn { color: #155724; }
.toast-danger { background-color: #f8d7da; color: #721c24; border-left: 5px solid var(--danger-color); }
.toast-danger .toast-close-btn { color: #721c24; }
.toast-warning { background-color: #fff3cd; color: #856404; border-left: 5px solid var(--warning-color); }
.toast-warning .toast-close-btn { color: #856404; }
.toast-info { background-color: #d1ecf1; color: #0c5460; border-left: 5px solid var(--info-color); }
.toast-info .toast-close-btn { color: #0c5460; }


/* ============================ */
/* Header Styles                */
/* ============================ */

.app-header {
  background-color: var(--primary-color);
  color: var(--light-color);
  padding: calc(var(--spacing-unit) * 0.4) var(--spacing-unit); /* Slightly reduced padding */
  position: sticky;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1200px; /* Max width for content */
  margin: 0 auto;
  gap: calc(var(--spacing-unit) * 0.5);
  min-height: 40px; /* Ensure minimum height */
}

/* Left Side (Logo) */
.nav-left {
  display: flex;
  align-items: center;
  flex-shrink: 0; /* Prevent shrinking */
}

.app-logo {
  display: flex;
  align-items: center;
  color: var(--light-color);
  font-size: 1.1rem; /* Slightly adjusted size */
  font-weight: 500;
  text-decoration: none;
  margin-right: calc(var(--spacing-unit) * 0.5); /* Adjusted margin */
}
.app-logo:hover,
.app-logo:focus {
  color: var(--warning-color); /* Use theme variable for hover */
  text-decoration: none;
}
.app-logo i {
  margin-right: calc(var(--spacing-unit) * 0.3);
  font-size: 1.2em; /* Relative to logo font size */
}

/* Center Section (Search - Desktop/Tablet) */
.search-container-dynamic {
  flex-grow: 1; /* Takes available space on desktop/tablet */
  display: flex;
  justify-content: center; /* Centers the form within */
  margin: 0 calc(var(--spacing-unit) * 0.5);
  max-width: 500px; /* Limit search bar width */
  position: relative; /* For suggestions dropdown */
}

/* --- Search Bar Black & White Styling --- */
.search-form-dynamic {
  display: flex;
  align-items: center;
  width: 100%;
  height: 38px; /* Consistent height */
  background-color: #ffffff; /* White background */
  border: 1px solid #ccc; /* Subtle grey border */
  border-radius: var(--border-radius);
  transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Keep transitions */
  overflow: hidden;
}
/* Remove focus-within styling if input handles it */
.search-form-dynamic:focus-within {
    /* Optional: keep a subtle border change if desired */
    /* border-color: var(--primary-color); */
    /* Rely on input focus style for primary indication */
}


#search-input-dynamic {
  flex-grow: 1;
  padding: 0 calc(var(--spacing-unit) * 0.75);
  border: none; /* No border inside the form */
  background-color: transparent; /* Inherit form background */
  color: var(--dark-color); /* Black text color */
  font-size: 0.9rem;
  height: 100%;
  outline: none; /* Use :focus style from general inputs */
}
#search-input-dynamic::placeholder {
  color: #6c757d; /* Darker gray placeholder */
  opacity: 1;
}

.search-submit-btn-dynamic {
  background: transparent; /* Inherit form background */
  border: none;
  color: var(--dark-color); /* Black icon color */
  padding: 0 calc(var(--spacing-unit) * 0.75);
  cursor: pointer;
  font-size: 1rem;
  height: 100%;
  display: flex;
  align-items: center;
  flex-shrink: 0;
  transition: background-color 0.15s ease-in-out; /* Add transition for hover */
}
.search-submit-btn-dynamic:hover {
  background-color: rgba(0, 0, 0, 0.05); /* Subtle hover effect */
}
/* --- End Search Bar Styling --- */

/* Suggestions Dropdown */
.suggestions-dropdown {
    display: none;
    position: absolute;
    top: 100%; /* Position below the search form */
    left: 0;
    right: 0;
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-top: none;
    border-radius: 0 0 var(--border-radius) var(--border-radius); /* Bottom corners rounded */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    max-height: 400px;
    overflow-y: auto;
    z-index: 1010; /* Above other content */
}
.suggestions-dropdown.active { display: block; }
.suggestion-item {
    display: flex;
    align-items: center;
    padding: calc(var(--spacing-unit) * 0.5) calc(var(--spacing-unit) * 0.75);
    cursor: pointer;
    color: var(--text-color);
    text-decoration: none;
    border-bottom: 1px solid var(--border-color);
    gap: calc(var(--spacing-unit) * 0.5);
}
.suggestion-item:last-child { border-bottom: none; }
.suggestion-item:hover,
.suggestion-item:focus {
    background-color: var(--light-color);
    text-decoration: none;
    color: var(--text-color);
}
.suggestion-item img {
    width: 35px;
    height: 35px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.75);
    flex-shrink: 0;
}
.suggestion-item span {
    font-size: 0.9rem;
    line-height: 1.3;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.suggestion-item i {
    font-style: normal;
    color: var(--secondary-color);
}


/* Right Side (Nav Links, Profile, Login) */
.nav-right {
  display: flex;
  align-items: center;
  flex-shrink: 0; /* Prevent shrinking */
  gap: calc(var(--spacing-unit) * 0.4); /* Base gap for mobile */
}

/* General Nav Link Styling (Mobile Base) */
.nav-link {
  color: var(--light-color);
  padding: calc(var(--spacing-unit) * 0.5) calc(var(--spacing-unit) * 0.6); /* Adjusted padding for touch */
  border-radius: var(--border-radius);
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 0.7rem; /* Small text on mobile */
  text-decoration: none;
  background: none;
  border: none;
  cursor: pointer; /* Ensure cursor indicates clickability */
  transition: background-color 0.2s ease;
  line-height: 1.2; /* Adjust line height */
}
.nav-link span { display: none; } /* Hide text on mobile */
.nav-link i { font-size: 1.2rem; margin-bottom: 2px; } /* Slightly larger icon */

.nav-link:hover,
.nav-link.active,
.nav-link:focus { /* Added focus state */
  background-color: rgba(255, 255, 255, 0.15); /* Slightly more visible hover */
  color: #fff;
  text-decoration: none;
  outline: none; /* Remove default focus outline if custom style is applied */
}

/* Cart Badge */
.nav-link-cart { position: relative; }
.cart-badge {
  position: absolute;
  top: 0px; /* Adjust positioning */
  right: 0px; /* Adjust positioning */
  background-color: var(--danger-color);
  color: white;
  border-radius: 50%;
  padding: 1px 5px;
  font-size: 0.7rem;
  font-weight: bold;
  line-height: 1;
  pointer-events: none; /* Prevent badge interfering with click */
}
.cart-badge.hide { display: none; }

/* Login/Register Button */
.btn-login-register {
    font-size: 0.85rem; /* Adjusted size */
    padding: calc(var(--spacing-unit) * 0.4) calc(var(--spacing-unit) * 0.8);
    background-color: rgba(255, 255, 255, 0.9); /* Brighter button */
    color: var(--primary-color); /* Use primary text color */
    border: none;
    font-weight: 500;
}
.btn-login-register:hover,
.btn-login-register:focus {
    background-color: #fff;
    color: var(--primary-hover);
}
.btn-login-register i {
    margin-right: calc(var(--spacing-unit) * 0.3);
}


/* Profile Avatar */
.profile-avatar-link {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 36px; /* Slightly smaller */
    height: 36px;
    border-radius: 50%;
    background-color: var(--light-color);
    color: var(--primary-color); /* Use primary color for text */
    font-weight: 500; /* Adjusted weight */
    font-size: 0.9rem;
    text-decoration: none;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border: 1px solid transparent;
    margin-left: calc(var(--spacing-unit) * 0.2); /* Adjust margin if needed */
}
.profile-avatar-link:hover,
.profile-avatar-link:focus,
.profile-avatar-link.active {
    text-decoration: none;
    /* Optional: subtle shadow or scale effect */
    /* transform: scale(1.05); */
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
    outline: none;
}
.profile-avatar-initials { line-height: 1; }

/* Mobile Search Toggle Button */
.search-toggle-btn {
    /* Inherits .nav-link styles */
    /* Ensure it's visible only on mobile */
    display: flex;
}

/* Container and Footer */
.container {
  width: 100%;
  padding: var(--spacing-unit);
  margin: 0 auto;
  flex-grow: 1;
}

.app-footer {
  padding: var(--spacing-unit);
  text-align: center;
  font-size: 0.85rem;
  color: var(--secondary-color);
  background-color: rgba(248, 249, 250, 0.9);
  border-top: 1px solid var(--border-color);
  margin-top: auto;
  /* No border-radius on full-width footer */
}


/* Product Index */
.product-index-container h1 { font-size: 1.5rem; }
.search-bar-container { display: none; } /* Kept for potential future use? */

.product-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: calc(var(--spacing-unit) * 0.75);
}

.product-card {
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: var(--card-shadow);
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.product-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.product-link {
  color: inherit;
  text-decoration: none;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}
.product-link:hover{
  color: inherit;
  text-decoration: none;
}

.product-image {
  width: 100%;
  aspect-ratio: 1 / 1;
  object-fit: cover;
}

.product-info {
  padding: calc(var(--spacing-unit) * 0.6);
  flex-grow: 1;
}

.product-name {
  font-size: 0.95rem;
  font-weight: 500;
  margin-bottom: calc(var(--spacing-unit) * 0.25);
  line-height: 1.3;
  height: 2.6em; /* Limit to 2 lines */
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.product-price {
  font-weight: 500;
  color: var(--success-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
  font-size: 1rem;
}

.product-stock,
.product-rating {
  font-size: 0.8rem;
  color: var(--secondary-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
}
.product-rating .fa-star, .product-rating .fa-star-half-alt { color: #f8d347; }
.product-rating .fa-star-regular { color: #e4e5e9; }

.add-to-cart-form { padding: 0 calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.6); }
.btn-add-to-cart {
  width: 100%;
  padding: calc(var(--spacing-unit) * 0.5);
  font-size: 0.9rem;
}
.btn-add-to-cart i { margin-right: calc(var(--spacing-unit) * 0.25); }

/* Product Detail */
.product-detail-container {
  background-color: var(--card-bg);
  padding: var(--spacing-unit);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
}
.product-detail-main {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-unit);
}
.product-detail-image {
    width: 100%;
    max-width: 450px;
    margin: 0 auto var(--spacing-unit) auto;
    aspect-ratio: 1 / 1;
    overflow: hidden;
    border-radius: calc(var(--border-radius) + 2px);
    background-color: #f8f9fa;
    position: relative;
}
.product-detail-image img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
}
.product-detail-info h1 {
    font-size: 1.6rem;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.detail-price {
    font-size: 1.4rem;
    font-weight: bold;
    color: var(--success-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.detail-stock {
    font-size: 0.9rem;
    color: var(--secondary-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.detail-rating { /* Combined rating display style */
    margin-bottom: calc(var(--spacing-unit) * 0.75);
    color: var(--secondary-color);
}
.detail-rating i { color: #f8d347; }
.detail-rating .fa-star-regular { color: #e4e5e9; }

.product-actions {
    margin: calc(var(--spacing-unit) * 1.2) 0;
    display: flex;
    flex-direction: column;
    gap: calc(var(--spacing-unit) * 0.5);
}
.quantity-selector {
    display: flex;
    align-items: center;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
    max-width: 150px;
}
.quantity-selector label {
    margin: 0 calc(var(--spacing-unit) * 0.4) 0 0;
    font-size: 0.9rem;
}
.quantity-selector input {
    text-align: center;
    font-size: 1rem;
    padding: calc(var(--spacing-unit) * 0.4);
}
.product-actions .btn {
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.6) var(--spacing-unit);
    font-size: 1rem;
}

.share-section { margin: calc(var(--spacing-unit) * 1.2) 0; }
.fallback-share-links { margin-top: 0.5rem; }
.fallback-share-links a { margin: 0 0.3rem; font-size: 1.5rem; }

.product-specifications { margin-top: calc(var(--spacing-unit) * 1.5); }
.product-specifications h3 { font-size: 1.1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3rem; margin-bottom: 0.5rem;}
.product-specifications pre {
    white-space: pre-wrap;
    font-size: 0.9rem;
    background-color: #f8f8f8;
    padding: calc(var(--spacing-unit) * 0.5);
    border-radius: var(--border-radius);
    max-height: 200px;
    overflow-y: auto;
}

/* Rating Section */
.product-rating-section {
    margin-top: var(--spacing-unit);
    border-top: 1px solid var(--border-color);
    padding-top: var(--spacing-unit);
}
.product-rating-section h3 {
    margin-bottom: calc(var(--spacing-unit) * 0.6);
    font-size: 1.2em;
}

.rating-stars { display: inline-flex; flex-direction: row-reverse; justify-content: flex-end; margin-bottom: calc(var(--spacing-unit) * 0.8); }
.rating-stars input[type="radio"] { display: none; }
.rating-stars label { display: inline-block; cursor: pointer; font-size: 1.8rem; color: lightgray; padding: 0 0.1em; margin: 0; transition: color 0.2s ease-in-out; }
.rating-stars label:hover, .rating-stars label:hover ~ label { color: #f8d347; }
.rating-stars input[type="radio"]:checked ~ label { color: #f8d347; }

.rating-stats-container { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; }
.rating-stats-container h3 { margin-bottom: 15px; font-size: 1.4em; color: #333; }
.rating-summary { display: flex; align-items: center; margin-bottom: 20px; gap: 15px; }
.rating-average { display: flex; align-items: center; }
.rating-average-value { font-size: 2.5em; font-weight: 500; margin-right: 5px; color: #222; }
.rating-average .fa-star { font-size: 1.2em; color: #666; margin-bottom: 8px; }
.rating-total { font-size: 0.95em; color: #555; }
.rating-bars { max-width: 400px; }
.rating-bar-row { display: flex; align-items: center; margin-bottom: 8px; gap: 10px; }
.rating-bar-label { width: 45px; font-size: 0.9em; color: #444; text-align: right; flex-shrink: 0; }
.rating-bar-label .fa-star { color: #f8c107; font-size: 0.9em; }
.rating-bar-progress { flex-grow: 1; height: 8px; background-color: #e0e0e0; border-radius: 4px; overflow: hidden; }
.progress { background-color: #e9ecef; border-radius: 4px; display: flex; height: 1rem; overflow: hidden; font-size: .75rem;}
.progress-bar { background-color: var(--primary-color); color: #fff; display: flex; flex-direction: column; justify-content: center; overflow: hidden; text-align: center; white-space: nowrap; transition: width .6s ease;}
.rating-bar-fill { height: 100%; background-color: #28a745; border-radius: 4px; transition: width 0.3s ease-in-out; }
.rating-bar-row:nth-child(1) .rating-bar-fill { background-color: #28a745; } /* 5 stars */
.rating-bar-row:nth-child(2) .rating-bar-fill { background-color: #84c54c; } /* 4 stars */
.rating-bar-row:nth-child(3) .rating-bar-fill { background-color: #ffc107; } /* 3 stars */
.rating-bar-row:nth-child(4) .rating-bar-fill { background-color: #fd7e14; } /* 2 stars */
.rating-bar-row:nth-child(5) .rating-bar-fill { background-color: #dc3545; } /* 1 star */
.rating-bar-count { width: 40px; font-size: 0.9em; color: #555; text-align: right; flex-shrink: 0; }


/* Auth */
.auth-container {
  max-width: 450px;
  margin: var(--spacing-unit) auto;
  padding: var(--spacing-unit);
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
}
.auth-container h1 { font-size: 1.6rem; text-align: center; margin-bottom: var(--spacing-unit); }
.auth-form .btn { width: 100%; margin-top: calc(var(--spacing-unit) * 0.5); padding: calc(var(--spacing-unit) * 0.7); }
.auth-links { margin-top: var(--spacing-unit); font-size: 0.9rem; text-align: center; }
.auth-links p { margin-bottom: calc(var(--spacing-unit) * 0.4); }
.auth-container p { text-align: center; margin-bottom: var(--spacing-unit);}
.auth-container form ~ .auth-links { border-top: 1px solid var(--border-color); padding-top: var(--spacing-unit); }
#otp { text-align: center; font-size: 1.2rem; letter-spacing: 4px; }


/* Cart */
.cart-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit); }
.cart-items { margin-bottom: var(--spacing-unit); }

.cart-item {
  display: grid;
  grid-template-columns: 80px 1fr auto;
  grid-template-areas:
    "image details remove"
    "image quantity subtotal";
  gap: calc(var(--spacing-unit) * 0.75);
  background-color: var(--card-bg);
  padding: calc(var(--spacing-unit) * 0.75);
  border-bottom: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  margin-bottom: var(--spacing-unit);
  box-shadow: var(--card-shadow);
}

.cart-item-image { grid-area: image; align-self: center;}
.cart-item-image img {
    width: 80px;
    height: 80px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.75);
}
.cart-item-details { grid-area: details; }
.cart-item-quantity { grid-area: quantity; display: flex; align-items: center; gap: 0.3rem; }
.cart-item-subtotal { grid-area: subtotal; text-align: right; font-weight: 500; align-self: center; }
.cart-item-remove { grid-area: remove; text-align: right; align-self: start;}
.cart-item-name { font-size: 1rem; font-weight: 500; margin-bottom: calc(var(--spacing-unit) * 0.2); }
.cart-item-price { font-size: 0.9rem; color: var(--secondary-color); margin-bottom: calc(var(--spacing-unit) * 0.2); }
.cart-item-stock { font-size: 0.8rem; color: #6c757d; }
.cart-item-quantity label { font-size: 0.9rem; margin-bottom: 0; display: none; }
.cart-item-quantity input { width: 50px; padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.4); text-align: center; font-size: 0.9rem; }
.cart-item-quantity .btn-update-qty { font-size: 0.8rem; padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.6); }
.cart-item-subtotal { font-size: 0.9rem; white-space: nowrap; }
.cart-item-subtotal .item-subtotal-value { font-weight: 500; }
.cart-item-remove .btn { padding: 0.1rem 0.4rem; font-size: 0.8rem; line-height: 1; }

.cart-summary {
  margin-top: calc(var(--spacing-unit) * 1.5);
  padding: var(--spacing-unit);
  background-color: #f8f9fa;
  border-top: 2px solid var(--primary-color);
  border-radius: var(--border-radius);
  text-align: right;
}
.cart-summary h2 { font-size: 1.3rem; margin-bottom: calc(var(--spacing-unit) * 0.75); }
.btn-checkout { width: 100%; padding: calc(var(--spacing-unit) * 0.7); font-size: 1.1rem; }


/* Checkout */
.checkout-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit);}
.checkout-grid { display: flex; flex-direction: column; gap: var(--spacing-unit); }

.checkout-address, .checkout-summary {
    background-color: var(--card-bg);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}
.checkout-address h2, .checkout-summary h2 { font-size: 1.2rem; border-bottom: 1px solid var(--border-color); padding-bottom: calc(var(--spacing-unit) * 0.4); margin-bottom: var(--spacing-unit); }
.saved-address { font-size: 0.95rem; margin-bottom: var(--spacing-unit); }
.saved-address p { margin-bottom: calc(var(--spacing-unit) * 0.2); line-height: 1.4; }
#edit-address-btn { margin-top: calc(var(--spacing-unit) * 0.5); }
.address-form h3 { font-size: 1.1rem; }

.checkout-items { max-height: 200px; overflow-y: auto; margin-bottom: var(--spacing-unit); padding-right: calc(var(--spacing-unit) * 0.5); }
.checkout-item { display: flex; align-items: center; gap: calc(var(--spacing-unit) * 0.5); margin-bottom: calc(var(--spacing-unit) * 0.5); font-size: 0.9rem; }
.checkout-item-image img {
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.75);
}
.checkout-item-info { flex-grow: 1; }
.checkout-item-price { font-weight: 500; white-space: nowrap;}

.checkout-totals { font-size: 0.95rem; }
.checkout-totals p { display: flex; justify-content: space-between; margin-bottom: calc(var(--spacing-unit) * 0.3); }
.checkout-totals hr { margin: calc(var(--spacing-unit) * 0.5) 0; border-color: var(--border-color); opacity: 0.5;}
.checkout-totals strong { font-weight: bold; }

.checkout-payment h3 { font-size: 1.1rem; margin: calc(var(--spacing-unit) * 1) 0 calc(var(--spacing-unit) * 0.5) 0; }
.payment-option {
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background-color: #f0f0f0;
    opacity: 0.8;
    margin-bottom: 0.5rem;
    cursor: pointer;
}
.payment-option.selected { border-color: var(--primary-color); opacity: 1; background-color: #e7f3ff; }
.payment-option label { font-weight: normal; display: flex; align-items: center; cursor: pointer; margin-bottom: 0; }
.payment-option input[type="radio"] { margin-right: 0.5rem; }
.payment-option i { margin-right: 0.3rem; color: var(--success-color);}

.place-order-form { margin-top: var(--spacing-unit); }
.btn-place-order { width: 100%; font-size: 1.1rem; padding: calc(var(--spacing-unit) * 0.7); }


/* My Orders */
.my-orders-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit); }
.order-list { display: flex; flex-direction: column; gap: var(--spacing-unit); }
.order-card {
  background-color: var(--card-bg);
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color);
  box-shadow: var(--card-shadow);
  overflow: hidden;
}

.order-header {
  background-color: #f8f9fa;
  padding: calc(var(--spacing-unit) * 0.6);
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  font-size: 0.85rem;
  color: var(--secondary-color);
  border-bottom: 1px solid var(--border-color);
}
.order-header > div { margin-right: calc(var(--spacing-unit) * 0.8); margin-bottom: calc(var(--spacing-unit) * 0.2); white-space: nowrap; }
.order-header strong { color: var(--text-color); }
.order-status { display: inline-block; } /* Used within header */

.order-body { padding: calc(var(--spacing-unit) * 0.75); display: flex; flex-direction: column; gap: calc(var(--spacing-unit) * 0.75); }

/* Order Item Images (Shared) */
.order-items-images { display: flex; flex-wrap: wrap; gap: 8px; padding-left: 0; list-style: none; } /* Added list-style: none */
.order-item-thumbnail {
    display: inline-block;
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.75);
    border: 1px solid var(--border-color);
    transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    vertical-align: middle;
    background-color: #f8f9fa;
}
.order-item-thumbnail:hover { opacity: 0.85; transform: scale(1.05); z-index: 10; }
.order-item-thumbnail-placeholder {
    display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px;
    border-radius: calc(var(--border-radius) * 0.75);
    border: 1px dashed var(--secondary-color); background-color: var(--light-color); color: var(--secondary-color); font-size: 0.6rem; font-weight: bold; text-align: center; text-decoration: none; transition: background-color 0.2s ease-in-out; vertical-align: middle; line-height: 1; padding: 2px;
}
.order-item-thumbnail-placeholder:hover { background-color: #e2e6ea; text-decoration: none; }

.order-details { font-size: 0.9rem; line-height: 1.5;}
.order-details p { margin-bottom: calc(var(--spacing-unit) * 0.3); }
.order-actions { padding: 0 calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 0.75); text-align: right; }


/* Status Badge */
.status-badge {
    font-weight: bold;
    padding: 0.2em 0.5em;
    border-radius: var(--border-radius);
    color: #333;
    background-color: var(--secondary-color);
    font-size: 0.85em;
    display: inline-block;
    vertical-align: middle;
    text-transform: capitalize;
}
.status-pending, .status-badge.status-pending { background-color: #fff3cd; color: #856404; }
.status-out-for-delivery, .status-badge.status-out-for-delivery { background-color: #d1ecf1; color: #0c5460; }
.status-delivered, .status-badge.status-delivered { background-color: #d4edda; color: #155724; }
.status-cancelled, .status-badge.status-cancelled { background-color: #f8d7da; color: #721c24; }
.status-approved, .status-badge.status-approved { background-color: #d4edda; color: #155724; } /* Added for consistency */
.status-rejected, .status-badge.status-rejected { background-color: #f8d7da; color: #721c24; } /* Added for consistency */

.order-card.status-cancelled, .data-table tr.status-cancelled { opacity: 0.9; }
.data-table tr.status-rejected { opacity: 0.85; } /* Slightly different opacity for rejected products */
.data-table tr.status-pending { /* Optional: style pending rows */ }

/* Admin/Seller Pages */
.admin-manage-container, .admin-dashboard-container { padding: var(--spacing-unit); }
.admin-manage-container h1, .admin-dashboard-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit); border-bottom: 1px solid var(--border-color); padding-bottom: calc(var(--spacing-unit) * 0.5); }


/* Responsive Tables */
.table-container { overflow-x: auto; margin-bottom: var(--spacing-unit); }

.data-table {
  width: 100%;
  border-collapse: separate; /* Needed for border-radius effect */
  border-spacing: 0;
  font-size: 0.9rem;
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
  overflow: hidden;
}

.data-table thead {
  display: none; /* Hidden by default for mobile */
  background-color: #f8f9fa;
  font-weight: 500;
  color: var(--dark-color);
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.data-table th { padding: calc(var(--spacing-unit) * 0.7) calc(var(--spacing-unit) * 0.6); text-align: left; border-bottom: 1px solid var(--border-color); }

/* Mobile Table Rows (Card-like) */
.data-table tbody tr {
  display: block;
  margin-bottom: calc(var(--spacing-unit) * 1);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: calc(var(--spacing-unit) * 0.8);
  background-color: var(--card-bg);
  box-shadow: var(--card-shadow);
  transition: box-shadow 0.2s ease-in-out;
}
.data-table tbody tr:last-child { margin-bottom: 0; } /* Remove margin from last card */
.data-table tbody tr:hover { box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1); }

.data-table td { display: block; text-align: right; padding: calc(var(--spacing-unit) * 0.4) 0; position: relative; border-bottom: 1px dashed #eee; }
.data-table td:last-child { border-bottom: none; }
.data-table td::before { content: attr(data-label); position: absolute; left: 0; font-weight: 500; text-align: left; padding-right: 10px; color: var(--secondary-color); width: 40%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.85em; }

.table-img {
    max-width: 50px;
    border-radius: calc(var(--border-radius) * 0.75);
    display: inline-block;
    margin-left: 45%; /* Push image to the right of the label */
    vertical-align: middle;
}
.data-table td:has(img) { text-align: right; padding: 5px 0; } /* Adjust padding for image cells */

/* Mobile Actions Cell */
.data-table td.actions-cell { padding-top: calc(var(--spacing-unit) * 0.6); }
.data-table td.actions-cell::before { display: none; } /* Hide label for actions */
.actions-cell .action-group { border-top: 1px solid #eee; padding-top: calc(var(--spacing-unit) * 0.6); margin-top: calc(var(--spacing-unit) * 0.6); text-align: left; }
.actions-cell .action-group:first-child { border-top: none; margin-top: 0; padding-top: 0; }
.actions-cell .action-group-title { font-size: 0.8em; font-weight: bold; color: var(--secondary-color); margin-bottom: calc(var(--spacing-unit) * 0.4); display: block; text-align: left; }
.actions-cell form, .actions-cell .btn { margin: calc(var(--spacing-unit) * 0.25) 0; display: block; width: 100%; }
.actions-cell .inline-form { display: flex; flex-wrap: wrap; gap: calc(var(--spacing-unit) * 0.4); align-items: center; }
.actions-cell .inline-form input, .actions-cell .inline-form button { width: auto; flex-grow: 1; }
.actions-cell .inline-form button { flex-grow: 0; flex-shrink: 0; }
.actions-cell select.form-control-sm { margin-bottom: 5px; font-size: 0.9rem; padding: calc(var(--spacing-unit)*0.4) calc(var(--spacing-unit)*0.6); height: auto; width: 100%; }
.actions-cell .no-actions-text { display: block; text-align: left; margin-top: calc(var(--spacing-unit) * 0.5); color: var(--secondary-color); font-style: italic; }

/* Mobile Order Table Specifics */
.order-table td[data-label="Items"] .order-items-summary { font-size: 0.85em; line-height: 1.5; margin-bottom: calc(var(--spacing-unit) * 0.5); text-align: left; margin-left: 45%; }
.order-table td[data-label="Items"] .order-items-summary strong { color: var(--dark-color); }
.order-table .order-items-images { margin-top: calc(var(--spacing-unit) * 0.4); justify-content: flex-end; margin-left: 45%; }
.order-table td[data-label="Total"].order-total strong { font-size: 1.1em; color: var(--success-color); }
.order-table td[data-label="Status"] .status-badge { float: right; margin-bottom: 5px; }
.order-table td[data-label="Status"] small { clear: both; display: block; text-align: right; margin-top: calc(var(--spacing-unit) * 0.3); }

/* Mobile Delivery OTP */
.delivery-otp-display {
    margin-top: 10px;
    padding: 8px 12px;
    background-color: #e6ffed;
    border: 1px solid #b7e4c7;
    border-radius: var(--border-radius);
    font-size: 0.9rem;
    text-align: left;
    clear: both;
    margin-left: 45%; /* Align with other mobile table content */
}
.delivery-otp-display p { margin-bottom: 3px !important; }
.delivery-otp-code {
    font-weight: bold;
    color: #2b9348;
    font-size: 1.1em;
    margin: 0 3px;
    letter-spacing: 1px;
    background-color: #fff;
    padding: 1px 4px;
    border-radius: calc(var(--border-radius) * 0.5);
}
.delivery-otp-display small { display: block; margin-top: 3px; color: #555; }
.verify-otp-form { display: flex; align-items: center; gap: 5px; width: 100%; }
.verify-otp-form input[name="otp"] { flex-grow: 1; max-width: 150px; padding: calc(var(--spacing-unit)*0.4) calc(var(--spacing-unit)*0.6); font-size: 0.9rem; text-align: center; border-radius: var(--border-radius); }
.verify-otp-form button { flex-shrink: 0; width: auto; padding: calc(var(--spacing-unit)*0.4) calc(var(--spacing-unit)*0.6); font-size: 0.9rem; line-height: 1.4; }

/* Admin Actions Grid */
.admin-actions-grid { display: grid; grid-template-columns: repeat(1, 1fr); gap: var(--spacing-unit); margin-top: var(--spacing-unit); } /* Default to 1 column */
.admin-action-card {
    background-color: var(--card-bg);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    text-align: center;
    box-shadow: var(--card-shadow);
    transition: transform 0.2s, box-shadow 0.2s;
    color: var(--text-color);
    text-decoration: none;
}
.admin-action-card:hover { transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); text-decoration: none; }
.admin-action-card i { font-size: 2rem; color: var(--primary-color); margin-bottom: 0.5rem; }
.admin-action-card h3 { font-size: 1.1rem; margin-bottom: 0.3rem; color: var(--text-color); }
.admin-action-card p { font-size: 0.85rem; color: var(--secondary-color); margin-bottom: 0.5rem; }


/* Error Page */
.error-container { text-align: center; padding-top: 2rem; }
.error-container h1 { color: var(--danger-color); margin-bottom: 0.5rem; }
.error-container .lead { font-size: 1.1rem; }
.error-container details {
    text-align: left;
    margin-top: 1rem;
    background: #f1f1f1;
    padding: 0.5rem;
    border-radius: var(--border-radius);
}
.error-container details summary { cursor: pointer; font-weight: bold; }
.error-container details pre { white-space: pre-wrap; font-size: 0.8em; margin-top: 0.5rem; }


/* Profile Page */
.profile-container {
    max-width: 800px;
    margin: var(--spacing-unit) auto;
    padding: calc(var(--spacing-unit) * 1.5);
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    box-shadow: var(--card-shadow);
}
.profile-container h1 { font-size: 1.8rem; text-align: center; margin-bottom: calc(var(--spacing-unit) * 0.5); }
.profile-container > p.text-muted { text-align: center; font-size: 1.1rem; }
.profile-section { margin-top: calc(var(--spacing-unit) * 1.5); padding-top: calc(var(--spacing-unit) * 1); border-top: 1px solid var(--border-color); }
.profile-section:first-of-type { border-top: none; padding-top: 0; margin-top: calc(var(--spacing-unit) * 0.8); }
.profile-section h2 { font-size: 1.4rem; margin-bottom: calc(var(--spacing-unit) * 0.8); color: var(--primary-color); }
#saved-address-display p { margin-bottom: calc(var(--spacing-unit) * 0.3); line-height: 1.5; font-size: 1rem; }
#saved-address-display strong { font-weight: 500; }
#edit-address-btn, #add-address-btn { margin-top: calc(var(--spacing-unit) * 0.5); }
.address-form { max-width: 500px; }
.address-form h3 { font-size: 1.2rem; margin-bottom: var(--spacing-unit); font-weight: 500; }
#cancel-edit-btn { margin-left: calc(var(--spacing-unit) * 0.5); }
.dashboards-section .btn,
.orders-section .btn { /* Include orders section buttons */
    margin-right: 10px; margin-bottom: 10px;
}
.logout-section .btn { min-width: 120px; }


/* Banner Slider Styles */
.banner-slider-container {
  position: relative;
  width: 100%;
  aspect-ratio: 25 / 6; /* Default widescreen */
  overflow: hidden;
  border-radius: var(--border-radius);
  background-color: #e0e0e0;
}

.banner-slides {
  position: relative;
  width: 100%;
  height: 100%;
}

.banner-slide {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.6s ease-in-out;
  background-color: #eee;
}

.banner-slide.active {
  opacity: 1;
  visibility: visible;
  z-index: 1;
}

.banner-link {
  display: block;
  width: 100%;
  height: 100%;
}

.banner-image {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Navigation Arrows */
.banner-nav {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background-color: rgba(0, 0, 0, 0.4);
  color: white;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 1rem;
  cursor: pointer;
  z-index: 2;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
  opacity: 0.8;
}

.banner-nav:hover {
  background-color: rgba(0, 0, 0, 0.6);
  opacity: 1;
}

.banner-prev { left: 10px; }
.banner-next { right: 10px; }

/* Navigation Dots */
.banner-dots {
  position: absolute;
  bottom: 15px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 8px;
  z-index: 2;
}

.banner-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.5);
  border: 1px solid rgba(0, 0, 0, 0.2);
  cursor: pointer;
  padding: 0;
  transition: background-color 0.3s ease;
}

.banner-dot.active { background-color: white; }


/* ============================ */
/* Media Queries                */
/* ============================ */

/* Mobile Specific Styles (Less than 768px) */
@media (max-width: 767px) {
  .app-footer { display: none; } /* Hide footer on small screens */
  .banner-slider-container { aspect-ratio: 2.4 / 1; } /* Taller banner on mobile */
  .banner-nav { width: 35px; height: 35px; font-size: 0.9rem; }
  .banner-dots { bottom: 10px; }
  .banner-dot { width: 8px; height: 8px; }

  /* Mobile Header Search Bar Handling */
  .search-container-dynamic {
      flex-grow: 0;
      max-width: none;
      order: 1;
      margin: 0;
      position: static;
  }
  .search-toggle-btn { order: 0; display: flex; } /* Ensure toggle is displayed */
  .nav-left { margin-right: auto; }

  .search-form-dynamic {
      position: absolute;
      top: calc(100% + 8px);
      left: var(--spacing-unit);
      right: var(--spacing-unit);
      width: calc(100% - (2 * var(--spacing-unit)));
      background-color: var(--card-bg); /* White background */
      border: 1px solid var(--border-color); /* Standard border */
      box-shadow: 0 3px 6px rgba(0,0,0,0.15);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px) scaleY(0.95);
      transform-origin: top center;
      transition: opacity 0.25s ease, visibility 0s linear 0.25s, transform 0.25s ease;
      z-index: 1005;
      border-radius: var(--border-radius);
      height: 42px;
  }
  /* Ensure mobile search input/button also use black/white */
  #search-input-dynamic {
      color: var(--dark-color); /* Black text */
      background-color: transparent; /* Inherit from form */
  }
  #search-input-dynamic::placeholder {
      color: #6c757d; /* Darker gray placeholder */
  }
  .search-submit-btn-dynamic {
      color: var(--dark-color); /* Black icon */
      background-color: transparent; /* Inherit from form */
  }
   .search-submit-btn-dynamic:hover {
      background-color: rgba(0, 0, 0, 0.05); /* Subtle hover */
  }


  .search-container-dynamic.active .search-form-dynamic {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scaleY(1);
      transition: opacity 0.25s ease, visibility 0s linear 0s, transform 0.25s ease;
  }

  .suggestions-dropdown {
      position: absolute;
      top: calc(100% + 8px + 42px + 4px); /* Adjust based on search bar position */
      left: var(--spacing-unit);
      right: var(--spacing-unit);
      width: calc(100% - (2 * var(--spacing-unit)));
      z-index: 1010;
      border-radius: var(--border-radius);
      border-top: 1px solid var(--border-color);
  }
   .search-container-dynamic.active .suggestions-dropdown.active { display: block; }
}


/* Tablet and Up (768px+) */
@media (min-width: 768px) {
  .container { max-width: 960px; }
  .app-footer { display: block; } /* Show footer */
  .product-grid { grid-template-columns: repeat(3, 1fr); }
  .product-name { height: auto; white-space: normal; display: block; -webkit-line-clamp: unset; -webkit-box-orient: unset; }
  .product-detail-main { flex-direction: row; align-items: flex-start; }
  .product-detail-info { flex: 1 1 60%; }
  .product-detail-image { flex: 1 1 40%; width: auto; max-width: none; margin: 0; }
  .product-actions { flex-direction: row; align-items: center; }
  .product-actions .btn { width: auto; }
  .quantity-selector { max-width: 120px; margin-bottom: 0; }
  .auth-container { margin: calc(var(--spacing-unit) * 2) auto; }
  .cart-item { grid-template-columns: 100px 1fr 100px 150px 80px; grid-template-areas: "image details price quantity remove"; align-items: center; padding: var(--spacing-unit); }
  .cart-item-details { grid-area: details; }
  .cart-item-price { display: block; grid-area: price; text-align: right; font-weight: 500; font-size: 1rem; color: var(--text-color); margin-bottom: 0; }
  .cart-item-quantity { grid-area: quantity; justify-content: center; }
  .cart-item-subtotal { display: none; }
  .cart-item-remove { grid-area: remove; align-self: center; text-align: center; }
  .checkout-grid { flex-direction: row; gap: calc(var(--spacing-unit) * 1.5); align-items: flex-start; }
  .checkout-address { flex: 1 1 55%; }
  .checkout-summary { flex: 1 1 45%; }

  /* --- Desktop Table Refinements --- */
  .data-table thead { display: table-header-group; }
  .data-table tbody tr { display: table-row; margin-bottom: 0; border: none; padding: 0; box-shadow: none; background-color: transparent; border-bottom: 1px solid var(--border-color); border-radius: 0; }
  .data-table tbody tr:last-child { border-bottom: none; }
  .data-table tbody tr:hover { background-color: #f1f5f9; }
  .data-table td { display: table-cell; text-align: left; padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.6); vertical-align: middle; border-bottom: none; position: static; margin-left: 0 !important; }
  .data-table td::before { content: none; }
  .table-img { max-width: 60px; margin-left: 0; }
  .data-table td:has(img) { text-align: left; width: 80px; }
  .data-table th[data-label*="Price"], .data-table td[data-label*="Price"],
  .data-table th[data-label*="Stock"], .data-table td[data-label*="Stock"],
  .data-table th[data-label*="Total"], .data-table td[data-label*="Total"],
  .data-table td.order-total { text-align: right; width: 100px; }
  .data-table th[data-label="Status"], .data-table td[data-label="Status"],
  .data-table td.order-status-cell { text-align: center; width: 150px; }
  .data-table td[data-label="Status"] .status-badge, .order-status-cell .status-badge { float: none; display: inline-block; }
  .order-status-cell small { text-align: center; }
  .data-table th.actions-cell, .data-table td.actions-cell { text-align: right !important; width: 250px; white-space: normal; }
  .actions-cell .action-group { border: none; padding: 0; margin: 0 0 calc(var(--spacing-unit) * 0.5) 0; display: block; text-align: right; }
  .actions-cell .action-group:last-child { margin-bottom: 0; }
  .actions-cell .action-group-title { display: none; }
  .actions-cell form, .actions-cell .btn { display: inline-block; width: auto; margin: 0 0 0 calc(var(--spacing-unit) * 0.3); vertical-align: middle; }
  .actions-cell .inline-form { display: inline-flex; width: auto; margin-left: 0; } /* Adjust inline form display */
  .actions-cell .inline-form + .inline-form { margin-left: calc(var(--spacing-unit) * 0.3); } /* Space between adjacent forms */
  .actions-cell .verify-otp-form input { max-width: 100px; }
  .actions-cell select.form-control-sm { width: auto; display: inline-block; margin-right: 5px;}
  .actions-cell .no-actions-text { display: inline-block; text-align: right; width: 100%;}
  .w-md-auto { width: auto !important; }
  .order-table td[data-label="Items"] .order-items-summary { margin-left: 0; text-align: left; }
  .order-table .order-items-images { justify-content: flex-start; margin-left: 0; }
  .delivery-otp-display { margin-left: 0; margin-top: 5px; padding: 5px 8px; font-size: 0.85rem; display: inline-block; width: auto; text-align: center; }
  .delivery-otp-display p { margin-bottom: 0 !important; }
  .delivery-otp-display small { display: none; } /* Hide verbose text on desktop */

  /* Admin Actions Grid */
  .admin-actions-grid { grid-template-columns: repeat(2, 1fr); } /* 2 columns for tablets */

  /* Rating Stats Layout */
  .rating-stats-container { display: flex; align-items: flex-start; gap: calc(var(--spacing-unit) * 2); }
  .rating-summary { flex-direction: column; align-items: center; margin-bottom: 0; flex-basis: 150px; flex-shrink: 0; }
  .rating-average-value { font-size: 3em; }
  .rating-total { font-size: 1em; }
  .rating-bars { max-width: none; flex-grow: 1; }

  .profile-container { padding: calc(var(--spacing-unit) * 2); }

  /* Desktop Header Search */
  .app-header {
      padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
  }
  .navbar { gap: var(--spacing-unit); }
  .app-logo .app-name { display: inline; }
  .app-logo { font-size: 1.2rem; }
  .search-toggle-btn { display: none; } /* Hide toggle button on desktop */
  .search-container-dynamic { display: flex; } /* Ensure search container is visible */
  /* Ensure desktop search form uses black/white */
  .search-form-dynamic {
      position: relative; /* Override absolute positioning from mobile */
      top: auto; left: auto; right: auto; width: 100%; /* Override mobile positioning */
      background-color: #ffffff; /* White background */
      border: 1px solid #ccc; /* Subtle grey border */
      box-shadow: none; /* Remove mobile shadow */
      opacity: 1; visibility: visible; transform: none; /* Override mobile transitions */
      transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Keep transitions */
      height: 38px;
  }
  #search-input-dynamic {
      color: var(--dark-color); /* Black text */
      background-color: transparent; /* Inherit from form */
  }
  #search-input-dynamic::placeholder {
      color: #6c757d; /* Darker gray placeholder */
  }
  .search-submit-btn-dynamic {
      color: var(--dark-color); /* Black icon */
      background-color: transparent; /* Inherit from form */
  }
  .search-submit-btn-dynamic:hover {
      background-color: rgba(0, 0, 0, 0.05); /* Subtle hover */
  }
  /* --- End Desktop Search Specific Styles --- */

  .nav-link { flex-direction: row; font-size: 0.9rem; align-items: center; padding: calc(var(--spacing-unit) * 0.4) calc(var(--spacing-unit) * 0.8); }
  .nav-link span { display: inline; margin-left: calc(var(--spacing-unit) * 0.3); }
  .nav-link i { font-size: 1rem; margin-bottom: 0; margin-right: 0; }
  .nav-right { gap: calc(var(--spacing-unit) * 0.75); }
  .profile-avatar-link { width: 38px; height: 38px; }
  .btn-login-register { font-size: 0.9rem; }
  .suggestions-dropdown { position: absolute; top: 100%; left: 0; right: 0; width: 100%; }

} /* End @media (min-width: 768px) */


/* Larger Desktops (1024px+) */
@media (min-width: 1024px) {
  .container { max-width: 1140px; }
  .product-grid { grid-template-columns: repeat(4, 1fr); }
  .product-grid, .admin-actions-grid { gap: calc(var(--spacing-unit) * 1); }
  .admin-actions-grid { grid-template-columns: repeat(3, 1fr); } /* 3 columns for larger screens */
  .navbar { max-width: 1140px; } /* Wider navbar content */
} /* End @media (min-width: 1024px) */


/* Extra Large Desktops (1200px+) */
@media (min-width: 1200px) {
    .admin-actions-grid { grid-template-columns: repeat(4, 1fr); } /* 4 columns for very large screens */
}

public/js/main.js:
// public/js/main.js
console.log("Main JS loaded.");

document.addEventListener('DOMContentLoaded', () => {

    // --- Button Spinner Logic ---
    document.querySelectorAll('form.form-submit-spinner').forEach(form => {
        form.addEventListener('submit', (event) => {
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton && !submitButton.disabled) {
                // Basic HTML5 validation check
                if (typeof form.checkValidity === 'function' && !form.checkValidity()) {
                    // If form is invalid, don't disable button or show spinner
                    return;
                }
                const originalText = submitButton.innerHTML;
                submitButton.dataset.originalText = originalText; // Store original HTML
                submitButton.disabled = true;
                submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';

                // Reset button if user navigates back without form submitting (browser specific)
                window.addEventListener('pageshow', function(pageEvent) { // Renamed event variable
                    if (pageEvent.persisted && submitButton.disabled) {
                        // Restore button only if it still has the loading state
                        if (submitButton.dataset.originalText) {
                            submitButton.innerHTML = submitButton.dataset.originalText;
                        }
                        submitButton.disabled = false;
                    }
                });
            }
        });
    });

    // --- Responsive Table Logic ---
    function responsiveTables() {
        const tables = document.querySelectorAll('.data-table');
        tables.forEach(table => {
            const headerElements = table.querySelectorAll('thead th');
            if (!headerElements || headerElements.length === 0) return;

            const headers = Array.from(headerElements).map(th => th.textContent.trim());
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                cells.forEach((cell, index) => {
                    // Add data-label only if it doesn't exist and header exists
                    if (!cell.hasAttribute('data-label') && headers[index] !== undefined && headers[index] !== '') {
                         cell.setAttribute('data-label', headers[index]);
                    }
                });
            });
        });
    }
     if (document.querySelector('.data-table')) {
         responsiveTables();
     }

    // --- Share Button Logic ---
    const shareButton = document.getElementById('share-product-btn');
    const fallbackLinks = document.getElementById('fallback-share-links');
    if (shareButton && fallbackLinks) {
        shareButton.addEventListener('click', async () => {
            const title = shareButton.dataset.title || document.title; // Fallback to page title
            const text = shareButton.dataset.text || `Check out ${title}`; // Fallback text
            const url = shareButton.dataset.url || window.location.href; // Fallback url

            if (navigator.share) {
                try {
                    await navigator.share({ title, text, url });
                    console.log('Product shared successfully!');
                    showToast('Link shared!', 'success'); // Optional feedback
                } catch (error) {
                    console.error('Error sharing:', error);
                    // Don't show fallback if user explicitly cancelled (AbortError)
                    if (error.name !== 'AbortError') {
                         fallbackLinks.classList.remove('hidden');
                         showToast('Sharing failed, use fallback links.', 'warning');
                    }
                }
            } else {
                console.log('Web Share API not supported, showing fallback links.');
                fallbackLinks.classList.remove('hidden');
                showToast('Web Share not supported, use link options.', 'info');
            }
        });
    }

    // --- Profile Address Toggle Logic ---
    const profilePage = document.querySelector('.profile-container'); // Check if we are on profile page
    if (profilePage) {
        const profileEditBtn = profilePage.querySelector('#edit-address-btn');
        const profileAddBtn = profilePage.querySelector('#add-address-btn');
        const profileCancelBtn = profilePage.querySelector('#cancel-edit-btn');
        const profileAddressForm = profilePage.querySelector('#address-form');
        const profileSavedAddressDiv = profilePage.querySelector('#saved-address-display');

        const showProfileForm = () => {
            if (!profileAddressForm || !profileSavedAddressDiv) return; // Safety check
            profileAddressForm.classList.remove('hidden');
            // Check if saved address has actual content besides the button
            const hasSavedContent = profileSavedAddressDiv.querySelector('p strong');
            profileAddressForm.querySelector('h3').textContent = hasSavedContent ? 'Edit Address' : 'Add Address';
            profileSavedAddressDiv.classList.add('hidden');
            if (profileCancelBtn && hasSavedContent) {
                profileCancelBtn.classList.remove('hidden'); // Show cancel only when editing existing
            } else if (profileCancelBtn) {
                profileCancelBtn.classList.add('hidden'); // Hide cancel when adding new
            }
            if (profileAddBtn) profileAddBtn.classList.add('hidden'); // Hide Add button when form is shown
        };

        const hideProfileForm = () => {
            if (!profileAddressForm || !profileSavedAddressDiv) return; // Safety check
            profileAddressForm.classList.add('hidden');
            profileSavedAddressDiv.classList.remove('hidden'); // Always show the container (it shows "No address" or the address)
            if (profileCancelBtn) profileCancelBtn.classList.add('hidden');
            // Show Add button only if no address content exists
            if (!profileSavedAddressDiv.querySelector('p strong') && profileAddBtn) {
                 profileAddBtn.classList.remove('hidden');
            } else if(profileAddBtn) {
                 profileAddBtn.classList.add('hidden'); // Ensure add button is hidden if address exists
            }
        };

        if (profileEditBtn) {
            profileEditBtn.addEventListener('click', showProfileForm);
        }
        if (profileAddBtn) {
             profileAddBtn.addEventListener('click', () => {
                 if(profileAddressForm) profileAddressForm.reset(); // Clear form fields when adding new
                showProfileForm();
             });
        }
        if (profileCancelBtn) {
            profileCancelBtn.addEventListener('click', hideProfileForm);
        }

        // Initial state check
        if (profileAddressForm && profileSavedAddressDiv && profileAddBtn) {
            if (!profileSavedAddressDiv.querySelector('p strong') && profileAddressForm.classList.contains('hidden')) {
                profileAddBtn.classList.remove('hidden'); // Show add button if no address
            } else {
                profileAddBtn.classList.add('hidden'); // Hide add button if address exists or form is shown
            }
        }

        // Name Edit Logic (Profile Page Only)
        const editNameBtn = document.getElementById('edit-name-btn');
        const cancelNameBtn = document.getElementById('cancel-edit-name-btn');
        const nameForm = document.getElementById('name-form');
        const savedNameDisplaySpan = document.getElementById('saved-name-display'); // The span containing the welcome text
        const nameInput = document.getElementById('name-input'); // The input field
        const displayUserNameStrong = document.getElementById('display-user-name'); // The strong tag holding the name

        const showNameForm = () => {
            if (!nameForm || !savedNameDisplaySpan || !editNameBtn) return;
            nameForm.classList.remove('hidden');        // Show the form
            savedNameDisplaySpan.classList.add('hidden'); // Hide the "Welcome, Name" span
            editNameBtn.classList.add('hidden');        // Hide the edit icon button
            nameInput.focus();                          // Focus the input field
        };

        const hideNameForm = () => {
            if (!nameForm || !savedNameDisplaySpan || !editNameBtn || !displayUserNameStrong) return;
            nameForm.classList.add('hidden');            // Hide the form
            savedNameDisplaySpan.classList.remove('hidden'); // Show the "Welcome, Name" span
            editNameBtn.classList.remove('hidden');      // Show the edit icon button again
            // Reset input value to the currently displayed name when cancelling
            if(displayUserNameStrong) nameInput.value = displayUserNameStrong.textContent;
        };

        if (editNameBtn) {
            editNameBtn.addEventListener('click', showNameForm);
        }

        if (cancelNameBtn) {
            cancelNameBtn.addEventListener('click', hideNameForm);
        }
    }

    // --- Checkout Address Toggle Logic ---
    const checkoutPage = document.querySelector('.checkout-container'); // Check if on checkout page
    if (checkoutPage) {
        const checkoutEditBtn = checkoutPage.querySelector('.checkout-address #edit-address-btn');
        const checkoutCancelBtn = checkoutPage.querySelector('.checkout-address #cancel-edit-btn');
        const checkoutAddressForm = checkoutPage.querySelector('.checkout-address #address-form');
        const checkoutSavedAddressDiv = checkoutPage.querySelector('.checkout-address .saved-address');
        const placeOrderBtn = checkoutPage.querySelector('.btn-place-order');

        // Check if an address is initially displayed (not hidden)
        const hasInitialAddress = checkoutSavedAddressDiv && !checkoutSavedAddressDiv.classList.contains('hidden');

        if (checkoutEditBtn) {
            checkoutEditBtn.addEventListener('click', () => {
                if (!checkoutAddressForm || !checkoutSavedAddressDiv) return;
                checkoutAddressForm.classList.remove('hidden');
                checkoutSavedAddressDiv.classList.add('hidden');
                if(placeOrderBtn) placeOrderBtn.disabled = true; // Disable place order when editing
                checkoutAddressForm.querySelector('h3').textContent = 'Edit Address';
                if (checkoutCancelBtn) checkoutCancelBtn.classList.remove('hidden'); // Show cancel button
            });
        }

        if (checkoutCancelBtn) {
            checkoutCancelBtn.addEventListener('click', () => {
                if (!checkoutAddressForm || !checkoutSavedAddressDiv) return;
                checkoutAddressForm.classList.add('hidden');
                if (hasInitialAddress) { // Only show saved div if it existed initially
                    checkoutSavedAddressDiv.classList.remove('hidden');
                    if(placeOrderBtn) placeOrderBtn.disabled = false; // Re-enable place order
                } else {
                    // If there was no initial address, cancelling means keep form hidden and button disabled
                    if(placeOrderBtn) placeOrderBtn.disabled = true;
                }
                checkoutCancelBtn.classList.add('hidden'); // Hide cancel button again
            });
        }

        // Initial state for checkout page
        if (!hasInitialAddress && checkoutAddressForm) {
            checkoutAddressForm.classList.remove('hidden'); // Show form if no address saved
            if (placeOrderBtn) placeOrderBtn.disabled = true; // Disable place order
            checkoutAddressForm.querySelector('h3').textContent = 'Add Shipping Address'; // Clearer label
            if (checkoutCancelBtn) checkoutCancelBtn.classList.add('hidden'); // Hide cancel btn if adding new
        } else if (hasInitialAddress && checkoutAddressForm) {
            checkoutAddressForm.classList.add('hidden'); // Ensure form is hidden initially
            if (placeOrderBtn) placeOrderBtn.disabled = false; // Enable if address exists
            if (checkoutCancelBtn) checkoutCancelBtn.classList.add('hidden'); // Ensure cancel is hidden initially
        }
    }


    // --- Cart Update AJAX Logic ---
    const updateQtyButtons = document.querySelectorAll('.btn-update-qty');
    updateQtyButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            e.preventDefault();
            const productId = button.dataset.productId;
            const quantityInput = document.getElementById(`quantity-${productId}`);
            if (!quantityInput) return;
            const newQuantity = parseInt(quantityInput.value, 10);

            // Store original value in case of error
            if (!quantityInput.dataset.originalValue) {
                quantityInput.dataset.originalValue = quantityInput.value;
            }


            if (isNaN(newQuantity) || newQuantity < 0) {
                 showToast('Invalid quantity entered.', 'danger');
                 quantityInput.value = quantityInput.dataset.originalValue; // Restore original
                return;
             }
            const maxStock = parseInt(quantityInput.max, 10);
            if (!isNaN(maxStock) && newQuantity > maxStock) {
                showToast(`Only ${maxStock} items available in stock.`, 'warning');
                quantityInput.value = maxStock; // Correct to max stock, don't restore original
                 return; // Don't proceed with AJAX call yet, let user confirm or re-update
             }
            updateCartItemQuantityAJAX(productId, newQuantity, button, quantityInput); // Pass input element
        });
    });


    // ========================================
    // Dynamic Search Bar Logic
    // ========================================
    const searchContainer = document.getElementById('dynamic-search-container');
    const searchToggleBtn = document.getElementById('search-toggle-btn');
    const searchForm = document.getElementById('dynamic-search-form');
    const searchInput = document.getElementById('search-input-dynamic');
    const suggestionsDropdown = document.getElementById('suggestions-dropdown');
    let suggestionFetchTimeout;

    // --- Toggle Search Bar (Mobile) ---
    if (searchToggleBtn && searchContainer) {
        searchToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            searchContainer.classList.toggle('active');
            if (searchContainer.classList.contains('active')) {
                requestAnimationFrame(() => { if(searchInput) searchInput.focus(); });
            } else {
                if(suggestionsDropdown) suggestionsDropdown.classList.remove('active');
            }
        });
    }

    // --- Handle Search Input ---
    if (searchInput && suggestionsDropdown) {
        searchInput.addEventListener('input', () => {
            const query = searchInput.value.trim();
            clearTimeout(suggestionFetchTimeout);

            if (query.length >= 2) {
                suggestionsDropdown.innerHTML = '<div class="suggestion-item"><i>Loading...</i></div>';
                suggestionsDropdown.classList.add('active');
                suggestionFetchTimeout = setTimeout(() => {
                    fetchSuggestions(query);
                }, 300); // Debounce
            } else {
                suggestionsDropdown.innerHTML = '';
                suggestionsDropdown.classList.remove('active');
            }
        });

        // Keep suggestions open on focus if suggestions exist
        searchInput.addEventListener('focus', () => {
             const query = searchInput.value.trim();
              const hasActualSuggestions = suggestionsDropdown.querySelector('a.suggestion-item');
              if (query.length >= 2 && hasActualSuggestions) {
                 suggestionsDropdown.classList.add('active');
             }
        });
    }

     // --- Fetch Suggestions ---
     async function fetchSuggestions(query) {
         if (!suggestionsDropdown) return;
         try {
             const response = await fetch(`/products/suggestions?q=${encodeURIComponent(query)}`);
             if (!response.ok) {
                 let errorMsg = `HTTP error! status: ${response.status}`;
                 try { const errorData = await response.json(); errorMsg = errorData.error || errorMsg; } catch (parseError) {}
                 throw new Error(errorMsg);
             }
             const suggestions = await response.json();
             displaySuggestions(suggestions);
         } catch (error) {
             console.error('Error fetching suggestions:', error);
             suggestionsDropdown.innerHTML = `<div class="suggestion-item text-danger"><i>Error: ${error.message || 'Failed to fetch'}</i></div>`;
             suggestionsDropdown.classList.add('active');
         }
     }

     // --- Display Suggestions ---
     function displaySuggestions(suggestions) {
          if (!suggestionsDropdown) return;
         suggestionsDropdown.innerHTML = '';
         if (suggestions.length > 0) {
             suggestions.forEach(product => {
                 const item = document.createElement('a');
                 item.classList.add('suggestion-item');
                 item.href = `/products/${product._id}`;
                 // Basic sanitization for display
                 const safeName = product.name ? product.name.replace(/</g, "<").replace(/>/g, ">") : '[No Name]';
                 const safeImageUrl = product.imageUrl ? product.imageUrl.replace(/</g, "<").replace(/>/g, ">") : '/images/placeholder.png';
                 item.innerHTML = `
                    <img src="${safeImageUrl}" alt="${safeName}" loading="lazy">
                    <span>${safeName}</span>
                 `;
                 suggestionsDropdown.appendChild(item);
             });
             suggestionsDropdown.classList.add('active');
         } else {
              suggestionsDropdown.innerHTML = '<div class="suggestion-item text-muted"><i>No matching products found.</i></div>';
              suggestionsDropdown.classList.add('active');
         }
     }

     // --- Close Search/Suggestions on Outside Click ---
     document.addEventListener('click', (e) => {
         // Ensure all elements exist before checking contains
         if (searchContainer && suggestionsDropdown && searchToggleBtn && !searchContainer.contains(e.target) && !searchToggleBtn.contains(e.target)) {
             searchContainer.classList.remove('active');
             suggestionsDropdown.classList.remove('active');
         }
     });

     // --- Handle Clicks Inside Suggestions ---
     if(suggestionsDropdown) {
         suggestionsDropdown.addEventListener('click', (e) => {
             const link = e.target.closest('a');
             if (!link) {
                 e.stopPropagation(); // Don't close if click is not on a link itself
             } else {
                 // Hide dropdown after clicking a link
                 suggestionsDropdown.classList.remove('active');
                 if (searchContainer && window.innerWidth < 768) { // Also hide mobile search bar
                    searchContainer.classList.remove('active');
                 }
             }
         });
     }
    // ========================================
    // End Dynamic Search Bar Logic
    // ========================================


    // ========================================
    // Toast Notification Logic (FASTER APPEARANCE)
    // ========================================
    const toastContainer = document.querySelector('.toast-container');
    if (toastContainer) {
        const toastElements = toastContainer.querySelectorAll('.toast');

        toastElements.forEach((toastElement) => { // No index needed now
            const closeButton = toastElement.querySelector('.toast-close-btn');
            const autoHideDelay = 5000; // 5 seconds
            let hideTimeoutId;

            const dismissToast = () => {
                clearTimeout(hideTimeoutId);
                if (toastElement.classList.contains('hide') || !toastElement.parentNode) return; // Already hiding or removed
                toastElement.classList.remove('show');
                toastElement.classList.add('hide');
                toastElement.addEventListener('transitionend', (event) => {
                    // Check propertyName to ensure it's the opacity/transform transition
                    if ((event.propertyName === 'opacity' || event.propertyName === 'transform') && toastElement.classList.contains('hide') && toastElement.parentNode) {
                        toastElement.remove();
                    }
                }, { once: true });
            };

            // --- Show Animation (IMMEDIATE TRIGGER using setTimeout 0) ---
            setTimeout(() => {
                // Check if element is still in DOM before showing
                if (toastElement.parentNode) {
                   toastElement.classList.add('show');
                }
            }, 0); // Minimal delay to allow rendering initial state

            // --- Auto Hide Timer ---
             hideTimeoutId = setTimeout(dismissToast, autoHideDelay);

            // --- Manual Close Button ---
            if (closeButton) {
                closeButton.addEventListener('click', dismissToast);
            }

             // --- Prevent auto-hide on hover ---
             toastElement.addEventListener('mouseenter', () => clearTimeout(hideTimeoutId));
             toastElement.addEventListener('mouseleave', () => hideTimeoutId = setTimeout(dismissToast, autoHideDelay / 2)); // Restart timer on mouse out

        });
    }
    // ========================================
    // End Toast Notification Logic
    // ========================================

    // --- Rating Stats Bar Animation ---
    document.querySelectorAll('.rating-bar-fill').forEach(function(el) {
        var width = el.getAttribute('data-width');
        if (width) {
            // Allow the browser a moment to render before starting animation
            requestAnimationFrame(() => {
                 if(el.parentNode) { // Check if element still exists
                    el.style.width = width + '%';
                 }
            });
        }
    });

    // ========================================
    // Loading State for Non-Form Actions (e.g., Proceed to Checkout Link)
    // ========================================
    const proceedCheckoutBtn = document.getElementById('btn-proceed-checkout');
    if (proceedCheckoutBtn) {
        const originalCheckoutText = proceedCheckoutBtn.innerHTML;
        // Retrieve loading text safely, provide default
        const loadingCheckoutText = proceedCheckoutBtn.dataset.loadingText || '<i class="fas fa-spinner fa-spin"></i> Loading...';

        proceedCheckoutBtn.addEventListener('click', function(event) {
            // Check if already loading
            if (proceedCheckoutBtn.classList.contains('loading')) {
                return;
            }

            // Apply loading state
            proceedCheckoutBtn.classList.add('loading');
            proceedCheckoutBtn.innerHTML = loadingCheckoutText;
            proceedCheckoutBtn.style.pointerEvents = 'none'; // Visually disable link
            proceedCheckoutBtn.setAttribute('aria-disabled', 'true'); // Accessibility

            // Allow navigation to proceed naturally
        });

        // Reset button on page show (e.g., back navigation)
        window.addEventListener('pageshow', function(pageEvent) {
            if (pageEvent.persisted && proceedCheckoutBtn.classList.contains('loading')) {
                proceedCheckoutBtn.classList.remove('loading');
                proceedCheckoutBtn.innerHTML = originalCheckoutText;
                proceedCheckoutBtn.style.pointerEvents = 'auto';
                proceedCheckoutBtn.removeAttribute('aria-disabled');
            }
        });
    }
    // ========================================
    // End Loading State for Non-Form Actions
    // ========================================

    // ========================================
    // Homepage Banner Slider Logic            <--- NEW SECTION
    // ========================================
    const sliderContainer = document.querySelector('[data-slider-container]');
    if (sliderContainer) {
        const slides = sliderContainer.querySelectorAll('[data-slide]');
        const prevBtn = sliderContainer.querySelector('[data-slider-prev]');
        const nextBtn = sliderContainer.querySelector('[data-slider-next]');
        const dotsContainer = sliderContainer.querySelector('[data-slider-dots]');
        const dots = dotsContainer ? dotsContainer.querySelectorAll('[data-slide-to]') : [];

        let currentSlideIndex = 0;
        let autoSlideInterval = null;
        const slideIntervalTime = 5000; // Time in ms (e.g., 5 seconds)

        function showSlide(index) {
            if (!slides || slides.length === 0) return; // Exit if no slides

            // Wrap index around if it goes out of bounds
            const newIndex = (index + slides.length) % slides.length;

            slides.forEach((slide, i) => {
                slide.classList.remove('active');
            });
            dots.forEach(dot => {
                dot.classList.remove('active');
            });

            slides[newIndex].classList.add('active');
            if (dots[newIndex]) {
                dots[newIndex].classList.add('active');
            }
            currentSlideIndex = newIndex;
        }

        function nextSlide() {
            showSlide(currentSlideIndex + 1);
        }

        function prevSlide() {
            showSlide(currentSlideIndex - 1);
        }

        function startAutoSlide() {
            // Clear any existing interval before starting a new one
            clearInterval(autoSlideInterval);
            if (slides.length > 1) { // Only auto-slide if more than one banner
                autoSlideInterval = setInterval(nextSlide, slideIntervalTime);
            }
        }

        // Initial setup
        if (slides.length > 0) {
             showSlide(0); // Show the first slide initially
             startAutoSlide(); // Start automatic sliding
        }

        // Event Listeners for Arrows
        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                nextSlide();
                startAutoSlide(); // Reset interval on manual click
            });
        }
        if (prevBtn) {
            prevBtn.addEventListener('click', () => {
                prevSlide();
                startAutoSlide(); // Reset interval on manual click
            });
        }

        // Event Listener for Dots
        if (dotsContainer) {
            dotsContainer.addEventListener('click', (e) => {
                const targetDot = e.target.closest('[data-slide-to]');
                if (targetDot) {
                    const index = parseInt(targetDot.dataset.slideTo, 10);
                    if (!isNaN(index)) {
                        showSlide(index);
                        startAutoSlide(); // Reset interval on manual click
                    }
                }
            });
        }

        // Pause on Hover
        sliderContainer.addEventListener('mouseenter', () => {
            clearInterval(autoSlideInterval);
        });

        sliderContainer.addEventListener('mouseleave', () => {
            startAutoSlide();
        });

    } // End if (sliderContainer)
    // ========================================
    // End Homepage Banner Slider Logic
    // ========================================


}); // End DOMContentLoaded


// --- Cart Update AJAX Function ---
async function updateCartItemQuantityAJAX(productId, quantity, buttonElement, quantityInputElement) { // Pass input el
     const originalButtonText = 'Update';
     const loadingButtonText = '<i class="fas fa-spinner fa-spin"></i>';
     const cartItemDiv = buttonElement.closest('.cart-item');

     buttonElement.disabled = true;
     buttonElement.innerHTML = loadingButtonText;
     if(quantityInputElement) quantityInputElement.readOnly = true;

    try {
        const response = await fetch('/user/cart/update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', },
            body: JSON.stringify({ productId, quantity })
         });

        const data = await response.json(); // Always parse response

        if (!response.ok) {
            throw new Error(data.message || `Update failed (Status: ${response.status})`);
        }

         // --- Show toast AFTER response is received ---
         if (data.success) {
             // Update original value dataset if successful
             if(quantityInputElement) quantityInputElement.dataset.originalValue = data.newQuantity;

             if (quantity === 0) {
                 // Handle removal animation and DOM update
                if (cartItemDiv) {
                    cartItemDiv.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease, border 0.3s ease';
                    cartItemDiv.style.opacity = '0';
                    cartItemDiv.style.height = '0';
                    cartItemDiv.style.paddingTop = '0';
                    cartItemDiv.style.paddingBottom = '0';
                    cartItemDiv.style.marginBottom = '0';
                    cartItemDiv.style.borderWidth = '0';
                    setTimeout(() => {
                        if (cartItemDiv.parentNode) {
                           cartItemDiv.remove();
                        }
                        updateCartTotalAndBadge(data.cartTotal);
                        handleEmptyCartDisplay();
                        showToast('Item removed from cart.', 'success'); // Show toast after removing
                    }, 300); // Wait for CSS transition
                     return; // Exit early
                }
             } else {
                 // Update quantity input and subtotal
                 const subtotalSpan = cartItemDiv?.querySelector('.item-subtotal-value');
                 if (subtotalSpan) subtotalSpan.textContent = (data.itemSubtotal !== undefined ? data.itemSubtotal : 0).toFixed(2);
                if(quantityInputElement) quantityInputElement.value = data.newQuantity;
                 // Update total and badge
                 updateCartTotalAndBadge(data.cartTotal);
                 // showToast('Cart quantity updated.', 'success'); // Optional success message
             }
         } else {
              // Show failure toast using backend message
              showToast(`Update failed: ${data.message || 'Unknown error'}`, 'danger');
              // Restore original value on backend failure
              if(quantityInputElement && quantityInputElement.dataset.originalValue) {
                  quantityInputElement.value = quantityInputElement.dataset.originalValue;
              }
         }

    } catch (error) {
         console.error('Error updating cart quantity:', error);
          // Show error toast
          showToast(`Error: ${error.message}`, 'danger');
          // Restore original value on fetch error
          if(quantityInputElement && quantityInputElement.dataset.originalValue) {
            quantityInputElement.value = quantityInputElement.dataset.originalValue;
          }

    } finally {
         // Re-enable button and input (unless item was removed)
         // Ensure this runs only if the item wasn't removed
         if (cartItemDiv && (!cartItemDiv.style.opacity || parseFloat(cartItemDiv.style.opacity) !== 0)) {
             buttonElement.disabled = false;
             buttonElement.innerHTML = originalButtonText;
             if(quantityInputElement) quantityInputElement.readOnly = false;
         }
     }
}

// --- Helper Function to Show Toasts Dynamically (FASTER APPEARANCE) ---
function showToast(message, type = 'info') {
    const toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
        console.error("Toast container not found! Falling back to alert.");
        alert(message); // Fallback
        return;
    }

    // Create elements
    const toastElement = document.createElement('div');
    toastElement.className = `toast toast-${type}`; // Apply classes
    toastElement.setAttribute('role', 'alert');
    toastElement.setAttribute('aria-live', 'assertive');
    toastElement.setAttribute('aria-atomic', 'true');

    // Basic sanitization - Replace with a more robust library (like DOMPurify) if needed for complex user-generated content
    const sanitizedMessage = typeof message === 'string'
        ? message.replace(/</g, "<").replace(/>/g, ">")
        : 'An unexpected error occurred.'; // Default message for non-strings

    // Set inner HTML safely
    toastElement.innerHTML = `
        <div class="toast-body">
            ${sanitizedMessage}
            <button type="button" class="toast-close-btn" aria-label="Close">Ã—</button>
        </div>
    `;

    const closeButton = toastElement.querySelector('.toast-close-btn');
    toastContainer.appendChild(toastElement);

    // --- Logic to show and hide the new toast ---
    const autoHideDelay = 5000;
    let hideTimeoutId;

    const dismissToast = () => {
        clearTimeout(hideTimeoutId);
        // Check if already hiding or removed to prevent errors/multiple executions
        if (toastElement.classList.contains('hide') || !toastElement.parentNode) return;
        toastElement.classList.remove('show');
        toastElement.classList.add('hide');
        toastElement.addEventListener('transitionend', (event) => {
            // Ensure transition is for opacity/transform and element still exists with 'hide' class
            if ((event.propertyName === 'opacity' || event.propertyName === 'transform') && toastElement.classList.contains('hide') && toastElement.parentNode) {
                toastElement.remove();
            }
        }, { once: true }); // Use 'once' to ensure listener is removed after firing
    };

    // Show animation (using setTimeout 0 for immediate trigger)
    setTimeout(() => {
        // Check if element is still in DOM before adding 'show'
        if (toastElement.parentNode) {
           toastElement.classList.add('show');
        }
    }, 0); // Minimal delay

    // Auto Hide Timer
    hideTimeoutId = setTimeout(dismissToast, autoHideDelay);

    // Manual Close Button
    if (closeButton) { // Check if button exists
        closeButton.addEventListener('click', dismissToast);
    }

    // Prevent auto-hide on hover
    toastElement.addEventListener('mouseenter', () => clearTimeout(hideTimeoutId));
    toastElement.addEventListener('mouseleave', () => hideTimeoutId = setTimeout(dismissToast, autoHideDelay / 2)); // Restart timer on mouse out
}


// --- Helper Functions for Cart Badge and Empty Display ---
function updateCartTotalAndBadge(newCartTotal) {
     const cartTotalSpan = document.getElementById('cart-total-value');
     if (cartTotalSpan) cartTotalSpan.textContent = (newCartTotal !== undefined ? newCartTotal : 0).toFixed(2);

     const newCartItemCount = calculateNewCartCount();
     const cartBadge = document.querySelector('.cart-badge');
     if (cartBadge) {
         if (newCartItemCount > 0) {
             cartBadge.textContent = newCartItemCount;
             cartBadge.classList.remove('hide');
         } else {
            cartBadge.textContent = '0';
            cartBadge.classList.add('hide');
         }
     }
}

function calculateNewCartCount() {
    // Count only items currently visible and not marked for removal
    const cartItems = document.querySelectorAll('.cart-item');
    let count = 0;
    cartItems.forEach(item => {
        // Check opacity style directly for cross-browser compatibility during transition
        const style = window.getComputedStyle(item);
        if (style.display !== 'none' && parseFloat(style.opacity) > 0) {
            const quantityInput = item.querySelector('input[name="quantity"]');
            if (quantityInput) {
                const value = parseInt(quantityInput.value, 10);
                if (!isNaN(value) && value > 0) {
                    // Update count based on the QUANTITY of each item
                    count += value; // THIS IS THE KEY CHANGE - SUM QUANTITIES, NOT ITEMS
                }
            }
        }
    });
    return count;
}

function handleEmptyCartDisplay() {
    const cartItemsContainer = document.querySelector('.cart-items');
     const cartContainer = document.querySelector('.cart-container');
     const cartSummary = document.querySelector('.cart-summary');

     // Check if the items container exists and has no *cart-item* children left
     // or only children that are hidden/fading out
     if (cartItemsContainer && cartContainer) {
         const visibleItems = Array.from(cartItemsContainer.querySelectorAll('.cart-item')).filter(item => {
             const style = window.getComputedStyle(item);
             return style.display !== 'none' && parseFloat(style.opacity) > 0;
         });

         if (visibleItems.length === 0) {
             // Use innerHTML carefully, ensure no user input is directly included here
             cartContainer.innerHTML = `
                <h1>Your Shopping Cart</h1>
                <p class="alert alert-info mt-3">
                    Your cart is empty. <a href="/" class="alert-link">Continue Shopping</a>
                </p>`;
             if(cartSummary) cartSummary.remove();
         }
     }
}

routes/adminRoutes.js:
// routes/adminRoutes.js
const express = require('express');
const adminController = require('../controllers/adminController');
const { isAuthenticated } = require('../middleware/authMiddleware');
const { isAdmin } = require('../middleware/roleMiddleware'); // Use specific admin check

const router = express.Router();

// Apply authentication and admin check to ALL routes in this file
router.use(isAuthenticated, isAdmin);

// Dashboard
router.get('/dashboard', adminController.getAdminDashboard);

// --- Product Management (Admin) ---
// *** ADDED BACK Admin Product Upload Routes ***
router.get('/upload-product', adminController.getUploadProductPage); // Page for admin upload form
router.post('/upload-product', adminController.uploadProduct);       // Handle admin product upload

// Manage All Products (Existing Routes)
router.get('/manage-products', adminController.getManageProductsPage);       // Admin sees all
router.get('/manage-products/edit/:id', adminController.getEditProductPage); // Admin edits any
router.post('/manage-products/update/:id', adminController.updateProduct);   // Admin updates any
router.post('/manage-products/remove/:id', adminController.removeProduct);   // Admin removes any

// Order Management (Admin View/Manage ALL - Existing Routes)
router.get('/manage-orders', adminController.getManageOrdersPage); // Admin sees all
router.post('/orders/:orderId/send-direct-delivery-otp', adminController.sendDirectDeliveryOtpByAdmin); // Admin OTP send
router.post('/orders/:orderId/confirm-direct-delivery', adminController.confirmDirectDeliveryByAdmin); // Admin OTP confirm
router.post('/orders/:orderId/cancel', adminController.cancelOrderByAdmin);                           // Admin cancel

// User Management (Existing Routes)
router.get('/manage-users', adminController.getManageUsersPage);     // List users
router.post('/users/:id/update-role', adminController.updateUserRole); // Update role (incl. seller)
router.post('/users/:id/remove', adminController.removeUser);         // Remove user

module.exports = router;

routes/authRoutes.js:
const express = require('express');
const authController = require('../controllers/authController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.get('/login', authController.getLoginPage);
router.get('/register', authController.getRegisterPage);
router.get('/verify-otp', authController.getVerifyOtpPage);
router.get('/forgot-password', authController.getForgotPasswordPage);
router.get('/reset-password/:token', authController.getResetPasswordPage);

router.post('/register', authController.registerUser);
router.post('/login', authController.loginUser);
 router.post('/logout', isAuthenticated, authController.logoutUser);
router.post('/verify-otp', authController.verifyOtp);
 router.post('/resend-otp', authController.resendOtp);

router.post('/forgot-password', authController.forgotPassword);
router.post('/reset-password/:token', authController.resetPassword);


module.exports = router;


routes/index.js:
// routes/index.js
const express = require('express');
const authRoutes = require('./authRoutes');
const productRoutes = require('./productRoutes');
const userRoutes = require('./userRoutes');
const orderRoutes = require('./orderRoutes');
const adminRoutes = require('./adminRoutes');
const sellerRoutes = require('./sellerRoutes'); // *** IMPORT Seller Routes ***
const { getHomePage } = require('../controllers/authController'); // Home page controller

const router = express.Router();

// --- Public Routes ---
router.get('/', getHomePage);           // Home page (shows approved products)
router.use('/auth', authRoutes);        // Login, Register, Forgot Pwd, OTP Verify, etc.
router.use('/products', productRoutes); // Public product list (approved) & details (permission checked)

// --- Authenticated User Routes ---
// Middleware inside these route files ensure user is logged in
router.use('/user', userRoutes);        // Profile, Cart, Checkout, Address
router.use('/orders', orderRoutes);     // Place Order, My Orders

// --- Role-Specific Routes ---
// Middleware inside these files ensures correct role (and authentication)
router.use('/admin', adminRoutes);      // Admin actions
router.use('/seller', sellerRoutes);    // *** USE Seller Routes ***

module.exports = router;

routes/orderRoutes.js:
const express = require('express');
const orderController = require('../controllers/orderController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.use(isAuthenticated);

router.post('/place', orderController.placeOrder);

router.get('/my-orders', orderController.getMyOrders);

 router.post('/cancel/:id', orderController.cancelOrder);

module.exports = router;


routes/productRoutes.js:
// routes/productRoutes.js
const express = require('express');
const productController = require('../controllers/productController');
 const { isAuthenticated } = require('../middleware/authMiddleware'); // Needed only for rating

const router = express.Router();

// --- NEW: Route for product suggestions ---
// Needs to be defined BEFORE the '/:id' route
router.get('/suggestions', productController.getProductSuggestions);

// Public routes - controllers ensure visibility rules (e.g., only 'approved')
router.get('/', productController.getProducts);         // List/Search approved, in-stock products
router.get('/:id', productController.getProductDetails); // Show product details (controller checks status/permissions)

// Rating requires user to be logged in
router.post('/:id/rate', isAuthenticated, productController.rateProduct);

module.exports = router;

routes/userRoutes.js:
// routes/userRoutes.js
const express = require('express');
const userController = require('../controllers/userController');
const { isAuthenticated } = require('../middleware/authMiddleware'); // Protect user-specific routes

const router = express.Router();

// Apply isAuthenticated middleware to all routes in this file
router.use(isAuthenticated);

// User Profile
router.get('/profile', userController.getUserProfilePage);
router.post('/profile/update-name', userController.updateUserName); // *** ADDED THIS LINE ***

// User Cart Management
router.get('/cart', userController.getCart);                // View cart (controller filters unapproved)
router.post('/cart/add', userController.addToCart);         // Add to cart (controller checks approval)
router.post('/cart/update', userController.updateCartQuantity); // Update quantity (controller checks approval/stock)
router.post('/cart/remove/:productId', userController.removeFromCart); // Remove from cart

// Address Management
router.post('/address/save', userController.saveAddress); // Save shipping address

// Checkout Process
router.get('/checkout', userController.getCheckoutPage);  // View checkout page (controller validates cart)

module.exports = router;

routes/sellerRoutes.js:
// routes/sellerRoutes.js
const express = require('express');
const sellerController = require('../controllers/sellerController');
const { isAuthenticated } = require('../middleware/authMiddleware');
// Import relevant role/ownership middleware
const { isSeller, isProductOwner, isOrderRelevantToSeller } = require('../middleware/roleMiddleware');

const router = express.Router();

// Apply authentication and seller check to ALL routes in this file
router.use(isAuthenticated, isSeller);

// Seller Dashboard
router.get('/dashboard', sellerController.getSellerDashboard);

// Seller Product Management
router.get('/products/upload', sellerController.getUploadProductPage); // Page to show upload form
router.post('/products/upload', sellerController.uploadProduct); // Handle product submission (triggers review)
router.get('/products', sellerController.getManageProductsPage); // List *only* this seller's products (incl. status)

// Actions requiring ownership of the specific product ID
// isProductOwner middleware runs AFTER isAuthenticated and isSeller
router.get('/products/edit/:id', isProductOwner, sellerController.getEditProductPage); // Get edit form for OWN product
router.post('/products/update/:id', isProductOwner, sellerController.updateProduct); // Handle update of OWN product (triggers re-review)
router.post('/products/remove/:id', isProductOwner, sellerController.removeProduct); // Handle removal of OWN product

// Seller Order Management
router.get('/orders', sellerController.getManageOrdersPage); // List orders containing *any* of this seller's products

// Actions requiring relevance to the specific order ID
// isOrderRelevantToSeller middleware runs AFTER isAuthenticated and isSeller
router.post('/orders/:orderId/send-otp', isOrderRelevantToSeller, sellerController.sendDirectDeliveryOtpBySeller); // Seller sends OTP for relevant orders
router.post('/orders/:orderId/confirm-delivery', isOrderRelevantToSeller, sellerController.confirmDirectDeliveryBySeller); // Seller confirms delivery for relevant orders

// --- NEW: Seller Cancel Order Route ---
router.post('/orders/:orderId/cancel', isOrderRelevantToSeller, sellerController.cancelOrderBySeller);

module.exports = router;

services/otpService.js:
// services/otpService.js
const crypto = require('crypto');

/**
 * Generates a random numeric OTP code of a specified length.
 * @param {number} [length=6] - The desired length of the OTP.
 * @returns {string} The generated OTP code.
 */
const generateOTP = (length = 6) => {
  // More robust generation ensuring target length even with non-numeric hex chars
  if (length <= 0) throw new Error('OTP length must be positive');
  const chars = '0123456789';
  let otp = '';
  const randomBytes = crypto.randomBytes(length); // Generate sufficient random bytes
  for (let i = 0; i < length; i++) {
    const randomIndex = randomBytes[i] % chars.length;
    otp += chars[randomIndex];
  }
  return otp;
};

/**
 * Calculates the expiration timestamp for an OTP.
 * @param {number} [minutes=10] - The duration in minutes until the OTP expires.
 * @returns {Date} The expiration date object.
 */
const setOTPExpiration = (minutes = 10) => {
  // Returns a Date object representing the expiration time
  return new Date(Date.now() + minutes * 60 * 1000);
};

module.exports = { generateOTP, setOTPExpiration };

services/geminiService.js:
// services/geminiService.js
const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = require("@google/generative-ai");
const axios = require('axios'); // Import axios for fetching image data

// --- Configuration ---
const API_KEY = process.env.GEMINI_API_KEY;

// Check if API key is set
if (!API_KEY) {
    console.warn("GEMINI_API_KEY is not set in .env file. Gemini features will be disabled.");
}

const genAI = API_KEY ? new GoogleGenerativeAI(API_KEY) : null;

// *** Use the Vision model ***
const visionModel = genAI ? genAI.getGenerativeModel({ model: "gemini-2.0-flash" }) : null;

// Optional: Configure safety settings
const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
];


if (genAI && visionModel) {
    console.log("Gemini AI SDK Initialized successfully with Vision model.");
} else {
     console.log("Gemini AI SDK Vision model could not be initialized (API Key missing or configuration error?).");
}

// --- Helper function to fetch image and get Base64 data + MIME type ---
async function urlToGenerativePart(url) {
    console.log(`Fetching image from: ${url}`);
    try {
        const response = await axios.get(url, {
            responseType: 'arraybuffer', // Fetch as binary data
            timeout: 10000 // Add a timeout (10 seconds)
        });

        if (response.status !== 200) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const contentType = response.headers['content-type'];
        // Basic validation for common image types Gemini supports
        if (!contentType || !['image/jpeg', 'image/png', 'image/webp', 'image/heic', 'image/heif'].includes(contentType.toLowerCase())) {
            console.warn(`Invalid or unsupported image Content-Type: ${contentType} from URL: ${url}`);
            throw new Error(`Unsupported image type: ${contentType}`);
        }

        const base64Data = Buffer.from(response.data).toString('base64');

        return {
            inlineData: {
                data: base64Data,
                mimeType: contentType,
            },
        };
    } catch (error) {
         console.error(`Error fetching image from ${url}: ${error.message}`);
         // Determine if the error is network related, timeout, or status code
         if (axios.isAxiosError(error)) {
             if (error.response) {
                 // Server responded with a status code outside 2xx range
                 throw new Error(`Failed to fetch image: Server responded with status ${error.response.status}`);
             } else if (error.request) {
                 // Request was made but no response received (e.g., timeout, network issue)
                  throw new Error(`Failed to fetch image: No response received (Timeout or network issue)`);
             } else {
                  // Something else happened in setting up the request
                 throw new Error(`Failed to fetch image: Request setup error (${error.message})`);
             }
         } else {
            // Not an Axios error (e.g., validation error thrown above)
             throw error; // Re-throw the original error
         }
    }
}


/**
 * Reviews product text and image content using Gemini Vision API.
 * Fetches the image from the provided URL.
 *
 * @param {object} product - The product object (name, category, price, imageUrl, specifications).
 * @returns {Promise<{status: ('approved'|'rejected'|'pending'), reason: string | null}>} Review result.
 */
const reviewProductWithGemini = async (product) => {
    // Check if Vision model is available
    if (!visionModel) {
        console.log("Gemini Vision model not available. Skipping review, defaulting to 'pending'.");
        return { status: 'pending', reason: 'Gemini Vision service unavailable' };
    }

    const { name, category, price, specifications, imageUrl } = product;

    // --- 1. Fetch and Prepare Image Part ---
    let imagePart;
    try {
        imagePart = await urlToGenerativePart(imageUrl);
        if (!imagePart) { // Should have thrown an error, but double-check
            throw new Error("Image processing failed unexpectedly.");
        }
         console.log(`Successfully prepared image part for ${name} from ${imageUrl}`);
    } catch (imageError) {
        console.error(`Cannot review product "${name}" due to image processing error: ${imageError.message}`);
        // Reject if image fetch/processing fails critically
        return { status: 'rejected', reason: `Image Error: ${imageError.message}` };
    }


    // --- 2. Construct Text Prompt Part ---
    // Update prompt to include image analysis instructions
    const textPrompt = `
        Analyze the following product details AND the provided image for an e-commerce store. Act as a strict content moderator.

        **Instructions:**
        1. Examine the IMAGE CONTENT closely.
        2. Examine the TEXT DETAILS (Name, Category, Price, Specifications).
        3. Verify if the image VISUALLY MATCHES the product described by the text (name, category). Is it clearly the item described?
        4. Check BOTH image and text for:
            - Explicit content (nudity, graphic violence).
            - Depictions of weapons (unless clearly a toy and stated category is 'Toys').
            - Illegal items or substances.
            - Hateful symbols or hate speech.
            - Any generally unsafe or harmful content.
        5. Check if the text details seem legitimate:
            - Is the name/description sensible? Avoid gibberish or clearly misleading text.
            - Is the price reasonable for the category (reject absurd prices like â‚¹1 for a car, but allow discounts)?
            - Does the category make sense for the name/image?
        6. **SAFETY IS PARAMOUNT**: If unsure, lean towards rejection, especially for safety concerns (weapons, explicit, illegal).
        7. Use ONLY the required response format.

        **Product Details (Text):**
        - Name: ${name}
        - Category: ${category}
        - Price: â‚¹${price?.toFixed(2) || 'N/A'}
        - Specifications: ${specifications || 'Not provided'}
        - Provided Image URL: ${imageUrl}

        **Analysis Task:** Based on BOTH the text analysis AND image content analysis:
        - Respond with "APPROVE" if the product (image and text) seems legitimate, safe, accurately described, and the image clearly matches the text description.
        - Respond with "REJECT: [BRIEF REASON]" if ANY issues are found (safety violation in image/text, image mismatch, misleading text, nonsensical entry, absurd price, etc.). Example Reasons: "Image contains prohibited items", "Text contains inappropriate language", "Image does not match product description", "Price is nonsensical".

        Your response:`;

    const textPart = { text: textPrompt };

    // --- 3. Call Gemini API ---
    try {
        console.log(`Sending product "${name}" (with image) for Gemini Vision review...`);
        const result = await visionModel.generateContent(
            [textPart, imagePart], // Send both text and image parts
            { safetySettings } // Apply safety settings
        );
        const response = result?.response;

        // Handle potential blocked response due to safety settings BEFORE checking text content
        if (!response || response.promptFeedback?.blockReason) {
           const blockReason = response?.promptFeedback?.blockReason || 'Unknown safety reason';
           const safetyRatings = response?.promptFeedback?.safetyRatings || [];
           console.warn(`Gemini review for "${name}" blocked. Reason: ${blockReason}. Ratings: ${JSON.stringify(safetyRatings)}`);
           return { status: 'rejected', reason: `Content blocked by AI safety filters (${blockReason}).` };
       }

        // Process the successful response text
        const reviewText = response?.text()?.trim().toUpperCase() || '';
        console.log(`Gemini Vision Review Raw Response for "${name}": ${reviewText}`);

        if (reviewText.startsWith('APPROVE')) {
            console.log(`Gemini Vision approved product: ${name}`);
            return { status: 'approved', reason: null };
        } else if (reviewText.startsWith('REJECT')) {
            // Extract reason, provide default if missing after colon
            const reason = reviewText.split(':')[1]?.trim() || 'Rejected by AI model (no specific reason provided).';
            console.log(`Gemini Vision rejected product: ${name}. Reason: ${reason}`);
            return { status: 'rejected', reason: reason };
        } else {
            // Handle unexpected valid response formats
            console.warn(`Unexpected Gemini Vision response format for "${name}": ${reviewText}. Defaulting to pending.`);
            return { status: 'pending', reason: 'AI review result unclear.' };
        }

    } catch (error) {
        // Catch errors during the Gemini API call itself
        console.error(`Error during Gemini Vision API call for product "${name}":`, error);
        let reason = 'AI review failed due to an API error.';
        // Check for specific safety errors sometimes caught here
        if (error.message && error.message.includes('SAFETY')) {
            reason = 'Content blocked by AI safety filters during API call.';
        } else if (error.message) {
            reason = `AI API Error: ${error.message.substring(0, 100)}...`; // Keep reason brief
        }
        // Default to rejection on significant API errors? Or pending? Rejection is safer.
        return { status: 'rejected', reason: reason };
    }
};

module.exports = { reviewProductWithGemini };

views/admin/dashboard.ejs:
<%- include('../partials/header', { title: 'Admin Dashboard' }) %>

<div class="admin-dashboard-container">
    <h1>Admin Dashboard</h1>
    <p class="text-muted mb-3">System-wide management access. Welcome, <%= currentUser.name %>!</p>

    <div class="admin-actions-grid">
         <a href="/admin/upload-product" class="admin-action-card">
            <i class="fas fa-upload text-primary"></i>
            <h3>Upload Product (as Admin)</h3>
            <p>Add a product directly to the system.</p>
        </a>
         <a href="/admin/manage-products" class="admin-action-card">
            <i class="fas fa-edit text-success"></i>
            <h3>Manage All Products</h3>
            <p>View, edit, remove products from any seller.</p>
         </a>
        <a href="/admin/manage-orders" class="admin-action-card">
             <i class="fas fa-clipboard-list text-info"></i>
             <h3>Manage All Orders</h3>
             <p>View, confirm delivery, or cancel any customer order.</p>
        </a>
        <a href="/admin/manage-users" class="admin-action-card">
             <i class="fas fa-users-cog text-warning"></i>
             <h3>Manage Users</h3>
             <p>Update roles (User, Seller, Admin), remove users.</p>
        </a>

         <a href="/admin/manage-banners" class="admin-action-card">
             <i class="fas fa-images text-secondary"></i>
             <h3>Manage Banners</h3>
             <p>Update the promotional banners on the homepage.</p>
         </a>

         <%# The "My Admin Profile" card linking to /user/profile has been removed %>

    </div>
</div>

 <%- include('../partials/footer') %>

views/admin/manage-banners.ejs:
<%# views/admin/manage-banners.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Enter direct URLs for the images. Banners will appear on the homepage if URLs are provided.</p>

    <form action="/admin/manage-banners" method="POST" class="form-submit-spinner">
        <% bannerConfig.banners.forEach((banner, index) => { %>
            <fieldset class="mb-4 border p-3 rounded"> <%# Group banner fields %>
                <legend class="h5">Banner <%= index + 1 %></legend>
                <div class="form-group">
                    <label for="imageUrl<%= index + 1 %>">Image URL <%= index + 1 %>:</label>
                    <input type="url" id="imageUrl<%= index + 1 %>" name="imageUrl<%= index + 1 %>" class="form-control" value="<%= banner.imageUrl %>" placeholder="https://example.com/banner<%= index + 1 %>.jpg">
                    <% if (banner.imageUrl) { %>
                        <img src="<%= banner.imageUrl %>" alt="Banner <%= index + 1 %> Preview" style="max-width: 200px; max-height: 75px; margin-top: 10px; border: 1px solid #ddd; padding: 2px; object-fit: contain;">
                    <% } else { %>
                         <small class="d-block mt-1 text-muted">No image set</small>
                    <% } %>
                </div>
                <div class="form-group">
                    <label for="linkUrl<%= index + 1 %>">Link URL <%= index + 1 %> (Optional):</label>
                    <input type="url" id="linkUrl<%= index + 1 %>" name="linkUrl<%= index + 1 %>" class="form-control" value="<%= banner.linkUrl %>" placeholder="https://example.com/category/offers">
                    <% if (banner.linkUrl) { %>
                       <small class="d-block mt-1 text-muted">Clicks to: <%= banner.linkUrl %></small>
                   <% } %>
                </div>
                <div class="form-group">
                    <label for="title<%= index + 1 %>">Title/Alt Text <%= index + 1 %> (Optional):</label>
                    <input type="text" id="title<%= index + 1 %>" name="title<%= index + 1 %>" class="form-control" value="<%= banner.title %>" placeholder="e.g., Special Summer Sale">
                </div>
             </fieldset>
        <% }) %>

        <button type="submit" class="btn btn-primary"><i class="fas fa-save"></i> Save Banners</button>
        <a href="/admin/dashboard" class="btn btn-secondary">Back to Dashboard</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/admin/edit-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p>Admin editing view for product originally uploaded by <%= product.sellerId ? product.sellerId.email : 'Unknown Seller' %>.</p>

    <form action="/admin/manage-products/update/<%= product._id %>" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" value="<%= product.name %>" required>
        </div>

        <div class="form-group">
            <label for="category">Category:</label>
            <input type="text" id="category" name="category" value="<%= product.category %>" required>
        </div>

        <div class="form-group">
            <label for="price">Price (â‚¹):</label>
            <input type="number" id="price" name="price" step="0.01" min="0" value="<%= product.price %>" required>
        </div>

        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" min="0" value="<%= product.stock %>" required>
        </div>

        <div class="form-group">
            <label for="imageUrl">Image URL:</label>
            <input type="url" id="imageUrl" name="imageUrl" value="<%= product.imageUrl %>" required>
            <% if (product.imageUrl) { %>
                <img src="<%= product.imageUrl %>" alt="Current Image" style="max-width: 100px; margin-top: 5px; border:1px solid #ccc; padding:2px;">
            <% } %>
        </div>

        <div class="form-group">
            <label for="specifications">Specifications:</label>
            <textarea id="specifications" name="specifications" rows="5"><%= product.specifications %></textarea>
        </div>

        <hr>
        <h4>Admin Review Control</h4>

        <div class="form-group">
            <label for="reviewStatus">Review Status:</label>
            <select id="reviewStatus" name="reviewStatus" class="form-control" onchange="toggleRejectionReason(this.value)">
                <option value="pending" <%= product.reviewStatus === 'pending' ? 'selected' : '' %>>Pending</option>
                <option value="approved" <%= product.reviewStatus === 'approved' ? 'selected' : '' %>>Approved</option>
                <option value="rejected" <%= product.reviewStatus === 'rejected' ? 'selected' : '' %>>Rejected</option>
            </select>
        </div>

        <div class="form-group" id="rejectionReasonGroup" <%= product.reviewStatus !== 'rejected' ? 'style="display: none;"' : '' %>>
            <label for="rejectionReason">Rejection Reason (Required if Rejected):</label>
            <textarea id="rejectionReason" name="rejectionReason" rows="3" class="form-control"><%= product.rejectionReason || '' %></textarea>
        </div>

        <button type="submit" class="btn btn-primary">Update Product (Admin)</button>
        <a href="/admin/manage-products" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<script>
    function toggleRejectionReason(status) {
        const reasonGroup = document.getElementById('rejectionReasonGroup');
        if (status === 'rejected') {
            reasonGroup.style.display = 'block';
        } else {
            reasonGroup.style.display = 'none';
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        toggleRejectionReason(document.getElementById('reviewStatus').value);
    });
</script>

<%- include('../partials/footer') %>


views/admin/manage-orders.ejs:
<%# views/admin/manage-orders.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container order-manage-page"> <%# Added 'order-manage-page' class %>
    <h1><%= title %></h1>

    <% if (orders.length > 0) { %>
        <div class="table-container">
            <table class="data-table order-table">
                <thead>
                    <tr>
                        <th>Details</th>
                        <th>Customer</th>
                        <th>Items</th>
                        <th>Total</th>
                        <th>Status</th>
                        <th class="actions-cell">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% orders.forEach(order => { %>
                        <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %>" data-order-id="<%= order._id %>">
                            <td data-label="Details">
                                <strong>ID:</strong> <%= order._id %><br>
                                <small class="text-muted"><%= formatDateIST(order.orderDate) %></small><br>
                                <% if (order.products && order.products.length > 0 && order.products[0].productId && order.products[0].productId.sellerId) { %>
                                    <small class="text-muted">Contains items from seller(s)</small>
                                <% } %>
                            </td>
                            <td data-label="Customer">
                                <strong><%= order.shippingAddress.name %></strong><br>
                                <small class="text-muted"><%= order.userEmail || order.userId?.email %></small><br>
                                <small><%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %></small><br>
                                <small><strong>Ph:</strong> <%= order.shippingAddress.phone %></small>
                            </td>
                            <td data-label="Items">
                                <div class="order-items-summary">
                                    <%- order.itemsSummary %>
                                </div>
                                <% if (order.products && order.products.length > 0) { %>
                                    <div class="order-items-images">
                                        <% order.products.forEach(item => { %>
                                            <% if (item.productId && item.productId._id && item.productId.imageUrl) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" title="View <%= item.productId.name || 'Product' %>">
                                                    <img src="<%= item.productId.imageUrl %>"
                                                         alt="<%= item.productId.name || 'Product Image' %>"
                                                         class="order-item-thumbnail" loading="lazy">
                                                </a>
                                            <% } else if (item.productId && item.productId._id) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" class="order-item-thumbnail-placeholder" title="View <%= item.productId.name || 'Product' %>">[No Img]</a>
                                            <% } else { %>
                                                <span class="order-item-thumbnail-placeholder" title="Product data missing">[N/A]</span>
                                            <% } %>
                                        <% }) %>
                                    </div>
                                <% } %>
                            </td>
                            <td data-label="Total" class="order-total"><strong>â‚¹<%= order.totalAmount.toFixed(2) %></strong></td>
                            <td data-label="Status" class="order-status-cell">
                                <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span>
                                <%# Display cancellation reason, whether from admin or seller %>
                                <% if(order.status === 'Cancelled' && order.cancellationReason) { %><br><small class="text-danger mt-1 d-block">Reason: <%= order.cancellationReason %></small><% } %>
                                <% if(order.status === 'Delivered' && order.receivedByDate) { %><br><small class="text-success mt-1 d-block">Delivered:<br><%= formatDateIST(order.receivedByDate) %></small><% } %>

                                <%# Display OTP Hint conditionally %>
                                <% if (order.showDeliveryOtp) { %>
                                  <div class="delivery-otp-display mt-1">
                                    <p>Customer OTP Sent</p>
                                    <%# Display partial OTP for security hint %>
                                    <small class="text-muted">Ask customer for code: <strong class="delivery-otp-code">****<%= order.orderOTP ? order.orderOTP.slice(-2) : 'XX' %></strong></small>
                                     <%# Display expiry time %>
                                     <% if (order.orderOTPExpires) { %>
                                         <small class="text-muted d-block">Expires: <%= formatDateIST(order.orderOTPExpires) %></small>
                                     <% } %>
                                  </div>
                                <% } %>
                                <%# End: Display OTP Hint %>

                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Admin Direct Delivery Confirmation %>
                                <% if (order.canBeDirectlyDeliveredByAdmin) { %>
                                    <div class="action-group mb-2">
                                        <p class="action-group-title">Direct Delivery:</p>
                                        <% if (!order.showDeliveryOtp) { %>
                                            <form action="/admin/orders/<%= order._id %>/send-direct-delivery-otp" method="POST" class="inline-form form-submit-spinner mb-1">
                                                <button type="submit" class="btn btn-warning btn-sm w-100 w-md-auto" title="Send OTP to customer for admin delivery">
                                                    <i class="fas fa-mobile-alt"></i> Send OTP
                                                </button>
                                            </form>
                                        <% } %>
                                        <form action="/admin/orders/<%= order._id %>/confirm-direct-delivery" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                            <input type="text" name="otp" placeholder="Enter OTP" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit OTP from customer">
                                            <button type="submit" class="btn btn-success btn-sm" title="Confirm direct delivery">
                                                <i class="fas fa-check-double"></i> Confirm
                                            </button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Admin Order Cancellation %>
                                <% if (order.canBeCancelledByAdmin) { %>
                                    <div class="action-group">
                                        <form action="/admin/orders/<%= order._id %>/cancel" method="POST" class="cancel-delivery-form form-submit-spinner" onsubmit="return confirm('ADMIN ACTION: Are you sure you want to cancel order <%= order._id %>? This cannot be undone.');">
                                            <label for="reason-<%= order._id %>" class="action-group-title">Cancel Order:</label>
                                            <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm d-block mb-1">
                                                <option value="" disabled selected>Select Admin Reason...</option>
                                                <% if (typeof cancellationReasons !== 'undefined' && cancellationReasons.length > 0) { %>
                                                    <% cancellationReasons.forEach(reason => { %>
                                                        <option value="<%= reason %>"><%= reason %></option>
                                                    <% }) %>
                                                <% } else { %>
                                                     <option value="Other (Admin)" selected>Other (Admin)</option> <%# Fallback %>
                                                <% } %>
                                            </select>
                                            <button type="submit" class="btn btn-danger btn-sm w-100 w-md-auto"><i class="fas fa-ban"></i> Cancel Order</button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Fallback for no actions %>
                                <% if (!order.canBeDirectlyDeliveredByAdmin && !order.canBeCancelledByAdmin) { %>
                                    <small class="text-muted no-actions-text">
                                        <% if (order.status === 'Delivered') { %>Completed<% } else if (order.status === 'Cancelled') { %>Cancelled<% } else { %>No admin actions<% } %>
                                    </small>
                                <% } %>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="alert alert-info">No orders received yet.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/admin/manage-products.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Showing all products from all sellers.</p>

    <% if (products.length > 0) { %>
        <div class="table-container card">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Image</th>
                        <th>Name / Category</th>
                        <th>Seller</th>
                        <th>Price / Stock</th>
                        <th>Status</th>
                        <th>Reason</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% products.forEach(product => { 
                        const productNameEsc = product.name.replace(/'/g, "\\'");
                        const sellerEmail = product.sellerId?.email || product.sellerEmail || 'Unknown';
                        const sellerEmailEsc = sellerEmail.replace(/'/g, "\\'");
                    %>
                        <tr class="status-<%= product.reviewStatus %>">
                            <td data-label="Image">
                                <a href="/products/<%= product._id %>">
                                    <img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="table-img">
                                </a>
                            </td>
                            <td data-label="Name / Category">
                                <%= product.name %><br>
                                <small class="text-muted"><%= product.category %></small>
                            </td>
                            <td data-label="Seller"><%= sellerEmail %></td>
                            <td data-label="Price / Stock">
                                â‚¹<%= product.price.toFixed(2) %><br>
                                <small>Stock: <%= product.stock %></small>
                            </td>
                            <td data-label="Status">
                                <span class="status-badge status-<%= product.reviewStatus %> text-capitalize">
                                    <%= product.reviewStatus %>
                                </span>
                            </td>
                            <td data-label="Reason">
                                <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %>
                                    <small class="text-danger" title="Rejection Reason"><%= product.rejectionReason %></small>
                                <% } else { %>
                                    <span class="text-muted">--</span>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <a href="/admin/manage-products/edit/<%= product._id %>" class="btn btn-text btn-sm" title="Edit Product (Admin)">
                                    <i class="fas fa-edit"></i> Edit
                                </a>
                                <form action="/admin/manage-products/remove/<%= product._id %>" method="POST" class="inline-form form-submit-spinner"
                                    onsubmit="return confirmAdminRemove('<%= productNameEsc %>', '<%= sellerEmailEsc %>')">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove Product (Admin)">
                                        <i class="fas fa-trash"></i> Remove
                                    </button>
                                </form>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="text-muted mt-3">No products found in the system.</p>
    <% } %>
</div>

<script>
    function confirmAdminRemove(productName, sellerEmail) {
        return confirm(`ADMIN ACTION: Remove product ${productName} (Seller: ${sellerEmail})?`);
    }
</script>

<%- include('../partials/footer') %>


views/admin/manage-users.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>

    <% if (users.length > 0) { %>
        <div class="table-container card">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Email / Phone</th>
                        <th>Role</th>
                        <th>Registered On</th>
                        <th>Verified</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% users.forEach(user => { %>
                        <tr>
                            <td data-label="Name"><%= user.name %></td>
                            <td data-label="Email / Phone">
                                <%= user.email %>
                                <% if (user.address && user.address.phone) { %>
                                    <br><small>(Ph: <%= user.address.phone %>)</small>
                                <% } %>
                            </td>
                            <td data-label="Role">
                                <form action="/admin/users/<%= user._id %>/update-role" method="POST" class="inline-form form-submit-spinner">
                                    <select name="role" onchange="this.form.submit()" class="form-control form-control-sm" style="display: inline-block; width: auto; vertical-align: middle;"> <%# Inline style for select %>
                                        <option value="user" <%= user.role === 'user' ? 'selected' : '' %>>User</option>
                                        <option value="seller" <%= user.role === 'seller' ? 'selected' : '' %>>Seller</option> <%# ADD SELLER %>
                                        <option value="admin" <%= user.role === 'admin' ? 'selected' : '' %>>Admin</option>
                                    </select>
                                    <noscript><button type="submit" class="btn btn-sm btn-primary ml-1">Update</button></noscript> <%# Fallback button %>
                                </form>
                            </td>
                            <td data-label="Registered On"><small><%= formatDateIST(user.createdAt) %></small></td>
                            <td data-label="Verified"><%= user.isVerified ? 'Yes' : 'No' %></td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Prevent removing self or last admin in controller logic %>
                                <form action="/admin/users/<%= user._id %>/remove" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('ADMIN ACTION: Are you sure you want to remove user <%= user.email %>? This is irreversible.');">
                                    <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-user-times"></i> Remove</button>
                                </form>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="text-muted mt-3">No other registered users found.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/admin/upload-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1>Admin: Upload New Product</h1>
    <p class="text-muted small mb-3">Product will be submitted for automatic review upon upload.</p>

    <form action="/admin/upload-product" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= typeof product !== 'undefined' ? product.name : '' %>" required>
        </div>
        <div class="form-group">
            <label for="category">Category:</label>
            <input type="text" id="category" name="category" class="form-control" value="<%= typeof product !== 'undefined' ? product.category : '' %>" required>
        </div>
        <div class="form-group">
            <label for="price">Price (â‚¹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= typeof product !== 'undefined' ? product.price : '' %>" required>
        </div>
        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= typeof product !== 'undefined' ? product.stock : '' %>" required>
        </div>
        <div class="form-group">
            <label for="imageUrl">Image URL:</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" placeholder="https://example.com/image.jpg" value="<%= typeof product !== 'undefined' ? product.imageUrl : '' %>" required>
        </div>
        <div class="form-group">
            <label for="specifications">Specifications (Optional):</label>
            <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= typeof product !== 'undefined' ? product.specifications : '' %></textarea>
        </div>
        <button type="submit" class="btn btn-primary">Upload & Submit for Review</button>
        <a href="/admin/dashboard" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/auth/forgot-password.ejs:
<%- include('../partials/header', { title: 'Forgot Password' }) %>

<div class="auth-container">
    <h1>Forgot Password</h1>
    <p>Enter your email address below. If an account exists, we'll send an OTP to verify your request.</p>

    <form action="/auth/forgot-password" method="POST" class="auth-form">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required>
        </div>
        <button type="submit" class="btn btn-primary">Send Reset OTP</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>


views/auth/login.ejs:
<%- include('../partials/header', { title: 'Login' }) %>

<div class="auth-container">
    <h1>Login</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/login" method="POST" class="auth-form form-submit-spinner">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" required autocomplete="current-password">
        </div>
        <button type="submit" class="btn btn-primary">Login</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/forgot-password">Forgot Password?</a></p>
        <p>Don't have an account? <a href="/auth/register">Register here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/register.ejs:
<%- include('../partials/header', { title: 'Register' }) %>

<div class="auth-container">
    <h1>Register</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/register" method="POST" class="auth-form form-submit-spinner">
         <div class="form-group">
            <label for="name">Name:</label>
            <input type="text" id="name" name="name" required autocomplete="name">
        </div>
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" minlength="6" required autocomplete="new-password">
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required autocomplete="new-password">
        </div>
        <button type="submit" class="btn btn-primary">Register</button>
    </form>
    <div class="auth-links">
        <p>Already have an account? <a href="/auth/login">Login here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/reset-password.ejs:
<%- include('../partials/header', { title: 'Reset Password' }) %>

<div class="auth-container">
    <h1>Reset Password</h1>
    <p>Enter your new password below.</p>

    <form action="/auth/reset-password/<%= token %>" method="POST" class="auth-form">
        <div class="form-group">
            <label for="password">New Password:</label>
            <input type="password" id="password" name="password" minlength="6" required>
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm New Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required>
        </div>
        <button type="submit" class="btn btn-primary">Reset Password</button>
    </form>
     <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>


views/auth/verify-otp.ejs:
<%- include('../partials/header', { title: title || 'Verify OTP' }) %>

<div class="auth-container">
    <h1>Verify OTP</h1>
    <p>An OTP has been sent to <strong><%= email %></strong>. Please enter it below.</p>

    <%# --- Spinner Class Added & Input Attributes Updated --- %>
    <form action="/auth/verify-otp" method="POST" class="auth-form form-submit-spinner">
         <input type="hidden" name="email" value="<%= email %>">
        <div class="form-group">
            <label for="otp">OTP Code:</label>
            <input type="text" <%# Changed type to text for better compatibility %>
                   id="otp"
                   name="otp"
                   required
                   pattern="\d{6}" <%# Ensures exactly 6 digits %>
                   maxlength="6"  <%# Limits input length %>
                   inputmode="numeric" <%# Suggests numeric keyboard on mobile %>
                   autocomplete="one-time-code" <%# Helps password managers/browsers %>
                   title="Enter the 6-digit OTP code received"> <%# Clear hint %>
        </div>
        <button type="submit" class="btn btn-primary">Verify OTP</button>
    </form>
    <div class="auth-links">
        <p>Didn't receive the OTP?</p>
        <form action="/auth/resend-otp" method="POST" style="display:inline;" class="form-submit-spinner">
             <input type="hidden" name="email" value="<%= email %>">
             <button type="submit" class="btn btn-secondary btn-sm">Resend OTP</button>
         </form>
    </div>
</div>

<%- include('../partials/footer') %>

views/partials/footer.ejs:
    </main> <%# End Main Content Area %>

    <footer class="app-footer desktop-only">
        <p>Â© <%= new Date().getFullYear() %> ProShop. All rights reserved.</p>
    </footer>

    <script src="/js/main.js"></script>

</body>
</html>

views/partials/header.ejs:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <% const pageTitle = typeof title !== 'undefined' ? title + ' - miniapp' : 'miniapp'; %>
  <% const siteName = typeof defaultSiteName !== 'undefined' ? defaultSiteName : 'miniapp'; %>
  <% const currentMetaTitle = typeof metaTitle !== 'undefined' ? metaTitle : pageTitle; %>
  <% const currentMetaDesc = typeof metaDescription !== 'undefined' ? metaDescription : 'Check out our products on ' + siteName; %>
  <% const currentMetaImage = typeof metaImageUrl !== 'undefined' ? metaImageUrl : '/images/default-logo.png'; %>
  <% const currentMetaUrl = typeof fullUrl !== 'undefined' ? fullUrl : ''; %>
  <% const currentMetaType = typeof metaType !== 'undefined' ? metaType : 'website'; %>

  <title><%= pageTitle %></title>
  <meta name="description" content="<%= currentMetaDesc %>">
  <meta property="og:title" content="<%= currentMetaTitle %>" />
  <meta property="og:description" content="<%= currentMetaDesc %>" />
  <meta property="og:image" content="<%= currentMetaImage %>" />
  <% if (currentMetaUrl) { %><meta property="og:url" content="<%= currentMetaUrl %>" /><% } %>
  <meta property="og:type" content="<%= currentMetaType %>" />
  <meta property="og:site_name" content="<%= siteName %>" />
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="<%= currentMetaTitle %>">
  <meta name="twitter:description" content="<%= currentMetaDesc %>">
  <meta name="twitter:image" content="<%= currentMetaImage %>">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <header class="app-header">
    <nav class="navbar">
      <div class="nav-left">
        <a href="/" class="app-logo">
          <i class="fas fa-shopping-bag"></i>
          <span class="app-name">miniapp</span>
        </a>
      </div>

      <%# --- NEW Dynamic Search Bar Container --- %>
      <div class="search-container-dynamic" id="dynamic-search-container">
          <form action="/products" method="GET" class="search-form-dynamic" id="dynamic-search-form">
              <input type="search"
                     id="search-input-dynamic"
                     name="search"
                     placeholder="Search products..."
                     aria-label="Search Products"
                     autocomplete="off">
              <button type="submit" class="search-submit-btn-dynamic" aria-label="Submit Search">
                  <i class="fas fa-search"></i>
              </button>
          </form>
           <div class="suggestions-dropdown" id="suggestions-dropdown">
              <%# Suggestions will be populated here by JS %>
          </div>
      </div>
      <%# --- END Dynamic Search Bar Container --- %>

      <div class="nav-right">
          <%# Search Icon Toggle (controls the container above) %>
          <button class="nav-link search-toggle-btn" id="search-toggle-btn" aria-label="Toggle Search Bar">
              <i class="fas fa-search"></i>
              <span>Search</span>
          </button>

        <%# Rest of the nav items %>
        <% if (currentUser) { %>
          <a href="/" class="nav-link <%= currentUrl === '/' ? 'active' : '' %>" title="Home Page">
            <i class="fas fa-home"></i> <span>Home</span>
          </a>
          <a href="/user/cart" class="nav-link nav-link-cart <%= currentUrl === '/user/cart' ? 'active' : '' %>" title="Cart Page">
            <i class="fas fa-shopping-cart"></i>
            <span class="cart-badge <%= cartItemCount > 0 ? '' : 'hide' %>"><%= cartItemCount %></span>
            <span>Cart</span>
          </a>

          <%# --- ORDERS LINK HAS BEEN REMOVED FROM HERE --- %>

          <%# --- REMOVED Admin and Seller Dashboard Links --- %>

          <a href="/user/profile" class="profile-avatar-link <%= currentUrl === '/user/profile' ? 'active' : '' %>" title="My Profile Page">
            <span class="profile-avatar-initials"><%= userInitials %></span>
          </a>
        <% } else { %>
          <a href="/auth/login" class="btn btn-login-register">
            <i class="fas fa-sign-in-alt"></i> Login / Register
          </a>
        <% } %>
      </div>
    </nav>
  </header>

  <%- include('messages') %>

  <main class="container">

views/partials/messages.ejs:
<%# views/partials/messages.ejs %>

<%# --- NEW: Toast Container --- %>
<div class="toast-container">
    <% if (success_msg && success_msg.length > 0) { %>
      <div class="toast toast-success" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-body">
          <%= success_msg %>
          <button type="button" class="toast-close-btn" aria-label="Close">Ã—</button>
        </div>
      </div>
    <% } %>

    <% if (error_msg && error_msg.length > 0) { %>
       <div class="toast toast-danger" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-body">
          <%= error_msg %>
           <button type="button" class="toast-close-btn" aria-label="Close">Ã—</button>
        </div>
      </div>
    <% } %>

    <% if (error && typeof error !== 'undefined' && error.length > 0) { %>
      <div class="toast toast-danger" role="alert" aria-live="assertive" aria-atomic="true">
         <div class="toast-body">
           <%= error %>
            <button type="button" class="toast-close-btn" aria-label="Close">Ã—</button>
         </div>
       </div>
    <% } %>

    <%# Add other flash message types (info, warning) here if needed %>

</div>
<%# --- End Toast Container --- %>

<%# The old alert divs are removed %>

views/products/detail.ejs:
<%# views/products/detail.ejs %>

<%# --- Meta Description Preparation (Same as before) --- %>
<% let metaDesc = `Check out ${product.name} on miniapp. Available now for â‚¹${product.price.toFixed(2)}.`; %>
<% if (metaDesc.length > 160) { metaDesc = metaDesc.substring(0, 157) + '...'; } %>

<%- include('../partials/header', {
    title: product.name,
    metaTitle: product.name + ' - ' + defaultSiteName, // Use defaultSiteName
    metaDescription: metaDesc,
    metaImageUrl: product.imageUrl,
    metaUrl: fullUrl,
    metaType: 'product'
}) %>

<div class="product-detail-container">

   <%# --- Status Banner for Admin/Owner if Not Approved --- %>
   <% if (!isApproved && (isAdminView || isOwnerView)) { %>
     <div class="alert alert-<%= product.reviewStatus === 'rejected' ? 'danger' : 'warning' %> mb-3" role="alert">
       <strong>Status:</strong> <span class="text-capitalize fw-bold"><%= product.reviewStatus %></span>
       <% if (product.reviewStatus === 'rejected' && product.rejectionReason) { %>
         <br><strong>Reason:</strong> <%= product.rejectionReason %>
       <% } else if (product.reviewStatus === 'pending') { %>
          - This product is awaiting review and is not visible to customers.
       <% } %>
       <% if (isOwnerView && product.reviewStatus !== 'approved') { %> <%# Show edit link only to owner if not approved %>
          <br><a href="/seller/products/edit/<%= product._id %>" class="alert-link">Edit and Resubmit for Review</a>
        <% } else if (isAdminView && product.reviewStatus !== 'approved') { %>
           <br><a href="/admin/manage-products/edit/<%= product._id %>" class="alert-link">Admin: Edit Status/Details</a>
       <% } %>
     </div>
   <% } else if (!isApproved && !isAdminView && !isOwnerView) { %>
      <%# This block should technically not be reachable due to controller redirect, but acts as safety %>
      <div class="alert alert-danger">This product is currently unavailable.</div>
      <%# Early exit or hide the rest of the content %>
      </div> <%- /* End product-detail-container */ %>
      <%- include('../partials/footer') %>
      <% return; %> <%# Stop rendering further %>
   <% } %>
   <%# --- End Status Banner --- %>


   <div class="product-detail-main">
        <div class="product-detail-image">
           <img src="<%= product.imageUrl %>" alt="<%= product.name %>">
        </div>
       <div class="product-detail-info">
            <h1><%= product.name %></h1>
            <p class="detail-price">â‚¹<%= product.price.toFixed(2) %></p>
            <p class="detail-stock">
                <% if (product.stock > 0) { %>
                    Available Stock : <%= product.stock %>
                <% } else { %>
                    <span class="text-danger fw-bold">Out of Stock</span>
                <% } %>
            </p> <%# End of stock paragraph %>

            <%# === MOVED SHARE BUTTON HERE === %>
            <div class="share-section mt-2"> <%# Adjusted margin %>
                <button id="share-product-btn" class="btn btn-outline-secondary btn-sm"
                        data-title="<%= product.name %>"
                        data-text="Check out this product: <%= product.name %>"
                        data-url="<%= fullUrl %>">
                    <i class="fas fa-share-alt"></i> Share
                </button>
                <div id="fallback-share-links" class="fallback-share-links hidden">
                    <small>Share via:</small>
                    <a href="https://www.facebook.com/sharer/sharer.php?u=<%= encodeURIComponent(fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Facebook"><i class="fab fa-facebook-square"></i></a>
                    <a href="https://twitter.com/intent/tweet?url=<%= encodeURIComponent(fullUrl) %>&text=<%= encodeURIComponent('Check out this product: ' + product.name) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Twitter"><i class="fab fa-twitter-square"></i></a>
                    <a href="https://api.whatsapp.com/send?text=<%= encodeURIComponent('Check out this product: ' + product.name + ' ' + fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on WhatsApp"><i class="fab fa-whatsapp-square"></i></a>
                    <a href="mailto:?subject=<%= encodeURIComponent('Check out this product: ' + product.name) %>&body=<%= encodeURIComponent('I thought you might like this product:\n\n' + product.name + '\n' + fullUrl) %>" aria-label="Share via Email"><i class="fas fa-envelope-square"></i></a>
                </div>
            </div>
            <%# === END MOVED SHARE BUTTON === %>

           <%# --- RATING DISPLAY BLOCK REMOVED FROM HERE --- %>

           <%# --- Conditional Purchase Actions --- %>
           <% if (isApproved) { %>
               <div class="product-actions">
                   <%# === MODIFIED Add to Cart Form === %>
                   <form action="/user/cart/add" method="POST" style="display: inline-block; margin-right: 10px;" class="form-submit-spinner">
                      <input type="hidden" name="productId" value="<%= product._id %>">
                       <div class="quantity-selector mb-2 d-inline-flex align-items-center"> <%# Added d-inline-flex and align-items-center %>
                           <label for="quantity" class="me-1 mb-0 text-muted">Quantity </label> <%# Kept text-muted style %>
                           <input type="number" id="quantity" name="quantity" value="1" min="1" max="<%= product.stock %>" required aria-label="Quantity" class="form-control form-control-sm" style="width: 70px;">
                       </div>
                       <button type="submit" class="btn btn-primary btn-sm" <%= product.stock <= 0 ? 'disabled' : '' %>>
                           <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                       </button>
                  </form>
                  <%# === END MODIFIED Add to Cart Form === %>

                   <%# Buy Now Form %>
                    <% if (product.stock > 0) { %>
                    <form action="/user/cart/add?redirectTo=checkout" method="POST" style="display: inline-block;" class="form-submit-spinner">
                          <input type="hidden" name="productId" value="<%= product._id %>">
                          <input type="hidden" name="quantity" value="1">
                         <button type="submit" class="btn btn-success btn-sm">Buy Now</button>
                       </form>
                    <% } else {%>
                      <button class="btn btn-success btn-sm" disabled>Buy Now</button>
                    <% } %>
               </div>
            <% } else { %>
                <div class="product-actions">
                     <button class="btn btn-primary btn-sm" disabled><i class="fas fa-cart-plus"></i> Add to Cart</button>
                     <button class="btn btn-success btn-sm" disabled>Buy Now</button>
                     <p class="text-muted small mt-2">This product is currently under review or unavailable.</p>
                 </div>
            <% } %>
            <%# --- End Conditional Purchase Actions --- %>

            <%# Specifications %>
            <div class="product-specifications mt-3">
                 <h3>Specifications</h3>
                 <pre class="border p-2 bg-light small"><%= product.specifications || 'No specifications provided.' %></pre>
            </div> <%# End of product-specifications div %>

            <%# === MOVED SELLER INFO HERE === %>
            <p class="small text-muted mt-3">Seller Info : <%= product.sellerEmail || 'Unknown Seller' %></p>
            <%# === END MOVED SELLER INFO === %>

       </div> <%# End product-detail-info %>
    </div> <%# End product-detail-main %>

   <%# --- Conditional Rating Section --- %>
   <div class="product-rating-section mt-4 border-top pt-3">
        <h3>Rate This Product</h3>
        <% if (isApproved) { %> <%# Only allow rating if approved %>
            <% if (userCanRate) { %>
                <form action="/products/<%= product._id %>/rate" method="POST" class="form-submit-spinner">
                    <div class="rating-stars">
                        <% for (let i = 5; i >= 1; i--) { %><input type="radio" id="star<%= i %>" name="rating" value="<%= i %>" <%= userRating === i ? 'checked' : '' %> required><label for="star<%= i %>" title="<%= i %> stars"><i class="fas fa-star"></i></label><% } %>
                    </div>
                    <button type="submit" class="btn btn-primary btn-sm">Submit Rating</button>
                </form>
            <% } else { %>
               <p><a href="/auth/login?returnTo=<%= encodeURIComponent(currentUrl) %>">Login</a> to rate this product.</p>
            <% } %>
         <% } else { %>
             <p class="text-muted">Rating is unavailable until the product is approved.</p>
         <% } %>
   </div>
   <%# --- End Conditional Rating Section --- %>

    <%# --- RATING DISPLAY BLOCK PASTED HERE --- %>
    <div class="mb-3"> <%# Removed mt-3, added mb-3 for spacing below %>
        <% if (product.numReviews > 0) { %>
            <p class="detail-rating">
                Rating:
               <% for(let i=1; i<=5; i++) { %><i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i><% } %>
                (<%= product.numReviews %> reviews) | <%= product.orderCount %> Ordered
            </p>
        <% } else { %>
            <p class="detail-rating">No reviews yet | <%= product.orderCount %> Ordered</p>
        <% } %>
    </div>
    <%# --- END PASTED RATING DISPLAY BLOCK --- %>


    <%# --- Rating Stats Display --- %>
    <div class="rating-stats-container mt-4 border-top pt-3">
        <h3>Ratings & Reviews Summary</h3>
         <% if (totalRatings > 0) { %>
             <div class="rating-summary mb-3">
                 <div class="rating-average">
                     <span class="rating-average-value"><%= product.averageRating.toFixed(1) %></span> <i class="fas fa-star text-warning"></i>
                 </div>
                 <div class="rating-total text-muted small">
                     Based on <%= totalRatings %> Rating<%= totalRatings !== 1 ? 's' : '' %>
                 </div>
             </div>
            <div class="rating-bars">
                <% for (let i = 5; i >= 1; i--) {
                      const count = ratingCounts[i] || 0;
                      const percentage = totalRatings > 0 ? (count / totalRatings) * 100 : 0;
                 %>
                     <div class="rating-bar-row">
                         <span class="rating-bar-label small"><%= i %> <i class="fas fa-star text-warning"></i></span>
                         <div class="rating-bar-progress progress" style="height: 8px;"> <%# Use Bootstrap progress bar style %>
                             <div class="rating-bar-fill progress-bar bg-success" role="progressbar" data-width="<%= percentage.toFixed(1) %>" aria-valuenow="<%= percentage.toFixed(1) %>" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"></div> <%# Start width at 0 %>
                         </div>
                         <span class="rating-bar-count small text-muted"><%= count %></span>
                     </div>
                 <% } %>
            </div>
        <% } else { %>
            <p>No ratings yet for this product.</p>
         <% } %>
    </div>
     <%# --- End Rating Stats Display --- %>

</div> <%# End product-detail-container %>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Animate progress bars
    document.querySelectorAll('.rating-bar-fill').forEach(function(el) {
        var width = el.getAttribute('data-width');
        if (width) {
            setTimeout(() => { // Small delay for visual effect
                 el.style.width = width + '%';
            }, 100);
        }
    });
});
</script>

<%- include('../partials/footer') %>

views/products/index.ejs:
<%# views/products/index.ejs %>
<%- include('../partials/header', { title: title }) %>

<%# --- UPDATED: Homepage Banner Slider Section --- %>
<% if (typeof homepageBanners !== 'undefined' && homepageBanners.length > 0) { %>
    <div class="banner-slider-container mb-4" data-slider-container>
        <div class="banner-slides" data-slides>
            <% homepageBanners.forEach((banner, index) => { %>
                <div class="banner-slide <%= index === 0 ? 'active' : '' %>" data-slide> <%# First slide is active initially %>
                    <% if (banner.linkUrl) { %>
                        <a href="<%= banner.linkUrl %>" target="_blank" rel="noopener noreferrer" class="banner-link">
                            <img src="<%= banner.imageUrl %>"
                                 alt="<%= banner.title || `Promotional Banner ${index + 1}` %>"
                                 class="banner-image"
                                 loading="lazy">
                        </a>
                    <% } else { %>
                        <img src="<%= banner.imageUrl %>"
                             alt="<%= banner.title || `Promotional Banner ${index + 1}` %>"
                             class="banner-image"
                             loading="lazy">
                    <% } %>
                </div>
            <% }) %>
        </div>

        <%# Optional: Navigation Arrows (hide if only one banner) %>
        <% if (homepageBanners.length > 1) { %>
            <button class="banner-nav banner-prev" data-slider-prev aria-label="Previous Banner"><i class="fas fa-chevron-left"></i></button>
            <button class="banner-nav banner-next" data-slider-next aria-label="Next Banner"><i class="fas fa-chevron-right"></i></button>
        <% } %>

        <%# Optional: Navigation Dots (hide if only one banner) %>
         <% if (homepageBanners.length > 1) { %>
            <div class="banner-dots" data-slider-dots>
                <% homepageBanners.forEach((_, index) => { %>
                    <button class="banner-dot <%= index === 0 ? 'active' : '' %>" data-slide-to="<%= index %>" aria-label="Go to banner <%= index + 1 %>"></button>
                <% }) %>
            </div>
        <% } %>
    </div>
<% } %>
<%# --- End: Homepage Banner Slider Section --- %>

<div class="product-index-container">
    <br>
        <h1>New Launches</h1>

    <% if (products.length > 0) { %>
        <div class="product-grid">
            <% products.forEach(product => { %>
                <div class="product-card">
                    <a href="/products/<%= product._id %>" class="product-link">
                        <img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="product-image">
                        <div class="product-info">
                            <h3 class="product-name"><%= product.name %></h3>
                            <p class="product-price">â‚¹<%= (typeof product.price === 'number' ? product.price : 0).toFixed(2) %></p>
                            <p class="product-stock">Stock: <%= product.stock %></p>
                            <% if (product.numReviews > 0) { %>
                                 <p class="product-rating">
                                    <% for(let i=1; i<=5; i++) { %>
                                        <i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i>
                                    <% } %>
                                    (<%= product.numReviews %>)
                                 </p>
                            <% } else { %>
                                <p class="product-rating">Â </p> <%# Keep space for alignment %>
                            <% } %>
                        </div>
                    </a>
                     <form action="/user/cart/add" method="POST" class="add-to-cart-form form-submit-spinner">
                         <input type="hidden" name="productId" value="<%= product._id %>">
                         <input type="hidden" name="quantity" value="1">
                        <button type="submit" class="btn btn-primary btn-add-to-cart" <%= product.stock <= 0 ? 'disabled' : '' %>>
                            <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                         </button>
                    </form>
                </div>
            <% }) %>
        </div>
    <% } else { %>
         <p class="alert alert-info">
             <% if (typeof searchTerm !== 'undefined' && searchTerm) { %>
                 No products found matching your search "<%= searchTerm %>".
             <% } else { %>
                 No products are currently available. Check back soon!
             <% } %>
         </p>
    <% } %>

</div>

<%- include('../partials/footer') %>

seller/dashboard.ejs:
<%- include('../partials/header', { title: 'Seller Dashboard' }) %>

<div class="admin-dashboard-container"> <%# Re-use admin style container %>
    <h1>Seller Dashboard</h1>
    <p class="text-muted mb-3">Manage your products and orders.</p>

    <div class="admin-actions-grid"> <%# Re-use admin style grid %>
         <a href="/seller/products/upload" class="admin-action-card">
            <i class="fas fa-upload text-primary"></i> <%# Added color class %>
            <h3>Upload Product</h3>
            <p>Add a new product to your listings.</p>
        </a>
         <a href="/seller/products" class="admin-action-card">
            <i class="fas fa-edit text-success"></i> <%# Added color class %>
            <h3>Manage Products</h3>
            <p>View status, edit, or remove your products.</p>
         </a>
        <a href="/seller/orders" class="admin-action-card">
             <i class="fas fa-clipboard-list text-info"></i> <%# Added color class %>
             <h3>Manage Orders</h3>
             <p>View and manage orders containing your products.</p>
        </a>

    </div>
</div>

<%- include('../partials/footer') %>

seller/edit-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Updating the product will reset its status to 'pending' and trigger a new review.</p>

     <form action="/seller/products/update/<%= product._id %>" method="POST" class="form-submit-spinner">
        <%# Display current status (read-only) %>
         <div class="alert alert-<%= product.reviewStatus === 'approved' ? 'success' : (product.reviewStatus === 'rejected' ? 'danger' : 'warning') %>" role="alert">
           <strong>Current Status:</strong> <span class="text-capitalize"><%= product.reviewStatus %></span>
           <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %>
            <br><strong>Rejection Reason:</strong> <%= product.rejectionReason %>
           <% } %>
         </div>

        <div class="form-group">
             <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" value="<%= product.name %>" required>
         </div>
        <div class="form-group">
            <label for="category">Category:</label>
             <input type="text" id="category" name="category" value="<%= product.category %>" required>
         </div>
         <div class="form-group">
            <label for="price">Price (â‚¹):</label>
            <input type="number" id="price" name="price" step="0.01" min="0" value="<%= product.price %>" required>
         </div>
        <div class="form-group">
             <label for="stock">Stock Quantity:</label>
             <input type="number" id="stock" name="stock" min="0" value="<%= product.stock %>" required>
        </div>
         <div class="form-group">
             <label for="imageUrl">Image URL:</label>
             <input type="url" id="imageUrl" name="imageUrl" value="<%= product.imageUrl %>" required>
             <% if(product.imageUrl) { %>
                <img src="<%= product.imageUrl %>" alt="Current Image" style="max-width: 100px; margin-top: 5px; border: 1px solid #ddd; padding: 2px;">
             <% } %>
         </div>
         <div class="form-group">
             <label for="specifications">Specifications (Optional):</label>
             <textarea id="specifications" name="specifications" rows="5"><%= product.specifications %></textarea>
        </div>
         <button type="submit" class="btn btn-primary">Update & Resubmit for Review</button>
         <a href="/seller/products" class="btn btn-secondary">Cancel</a>
    </form>
 </div>

 <%- include('../partials/footer') %>

seller/manage-orders.ejs:
<%# views/seller/manage-orders.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container order-manage-page"> <%# Added 'order-manage-page' class %>
    <h1>Manage Your Orders</h1>
    <p class="text-muted small mb-3">Showing orders that contain one or more of your products.</p>

    <% if (message) { %>
        <p class="alert alert-info"><%= message %></p>
    <% } %>

    <% if (orders.length > 0) { %>
        <div class="table-container"> <%# Removed 'card' class %>
            <table class="data-table order-table"> <%# Added 'order-table' class %>
                <thead>
                    <tr>
                        <th>Order ID / Date</th>
                        <th>Customer / Address</th>
                        <th>Items (Your items highlighted)</th>
                        <th>Total</th>
                        <th>Status</th>
                        <th class="actions-cell">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% orders.forEach(order => { %>
                        <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %>" data-order-id="<%= order._id %>">
                            <td data-label="Order ID / Date">
                                <%= order._id %><br>
                                <small class="text-muted"><%= formatDateIST(order.orderDate) %></small>
                            </td>
                            <td data-label="Customer / Address">
                                <strong><%= order.shippingAddress.name %></strong><br>
                                <small class="text-muted"><%= order.userEmail || order.userId?.email %></small><br> <%# Added null check for email %>
                                <small class="text-muted"><%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %></small><br>
                                <small><strong>Ph:</strong> <%= order.shippingAddress.phone %></small>
                            </td>
                            <td data-label="Items">
                                <div class="order-items-summary">
                                    <%- order.itemsSummary %> <%# Raw HTML summary %>
                                </div>
                                <% if (order.products && order.products.length > 0) { %>
                                    <div class="order-items-images">
                                        <% order.products.forEach(item => { %>
                                            <% if (item.productId && item.productId._id && item.productId.imageUrl) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" title="View <%= item.productId.name || 'Product' %>">
                                                    <img src="<%= item.productId.imageUrl %>"
                                                         alt="<%= item.productId.name || 'Product Image' %>"
                                                         class="order-item-thumbnail" loading="lazy"> <%# Added lazy loading %>
                                                </a>
                                            <% } else if (item.productId && item.productId._id) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" class="order-item-thumbnail-placeholder" title="View <%= item.productId.name || 'Product' %>">[No Img]</a>
                                            <% } else { %>
                                                <span class="order-item-thumbnail-placeholder" title="Product data missing">[N/A]</span>
                                            <% } %>
                                        <% }) %>
                                    </div>
                                <% } %>
                            </td>
                            <td data-label="Total" class="order-total"><strong>â‚¹<%= order.totalAmount.toFixed(2) %></strong></td>
                            <td data-label="Status" class="order-status-cell">
                                <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span>
                                <%# Display cancellation reason including seller prefix %>
                                <% if(order.status === 'Cancelled' && order.cancellationReason) { %>
                                    <br><small class="text-danger mt-1 d-block">Reason:<br><%= order.cancellationReason %></small>
                                <% } %>
                                <% if(order.status === 'Delivered' && order.receivedByDate) { %><br><small class="text-success mt-1 d-block">Delivered:<br><%= formatDateIST(order.receivedByDate) %></small><% } %>
                                <% if (order.showDeliveryOtp && order.status === 'Pending') { %>
                                  <div class="delivery-otp-display mt-1"> <%# Reusing user style %>
                                    <p>Customer OTP Sent</p>
                                    <small class="text-muted">Ask customer for code: <strong class="delivery-otp-code">****<%= order.orderOTP ? order.orderOTP.slice(-2) : 'XX' %></strong></small>
                                  </div>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Seller Direct Delivery Confirmation %>
                                <% if (order.canBeDirectlyDeliveredBySeller) { %>
                                    <div class="action-group mb-2"> <%# Added mb-2 for spacing %>
                                        <p class="action-group-title">Confirm Delivery:</p>
                                        <% if (!order.showDeliveryOtp) { %>
                                            <form action="/seller/orders/<%= order._id %>/send-otp" method="POST" class="inline-form form-submit-spinner mb-1">
                                                <button type="submit" class="btn btn-warning btn-sm w-100 w-md-auto" title="Send OTP to customer to confirm delivery"> <%# Control width %>
                                                    <i class="fas fa-mobile-alt"></i> Send OTP
                                                </button>
                                            </form>
                                        <% } %>
                                        <form action="/seller/orders/<%= order._id %>/confirm-delivery" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                            <input type="text" name="otp" placeholder="Enter OTP" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit OTP from customer">
                                            <button type="submit" class="btn btn-success btn-sm" title="Confirm delivery using customer's OTP">
                                                <i class="fas fa-check-double"></i> Confirm
                                            </button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# --- NEW: Seller Order Cancellation Form --- %>
                                <% if (order.canBeCancelledBySeller) { %>
                                    <div class="action-group">
                                        <form action="/seller/orders/<%= order._id %>/cancel" method="POST" class="cancel-delivery-form form-submit-spinner" onsubmit="return confirm('SELLER ACTION: Are you sure you want to cancel your items in order <%= order._id %>? This action cannot be undone.');">
                                            <label for="reason-<%= order._id %>" class="action-group-title">Cancel Your Items:</label>
                                            <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm d-block mb-1">
                                                <option value="" disabled selected>Select Seller Reason...</option>
                                                <% if (typeof sellerCancellationReasons !== 'undefined' && sellerCancellationReasons.length > 0) { %>
                                                    <% sellerCancellationReasons.forEach(reason => { %>
                                                        <option value="<%= reason %>"><%= reason %></option>
                                                    <% }) %>
                                                <% } else { %>
                                                    <option value="Other Reason (Seller)" selected>Other Reason (Seller)</option> <%# Fallback %>
                                                <% } %>
                                            </select>
                                            <button type="submit" class="btn btn-danger btn-sm w-100 w-md-auto"><i class="fas fa-ban"></i> Cancel Items</button>
                                        </form>
                                    </div>
                                <% } %>
                                <%# --- End: Seller Order Cancellation Form --- %>

                                <%# Fallback for no actions %>
                                <% if (!order.canBeDirectlyDeliveredBySeller && !order.canBeCancelledBySeller) { %>
                                     <small class="text-muted no-actions-text">
                                         <% if (order.status === 'Delivered') { %>Completed<% } else if (order.status === 'Cancelled') { %>Cancelled<% } else { %>No actions available<% } %>
                                    </small>
                                <% } %>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else if (!message) { %>
        <p class="alert alert-info">No orders containing your products found.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

seller/manage-products.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1>Manage Your Products</h1>
    <a href="/seller/products/upload" class="btn btn-primary mb-3"><i class="fas fa-plus"></i> Upload New Product</a>

   <% if (products.length > 0) { %>
       <div class="table-container card">
           <table class="data-table">
               <thead>
                   <tr>
                       <th>Image</th>
                       <th>Name</th>
                       <th>Price</th>
                       <th>Stock</th>
                       <th>Status</th> <%# NEW %>
                       <th>Reason</th> <%# NEW %>
                       <th class="actions-cell" style="text-align: right;">Actions</th>
                   </tr>
                </thead>
                <tbody>
                   <% products.forEach(product => { %>
                       <tr class="status-<%= product.reviewStatus %>"> <%# Add status class %>
                           <td data-label="Image"><a href="/products/<%= product._id %>"><img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="table-img"></a></td>
                            <td data-label="Name"><%= product.name %><br><small class="text-muted"><%= product.category %></small></td>
                            <td data-label="Price">â‚¹<%= product.price.toFixed(2) %></td>
                            <td data-label="Stock"><%= product.stock %></td>
                            <td data-label="Status">
                                <span class="status-badge status-<%= product.reviewStatus %> text-capitalize">
                                    <%= product.reviewStatus %>
                                </span>
                            </td>
                             <td data-label="Reason">
                                <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %>
                                    <small class="text-danger"><%= product.rejectionReason %></small>
                                <% } else { %>
                                    <span class="text-muted">--</span>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                               <%# Edit button always available, triggers re-review %>
                               <a href="/seller/products/edit/<%= product._id %>" class="btn btn-text btn-sm" title="Edit Product"><i class="fas fa-edit"></i> Edit</a>

                               <form action="/seller/products/remove/<%= product._id %>" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to permanently remove this product: <%= product.name %>?');">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove Product"><i class="fas fa-trash"></i> Remove</button>
                               </form>
                           </td>
                        </tr>
                    <% }) %>
               </tbody>
            </table>
       </div>
   <% } else { %>
        <p class="text-muted mt-3">You haven't uploaded any products yet. <a href="/seller/products/upload">Upload your first product!</a></p>
   <% } %>
</div>

<%- include('../partials/footer') %>

seller/upload-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1>Upload New Product</h1>
    <p class="text-muted small mb-3">Your product will be submitted for automatic review upon upload.</p>

    <form action="/seller/products/upload" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" value="<%= typeof product !== 'undefined' ? product.name : '' %>" required>
        </div>
        <div class="form-group">
            <label for="category">Category:</label>
            <input type="text" id="category" name="category" value="<%= typeof product !== 'undefined' ? product.category : '' %>" required>
        </div>
        <div class="form-group">
            <label for="price">Price (â‚¹):</label>
            <input type="number" id="price" name="price" step="0.01" min="0" value="<%= typeof product !== 'undefined' ? product.price : '' %>" required>
        </div>
        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" min="0" value="<%= typeof product !== 'undefined' ? product.stock : '' %>" required>
        </div>
        <div class="form-group">
            <label for="imageUrl">Image URL:</label>
            <input type="url" id="imageUrl" name="imageUrl" placeholder="https://example.com/image.jpg" value="<%= typeof product !== 'undefined' ? product.imageUrl : '' %>" required>
        </div>
        <div class="form-group">
            <label for="specifications">Specifications (Optional):</label>
            <textarea id="specifications" name="specifications" rows="5"><%= typeof product !== 'undefined' ? product.specifications : '' %></textarea>
        </div>
        <button type="submit" class="btn btn-primary">Upload & Submit for Review</button>
        <a href="/seller/dashboard" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/user/cart.ejs:
<%# views/user/cart.ejs %>
<%- include('../partials/header', { title: 'Shopping Cart' }) %>

<div class="cart-container">
    <h1>Your Shopping Cart</h1>

    <% if (cart.length > 0) { %>
        <div class="cart-items">
            <% cart.forEach(item => { %>
                <div class="cart-item" data-product-id="<%= item.productId %>">
                    <div class="cart-item-image">
                        <a href="/products/<%= item.productId %>"><img src="<%= item.imageUrl %>" alt="<%= item.name %>"></a>
                    </div>
                    <div class="cart-item-details">
                        <h3 class="cart-item-name"><%= item.name %></h3>
                        <p class="cart-item-price">â‚¹<%= (typeof item.price === 'number' ? item.price : 0).toFixed(2) %></p>
                        <p class="cart-item-stock">Stock: <%= item.stock %></p>
                    </div>
                    <div class="cart-item-quantity">
                        <label for="quantity-<%= item.productId %>" class="visually-hidden">Quantity for <%= item.name %></label> <%# Added visually-hidden label %>
                        <input type="number"
                               id="quantity-<%= item.productId %>"
                               class="quantity-input" <%# Use class for consistency %>
                               name="quantity"
                               value="<%= item.quantity %>"
                               min="0"
                               max="<%= item.stock %>"
                               data-product-id="<%= item.productId %>"
                               data-item-price="<%= item.price %>"
                               aria-label="Quantity for <%= item.name %>">
                        <button class="btn btn-secondary btn-sm btn-update-qty" data-product-id="<%= item.productId %>">Update</button> <%# Spinner handled by AJAX logic %>
                     </div>
                     <div class="cart-item-subtotal">
                         Subtotal: â‚¹<span class="item-subtotal-value"><%= (typeof item.subtotal === 'number' ? item.subtotal : 0).toFixed(2) %></span>
                    </div>
                    <div class="cart-item-remove">
                        <form action="/user/cart/remove/<%= item.productId %>" method="POST" class="form-submit-spinner">
                            <button type="submit" class="btn btn-danger btn-sm">Ã— Remove</button>
                         </form>
                     </div>
                </div>
            <% }) %>
        </div>

         <div class="cart-summary">
             <h2>Cart Total: â‚¹<span id="cart-total-value"><%= (typeof cartTotal === 'number' ? cartTotal : 0).toFixed(2) %></span></h2>
             <%# --- ADDED ID and loading state attributes --- %>
             <a href="/user/checkout"
                id="btn-proceed-checkout" <%# ADDED ID %>
                class="btn btn-success btn-checkout"
                data-loading-text="<i class='fas fa-spinner fa-spin'></i> Proceeding..." <%# ADDED loading text data attribute %>
                >Proceed to Checkout</a>
        </div>

    <% } else { %>
        <%# Updated empty cart message to use alert style %>
        <p class="alert alert-info mt-3">Your cart is empty. <a href="/" class="alert-link">Continue Shopping</a></p>
    <% } %>
</div>

 <%- include('../partials/footer') %>

views/user/checkout.ejs:
<%# views/user/checkout.ejs %>
<%- include('../partials/header', { title: 'Checkout' }) %>

<div class="checkout-container">
    <h1>Checkout</h1>

    <div class="checkout-grid">
        <div class="checkout-address">
            <h2>Shipping Address</h2>
            <% if (userAddress && userAddress.name) { %>
                <div class="saved-address">
                    <p><strong><%= userAddress.name %></strong></p>
                    <p><%= userAddress.phone %></p>
                    <p><%= userAddress.landmarkNearby ? userAddress.landmarkNearby + ', ' : '' %><%= userAddress.cityVillage %></p>
                    <p>Pincode: <%= userAddress.pincode %></p>
                    <button type="button" id="edit-address-btn" class="btn btn-secondary btn-sm">Edit Address</button>
                </div>
             <% } %>

            <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (userAddress && userAddress.name) ? 'hidden' : '' %> form-submit-spinner">
                <h3><%= (userAddress && userAddress.name) ? 'Edit Address' : 'Add Address' %></h3>
                <div class="form-group">
                    <label for="name">Full Name:</label>
                    <input type="text" id="name" name="name" value="<%= userAddress?.name || '' %>" required autocomplete="name">
                </div>
                <div class="form-group">
                    <label for="phone">Phone Number:</label>
                    <input type="tel" <%# Correct semantic type %>
                           id="phone"
                           name="phone"
                           value="<%= userAddress?.phone || '' %>"
                           required
                           pattern="\d{10,15}" <%# Expect 10-15 digits %>
                           minlength="10"  <%# Minimum 10 digits %>
                           maxlength="15" <%# Maximum 15 digits %>
                           title="Enter 10 to 15 digit phone number (numbers only)" <%# Clear hint %>
                           autocomplete="tel"> <%# Standard autocomplete %>
                </div>
                 <div class="form-group">
                    <label for="pincode">Pincode:</label>
                     <input type="text" <%# Use text type, pattern handles format %>
                            id="pincode"
                            name="pincode"
                            value="<%= userAddress?.pincode || '' %>"
                            required
                            pattern="\d{6}" <%# Assuming 6 digit Indian pincode %>
                            maxlength="6"
                            inputmode="numeric"
                            title="Enter 6-digit Pincode"
                            autocomplete="postal-code">
                </div>
                 <div class="form-group">
                    <label for="cityVillage">City / Village:</label>
                     <input type="text" id="cityVillage" name="cityVillage" value="<%= userAddress?.cityVillage || '' %>" required autocomplete="address-level2">
                </div>
                <div class="form-group">
                    <label for="landmarkNearby">Landmark / Nearby (Optional):</label>
                     <input type="text" id="landmarkNearby" name="landmarkNearby" value="<%= userAddress?.landmarkNearby || '' %>">
                </div>
                <button type="submit" class="btn btn-primary">Save Address</button>
                <% if (userAddress && userAddress.name) { %>
                    <button type="button" id="cancel-edit-btn" class="btn btn-secondary">Cancel Edit</button>
                <% } %>
             </form>
        </div>

         <div class="checkout-summary">
             <h2>Order Summary</h2>
             <div class="checkout-items">
                 <% items.forEach(item => { %>
                    <div class="checkout-item">
                         <a href="/products/<%= item.productId %>" class="checkout-item-image">
                            <img src="<%= item.imageUrl %>" alt="<%= item.name %>">
                        </a>
                        <div class="checkout-item-info">
                             <%= item.name %> (Qty: <%= item.quantity %>)
                        </div>
                        <div class="checkout-item-price">â‚¹<%= item.itemTotal.toFixed(2) %></div>
                     </div>
                <% }) %>
            </div>
            <hr>
            <div class="checkout-totals">
                <p>Subtotal: <span>â‚¹<%= subTotal.toFixed(2) %></span></p>
                 <p>Shipping: <span>FREE</span></p>
                <hr>
                 <p><strong>Total: <span>â‚¹<%= totalAmount.toFixed(2) %></span></strong></p>
            </div>

            <div class="checkout-payment">
                <h3>Payment Method</h3>
                 <div class="payment-option selected">
                     <input type="radio" id="cod" name="paymentMethodValue" value="COD" checked disabled>
                     <label for="cod"><i class="fas fa-money-bill-wave"></i> Cash on Delivery (COD)</label>
                 </div>
            </div>

            <form action="/orders/place" method="POST" class="place-order-form form-submit-spinner">
                 <input type="hidden" name="paymentMethod" value="COD">
                 <button type="submit" class="btn btn-success btn-block btn-place-order" <%= (!userAddress || !userAddress.name) ? 'disabled' : '' %>>
                    Place Order
                 </button>
                 <% if (!userAddress || !userAddress.name) { %>
                    <p class="text-danger small">Please add/save your shipping address first.</p>
                 <% } %>
             </form>
         </div>
    </div>
</div>

<%- include('../partials/footer') %>

<%# Checkout specific JS logic was moved to public/js/main.js %>

views/user/my-orders.ejs:
<%# views/user/my-orders.ejs %>
<%- include('../partials/header', { title: 'My Orders' }) %>

<div class="my-orders-container">
    <h1>My Orders</h1>

    <% if (orders.length > 0) { %>
        <div class="order-list">
            <% orders.forEach(order => { %>
                <div class="order-card status-<%= order.status.toLowerCase().replace(/ /g, '-') %> mb-3"> <%# Add mb-3 for spacing %>
                     <div class="order-header">
                         <div><strong>Order ID:</strong><br><%= order._id %></div>
                         <div><strong>Placed on:</strong><br><%= formatDateIST(order.orderDate) %></div>
                         <div><strong>Total:</strong><br>â‚¹<%= order.totalAmount.toFixed(2) %></div>
                         <div><strong>Status:</strong><br><span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span></div>
                     </div>
                    <div class="order-body">
                         <%# Simplified item display (text) %>
                         <p class="mb-1"><strong>Items:</strong></p>
                         <div class="order-items-list mb-2">
                            <% order.products.forEach((item, index) => { %>
                                <small><%= item.name || '[Product Name Missing]' %> (Qty: <%= item.quantity %>) <% if(index < order.products.length - 1) { %> | <% } %></small>
                            <% }) %>
                         </div>

                         <%# --- NEW: Display Product Images --- %>
                         <div class="order-items-images mt-2">
                            <% order.products.forEach(item => { %>
                                <%# Check if product was populated and has necessary info %>
                                <% if (item.productId && item.productId._id && item.imageUrl) { %>
                                    <a href="/products/<%= item.productId._id %>" title="View <%= item.name || 'Product' %>">
                                        <img src="<%= item.imageUrl %>"
                                             alt="<%= item.name || 'Product Image' %>"
                                             class="order-item-thumbnail">
                                    </a>
                                <% } else if (item.productId && item.productId._id) { %>
                                    <%# Fallback if image URL is missing but product exists %>
                                    <a href="/products/<%= item.productId._id %>" class="order-item-thumbnail-placeholder" title="View <%= item.name || 'Product' %>">[No Img]</a>
                                <% } else { %>
                                    <%# Very basic fallback if productId is missing entirely %>
                                    <span class="order-item-thumbnail-placeholder">[Item NA]</span>
                                <% } %>
                            <% }) %>
                         </div>
                         <%# --- End: Display Product Images --- %>

                        <div class="order-details mt-3"> <%# Add margin-top for spacing %>
                             <p class="mb-1"><strong>Shipping To:</strong> <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, Pin: <%= order.shippingAddress.pincode %></p>
                             <% if (order.status === 'Delivered' && order.receivedByDate) { %>
                                <p class="text-success mb-1"><small><strong>Delivered On:</strong> <%= formatDateIST(order.receivedByDate) %></small></p>
                              <% } %>
                              <%# Display cancellation reason if present %>
                              <% if (order.status === 'Cancelled' && order.cancellationReason) { %>
                                <p class="text-danger mb-1"><small><strong>Reason:</strong> <%= order.cancellationReason %></small></p>
                              <% } %>

                              <%# Display Delivery OTP for Customer %>
                              <% if (order.showDeliveryOtp) { %>
                                <div class="delivery-otp-display mt-2 p-2 border rounded bg-light">
                                    <p class="mb-1">
                                        <strong>Delivery OTP:</strong>
                                        <strong class="delivery-otp-code ms-1"><%= order.orderOTP %></strong> <%# Display full OTP %>
                                    </p>
                                    <small class="text-muted d-block">Provide this code to the delivery person (Seller/Admin).</small>
                                    <% if (order.orderOTPExpires) { %>
                                        <small class="text-muted d-block">Expires: <%= formatDateIST(order.orderOTPExpires) %></small>
                                    <% } %>
                                </div>
                              <% } %>
                              <%# End: Display Delivery OTP %>
                         </div>
                    </div>
                     <div class="order-actions text-end p-2 border-top"> <%# Adjusted padding/border %>
                        <% if (order.isCancellable) { %>
                            <form action="/orders/cancel/<%= order._id %>" method="POST" onsubmit="return confirm('Are you sure you want to cancel this order?');" class="form-submit-spinner d-inline-block">
                                <button type="submit" class="btn btn-danger btn-sm">Cancel Order</button>
                             </form>
                         <% } else if (order.status === 'Pending' && !order.showDeliveryOtp && order.cancellationAllowedUntil && new Date(order.cancellationAllowedUntil).getTime() < Date.now()) { %>
                             <small class="text-muted">Cancellation window closed.</small>
                         <% } else if (order.status === 'Pending' && !order.showDeliveryOtp) { %>
                            <small class="text-muted">Processing...</small>
                        <% } else if (order.status === 'Pending' && order.showDeliveryOtp) { %>
                             <small class="text-info">Awaiting delivery confirmation...</small>
                         <% } else if (order.status === 'Delivered') { %>
                              <small class="text-success">Order Completed.</small>
                         <% } else if (order.status === 'Cancelled') { %>
                              <small class="text-danger">Order Cancelled.</small>
                         <% } %>
                     </div>
                </div>
            <% }) %>
        </div>
    <% } else { %>
        <p>You haven't placed any orders yet. <a href="/">Start Shopping!</a></p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/user/profile.ejs:
<%# views/user/profile.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="profile-container">
    <%# --- Combine Welcome and Name Edit --- %>
    <div class="profile-header mb-4 d-flex align-items-center justify-content-center flex-wrap"> <%# Flex container %>
        <h1 class="mb-0 me-3">My Profile</h1> <%# Removed bottom margin from h1 %>
        <div class="d-flex align-items-center">
             <%# Display current name - initially visible %>
             <span id="saved-name-display" class="fs-5 me-2">Welcome, <strong id="display-user-name"><%= user.name %></strong></span>
             <%# Edit button (icon) - initially visible %>
            <button type="button" id="edit-name-btn" class="btn btn-text btn-sm" title="Edit Name"><i class="fas fa-edit"></i></button>

             <%# Name edit form - initially hidden %>
             <form action="/user/profile/update-name" method="POST" id="name-form" class="hidden inline-form align-items-center ms-2 form-submit-spinner">
                 <label for="name-input" class="visually-hidden">New Name:</label>
                 <input type="text" id="name-input" name="name" class="form-control form-control-sm me-2" value="<%= user.name %>" required minlength="2" placeholder="Enter new name">
                 <button type="submit" class="btn btn-primary btn-sm me-1">Save</button>
                 <button type="button" id="cancel-edit-name-btn" class="btn btn-secondary btn-sm">Cancel</button>
             </form>
         </div>
    </div>
    <p class="text-muted text-center small mb-3">Email: <%= user.email %></p> <%# Moved email below %>

    <%# --- NEW: My Orders Section --- %>
    <div class="profile-section orders-section mb-4">
        <h2>My Orders</h2>
        <div class="d-flex flex-wrap gap-2">
            <a href="/orders/my-orders" class="btn btn-secondary"> <%# Using btn-secondary style %>
                <i class="fas fa-box"></i> View My Orders
            </a>
        </div>
    </div>
    <%# --- End: My Orders Section --- %>

    <%# --- Conditional Dashboards Section --- %>
    <div class="profile-section dashboards-section mb-4">
        <h2>Dashboards</h2>
        <div class="d-flex flex-wrap gap-2"> <%# Use flex for button layout %>
            <% if (user.role === 'admin') { %>
                <a href="/admin/dashboard" class="btn btn-info"><i class="fas fa-user-shield"></i> Admin Dashboard</a>
            <% } %>
             <% if (user.role === 'seller') { %>
                 <a href="/seller/dashboard" class="btn btn-success"><i class="fas fa-store"></i> Seller Dashboard</a>
             <% } %>
             <% if (user.role === 'user') { %> <%# Explicitly show user status %>
                 <p class="mb-0 align-self-center">Standard User Account</p>
            <% } %>
         </div>
    </div>

    <%# --- Address Management Section --- %>
    <div class="profile-section address-section mb-4">
        <h2>My Address</h2>
        <%# Display Saved Address %>
        <div id="saved-address-display" class="<%= (!user.address || !user.address.name) ? 'hidden' : '' %>">
            <% if (user.address && user.address.name) { %>
                <p class="mb-1"><strong><%= user.address.name %></strong></p>
                <p class="mb-1"><%= user.address.phone %></p>
                <p class="mb-1"><%= user.address.landmarkNearby ? user.address.landmarkNearby + ', ' : '' %><%= user.address.cityVillage %>, Pincode: <%= user.address.pincode %></p>
                <button type="button" id="edit-address-btn" class="btn btn-outline-secondary btn-sm mt-2">Edit Address</button>
            <% } else { %>
                <p class="text-muted">No address saved yet.</p>
                 <button type="button" id="add-address-btn" class="btn btn-outline-primary btn-sm mt-2">Add Address</button>
            <% } %>
        </div>

        <%# Address Form (Initially hidden if address exists) %>
        <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (user.address && user.address.name) ? 'hidden' : '' %> form-submit-spinner mt-3">
             <h3 class="h5"><%= (user.address && user.address.name) ? 'Edit Address' : 'Add Address' %></h3>
             <input type="hidden" name="source" value="profile">
             <div class="form-group">
                 <label for="name" class="form-label small">Full Name:</label>
                 <input type="text" id="name" name="name" class="form-control" value="<%= user.address?.name || '' %>" required autocomplete="name">
             </div>
             <div class="form-group">
                 <label for="phone" class="form-label small">Phone Number:</label>
                 <input type="tel" id="phone" name="phone" class="form-control" value="<%= user.address?.phone || '' %>" required pattern="\d{10,15}" minlength="10" maxlength="15" title="Enter 10 to 15 digit phone number" autocomplete="tel">
             </div>
             <div class="form-group">
                 <label for="pincode" class="form-label small">Pincode:</label>
                 <input type="text" id="pincode" name="pincode" class="form-control" value="<%= user.address?.pincode || '' %>" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit Pincode" autocomplete="postal-code">
             </div>
             <div class="form-group">
                 <label for="cityVillage" class="form-label small">City / Village:</label>
                 <input type="text" id="cityVillage" name="cityVillage" class="form-control" value="<%= user.address?.cityVillage || '' %>" required autocomplete="address-level2">
             </div>
             <div class="form-group">
                 <label for="landmarkNearby" class="form-label small">Landmark / Nearby (Optional):</label>
                 <input type="text" id="landmarkNearby" name="landmarkNearby" class="form-control" value="<%= user.address?.landmarkNearby || '' %>">
             </div>
             <button type="submit" class="btn btn-primary me-2">Save Address</button>
             <button type="button" id="cancel-edit-btn" class="btn btn-secondary <%= (!user.address || !user.address.name) ? 'hidden' : '' %>">Cancel Edit</button>
        </form>
    </div>

    <%# --- Logout Section --- %>
    <div class="profile-section logout-section mt-4 pt-3 border-top">
        <h2>Account Actions</h2>
        <form action="/auth/logout" method="POST" class="form-submit-spinner">
            <button type="submit" class="btn btn-danger"><i class="fas fa-sign-out-alt"></i> Logout</button>
        </form>
    </div>

</div>

<%# --- Consolidated Script for Profile Page --- %>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Address Edit Logic (Existing) ---
    const editAddressBtn = document.getElementById('edit-address-btn');
    const addAddressBtn = document.getElementById('add-address-btn');
    const cancelAddressBtn = document.getElementById('cancel-edit-btn');
    const addressForm = document.getElementById('address-form');
    const savedAddressDiv = document.getElementById('saved-address-display');

    const showAddressForm = () => {
        if (!addressForm || !savedAddressDiv) return;
        addressForm.classList.remove('hidden');
        addressForm.querySelector('h3').textContent = savedAddressDiv.querySelector('strong') ? 'Edit Address' : 'Add Address';
        savedAddressDiv.classList.add('hidden');
        if (cancelAddressBtn) cancelAddressBtn.classList.remove('hidden');
    };

    const hideAddressForm = () => {
        if (!addressForm || !savedAddressDiv) return;
        addressForm.classList.add('hidden');
        if (savedAddressDiv.querySelector('strong')) { // Check if address actually exists
            savedAddressDiv.classList.remove('hidden');
        } else {
            savedAddressDiv.classList.remove('hidden'); // Still show "No address" message
            if (cancelAddressBtn) cancelAddressBtn.classList.add('hidden');
        }
    };

    if (editAddressBtn) {
        editAddressBtn.addEventListener('click', showAddressForm);
    }
    if (addAddressBtn) {
         addAddressBtn.addEventListener('click', () => {
            if(addressForm) addressForm.reset();
            showAddressForm();
            if(cancelAddressBtn) cancelAddressBtn.classList.add('hidden');
         });
    }
    if (cancelAddressBtn) {
        cancelAddressBtn.addEventListener('click', hideAddressForm);
    }

    // Initial Address State
    if (savedAddressDiv && addressForm && addAddressBtn) {
        if (!savedAddressDiv.querySelector('strong') && addressForm.classList.contains('hidden')) {
           addAddressBtn.classList.remove('hidden');
        } else {
             addAddressBtn.classList.add('hidden');
        }
    }


    // --- Name Edit Logic (New) ---
    const editNameBtn = document.getElementById('edit-name-btn');
    const cancelNameBtn = document.getElementById('cancel-edit-name-btn');
    const nameForm = document.getElementById('name-form');
    const savedNameDisplaySpan = document.getElementById('saved-name-display'); // The span containing the welcome text
    const nameInput = document.getElementById('name-input'); // The input field
    const displayUserNameStrong = document.getElementById('display-user-name'); // The strong tag holding the name

    const showNameForm = () => {
        if (!nameForm || !savedNameDisplaySpan || !editNameBtn) return;
        nameForm.classList.remove('hidden');        // Show the form
        savedNameDisplaySpan.classList.add('hidden'); // Hide the "Welcome, Name" span
        editNameBtn.classList.add('hidden');        // Hide the edit icon button
        nameInput.focus();                          // Focus the input field
    };

    const hideNameForm = () => {
        if (!nameForm || !savedNameDisplaySpan || !editNameBtn || !displayUserNameStrong) return;
        nameForm.classList.add('hidden');            // Hide the form
        savedNameDisplaySpan.classList.remove('hidden'); // Show the "Welcome, Name" span
        editNameBtn.classList.remove('hidden');      // Show the edit icon button again
        // Reset input value to the currently displayed name when cancelling
        nameInput.value = displayUserNameStrong.textContent;
    };

    if (editNameBtn) {
        editNameBtn.addEventListener('click', showNameForm);
    }

    if (cancelNameBtn) {
        cancelNameBtn.addEventListener('click', hideNameForm);
    }
});
</script>

<%- include('../partials/footer') %>

views/error.ejs:
<%- include('./partials/header', { title: 'Error' }) %>

<div class="error-container container">
    <h1>Error <%= typeof statusCode !== 'undefined' ? statusCode : '' %></h1>
    <p class="lead text-danger"><%= message %></p>

    <%# Use NODE_ENV from res.locals now %>
    <% if (NODE_ENV === 'development' && typeof stack !== 'undefined' && stack) { %>
        <details style="white-space: pre-wrap; margin-top: 20px; background: #f1f1f1; padding: 10px; border-radius: 5px; font-size: 0.8em;">
            <summary>Stack Trace (Development Mode)</summary>
            <code><%= stack %></code>
        </details>
    <% } %>

    <p style="margin-top: 20px;"><a href="/" class="btn btn-primary">Go back to Home</a></p>
</div>

<%- include('./partials/footer') %>

.env:
NODE_ENV=development
PORT=3000
MONGO_URI=mongodb+srv://ecommerce:ecommerce@cluster0.jcfuk.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
SESSION_SECRET=e6142a6d230d0445c9b050af41bfd1e53ece6270797e546fbdaa97af20f3b77e # Use a strong, random secret
SESSION_MAX_AGE=86400000 # 1 day in milliseconds

# Email Configuration
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USER=ayyappanallamothu4@gmail.com
MAIL_PASS=yxor nmot lxmq skyc # Use an App Password if using Gmail 2FA
MAIL_FROM='"Surya Ecom" <ayyappanallamothu4@gmail.com>' # Ensure format is correct

# --- NEW: Add your Gemini API Key ---
GEMINI_API_KEY=AIzaSyCX31vkQ9Qf7t-ytSeDZUGR8hK4XZUHQT0

server.js:
// server.js
require('dotenv').config();
const express = require('express');
const path = require('path');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const flash = require('connect-flash');
const methodOverride = require('method-override');

const connectDB = require('./config/database');
const mainRouter = require('./routes/index');
const { notFound, errorHandler } = require('./middleware/errorMiddleware');


connectDB();

const app = express();


app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));


app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));
app.use(methodOverride('_method'));


app.use(
  session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({
        mongoUrl: process.env.MONGO_URI,
        collectionName: 'sessions'
    }),
    cookie: {
        maxAge: parseInt(process.env.SESSION_MAX_AGE || '86400000', 10),
        httpOnly: true
        // secure: process.env.NODE_ENV === 'production',
        // sameSite: 'lax'
    }
  })
);


app.use(flash());


app.use((req, res, next) => {

  res.locals.success_msg = req.flash('success_msg');
  res.locals.error_msg = req.flash('error_msg');
  res.locals.error = req.flash('error');


  res.locals.currentUser = req.session.user || null;


  res.locals.currentUrl = req.originalUrl;
  res.locals.fullUrl = `${req.protocol}://${req.get('host')}${req.originalUrl}`;


  res.locals.cartItemCount = req.session.user?.cart?.reduce((count, item) => count + (item.quantity || 0), 0) || 0;


  let userInitials = '??';
  if (req.session.user && req.session.user.name) {
    try {
      const nameParts = req.session.user.name.trim().split(' ');
      if (nameParts.length > 1 && nameParts[0] && nameParts[1]) {
          userInitials = (nameParts[0][0] + nameParts[nameParts.length - 1][0]).toUpperCase();
      } else if (nameParts.length === 1 && nameParts[0].length >= 2) {
          userInitials = nameParts[0].substring(0, 2).toUpperCase();
      } else if (nameParts.length === 1 && nameParts[0].length === 1) {
           userInitials = (nameParts[0][0] + nameParts[0][0]).toUpperCase();
      }
       else if (req.session.user.email) {
            const emailPrefix = req.session.user.email.split('@')[0];
            if (emailPrefix.length >= 2) {
                userInitials = emailPrefix.substring(0, 2).toUpperCase();
            } else if (emailPrefix.length === 1) {
                userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
            }
       }
    } catch (e) {
      console.error("Error generating initials:", e);
       if (req.session.user.email) {
            const emailPrefix = req.session.user.email.split('@')[0];
            if (emailPrefix.length >= 2) {
                userInitials = emailPrefix.substring(0, 2).toUpperCase();
            } else if (emailPrefix.length === 1) {
                userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
            }
       }
    }
  } else if (req.session.user && req.session.user.email) {
        const emailPrefix = req.session.user.email.split('@')[0];
        if (emailPrefix.length >= 2) {
            userInitials = emailPrefix.substring(0, 2).toUpperCase();
        } else if (emailPrefix.length === 1) {
            userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
        }
  }
  res.locals.userInitials = userInitials;


  res.locals.formatDateIST = (dateInput) => {
      if (!dateInput) return 'N/A';
      try {
          const date = new Date(dateInput);
          if (isNaN(date.getTime())) {
              console.warn(`formatDateIST received invalid dateInput: ${dateInput}`);
              return 'Invalid Date';
          }

          const options = {
              timeZone: 'Asia/Kolkata',
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              // second: '2-digit',
              hour12: true
          };
          return date.toLocaleString('en-IN', options);
      } catch (error) {
          console.error("Error formatting date to IST:", error, "Input:", dateInput);
          return 'Date Error';
      }
  };


  res.locals.defaultSiteName = 'miniapp';


  res.locals.NODE_ENV = process.env.NODE_ENV;

  next();
});


app.use('/', mainRouter);


app.use(notFound);
app.use(errorHandler);


const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});