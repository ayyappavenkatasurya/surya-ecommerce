config/database.js:
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error connecting to MongoDB: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;

config/mailer.js:
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
  host: process.env.MAIL_HOST,
  port: parseInt(process.env.MAIL_PORT, 10),
  secure: parseInt(process.env.MAIL_PORT, 10) === 465,
  auth: {
    user: process.env.MAIL_USER,
    pass: process.env.MAIL_PASS,
  },
});

transporter.verify((error, success) => {
  if (error) {
    console.error('Error with Nodemailer transporter configuration:', error);
  } else {
    console.log('Nodemailer transporter is ready to send emails');
  }
});

const sendEmail = async (to, subject, text, html) => {
  try {
    await transporter.sendMail({
      from: process.env.MAIL_FROM,
      to: to,
      subject: subject,
      text: text,
      html: html,
    });
    console.log(`Email sent successfully to ${to}`);
    return true;
  } catch (error) {
    console.error(`Error sending email to ${to}:`, error);
    return false;
  }
};

module.exports = { sendEmail };

controllers/adminController.js:
// controllers/adminController.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const { sendEmail } = require('../config/mailer');
const {
    generateAndSendDirectDeliveryOTPByAdmin,
    confirmDirectDeliveryByAdmin,
    // Note: generateAndSendDeliveryOTP, verifyDeliveryOTP are typically called from deliveryController, not directly here
} = require('./orderController'); // Assuming these are correctly imported

// --- Keep cancellationReasons array ---
const cancellationReasons = [
    "📞 Unable to contact the customer",
    "🕒 Delay in shipping/delivery timeframe exceeded",
    "❗ Out of stock/unavailable item",
    "🗺️ Address incorrect/incomplete",
    "🚫 Customer requested cancellation",
    "🚚 Logistics issue/Vehicle breakdown",
    "❓ Other (Admin/Delivery)",
];

// =======================
// Dashboard & Page Getters
// =======================
exports.getAdminDashboard = (req, res) => {
    res.render('admin/dashboard', { title: 'Admin Dashboard' });
};

exports.getUploadProductPage = (req, res) => {
    res.render('admin/upload-product', { title: 'Upload New Product' });
};

exports.getManageProductsPage = async (req, res, next) => {
    try {
        const products = await Product.find({}).sort({ createdAt: -1 });
        res.render('admin/manage-products', {
            title: 'Manage Products',
            products: products
        });
    } catch (error) {
        next(error);
    }
};

exports.getEditProductPage = async (req, res, next) => {
     try {
        const product = await Product.findById(req.params.id);
         if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.redirect('/admin/manage-products');
        }
        res.render('admin/edit-product', {
            title: `Edit Product: ${product.name}`,
            product: product
        });
    } catch (error) {
         if (error.name === 'CastError') {
           req.flash('error_msg', 'Invalid product ID format.');
            return res.redirect('/admin/manage-products');
       }
        next(error);
     }
 };

// --- UPDATED getManageOrdersPage function (includes logic for bulk assign checks) ---
exports.getManageOrdersPage = async (req, res, next) => {
    try {
        const orders = await Order.find({})
                                   .sort({ orderDate: -1 })
                                   .populate('products.productId', 'name imageUrl _id price') // Ensure necessary fields are populated
                                   .lean();

        orders.forEach(order => {
            order.formattedOrderDate = new Date(order.orderDate).toLocaleString();
            order.formattedReceivedDate = order.receivedByDate ? new Date(order.receivedByDate).toLocaleString() : 'N/A';
            // Determine capabilities for each order
            order.canBeCancelledByAdmin = ['Pending', 'Out for Delivery'].includes(order.status);
            order.canBeAssignedByAdmin = order.status === 'Pending'; // Check for individual and bulk assignment eligibility
            order.canBeDirectlyDeliveredByAdmin = order.status === 'Pending';
            order.canBeUnassignedByAdmin = order.status === 'Out for Delivery';

            // Pre-calculate item details string for display (optional improvement)
            if (order.products && order.products.length > 0) {
                order.itemsSummary = order.products.map(p =>
                    `${p.name || '[Product Name Missing]'} (Qty: ${p.quantity}) @ ₹${(p.priceAtOrder || 0).toFixed(2)}`
                ).join('<br>');
            } else {
                order.itemsSummary = 'No items found';
            }
        });

         const deliveryAdmins = await User.find({ role: 'delivery_admin' })
                                          .select('email _id address.phone name') // Added name
                                          .lean();

        res.render('admin/manage-orders', {
            title: 'Manage Orders',
            orders: orders,
            deliveryAdmins: deliveryAdmins,
            cancellationReasons: cancellationReasons
        });
    } catch (error) {
        next(error);
    }
};
// --- END UPDATED getManageOrdersPage function ---


exports.getManageUsersPage = async (req, res, next) => {
    try {
        // Exclude the current admin from the list
        const users = await User.find({ _id: { $ne: req.session.user._id } })
                                  .select('name email role createdAt isVerified address.phone') // Select necessary fields including phone
                                  .sort({ createdAt: -1 });
        res.render('admin/manage-users', {
            title: 'Manage Registered Users',
            users: users
        });
    } catch (error) {
        next(error);
    }
};

exports.getManageAssignedOrdersPage = async (req, res, next) => {
    try {
         const deliveryAdmins = await User.find({ role: 'delivery_admin' })
                                         .select('email _id name address.phone') // Select phone
                                         .lean();

        const adminStatsPromises = deliveryAdmins.map(async (admin) => {
            const totalAssigned = await Order.countDocuments({ assignedTo: admin._id });
            // Pending for delivery admin means 'Out for Delivery' status assigned to them
            const pendingCount = await Order.countDocuments({ assignedTo: admin._id, status: 'Out for Delivery' });
            const deliveredCount = await Order.countDocuments({ assignedTo: admin._id, status: 'Delivered' });

            // Safely access phone number
            const phone = admin.address?.phone || null;

            return { ...admin, phone, totalAssigned, pendingCount, deliveredCount };
        });

        const deliveryAdminStats = await Promise.all(adminStatsPromises);

        res.render('admin/manage-assigned-orders', {
             title: 'Manage Assigned Orders & Delivery Admins', // Updated title
            deliveryAdmins: deliveryAdminStats
         });

    } catch (error) {
        next(error);
    }
};


exports.getAssignedOrdersDetailForAdmin = async(req, res, next) => {
   const deliveryAdminId = req.params.deliveryAdminId;
    const type = req.params.type; // 'total', 'pending', 'delivered'

   try {
        const deliveryAdmin = await User.findById(deliveryAdminId).select('email name').lean(); // Select needed fields
       if(!deliveryAdmin || deliveryAdmin.role !== 'delivery_admin'){
           req.flash('error_msg', 'Delivery Admin not found.');
           return res.redirect('/admin/manage-assigned-orders');
       }

       let query = { assignedTo: deliveryAdminId };
       let pageTitle = `Orders Assigned to ${deliveryAdmin.email}`;

       if (type === 'pending') {
          query.status = 'Out for Delivery'; // Pending for delivery admin means 'Out for Delivery'
          pageTitle = `Active Deliveries for ${deliveryAdmin.email}`;
       } else if (type === 'delivered') {
           query.status = 'Delivered';
          pageTitle = `Delivered by ${deliveryAdmin.email}`;
      } // 'total' uses the base query

      const orders = await Order.find(query)
                                .sort({ orderDate: -1 })
                                .populate('products.productId', 'name imageUrl') // Populate for image/details
                                .lean();

      orders.forEach(order => {
           order.formattedOrderDate = new Date(order.orderDate).toLocaleString();
           order.formattedReceivedDate = order.receivedByDate ? new Date(order.receivedByDate).toLocaleString() : 'N/A';
            // Add primary image URL
           order.primaryImageUrl = order.products?.[0]?.imageUrl;
      });

       res.render('admin/assigned-orders-detail', {
           title: pageTitle,
           orders: orders,
           deliveryAdminEmail: deliveryAdmin.email // Pass email for display
       });

   } catch (error) {
      if (error.name === 'CastError') {
           req.flash('error_msg', 'Invalid delivery admin ID.');
           return res.redirect('/admin/manage-assigned-orders');
      }
       next(error);
  }
}


// =======================
// Product Actions
// =======================
exports.uploadProduct = async (req, res, next) => {
    const { name, category, price, stock, imageUrl, specifications } = req.body;
    // Assuming sellerEmail comes from the logged-in admin session
    const sellerEmail = req.session.user.email;

    // Basic Validation
    if (!name || !category || !price || !stock || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields (Name, Category, Price, Stock, Image URL).');
        return res.redirect('/admin/upload-product');
    }
     // Number validation
     if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
        req.flash('error_msg', 'Price and Stock must be non-negative numbers.');
        return res.redirect('/admin/upload-product');
     }

    try {
        const newProduct = new Product({
            name: name.trim(),
            category: category.trim(),
            price: Number(price),
            stock: Number(stock),
            imageUrl: imageUrl.trim(),
            specifications: specifications ? specifications.trim() : '',
            sellerEmail // Assign seller email
        });

        await newProduct.save();
        req.flash('success_msg', `Product "${newProduct.name}" uploaded successfully.`);
        res.redirect('/admin/manage-products'); // Redirect to manage products page

    } catch (error) {
        // Handle validation errors from Mongoose Schema
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', errors.join(' '));
           return res.redirect('/admin/upload-product');
       }
        // Handle other errors (e.g., database connection issues)
        next(error); // Pass to the global error handler
    }
};

 exports.updateProduct = async (req, res, next) => {
    const productId = req.params.id;
    const { name, category, price, stock, imageUrl, specifications } = req.body;

    // Basic Validation
     if (!name || !category || !price || !stock || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields.');
        // Redirect back to the edit page for this specific product
        return res.redirect(`/admin/manage-products/edit/${productId}`);
    }
    // Number validation
     if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
         req.flash('error_msg', 'Price and Stock must be non-negative numbers.');
        return res.redirect(`/admin/manage-products/edit/${productId}`);
    }

    try {
        const product = await Product.findById(productId);
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            // Use 404 status for resource not found
            return res.status(404).redirect('/admin/manage-products');
         }

         // Update product fields
         product.name = name.trim();
         product.category = category.trim();
         product.price = Number(price);
        product.stock = Number(stock);
         product.imageUrl = imageUrl.trim();
         product.specifications = specifications ? specifications.trim() : '';
         // sellerEmail typically doesn't change on update, but could be added if needed

         await product.save(); // Trigger validation and save
         req.flash('success_msg', `Product "${product.name}" updated successfully.`);
         res.redirect('/admin/manage-products'); // Redirect to manage products page

    } catch (error) {
         // Handle Mongoose validation errors
         if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
             req.flash('error_msg', errors.join(' '));
             return res.redirect(`/admin/manage-products/edit/${productId}`);
         }
         // Handle invalid ID format errors (CastError)
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid product ID format.');
             // Redirect to manage products as the ID is likely wrong
             return res.redirect('/admin/manage-products');
         }
        // Pass other errors to the global error handler
        next(error);
     }
 };

exports.removeProduct = async (req, res, next) => {
    const productId = req.params.id;

    try {
         // Use findByIdAndDelete for atomicity
         const product = await Product.findByIdAndDelete(productId);
        if (!product) {
             // Product already deleted or never existed
             req.flash('error_msg', 'Product not found.');
            return res.redirect('/admin/manage-products');
         }
         // Success message using the deleted product's name
         req.flash('success_msg', `Product "${product.name}" removed successfully.`);
         res.redirect('/admin/manage-products');

    } catch (error) {
        // Handle invalid ID format errors (CastError)
        if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid product ID format.');
             return res.redirect('/admin/manage-products');
         }
        // Pass other errors to the global error handler
        next(error);
    }
};

// =======================
// Order Actions
// =======================

exports.sendDirectDeliveryOtpByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    try {
        const result = await generateAndSendDirectDeliveryOTPByAdmin(orderId);
        req.flash('success_msg', result.message + ' Ask customer for OTP to confirm delivery.');
    } catch (error) {
        req.flash('error_msg', `Failed to send direct delivery OTP: ${error.message}`);
    }
    res.redirect('/admin/manage-orders');
};

exports.confirmDirectDeliveryByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { otp } = req.body;
    const adminUserId = req.session.user._id;

    // Basic OTP validation
    if (!otp || !/^\d{6}$/.test(otp)) {
        req.flash('error_msg', 'Please enter the 6-digit OTP received by the customer.');
        return res.redirect('/admin/manage-orders');
    }

    try {
        // Delegate OTP verification and order update logic
        const { order } = await confirmDirectDeliveryByAdmin(orderId, adminUserId, otp);
        req.flash('success_msg', `Order ${orderId} confirmed delivered successfully (Directly by Admin).`);
    } catch (error) {
        req.flash('error_msg', `Direct delivery confirmation failed: ${error.message}`);
    }
    res.redirect('/admin/manage-orders');
};


exports.assignOrder = async (req, res, next) => {
     const { orderId } = req.params;
     const { deliveryAdminId } = req.body;

     // Basic validation
     if (!deliveryAdminId) {
         req.flash('error_msg', 'Please select a Delivery Admin to assign the order.');
         return res.redirect('/admin/manage-orders');
     }

    try {
         const order = await Order.findById(orderId);
         if (!order) {
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/admin/manage-orders');
         }
        // Check if order is assignable
        if (order.status !== 'Pending') {
             req.flash('error_msg', `Order cannot be assigned in its current status ('${order.status}'). It must be 'Pending'.`);
            return res.redirect('/admin/manage-orders');
         }
        // Find the selected delivery admin
        const deliveryAdmin = await User.findOne({ _id: deliveryAdminId, role: 'delivery_admin' }).select('email name address.phone'); // Select name & phone
         if (!deliveryAdmin) {
            req.flash('error_msg', 'Selected Delivery Admin not found or is not a valid delivery admin.');
            return res.status(400).redirect('/admin/manage-orders');
        }

        // Update order status and assignment
        order.assignedTo = deliveryAdmin._id;
        // Store email and phone (if exists) for display
        order.assignedAdminEmail = deliveryAdmin.address?.phone
            ? `${deliveryAdmin.email} (${deliveryAdmin.address.phone})`
            : deliveryAdmin.email;
        order.status = 'Out for Delivery';

         await order.save(); // Save the changes

         // --- Notifications (Best Effort) ---
         // Notify Delivery Admin
         try{
            const subjectAdmin = `New Order Assigned: ${order._id}`;
             const htmlAdmin = `<p>You have been assigned order ${order._id} for delivery.</p><p>Customer: ${order.shippingAddress.name}, ${order.shippingAddress.cityVillage}</p><p>Please check your Delivery Dashboard for details.</p>`;
            await sendEmail(deliveryAdmin.email, subjectAdmin, `New order ${order._id} assigned for delivery.`, htmlAdmin);
         } catch(emailError) {
             // Log failure, but don't block the process
             console.error(`Failed sending assignment email to delivery admin ${deliveryAdmin.email} for order ${order._id}:`, emailError);
         }
         // Notify Customer
        try{
            const subjectCust = `Your Order is Out for Delivery!`;
            // Include assigned person's name or email/phone if name is unavailable
            const assignedPersonInfo = deliveryAdmin.name || order.assignedAdminEmail;
            const htmlCust = `<p>Your order (${order._id}) is now out for delivery with ${assignedPersonInfo}.</p><p>You can track its progress in the 'My Orders' section of your account.</p>`;
            await sendEmail(order.userEmail, subjectCust, `Your order ${order._id} is out for delivery.`, htmlCust);
         } catch(emailError) {
             console.error(`Failed sending out-for-delivery email to customer for order ${order._id}:`, emailError);
         }
         // --- End Notifications ---

         req.flash('success_msg', `Order ${orderId} assigned to ${deliveryAdmin.email} and status updated to 'Out for Delivery'.`);
         res.redirect('/admin/manage-orders');

    } catch (error) {
        // Handle CastError for invalid IDs
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid Order ID or Delivery Admin ID format.');
            return res.redirect('/admin/manage-orders');
        }
        // Log unexpected errors
         console.error(`Error assigning order ${orderId} to ${deliveryAdminId}:`, error);
        req.flash('error_msg', 'An unexpected error occurred while assigning the order.');
        // Pass to generic error handler only if truly unexpected
        next(error);
    }
 };


// --- NEW: Bulk Assign Orders by Admin ---
exports.bulkAssignOrders = async (req, res, next) => {
    let { orderIds, deliveryAdminId } = req.body; // Use let as orderIds might be reassigned

    // Ensure orderIds is always an array, even if only one checkbox is submitted
    if (orderIds && !Array.isArray(orderIds)) {
        orderIds = [orderIds];
    }

    // 1. Initial Validation
    if (!orderIds || orderIds.length === 0) {
        req.flash('error_msg', 'No orders selected for bulk assignment.');
        return res.redirect('/admin/manage-orders');
    }
    if (!deliveryAdminId) {
        req.flash('error_msg', 'Please select a Delivery Admin to assign the orders to.');
        return res.redirect('/admin/manage-orders');
    }

    let successCount = 0;
    let failCount = 0;
    const failures = []; // To store { orderId, reason }

    try {
        // 2. Validate Delivery Admin
        const deliveryAdmin = await User.findOne({ _id: deliveryAdminId, role: 'delivery_admin' })
                                        .select('email name address.phone'); // Select name & phone
        if (!deliveryAdmin) {
            req.flash('error_msg', 'Selected Delivery Admin not found or is not valid.');
            return res.redirect('/admin/manage-orders');
        }
        const assignedAdminEmailString = deliveryAdmin.address?.phone
            ? `${deliveryAdmin.email} (${deliveryAdmin.address.phone})`
            : deliveryAdmin.email;

        // 3. Process Orders Iteratively (Best Effort)
        // Using Promise.allSettled allows all assignments to attempt even if some fail
        const assignmentPromises = orderIds.map(async (orderId) => {
            try {
                const order = await Order.findById(orderId);

                if (!order) {
                    throw new Error('Not found.');
                }
                if (order.status !== 'Pending') {
                    throw new Error(`Invalid status ('${order.status}'). Must be 'Pending'.`);
                }

                // Assign and update status
                order.assignedTo = deliveryAdmin._id;
                order.assignedAdminEmail = assignedAdminEmailString;
                order.status = 'Out for Delivery';
                await order.save();

                // --- Send Notifications (Best effort per order) ---
                const notifyPromises = [];
                // Notify Delivery Admin
                notifyPromises.push(
                    sendEmail(
                        deliveryAdmin.email,
                        `New Order Assigned: ${order._id}`,
                        `New order ${order._id} assigned for delivery.`,
                        `<p>You have been assigned order ${order._id} for delivery.</p><p>Customer: ${order.shippingAddress.name}, ${order.shippingAddress.cityVillage}</p><p>Please check your Delivery Dashboard for details.</p>`
                    ).catch(emailError => console.error(`Failed sending assignment email to delivery admin ${deliveryAdmin.email} for order ${order._id}:`, emailError))
                );
                // Notify Customer
                const assignedPersonInfo = deliveryAdmin.name || assignedAdminEmailString;
                notifyPromises.push(
                    sendEmail(
                        order.userEmail,
                        `Your Order is Out for Delivery!`,
                        `Your order ${order._id} is out for delivery.`,
                        `<p>Your order (${order._id}) is now out for delivery with ${assignedPersonInfo}.</p><p>You can track its progress in the 'My Orders' section of your account.</p>`
                    ).catch(emailError => console.error(`Failed sending out-for-delivery email to customer for order ${order._id}:`, emailError))
                );
                // Wait for notifications to attempt sending, but don't let them block assignment success
                await Promise.allSettled(notifyPromises);

                return { status: 'fulfilled', orderId: orderId }; // Indicate success for this order

            } catch (orderError) {
                // Log the specific error for this order
                console.error(`Failed to assign order ${orderId} in bulk:`, orderError);
                return { status: 'rejected', orderId: orderId, reason: orderError.message || 'Unknown error' }; // Indicate failure
            }
        });

        // Wait for all assignment attempts to complete
        const results = await Promise.allSettled(assignmentPromises);

        // Process results
        results.forEach(result => {
            if (result.status === 'fulfilled') {
                successCount++;
            } else {
                // result.status === 'rejected'
                failCount++;
                // The reason is already captured from the inner catch block if available
                // Store the detailed reason if provided by the promise rejection
                failures.push({ orderId: result.reason?.orderId || 'Unknown', reason: result.reason?.reason || result.reason || 'Processing failed' });
            }
        });


        // 4. Provide Feedback
        if (successCount > 0) {
            req.flash('success_msg', `${successCount} order(s) successfully assigned to ${deliveryAdmin.email}.`);
        }
        if (failCount > 0) {
            const failureDetails = failures.map(f => `Order ${f.orderId}: ${f.reason}`).join('; ');
            req.flash('error_msg', `${failCount} order(s) failed to assign. Details: ${failureDetails}`);
        }
        if (successCount === 0 && failCount === 0 && orderIds.length > 0) {
             // This case might happen if all selected orders were already processed or invalid IDs
             req.flash('error_msg', 'No valid orders were processed during bulk assignment. Please check the order statuses.');
        } else if (successCount === 0 && failCount === 0 && orderIds.length === 0) {
             // This case is handled by initial validation, but included for completeness
            req.flash('error_msg', 'No orders were selected.');
        }

        res.redirect('/admin/manage-orders');

    } catch (error) { // Catch errors like deliveryAdmin validation or major issues before the loop
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid Delivery Admin ID format.');
        } else {
            console.error(`General error during bulk order assignment setup:`, error);
            req.flash('error_msg', 'An unexpected error occurred during bulk assignment initiation.');
        }
        res.redirect('/admin/manage-orders');
    }
};
// --- END: Bulk Assign Orders by Admin ---


// --- Unassign Order by Admin ---
exports.unassignOrderFromAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const adminUserId = req.session.user._id; // For logging purposes

    try {
        const order = await Order.findById(orderId);
        if (!order) {
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/admin/manage-orders');
        }

        // Ensure the order is actually assigned and Out for Delivery
        if (order.status !== 'Out for Delivery') {
            req.flash('error_msg', `Order cannot be unassigned in its current status ('${order.status}'). Must be 'Out for Delivery'.`);
            return res.redirect('/admin/manage-orders');
        }
        if (!order.assignedTo) {
             // This state shouldn't happen if status is 'Out for Delivery', but check defensively
             req.flash('error_msg', 'Order is marked "Out for Delivery" but is not currently assigned to anyone. Please review.');
             return res.redirect('/admin/manage-orders');
        }

        const originalAssignedAdminId = order.assignedTo; // For notification (optional)
        const originalAssignedAdminEmail = order.assignedAdminEmail; // Store email/phone string for notification

        // Reset status and assignment fields
        order.status = 'Pending';
        order.assignedTo = null;
        order.assignedAdminEmail = null;
        // The pre-save hook should automatically clear OTP fields when status changes away from relevant states

        await order.save();

        // Notify the Delivery Admin whose order was unassigned (Best Effort)
        // Extract email part if phone was included
        const deliveryAdminEmailOnly = originalAssignedAdminEmail ? originalAssignedAdminEmail.split(' ')[0] : null;
        if (deliveryAdminEmailOnly) {
             try {
                const subjectAdmin = `Order Unassigned: ${order._id}`;
                 const htmlAdmin = `<p>Order ${order._id}, previously assigned to you, has been unassigned by an administrator and returned to the pending queue.</p><p>Please check with administration if you have questions.</p>`;
                await sendEmail(deliveryAdminEmailOnly, subjectAdmin, `Assigned order ${order._id} was unassigned by admin.`, htmlAdmin);
             } catch(emailError) {
                 // Log error but don't block user feedback
                 console.error(`Failed sending unassignment notice to delivery admin ${deliveryAdminEmailOnly} for order ${order._id}:`, emailError);
             }
        }

        req.flash('success_msg', `Order ${orderId} unassigned successfully and returned to Pending status.`);
        res.redirect('/admin/manage-orders');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid Order ID format.');
        } else {
            console.error(`Error unassigning order ${orderId} by admin ${adminUserId}:`, error);
            req.flash('error_msg', 'Failed to unassign the order due to an internal error.');
        }
        // Redirect back even on error
        res.redirect('/admin/manage-orders');
    }
};
// --- END: Unassign Order by Admin ---

exports.cancelOrderByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const adminUserId = req.session.user._id; // For logging

    // Validate reason
    if (!reason || !cancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid reason for cancellation.');
        return res.redirect('/admin/manage-orders');
    }

    try {
        const order = await Order.findById(orderId).populate('products.productId', 'name'); // Populate name for logging stock restore
        if (!order) {
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/admin/manage-orders');
        }
        // Check if cancellable by admin
        const cancellableStatuses = ['Pending', 'Out for Delivery'];
        if (!cancellableStatuses.includes(order.status)) {
            req.flash('error_msg', `Order cannot be cancelled by admin in its current status ('${order.status}').`);
            return res.redirect('/admin/manage-orders');
        }
        const originalStatus = order.status; // Track status before cancellation
        const originalAssignedAdminEmail = order.assignedAdminEmail; // For potential notification

        // --- Stock Restoration Logic ---
        console.log(`Admin Cancellation: Attempting to restore stock for cancelled order ${orderId} (Original Status: ${originalStatus}).`);
        const productStockRestorePromises = order.products.map(item => {
              // Validate quantity before restoring
              const quantityToRestore = Number(item.quantity);
             if (isNaN(quantityToRestore) || quantityToRestore <= 0) {
                console.error(`Admin Cancel: Invalid quantity ${item.quantity} for product ${item.productId?._id || 'Unknown ID'} in order ${orderId}, skipping stock restore.`);
                return Promise.resolve(); // Skip this item
            }
            // Check if productId exists (it should, but check defensively)
            if (!item.productId) {
                console.error(`Admin Cancel: Missing productId for an item in order ${orderId}, skipping stock restore for this item.`);
                return Promise.resolve(); // Skip this item
            }
             // Update stock and decrement orderCount using $inc
             return Product.updateOne(
                { _id: item.productId._id }, // Use populated ID
                { $inc: { stock: quantityToRestore, orderCount: -1 } }
            ).catch(err => {
               // Log error but continue with cancellation (best effort stock restore)
               console.error(`Admin Cancel: Failed restore stock/orderCount for product ${item.productId._id} (${item.productId.name}) on order ${orderId}: ${err.message}`);
            });
        });
        // Wait for all stock updates to attempt completion
        await Promise.all(productStockRestorePromises);
        console.log(`Admin Cancel: Stock restoration attempted for order ${orderId}. Check logs for details.`);
        // --- End Stock Restoration ---

        // Update order status and reason
        order.status = 'Cancelled';
        order.cancellationReason = reason;
        // Note: The pre-save hook in Order.js should clear assignedTo, OTPs etc. based on 'Cancelled' status
        await order.save();

        // --- Notifications (Best Effort) ---
        // Notify Customer
        try {
            const subjectCust = `Your Order (${order._id}) Has Been Cancelled`;
            const htmlCust = `<p>Your order (${order._id}) has been cancelled by administration.</p><p><strong>Reason:</strong> ${order.cancellationReason}</p><p>Please contact support if you have questions regarding this cancellation.</p>`;
            await sendEmail(order.userEmail, subjectCust, `Your order ${order._id} has been cancelled. Reason: ${order.cancellationReason}`, htmlCust);
        } catch (emailError) {
            console.error(`Failed sending cancellation email to customer for order ${order._id}:`, emailError);
        }
        // Notify Delivery Admin IF it was 'Out for Delivery' when cancelled
        const deliveryAdminEmailOnly = originalAssignedAdminEmail ? originalAssignedAdminEmail.split(' ')[0] : null;
        if (originalStatus === 'Out for Delivery' && deliveryAdminEmailOnly) {
             try {
                const subjectAdmin = `Assigned Order Cancelled: ${order._id}`;
                 const htmlAdmin = `<p>Order ${order._id}, which was assigned to you, has been cancelled by an administrator.</p><p><strong>Reason:</strong> ${reason}</p><p>This order should no longer be delivered.</p>`;
                await sendEmail(deliveryAdminEmailOnly, subjectAdmin, `Assigned order ${order._id} cancelled by admin. Reason: ${reason}`, htmlAdmin);
             } catch(emailError) {
                 console.error(`Failed sending cancellation notice to delivery admin ${deliveryAdminEmailOnly} for order ${order._id}:`, emailError);
             }
        }
        // --- End Notifications ---

        req.flash('success_msg', `Order ${orderId} cancelled successfully with reason: ${reason}.`);
        res.redirect('/admin/manage-orders');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid Order ID format.');
        } else {
            // Log unexpected errors
            console.error(`Error cancelling order ${orderId} by admin ${adminUserId}:`, error);
            req.flash('error_msg', 'Failed to cancel the order due to an internal error.');
        }
        // Redirect back even on error
        res.redirect('/admin/manage-orders');
    }
};


// =======================
// User Management Actions
// =======================
exports.updateUserRole = async (req, res, next) => {
    const userId = req.params.id;
    const { role } = req.body;

    // Validate role
     const allowedRoles = ['user', 'admin', 'delivery_admin'];
     if (!role || !allowedRoles.includes(role)) {
        req.flash('error_msg', 'Invalid role selected.');
         return res.redirect('/admin/manage-users');
     }

    try {
        // Prevent admin from changing their own role
        if (req.params.id === req.session.user._id.toString()) {
             req.flash('error_msg', 'You cannot change your own role.');
             return res.redirect('/admin/manage-users');
         }

        const user = await User.findById(userId);
         if (!user) {
            req.flash('error_msg', 'User not found.');
             return res.status(404).redirect('/admin/manage-users');
         }

         // Update the role and save
         user.role = role;
        await user.save();

        req.flash('success_msg', `User ${user.email}'s role updated to ${role}.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
         // Handle CastError for invalid ID
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid user ID format.');
         } else {
             // Log unexpected errors
             console.error(`Error updating role for user ${userId}:`, error);
            req.flash('error_msg', 'Error updating user role.');
         }
         res.redirect('/admin/manage-users'); // Redirect back on error
    }
};

exports.removeUser = async (req, res, next) => {
    const userId = req.params.id;
    try {
        // Prevent admin from removing themselves
        if (req.params.id === req.session.user._id.toString()) {
            req.flash('error_msg', 'You cannot remove yourself.');
            return res.redirect('/admin/manage-users');
        }

         const user = await User.findById(userId);
         if (!user) {
            req.flash('error_msg', 'User not found.');
             return res.redirect('/admin/manage-users');
         }

         // Prevent removing the last admin
         if (user.role === 'admin') {
             const adminCount = await User.countDocuments({ role: 'admin' });
             if (adminCount <= 1) {
                 req.flash('error_msg', 'Cannot remove the last admin account.');
                return res.redirect('/admin/manage-users');
             }
         }

        // Remove the user
        await User.deleteOne({ _id: userId });
        let message = `User ${user.email} removed successfully.`;

        // If the removed user was a delivery admin, unassign their active orders
        if (user.role === 'delivery_admin') {
             const updateResult = await Order.updateMany(
                { assignedTo: userId, status: 'Out for Delivery' }, // Find active orders assigned to them
                { $set: { assignedTo: null, assignedAdminEmail: null, status: 'Pending' } } // Reset assignment and status
             );
             // Provide feedback on unassigned orders
             if (updateResult.modifiedCount > 0) {
                 message = `Delivery Admin ${user.email} removed. ${updateResult.modifiedCount} active deliveries have been unassigned and set back to 'Pending'.`;
             } else {
                 message = `Delivery Admin ${user.email} removed. No active orders needed unassignment.`;
             }
         }

        req.flash('success_msg', message);
        res.redirect('/admin/manage-users');

    } catch (error) {
         // Handle CastError for invalid ID
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid user ID format.');
         } else {
             // Log unexpected errors
             console.error(`Error removing user ${userId}:`, error);
            req.flash('error_msg', 'Error removing user.');
         }
        res.redirect('/admin/manage-users'); // Redirect back on error
     }
 };

// ======================================
// Assigned Orders / Delivery Admin Mgmt
// (This is essentially covered by manage-users removeUser now, but kept for potential direct removal from assigned orders page)
exports.removeDeliveryAdminAssignment = async (req, res, next) => {
    const userId = req.params.id; // This is the delivery admin's ID to remove
    try {
        // Prevent action on self if accessed via a route potentially available to delivery admins too
        if (userId === req.session.user._id.toString()) {
            req.flash('error_msg', 'Action not allowed on self.');
            return res.redirect('/admin/manage-assigned-orders');
        }

         const user = await User.findOne({_id: userId, role: 'delivery_admin'});
         if (!user) {
            req.flash('error_msg', 'Delivery Admin user not found.');
             return res.status(404).redirect('/admin/manage-assigned-orders');
         }

        // Remove the user account entirely
        await User.deleteOne({ _id: userId });

        // Unassign their 'Out for Delivery' orders
         const updateResult = await Order.updateMany(
             { assignedTo: userId, status: 'Out for Delivery' },
             { $set: { assignedTo: null, assignedAdminEmail: null, status: 'Pending' } } // Revert to Pending
         );

         req.flash('success_msg', `Delivery Admin ${user.email} removed. ${updateResult.modifiedCount} active deliveries unassigned and reverted to 'Pending'.`);
         res.redirect('/admin/manage-assigned-orders');

     } catch (error) {
        if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid delivery admin ID format.');
         } else {
             console.error(`Error removing delivery admin ${userId}:`, error);
             req.flash('error_msg', 'Error removing delivery admin.');
         }
        res.redirect('/admin/manage-assigned-orders');
     }
 };

controllers/authController.js:
const User = require('../models/User');
const Product = require('../models/Product');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { generateOTP, setOTPExpiration } = require('../services/otpService');
const { sendEmail } = require('../config/mailer');

exports.getLoginPage = (req, res) => {
    if (req.session.user) {
         return res.redirect('/');
    }
    res.render('auth/login', { title: 'Login' });
};

exports.getRegisterPage = (req, res) => {
    if (req.session.user) {
        return res.redirect('/');
   }
    res.render('auth/register', { title: 'Register' });
};

exports.getVerifyOtpPage = (req, res) => {
    const email = req.query.email;
    if (!email) {
        req.flash('error_msg', 'Email required for OTP verification.');
        return res.redirect('/auth/register');
    }
     if (req.session.user) {
        return res.redirect('/');
   }
    res.render('auth/verify-otp', { title: 'Verify Email', email });
};

exports.getForgotPasswordPage = (req, res) => {
    res.render('auth/forgot-password', { title: 'Forgot Password' });
};

exports.getResetPasswordPage = async (req, res, next) => {
    try {
        const user = await User.findOne({
            resetPasswordToken: req.params.token,
            resetPasswordExpires: { $gt: Date.now() },
        });

        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired.');
            return res.redirect('/auth/forgot-password');
        }
        res.render('auth/reset-password', { title: 'Reset Password', token: req.params.token });
    } catch (error) {
        next(error);
    }
};

exports.registerUser = async (req, res, next) => {
    const { name, email, password, confirmPassword } = req.body;

    if (!name || !email || !password || !confirmPassword) {
        req.flash('error_msg', 'Please fill in all fields.');
        return res.redirect('/auth/register');
    }
    if (password !== confirmPassword) {
        req.flash('error_msg', 'Passwords do not match.');
        return res.redirect('/auth/register');
    }
    if (password.length < 6) {
        req.flash('error_msg', 'Password must be at least 6 characters.');
        return res.redirect('/auth/register');
    }

    try {
        let user = await User.findOne({ email: email.toLowerCase() });

        if (user && user.isVerified) {
            req.flash('error_msg', 'Email is already registered and verified.');
            return res.redirect('/auth/login');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10);

        if (user && !user.isVerified) {
            // Found unverified user - update details and OTP
            user.name = name;
            user.password = password; // Will be re-hashed by pre-save hook
            user.otp = otp;
            user.otpExpires = otpExpires;
            user.isVerified = false;
             // We need to save without full validation if only updating OTP/password on unverified doc
             await user.save({ validateBeforeSave: false });
        } else {
            // Create brand new user
            user = new User({
                name,
                email: email.toLowerCase(),
                password, // Will be hashed by pre-save hook
                otp,
                otpExpires,
                isVerified: false,
            });
            await user.save(); // Full validation runs here
        }

        const subject = 'Verify Your Email Address';
        const text = `Your verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
        const html = `<p>Your verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;

        const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
            req.flash('success_msg', `An OTP has been sent to ${user.email}. Please verify.`);
            res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
        } else {
             // Clean up user if email failed ONLY IF IT WAS A NEW USER attempt
             if(!user.createdAt || (Date.now() - user.createdAt.getTime()) < 2000) { // Heuristic: If created within last 2s
                await User.deleteOne({ _id: user._id, isVerified: false });
             }
            req.flash('error_msg', 'Could not send OTP email. Please try registering again or contact support.');
            res.redirect('/auth/register');
        }

    } catch (error) {
        if (error.code === 11000) { // Handle duplicate key error specifically
            req.flash('error_msg', 'Email already exists.');
             return res.redirect('/auth/register');
        }
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', errors.join(' '));
            return res.redirect('/auth/register');
       }
        next(error); // Pass other errors to the error handler
    }
};

exports.verifyOtp = async (req, res, next) => {
    const { email, otp } = req.body;

    if (!email || !otp) {
        req.flash('error_msg', 'Email and OTP are required.');
         // Ensure email is passed back even on error
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email || '')}`);
    }

    try {
        const user = await User.findOne({
            email: email.toLowerCase(),
            otp: otp,
            otpExpires: { $gt: Date.now() },
        }).select('+password'); // Include password if needed later (e.g., for immediate login)

        if (!user) {
            req.flash('error_msg', 'Invalid or expired OTP.');
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email)}`);
        }

         // Check if this OTP verification is part of a password reset flow
         let wasPasswordReset = user.resetPasswordToken && user.resetPasswordExpires > Date.now();

         // Mark user as verified and clear OTP fields
         user.isVerified = true;
         user.otp = undefined;
         user.otpExpires = undefined;

         if(wasPasswordReset){
             // OTP was for password reset verification, proceed to reset page
             req.flash('success_msg', 'OTP Verified. Please set your new password.');
             // Don't clear reset token yet, needed for next step
             await user.save({ validateBeforeSave: false }); // Save without full validation if needed
             res.redirect(`/auth/reset-password/${user.resetPasswordToken}`);
         } else {
            // OTP was for registration verification, log the user in
            await user.save(); // Save changes (isVerified, cleared OTP)

            // Log the user in by setting up the session
            req.session.user = {
                _id: user._id,
                name: user.name,
                email: user.email,
                role: user.role,
                address: user.address,
                cart: user.cart // Make sure cart is loaded or initialized if needed
             };

            // Save the session before redirecting
            req.session.save(err => {
               if (err) {
                    console.error("Session save error after OTP verify:", err);
                    return next(err); // Pass error to handler
                }
                // Successful login after verification
                req.flash('success_msg', 'Email verified successfully! You are now logged in.');
                const returnTo = req.session.returnTo || '/';
                delete req.session.returnTo; // Clean up returnTo URL
                res.redirect(returnTo);
             });
         }

    } catch (error) {
        next(error); // Pass errors to the error handler
    }
};

exports.resendOtp = async (req, res, next) => {
    const { email } = req.body;

    if (!email) {
        req.flash('error_msg', 'Email is required to resend OTP.');
         // Try to get email from query if available for redirect
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(req.query.email || '')}`);
    }

    try {
        const user = await User.findOne({ email: email.toLowerCase() });

        if (!user) {
            // Don't reveal if user exists, redirect to register for consistency
            req.flash('error_msg', 'If your email is registered but not verified, an OTP will be sent.');
            return res.redirect('/auth/register');
        }

        // Determine if OTP resend is for registration or password reset
        const isForReset = user.resetPasswordToken && user.resetPasswordExpires > Date.now();

        if(user.isVerified && !isForReset) {
             // Already verified, not a password reset case
             req.flash('error_msg', 'This account is already verified.');
            return res.redirect('/auth/login');
        }

        // Generate new OTP and expiry
        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10); // 10 minutes

        user.otp = otp;
        user.otpExpires = otpExpires;
        await user.save(); // Save the new OTP

        // Prepare email content
        let subject = isForReset ? 'Your New Password Reset OTP' : 'Your New Verification OTP';
         let text = `Your new OTP is: ${otp}\nIt will expire in 10 minutes.`;
        let html = `<p>Your new OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;
        if (isForReset) {
            text = `Your new password reset OTP is: ${otp}\nIt will expire in 10 minutes.\nIf you did not request this, please ignore this email.`;
            html = `<p>Your new password reset OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;
        }


        // Send the email
        const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
            req.flash('success_msg', `A new OTP has been sent to ${user.email}.`);
            // Redirect back to OTP entry page, indicating purpose if reset
            const redirectUrl = `/auth/verify-otp?email=${encodeURIComponent(user.email)}${isForReset ? '&reason=reset' : ''}`;
            res.redirect(redirectUrl);
        } else {
            req.flash('error_msg', 'Could not resend OTP email. Please try again.');
             // Redirect back to OTP entry page even on failure
             res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}${isForReset ? '&reason=reset' : ''}`);
        }
    } catch (error) {
        next(error); // Pass errors to the error handler
    }
};


exports.loginUser = async (req, res, next) => {
    const { email, password } = req.body;

    if (!email || !password) {
        req.flash('error_msg', 'Please provide email and password.');
        return res.redirect('/auth/login');
    }

    try {
        // Find user and include password field for comparison
        const user = await User.findOne({ email: email.toLowerCase() })
                             .select('+password')
                             .populate('cart.productId'); // Populate cart details for session

        if (!user) {
            req.flash('error_msg', 'Invalid credentials.');
            return res.redirect('/auth/login');
        }

         // Check if user's email is verified
         if (!user.isVerified) {
            req.flash('error_msg', 'Please verify your email first. Check your inbox for the OTP.');
            // Redirect to OTP page, passing email
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
         }

        // Compare submitted password with stored hash
        const isMatch = await user.matchPassword(password);

        if (!isMatch) {
            req.flash('error_msg', 'Invalid credentials.');
            return res.redirect('/auth/login');
        }

        // Password matched, setup session
        // Regenerate session ID to prevent fixation attacks
         req.session.regenerate(err => {
            if (err) {
                 console.error("Session regeneration error:", err);
                 return next(err); // Pass error to handler
             }

            // Store essential, non-sensitive user data in session
            req.session.user = {
                _id: user._id,
                name: user.name,
                email: user.email,
                role: user.role,
                address: user.address, // Include address if available
                cart: user.cart // Include populated cart details
            };

             // Save the newly regenerated session
             req.session.save(err => {
                 if (err) {
                     console.error("Session save error after login:", err);
                     return next(err); // Pass error to handler
                 }
                 // Successful login
                 req.flash('success_msg', 'You are now logged in.');
                 const returnTo = req.session.returnTo || '/'; // Redirect to intended page or home
                 delete req.session.returnTo; // Clean up returnTo URL
                 res.redirect(returnTo);
            });
        });

    } catch (error) {
        next(error); // Pass errors to the error handler
    }
};

exports.logoutUser = (req, res, next) => {
    // Set the flash message *BEFORE* destroying the session
    req.flash('success_msg', 'You have been logged out.');

    req.session.destroy(err => {
        if (err) {
            console.error('Session destruction error:', err);
            // Pass the error to the main error handler instead of trying to flash again
            return next(err);
        }
        // Clear the session cookie after successful destruction
        res.clearCookie('connect.sid'); // Use the default cookie name or your configured name

        // Redirect to login page
        res.redirect('/auth/login');
    });
};


exports.forgotPassword = async (req, res, next) => {
    const { email } = req.body;
    if (!email) {
        req.flash('error_msg', 'Please provide an email address.');
        return res.redirect('/auth/forgot-password');
    }

    try {
        const user = await User.findOne({ email: email.toLowerCase() });

        // Security: Always show a generic success message regardless of whether the user exists
        // This prevents attackers from enumerating registered emails.
        const genericSuccessMessage = 'If an account with that email exists and is verified, a password reset OTP will be sent.';

        if (!user) {
            req.flash('success_msg', genericSuccessMessage);
            return res.redirect('/auth/forgot-password');
        }

        // Check if the found user is verified
        if (!user.isVerified) {
            req.flash('error_msg', 'This account is not verified. Please complete registration verification first.');
             // Redirect to OTP verification page for registration
             return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
         }

         // Generate OTP and reset token with expiry dates
         const otp = generateOTP();
         const resetToken = crypto.randomBytes(20).toString('hex');
        const otpExpires = setOTPExpiration(10); // OTP valid for 10 mins
        const resetExpires = setOTPExpiration(60); // Reset token valid for 60 mins

        // Store OTP, token, and expiry times on the user document
        user.otp = otp;
        user.otpExpires = otpExpires;
        user.resetPasswordToken = resetToken;
        user.resetPasswordExpires = resetExpires;
        await user.save();

        // Prepare email content
        const subject = 'Password Reset Request - Verify OTP';
         const text = `You requested a password reset.\n\nPlease use the following OTP to verify your request: ${otp}\n\nIt will expire in 10 minutes.\n\nIf you did not request this, please ignore this email.`;
         const html = `<p>You requested a password reset.</p><p>Please use the following OTP to verify your request: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;

         // Send the email containing the OTP
         const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
            req.flash('success_msg', `An OTP has been sent to ${user.email} to verify your password reset request.`);
             // Redirect to OTP verification page, indicating it's for reset
             res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}&reason=reset`);
        } else {
            // If email fails, clear the OTP/token fields to prevent misuse
            user.otp = undefined;
            user.otpExpires = undefined;
             user.resetPasswordToken = undefined;
            user.resetPasswordExpires = undefined;
             await user.save(); // Save the cleared fields
            req.flash('error_msg', 'Could not send password reset OTP. Please try again.');
            res.redirect('/auth/forgot-password');
        }

    } catch (error) {
        next(error); // Pass errors to the error handler
    }
};


exports.resetPassword = async (req, res, next) => {
    const { password, confirmPassword } = req.body;
    const token = req.params.token;

    // Validation checks
    if (!password || !confirmPassword) {
        req.flash('error_msg', 'Please enter and confirm your new password.');
         return res.redirect(`/auth/reset-password/${token}`);
    }
    if (password !== confirmPassword) {
        req.flash('error_msg', 'Passwords do not match.');
         return res.redirect(`/auth/reset-password/${token}`);
    }
     if (password.length < 6) {
         req.flash('error_msg', 'Password must be at least 6 characters.');
        return res.redirect(`/auth/reset-password/${token}`);
    }

    try {
        // Find user by valid reset token and expiry
        const user = await User.findOne({
            resetPasswordToken: token,
            resetPasswordExpires: { $gt: Date.now() }, // Ensure token hasn't expired
         });


        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired.');
            return res.redirect('/auth/forgot-password');
        }

        // Update password (pre-save hook will hash it)
        user.password = password;
        // Clear reset token and OTP fields after successful reset
        user.resetPasswordToken = undefined;
        user.resetPasswordExpires = undefined;
         user.otp = undefined; // Ensure OTP used for verification is cleared too
         user.otpExpires = undefined;

        await user.save(); // Save the user with new password and cleared tokens

        // Log the user in after successful password reset
        req.session.regenerate(err => {
             if (err) {
                console.error("Session regeneration error after reset:", err);
                return next(err);
             }
             req.session.user = {
                _id: user._id,
                name: user.name,
                email: user.email,
                role: user.role,
                address: user.address,
                cart: user.cart // Assuming cart might be needed immediately
            };
            req.session.save(err => {
                if(err) {
                    console.error("Session save error after reset:", err);
                    return next(err);
                 }
                 req.flash('success_msg', 'Password has been reset successfully. You are now logged in.');
                res.redirect('/'); // Redirect to homepage
             });
         });


    } catch (error) {
        next(error); // Pass errors to the error handler
    }
};

// Combined Controller Action for Home Page and Product Listing
exports.getHomePage = async (req, res, next) => {
  try {
    // This now handles both '/' and '/products' with potential search
    const searchTerm = req.query.search || '';
    let query = { stock: { $gt: 0 } }; // Always filter for products in stock

    if (searchTerm) {
      // Build search query if searchTerm exists
      const regex = new RegExp(searchTerm.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'), 'i'); // Escape special chars, case-insensitive
      query.$or = [
         { name: regex },
         { category: regex },
         { specifications: regex }
         // Add more fields to search if needed (e.g., description)
      ];
    }

    // Fetch products based on query, sort by newest first
    const products = await Product.find(query).sort({ createdAt: -1 });

    // Render the main product listing page
    res.render('products/index', {
      title: searchTerm ? `Search Results for "${searchTerm}"` : 'Home', // Dynamic title
      products: products,
      searchTerm: searchTerm // Pass searchTerm back to view for input field
    });
  } catch (error) {
    next(error); // Pass errors to the error handler
  }
};
controllers/deliveryController.js:
// controllers/deliveryController.js
const Order = require('../models/Order');
const User = require('../models/User');
const Product = require('../models/Product'); // --- ADDED for stock update ---
const { sendEmail } = require('../config/mailer');
const { generateAndSendDeliveryOTP, verifyDeliveryOTP } = require('./orderController');

// --- Define Cancellation Reasons (Consistent with Admin) ---
const cancellationReasons = [
    "📞 Unable to contact the customer",
    "🕒 Delay in shipping/delivery timeframe exceeded",
    "❗ Out of stock/unavailable item",
    "🗺️ Address incorrect/incomplete",
    "🚫 Customer requested cancellation",
    "🚚 Logistics issue/Vehicle breakdown",
    "❓ Other (Admin/Delivery)",
];

// --- Get Contact Page ---
exports.getContactPage = async (req, res, next) => {
    try {
        // Fetch fresh user data to ensure address is up-to-date
        const user = await User.findById(req.session.user._id).select('address.phone').lean();
        const currentPhoneNumber = user?.address?.phone || ''; // Safely access phone

        res.render('delivery/contact', {
            title: 'My Contact Information',
            currentPhoneNumber: currentPhoneNumber
        });
    } catch (error) {
        next(error);
    }
};

// --- Update Contact Info ---
exports.updateContactInfo = async (req, res, next) => {
    const { phone } = req.body;
    const userId = req.session.user._id;

    if (!phone || phone.trim().length < 10 || !/^\d+$/.test(phone.trim())) {
        req.flash('error_msg', 'Please enter a valid phone number (at least 10 digits, numbers only).');
        return res.redirect('/delivery/contact');
    }

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return req.session.destroy(err => {
                if (err) return next(err);
                res.redirect('/auth/login');
            });
        }

        if (!user.address) {
            user.address = {};
        }
        user.address.phone = phone.trim();

        await user.save();

        if (!req.session.user.address) {
             req.session.user.address = {};
        }
        req.session.user.address.phone = user.address.phone;
        await req.session.save();

        req.flash('success_msg', 'Phone number updated successfully.');
        res.redirect('/delivery/dashboard');

    } catch (error) {
        if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', errors.join(' '));
            return res.redirect('/delivery/contact');
       }
        next(error);
    }
};


exports.getDeliveryDashboard = async (req, res, next) => {
  const deliveryAdminId = req.session.user._id;
   const deliveryAdminEmail = req.session.user.email;

  try {
    const totalAssigned = await Order.countDocuments({ assignedTo: deliveryAdminId });
    const pendingCount = await Order.countDocuments({
        assignedTo: deliveryAdminId,
        status: { $nin: ['Delivered', 'Cancelled'] }
     });
     const deliveredCount = await Order.countDocuments({
        assignedTo: deliveryAdminId,
        status: 'Delivered'
     });

    res.render('delivery/dashboard', {
      title: 'Delivery Dashboard',
      assignedAdminEmail: deliveryAdminEmail,
      totalAssigned,
      pendingCount,
      deliveredCount
    });

  } catch (error) {
    next(error);
  }
};

exports.getAssignedOrdersDetail = async (req, res, next) => {
    const deliveryAdminId = req.session.user._id;
    const type = req.params.type; // 'total', 'pending', 'delivered'

    try {
         let query = { assignedTo: deliveryAdminId };
         let pageTitle = `My Assigned Orders`;

         if (type === 'pending') {
            query.status = { $nin: ['Delivered', 'Cancelled'] };
             pageTitle = `My Active Deliveries`;
        } else if (type === 'delivered') {
            query.status = 'Delivered';
            pageTitle = `My Delivered Orders`;
        }

        const orders = await Order.find(query)
                                 .sort({ orderDate: -1 })
                                  .lean();

         orders.forEach(order => {
             order.formattedOrderDate = new Date(order.orderDate).toLocaleString();
             order.formattedReceivedDate = order.receivedByDate ? new Date(order.receivedByDate).toLocaleString() : 'N/A';
             order.canRequestDeliveryOtp = order.status === 'Out for Delivery';
             order.canBeCancelledByDelivery = order.status === 'Out for Delivery';
             order.canBeUnassignedByDelivery = order.status === 'Out for Delivery';
         });

        res.render('delivery/assigned-orders-detail', {
             title: pageTitle,
             orders: orders,
             listType: type,
             cancellationReasons: cancellationReasons
         });

    } catch (error) {
        next(error);
    }
};

// --- Send Delivery OTP Handler ---
exports.sendDeliveryOtp = async (req, res, next) => {
    const { orderId } = req.params;
    const deliveryAdminId = req.session.user._id;

    try {
        const result = await generateAndSendDeliveryOTP(orderId, deliveryAdminId);
        req.flash('success_msg', result.message + ' Ask the customer for the OTP.');
    } catch (error) {
        req.flash('error_msg', `Failed to send delivery OTP: ${error.message}`);
    }
    res.redirect(req.headers.referer || '/delivery/dashboard');
};

// --- Verify Delivery OTP Handler ---
exports.verifyDeliveryOtp = async (req, res, next) => {
     const { orderId } = req.params;
    const { otp } = req.body;
    const deliveryAdminId = req.session.user._id;

    if (!otp || !/^\d{6}$/.test(otp)) {
        req.flash('error_msg', 'Please enter the 6-digit OTP from the customer.');
        return res.redirect(req.headers.referer || '/delivery/dashboard');
    }

    try {
        const { order } = await verifyDeliveryOTP(orderId, deliveryAdminId, otp);
        req.flash('success_msg', `Order ${orderId} confirmed delivered successfully!`);
    } catch (error) {
        req.flash('error_msg', `Delivery confirmation failed: ${error.message}`);
    }
    res.redirect(req.headers.referer || '/delivery/dashboard');
};

// --- UPDATED: Cancel Assigned Order (Delivery Admin) ---
exports.cancelAssignedOrder = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const deliveryAdminId = req.session.user._id;

    if (!reason || !cancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid reason for cancellation.');
        return res.redirect(req.headers.referer || '/delivery/orders/pending');
    }

    try {
        const order = await Order.findById(orderId).populate('products.productId', 'name'); // Populate name for logging
        if (!order) {
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/delivery/orders/pending');
        }

        if (!order.assignedTo || order.assignedTo.toString() !== deliveryAdminId.toString()) {
            req.flash('error_msg', 'You are not assigned to this order.');
            return res.status(403).redirect('/delivery/orders/pending');
        }

        // Only allow cancellation if 'Out for Delivery' (handled by the delivery person)
        if (order.status !== 'Out for Delivery') {
            req.flash('error_msg', `Order cannot be cancelled by you in its current status ('${order.status}'). Must be 'Out for Delivery'.`);
            return res.redirect(req.headers.referer || '/delivery/orders/pending');
        }

        // --- ADDED: Stock Restoration Logic ---
        console.log(`Delivery Cancellation: Attempting to restore stock for cancelled order ${orderId}.`);
        const productStockRestorePromises = order.products.map(item => {
            const quantityToRestore = Number(item.quantity);
            if (isNaN(quantityToRestore) || quantityToRestore <= 0) {
                 console.error(`Delivery Cancel: Invalid quantity ${item.quantity} for product ${item.productId?._id || 'Unknown ID'} in order ${orderId}, skipping stock restore.`);
                 return Promise.resolve();
            }
            if (!item.productId) {
                 console.error(`Delivery Cancel: Missing productId for an item in order ${orderId}, skipping stock restore for this item.`);
                return Promise.resolve();
            }
            return Product.updateOne(
                { _id: item.productId._id },
                { $inc: { stock: quantityToRestore, orderCount: -1 } } // Also decrement order count
            ).catch(err => {
               console.error(`Delivery Cancel: Failed restore stock/orderCount for product ${item.productId._id} (${item.productId.name}) on order ${orderId}: ${err.message}`);
               // Continue despite error (best effort)
            });
        });
        await Promise.all(productStockRestorePromises);
        console.log(`Delivery Cancel: Stock restoration attempted for order ${orderId}.`);
        // --- END Stock Restoration ---

        order.status = 'Cancelled';
        order.cancellationReason = reason;
        // Note: pre-save hook clears assignedTo, OTPs etc. based on 'Cancelled' status
        await order.save();

        // Notify Customer
        try {
            const subjectCust = `Your Order (${order._id}) Delivery Cancelled`;
            const htmlCust = `<p>We regret to inform you that the delivery for your order (${order._id}) has been cancelled by the delivery partner.</p>
                           <p><strong>Reason:</strong> ${order.cancellationReason}</p>
                           <p>We apologize for any inconvenience. Please contact support if you have questions or to rearrange.</p>`;
            await sendEmail(order.userEmail, subjectCust, `Delivery for order ${order._id} cancelled. Reason: ${order.cancellationReason}`, htmlCust);
        } catch (emailError) {
            console.error(`Failed sending delivery cancellation email to customer for order ${order._id}:`, emailError);
        }

        // Notify Admin? (Optional - Admin sees it in manage orders)

        req.flash('success_msg', `Order ${orderId} cancelled successfully with reason: ${reason}.`);
        res.redirect(req.headers.referer || '/delivery/orders/pending');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid Order ID format.');
        } else {
            console.error(`Error cancelling order ${orderId} by delivery admin ${deliveryAdminId}:`, error);
            req.flash('error_msg', 'Failed to cancel the order.');
        }
        res.redirect(req.headers.referer || '/delivery/orders/pending');
    }
};

// --- Unassign Order (Delivery Admin) ---
exports.unassignOrder = async (req, res, next) => {
    const { orderId } = req.params;
    const deliveryAdminId = req.session.user._id;

    try {
        const order = await Order.findById(orderId);
        if (!order) {
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/delivery/orders/pending');
        }

        if (!order.assignedTo || order.assignedTo.toString() !== deliveryAdminId.toString()) {
            req.flash('error_msg', 'You are not assigned to this order.');
            return res.status(403).redirect('/delivery/orders/pending');
        }

        if (order.status !== 'Out for Delivery') {
            req.flash('error_msg', `Order cannot be unassigned in its current status ('${order.status}'). Must be 'Out for Delivery'.`);
            return res.redirect(req.headers.referer || '/delivery/orders/pending');
        }

        // No stock adjustment needed for unassigning, just status/assignment change
        order.status = 'Pending'; // Revert to Pending for Admin to re-assign
        order.assignedTo = null;
        order.assignedAdminEmail = null;

        await order.save();

        // Notify Admin? (Optional)
        // Notify Customer? (Maybe not necessary, just appears back in processing state)

        req.flash('success_msg', `Order ${orderId} unassigned successfully. It has been returned to the admin's Pending queue.`);
        res.redirect(req.headers.referer || '/delivery/orders/pending'); // Redirect back to pending list usually

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid Order ID format.');
        } else {
            console.error(`Error unassigning order ${orderId} by delivery admin ${deliveryAdminId}:`, error);
            req.flash('error_msg', 'Failed to unassign the order.');
        }
        res.redirect(req.headers.referer || '/delivery/orders/pending');
    }
};
controllers/orderController.js:
// controllers/orderController.js
const Order = require('../models/Order');
const User = require('../models/User');
const Product = require('../models/Product');
const { sendEmail } = require('../config/mailer');
const mongoose = require('mongoose');
const { generateOTP, setOTPExpiration } = require('../services/otpService');

// --- Place Order Function (No Transaction Wrapper) ---
exports.placeOrder = async (req, res, next) => {
    try {
        const userId = req.session.user._id;
        const user = await User.findById(userId).populate('cart.productId');

        if (!user) {
            req.flash('error_msg', 'User session not found. Please log in again.');
            return res.redirect('/auth/login');
        }
        if (!user.cart || user.cart.length === 0) {
            req.flash('error_msg', 'Your cart is empty.');
            return res.redirect('/user/cart');
        }
        if (!user.address || !user.address.name || !user.address.phone || !user.address.pincode || !user.address.cityVillage) {
            req.flash('error_msg', 'Please save your shipping address before placing the order.');
            return res.redirect('/user/checkout');
        }

        let orderProducts = [];
        let totalAmount = 0;
        const productUpdates = [];
        let validationFailed = false;

        // 1. Validate stock AND quantity, prepare order data
        for (const item of user.cart) {
            const itemQuantity = Number(item.quantity);
            if (isNaN(itemQuantity) || !Number.isInteger(itemQuantity) || itemQuantity <= 0) {
                console.error(`Invalid quantity found in cart for user ${userId}, product ID ${item.productId?._id || 'N/A'}: ${item.quantity}`);
                req.flash('error_msg', `An item in your cart has an invalid quantity (${item.quantity || 'empty'}). Please remove or update it.`);
                validationFailed = true;
                break;
            }

             if (!item.productId || typeof item.productId !== 'object') {
                console.warn(`User ${userId} cart contains invalid item reference: ${item._id}. Removing.`);
                await User.updateOne({ _id: userId }, { $pull: { cart: { _id: item._id } } });
                req.flash('error_msg', `An invalid item was detected and removed from your cart. Please review your cart and checkout again.`);
                validationFailed = true;
                break;
            }

            const currentProduct = await Product.findById(item.productId._id).select('stock name price imageUrl');

            if (!currentProduct) {
                req.flash('error_msg', `Product "${item.productId.name || 'ID: '+item.productId._id}" is no longer available. Please remove it from your cart.`);
                validationFailed = true;
                await User.updateOne({ _id: userId }, { $pull: { cart: { productId: item.productId._id } } });
                break;
            }

            if (currentProduct.stock < itemQuantity) {
                req.flash('error_msg', `Insufficient stock for "${currentProduct.name}". Available: ${currentProduct.stock}. Your cart has ${itemQuantity}. Please update your cart.`);
                validationFailed = true;
                break;
            }

            orderProducts.push({
                productId: currentProduct._id,
                name: currentProduct.name,
                priceAtOrder: currentProduct.price,
                quantity: itemQuantity,
                imageUrl: currentProduct.imageUrl,
            });
            totalAmount += currentProduct.price * itemQuantity;
            productUpdates.push({
                productId: currentProduct._id,
                quantityToDecrement: itemQuantity
            });
        }

        if (validationFailed) {
            const updatedUser = await User.findById(userId).select('cart');
            req.session.user.cart = updatedUser ? updatedUser.cart : [];
            await req.session.save();
            return res.redirect('/user/cart');
        }

        // --- 2. Perform Operations (No Transaction Wrapper) ---
        try {
            for (const update of productUpdates) {
                const updateResult = await Product.updateOne(
                    { _id: update.productId, stock: { $gte: update.quantityToDecrement } },
                    { $inc: { stock: -update.quantityToDecrement, orderCount: 1 } }
                );
                if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 1) {
                     throw new Error(`Stock level changed concurrently for a product (ID: ${update.productId}). Please try again.`);
                 }
                 if(updateResult.matchedCount === 0) {
                      throw new Error(`A product (ID: ${update.productId}) was removed during checkout. Please review your cart.`);
                 }
            }

            const order = new Order({
                userId: userId,
                userEmail: user.email,
                products: orderProducts,
                totalAmount: totalAmount,
                shippingAddress: user.address,
                paymentMethod: 'COD',
                status: 'Pending', // Initial status is always Pending now
            });
            await order.save();

            user.cart = [];
            await user.save();

            req.session.user.cart = [];
            await req.session.save();

            try {
                const subject = 'Your Order Has Been Placed!';
                let productListHTML = order.products.map(p => `<li>${p.name} (Qty: ${p.quantity}) - ₹${p.priceAtOrder.toFixed(2)}</li>`).join('');
                const html = `<h2>Thank you for your order!</h2><p>Your Order ID: ${order._id}</p><p>Total Amount: ₹${order.totalAmount.toFixed(2)}</p><p>Shipping To: ${order.shippingAddress.name}, ${order.shippingAddress.cityVillage}</p><h3>Items:</h3><ul>${productListHTML}</ul><p>You can track your order status in the 'My Orders' section.</p>`;
                await sendEmail(user.email, subject, `Your order ${order._id} has been placed. Total: ₹${totalAmount.toFixed(2)}`, html);
            } catch (emailError) {
                console.error(`Failed to send order confirmation email for order ${order._id}:`, emailError);
            }

            req.flash('success_msg', 'Order placed successfully!');
            res.redirect('/orders/my-orders');

        } catch (error) {
            console.error("Error during critical order processing block:", error);
            console.error("Order placement failed AFTER potentially decrementing some stock. Manual stock check might be required.");
            req.flash('error_msg', `Order placement failed due to an unexpected issue: ${error.message}. Please check 'My Orders' or contact support.`);
            res.redirect('/orders/my-orders');
        }

    } catch (error) {
        console.error("Outer Order Placement Error:", error);
        next(error);
    }
};

// --- Cancel Order Function (BY USER) ---
// Logic remains the same, only cancels 'Pending' orders within window
exports.cancelOrder = async (req, res, next) => {
    try {
        const orderId = req.params.id;
        const userId = req.session.user._id;

        const order = await Order.findOne({
             _id: orderId,
            userId: userId,
            status: 'Pending', // Still correct, user can only cancel pending
             cancellationAllowedUntil: { $gt: Date.now() }
        });

        if (!order) {
             req.flash('error_msg', 'Order not found, already processed, or cancellation period expired.');
            return res.redirect('/orders/my-orders');
        }

        // Restore stock (best effort)
        console.log(`User Cancellation: Attempting to restore stock for order ${orderId}.`);
        const productStockRestorePromises = order.products.map(item => {
             const quantityToRestore = Number(item.quantity);
             if (isNaN(quantityToRestore) || quantityToRestore <= 0) return Promise.resolve();
             return Product.updateOne(
                 { _id: item.productId },
                 { $inc: { stock: quantityToRestore, orderCount: -1 } }
             ).catch(err => {
                console.error(`User Cancel: Failed to restore stock/orderCount for product ${item.productId} on cancelling order ${orderId}: ${err.message}`);
             });
        });
        await Promise.all(productStockRestorePromises);
        console.log(`User Cancel: Stock restoration attempted for order ${orderId}.`);

        order.status = 'Cancelled';
        order.cancellationReason = "Cancelled by customer";
        await order.save(); // pre-save hook clears fields

         try{
             const subject = 'Your Order Has Been Cancelled';
             const html = `<p>Your order (${order._id}) has been successfully cancelled as requested.</p>`;
            await sendEmail(order.userEmail, subject, `Order ${order._id} cancelled.`, html);
         } catch (emailError){
             console.error(`Failed to send cancellation email for order ${order._id}:`, emailError);
         }

        req.flash('success_msg', 'Order cancelled successfully.');
        res.redirect('/orders/my-orders');

    } catch (error) {
         console.error("Order Cancellation Error:", error);
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid order ID format.');
         } else {
            req.flash('error_msg', 'Failed to cancel the order due to an internal error.');
         }
         res.redirect('/orders/my-orders');
    }
};


// --- Get User's Orders ---
exports.getMyOrders = async (req, res, next) => {
    try {
        const orders = await Order.find({ userId: req.session.user._id })
                                   .select('+cancellationReason')
                                   .sort({ orderDate: -1 })
                                   .lean();

         const now = Date.now();
        orders.forEach(order => {
            order.isCancellable = order.status === 'Pending' && order.cancellationAllowedUntil && now < new Date(order.cancellationAllowedUntil).getTime();
            order.formattedOrderDate = new Date(order.orderDate).toLocaleString();
            order.formattedReceivedDate = order.receivedByDate ? new Date(order.receivedByDate).toLocaleString() : 'N/A';
         });

        res.render('user/my-orders', {
            title: 'My Orders',
            orders: orders
        });
    } catch (error) {
        console.error("Error fetching user orders:", error);
        next(error);
    }
};

// --- REMOVED Admin Verification Helpers ---
// exports.verifyOrderWithOTP = ...
// exports.generateAndSendOrderVerificationOTP = ...


// --- NEW: Generate OTP for ADMIN Direct Delivery ---
// Sends OTP to customer, intended for admin to use for immediate delivery confirmation
exports.generateAndSendDirectDeliveryOTPByAdmin = async (orderId) => {
     try {
         const order = await Order.findById(orderId);
         if (!order) throw new Error('Order not found.');
         // Admin can only trigger this if the order is Pending
         if (order.status !== 'Pending') throw new Error(`Cannot confirm direct delivery for order with status '${order.status}'. Must be 'Pending'.`);

        const otp = generateOTP();
         const otpExpires = setOTPExpiration(5); // Short expiry for immediate use
         order.orderOTP = otp;
         order.orderOTPExpires = otpExpires;
         await order.save();

         // Email to CUSTOMER for ADMIN direct delivery confirmation
         const subject = 'Confirming Delivery - Action Required';
         const text = `An administrator is ready to complete the delivery for your order (${order._id}).\nPlease provide them with the following OTP to confirm you have received your items: ${otp}\nIt will expire in 5 minutes.\nDo not share if you haven't received your items.`;
         const html = `<p>An administrator is ready to complete the delivery for your order (${order._id}).</p><p>Please provide the administrator with the following OTP to confirm you have received your items: <strong>${otp}</strong></p><p>The OTP will expire in 5 minutes.</p><p><strong>Only share this OTP once you have received your items from the administrator.</strong></p>`;

        // Ensure user exists before sending email
        const user = await User.findById(order.userId).select('email');
        if (!user) {
             order.orderOTP = undefined;
             order.orderOTPExpires = undefined;
             await order.save();
             throw new Error('Customer user account not found for sending OTP.');
         }

        const emailSent = await sendEmail(user.email, subject, text, html);
        if (!emailSent) {
            order.orderOTP = undefined;
            order.orderOTPExpires = undefined;
            await order.save(); // Rollback OTP
            throw new Error('Failed to send direct delivery confirmation OTP email to the customer.');
         }
        return { success: true, message: `Direct delivery confirmation OTP sent to customer ${user.email}.` };
    } catch (error) {
         console.error(`Error sending ADMIN Direct Delivery OTP for order ${orderId}:`, error);
         throw error; // Re-throw
     }
 };

// --- NEW: Verify OTP and Confirm Delivery Directly By Admin ---
// Used when an admin confirms delivery using OTP from customer for a 'Pending' order
exports.confirmDirectDeliveryByAdmin = async (orderId, adminUserId, providedOtp) => {
     try {
         const order = await Order.findOne({
            _id: orderId,
            status: 'Pending', // MUST be Pending for this flow
             orderOTP: providedOtp,
             orderOTPExpires: { $gt: Date.now() }
         });

         if (!order) {
            // Check specific reason for failure
            const checkOrder = await Order.findById(orderId);
            if (!checkOrder) throw new Error('Order not found.');
            if (checkOrder.status !== 'Pending') throw new Error(`Order status is '${checkOrder.status}', cannot confirm direct delivery from this state.`);
             // If we reach here, OTP is likely wrong/expired
             throw new Error('Invalid or expired OTP.');
        }

        // --- OTP Valid: Update Order ---
        order.status = 'Delivered';
        order.receivedByDate = new Date();
        order.assignedTo = adminUserId; // Record the admin who delivered it
        order.assignedAdminEmail = `AdminDirect: ${adminUserId}`; // Indicate admin direct delivery maybe? Or use the admin's email if fetched. Let's use adminUserId for now.

        // The pre-save hook will clear the OTP fields upon save
        await order.save();

        // --- Send Delivery Confirmation Email ---
        try {
             const subject = `Your Order Has Been Delivered!`;
             const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed by administration.</p><p>Received Date: ${order.receivedByDate.toLocaleString()}</p><p>Thank you for shopping with us!</p>`;
            await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
         } catch (emailError){
             console.error(`Failed sending direct delivery confirmation email for order ${order._id}:`, emailError);
         }
        return { success: true, order: order };
     } catch (error) {
         console.error(`Error verifying ADMIN Direct Delivery OTP for order ${orderId}:`, error);
        throw error; // Re-throw
    }
};


// --- DELIVERY PARTNER OTP Verification Helpers (No change needed in core logic) ---
exports.generateAndSendDeliveryOTP = async (orderId, deliveryAdminId) => {
    try {
        const order = await Order.findById(orderId);
        if (!order) throw new Error('Order not found.');
        if (!order.assignedTo || order.assignedTo.toString() !== deliveryAdminId.toString()) throw new Error('Order is not assigned to you.');
        // Correct: Only allow for 'Out for Delivery' status for delivery partner flow
        if (order.status !== 'Out for Delivery') throw new Error(`Cannot send delivery OTP for order with status '${order.status}'. Must be 'Out for Delivery'.`);

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(5);
        order.orderOTP = otp;
        order.orderOTPExpires = otpExpires;
        await order.save();

        const subject = 'Delivery Confirmation OTP';
        const text = `Your delivery driver is ready to complete your order (${order._id}).\nPlease provide them with the following OTP to confirm delivery: ${otp}\nIt will expire in 5 minutes.\nDo not share if you haven't received your items.`;
        const html = `<p>Your delivery driver is ready to complete your order (${order._id}).</p><p>Please provide the driver with the following OTP to confirm you have received your items: <strong>${otp}</strong></p><p>The OTP will expire in 5 minutes.</p><p><strong>Only share this OTP once you have received your items.</strong></p>`;

        const emailSent = await sendEmail(order.userEmail, subject, text, html);
        if (!emailSent) {
            order.orderOTP = undefined;
            order.orderOTPExpires = undefined;
            await order.save();
            throw new Error('Failed to send delivery confirmation OTP email to the customer.');
        }
        return { success: true, message: `Delivery confirmation OTP sent to customer ${order.userEmail}.` };
    } catch (error) {
        console.error(`Error sending DELIVERY PARTNER OTP for order ${orderId}:`, error);
        throw error; // Re-throw
    }
};

exports.verifyDeliveryOTP = async (orderId, deliveryAdminId, providedOtp) => {
    try {
        const order = await Order.findOne({
           _id: orderId,
           assignedTo: deliveryAdminId,
           // Correct: Only verify for 'Out for Delivery' status in this function
           status: 'Out for Delivery',
            orderOTP: providedOtp,
            orderOTPExpires: { $gt: Date.now() }
       });

        if (!order) {
           const checkOrder = await Order.findById(orderId);
           if (!checkOrder) throw new Error('Order not found.');
           if (!checkOrder.assignedTo || checkOrder.assignedTo.toString() !== deliveryAdminId.toString()) throw new Error('Order not assigned to you.');
           if (checkOrder.status !== 'Out for Delivery') throw new Error(`Order status is '${checkOrder.status}', cannot mark as delivered via this method.`);
            throw new Error('Invalid or expired OTP.');
       }

       order.status = 'Delivered';
       order.receivedByDate = new Date();
       await order.save(); // pre-save hook clears OTP

       try{
            const subject = `Your Order Has Been Delivered!`;
            const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed.</p><p>Received Date: ${order.receivedByDate.toLocaleString()}</p><p>Thank you for shopping with us!</p>`;
           await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
        } catch (emailError){
            console.error(`Failed to send delivery confirmation email for order ${order._id}:`, emailError);
        }
       return { success: true, order: order };
    } catch (error) {
        console.error(`Error verifying DELIVERY PARTNER OTP for order ${orderId}:`, error);
       throw error; // Re-throw
   }
};
controllers/productController.js:
// controllers/productController.js
const Product = require('../models/Product');
const User = require('../models/User');

// getProducts remains the same...
exports.getProducts = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || '';
    let query = { stock: { $gt: 0 } };

    if (searchTerm) {
      // Escape regex special characters for safety
      const escapedSearchTerm = searchTerm.replace(/[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
      const regex = new RegExp(escapedSearchTerm, 'i');
      query.$or = [
         { name: regex },
         { category: regex },
         { specifications: regex }
      ];
    }

    const products = await Product.find(query).sort({ createdAt: -1 });

    res.render('products/index', {
      title: searchTerm ? `Search Results for "${searchTerm}"` : 'Home',
      products: products,
      searchTerm: searchTerm
    });
  } catch (error) {
    next(error);
  }
};


exports.getProductDetails = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) {
       const error = new Error('Product not found');
       error.status = 404;
       return next(error);
    }

    let userRating = null;
    if (req.session.user) {
       const ratingData = product.ratings.find(r => r.userId.toString() === req.session.user._id.toString());
       userRating = ratingData ? ratingData.rating : null;
    }

    // --- Calculate Rating Counts ---
    const ratingCounts = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
    let totalRatings = 0;
    if (product.ratings && product.ratings.length > 0) {
        totalRatings = product.ratings.length; // Use the actual array length for calculation
        product.ratings.forEach(r => {
            if (ratingCounts.hasOwnProperty(r.rating)) {
                ratingCounts[r.rating]++;
            }
        });
    }
    // Ensure totalRatings used for percentage calculation matches numReviews if available
    // This handles potential small discrepancies if numReviews wasn't updated perfectly
    const displayTotalRatings = product.numReviews || totalRatings;
    // --- End Calculation ---

    res.render('products/detail', {
      title: product.name,
      product: product,
      userRating: userRating,
      userCanRate: req.session.user ? true : false,
      ratingCounts: ratingCounts, // Pass the counts
      totalRatings: displayTotalRatings // Pass the total count for percentage calculation
    });
  } catch (error) {
       if (error.name === 'CastError') {
           const notFoundError = new Error('Product not found');
           notFoundError.status = 404;
           return next(notFoundError);
       }
    next(error);
  }
};

// rateProduct remains the same...
 exports.rateProduct = async (req, res, next) => {
     const { rating } = req.body;
    const productId = req.params.id;
    const userId = req.session.user._id;

     if (!rating || rating < 1 || rating > 5) {
         req.flash('error_msg', 'Please provide a valid rating between 1 and 5.');
        return res.redirect(`/products/${productId}`);
     }

    try {
        const product = await Product.findById(productId);

         if (!product) {
             req.flash('error_msg', 'Product not found.');
             return res.status(404).redirect('/');
         }

         const existingRatingIndex = product.ratings.findIndex(r => r.userId.toString() === userId.toString());

         if (existingRatingIndex > -1) {
            // Update existing rating
            product.ratings[existingRatingIndex].rating = Number(rating);
             // Optionally update timestamp if RatingSchema has timestamps:true
             // product.ratings[existingRatingIndex].updatedAt = new Date();
         } else {
            // Add new rating
            product.ratings.push({ userId, rating: Number(rating) });
        }

        // Pre-save hook in Product.js will recalculate averageRating and numReviews
        await product.save();

         req.flash('success_msg', 'Thank you for your rating!');
         res.redirect(`/products/${productId}`);

     } catch (error) {
        next(error);
     }
 };
controllers/userController.js:
// controllers/userController.js
const User = require('../models/User');
const Product = require('../models/Product');

// --- NEW: Get User Profile Page ---
exports.getUserProfilePage = async (req, res, next) => {
    try {
        const userId = req.session.user._id;
        // Select necessary fields including role and address
        const user = await User.findById(userId).select('name email role address').lean();

        if (!user) {
            req.flash('error_msg', 'User not found. Please log in again.');
            return req.session.destroy(err => {
                if (err) return next(err);
                res.redirect('/auth/login');
            });
        }

        res.render('user/profile', {
            title: 'My Profile',
            user: user // Pass the user object to the view
        });

    } catch (error) {
        next(error);
    }
};
// --- END NEW FUNCTION ---

// --- Modify saveAddress to handle redirection ---
exports.saveAddress = async (req, res, next) => {
    // --- ADD source field ---
    const { name, phone, pincode, cityVillage, landmarkNearby, source } = req.body;
    const userId = req.session.user._id;

    // Determine the redirect path based on the source
    const redirectPath = (source === 'profile') ? '/user/profile' : '/user/checkout';

    // Basic validation for required fields
    if (!name || !phone || !pincode || !cityVillage) {
        req.flash('error_msg', 'Please provide Name, Phone, Pincode, and City/Village.');
        // Redirect back to the determined path
        return res.redirect(redirectPath);
    }

    // Phone number validation (simple example: 10-15 digits)
    if (!/^\d{10,15}$/.test(phone.trim())) {
        req.flash('error_msg', 'Please enter a valid phone number (10-15 digits, numbers only).');
        return res.redirect(redirectPath);
    }
    // Pincode validation (simple example: 6 digits)
     if (!/^\d{6}$/.test(pincode.trim())) {
        req.flash('error_msg', 'Please enter a valid 6-digit pincode.');
        return res.redirect(redirectPath);
    }


    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return res.redirect('/auth/login');
        }

        // Update or set the address subdocument
        user.address = {
            name: name.trim(),
            phone: phone.trim(),
            pincode: pincode.trim(),
            cityVillage: cityVillage.trim(),
            landmarkNearby: landmarkNearby ? landmarkNearby.trim() : ''
        };

        await user.save(); // Validate and save the user document

        // Update session with the new address
        req.session.user.address = user.address;
        await req.session.save(); // Save session

        req.flash('success_msg', 'Address saved successfully.');
        // Redirect back to the determined path after saving
        res.redirect(redirectPath);

    } catch (error) {
        if (error.name === 'ValidationError') {
            // Extract and flash validation errors
            let errors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', errors.join(' '));
            return res.redirect(redirectPath);
        }
        next(error); // Pass other errors to handler
    }
};
// --- END MODIFICATION ---


// --- Existing Cart functions remain the same ---
exports.getCart = async (req, res, next) => {
    // ... (keep existing code)
    try {
        const user = await User.findById(req.session.user._id)
                                    .populate('cart.productId')
                                    .lean();

        if (!user) {
           req.flash('error_msg', 'User not found.');
           // Ensure session is destroyed before redirecting if user is invalid
           return req.session.destroy(err => {
                if(err) return next(err);
                res.redirect('/auth/login');
           });
         }

        let cartTotal = 0;
        const populatedCart = user.cart.map(item => {
             if (!item.productId) {
                 console.warn(`Cart item refers to a non-existent product ID: ${item._id} for user: ${user.email}`);
                 // Optionally remove invalid item from cart here
                 // User.updateOne({ _id: user._id }, { $pull: { cart: { _id: item._id } } }).catch(console.error);
                 return null;
             }
            const itemSubtotal = item.productId.price * item.quantity;
            cartTotal += itemSubtotal;
            return {
                // Ensure all necessary fields for the view are included
                _id: item._id, // Might be needed if you have specific item operations
                productId: item.productId._id,
                name: item.productId.name,
                price: item.productId.price,
                imageUrl: item.productId.imageUrl,
                stock: item.productId.stock,
                quantity: item.quantity,
                subtotal: itemSubtotal
            };
         }).filter(item => item !== null); // Filter out null items (invalid products)

         // Update session cart (important if items were filtered)
         req.session.user.cart = user.cart.filter(item => item.productId); // Store only valid items in session

        res.render('user/cart', {
          title: 'Your Shopping Cart',
          cart: populatedCart, // Pass the processed cart data
          cartTotal: cartTotal
        });
      } catch (error) {
        next(error);
      }
};

exports.addToCart = async (req, res, next) => {
    // ... (keep existing code)
    const { productId, quantity = 1 } = req.body;
      const userId = req.session.user._id;
       const numQuantity = parseInt(quantity, 10);


        if (!productId || isNaN(numQuantity) || numQuantity < 1) {
           req.flash('error_msg', 'Invalid product or quantity.');
           // Redirect back to the product page or home if referer is missing/invalid
           return res.redirect(req.headers.referer && req.headers.referer.includes('/products/') ? req.headers.referer : '/');
       }

      try {
          const product = await Product.findById(productId);
          const user = await User.findById(userId); // Fetch the user document

          if (!user) {
              req.flash('error_msg', 'User session error. Please log in again.');
              return res.redirect('/auth/login');
          }
          if (!product) {
              req.flash('error_msg', 'Product not found.');
              // Redirect back safely
              return res.redirect(req.headers.referer && req.headers.referer.includes('/products/') ? req.headers.referer : '/');
          }

         if (product.stock < numQuantity) {
              req.flash('error_msg', `Insufficient stock for ${product.name}. Only ${product.stock} available.`);
              return res.redirect(`/products/${productId}`); // Redirect specifically to product detail
          }

         const existingCartItemIndex = user.cart.findIndex(item => item.productId.toString() === productId.toString());

         if (existingCartItemIndex > -1) {
             // Item exists, update quantity
             const existingQuantity = user.cart[existingCartItemIndex].quantity;
             const newQuantity = existingQuantity + numQuantity;
              if (product.stock < newQuantity) {
                 req.flash('error_msg', `Cannot add ${numQuantity} more ${product.name}. Only ${product.stock} available in total, you have ${existingQuantity} in cart.`);
                  return res.redirect(`/products/${productId}`);
             }
              user.cart[existingCartItemIndex].quantity = newQuantity;
         } else {
             // Item does not exist, add new item
             user.cart.push({ productId, quantity: numQuantity });
         }

          await user.save(); // Save the updated user document

         // Update the cart in the session
         req.session.user.cart = user.cart;
         await req.session.save(); // Ensure session is saved before redirect

          req.flash('success_msg', `${product.name} added to cart!`);

           // Handle redirection based on potential query parameter from 'Buy Now'
           if(req.query.redirectTo === 'checkout') {
              return res.redirect('/user/checkout'); // Correct checkout path
          }
          // --- FIX: Redirect to the correct cart path ---
          res.redirect('/user/cart');
          // --- END FIX ---

      } catch (error) {
           if (error.name === 'CastError') {
              req.flash('error_msg', 'Invalid product ID format.');
               return res.redirect('/'); // Redirect home on invalid ID
            }
          next(error);
      }
};

exports.updateCartQuantity = async (req, res, next) => {
    // ... (keep existing code)
         const { productId, quantity } = req.body;
         const userId = req.session.user._id;
        const numQuantity = parseInt(quantity, 10);


          if (!productId || isNaN(numQuantity) || numQuantity < 0) { // Allow 0 for removal
              return res.status(400).json({ success: false, message: 'Invalid product ID or quantity.' });
         }

        try {
            const user = await User.findById(userId);
             const product = await Product.findById(productId).select('stock price'); // Only fetch needed fields

             if (!user || !product) {
                return res.status(404).json({ success: false, message: 'User or Product not found.' });
             }

             const cartItemIndex = user.cart.findIndex(item => item.productId.toString() === productId.toString());

            if (cartItemIndex === -1 && numQuantity > 0) { // Don't error if trying to remove non-existent item
                return res.status(404).json({ success: false, message: 'Item not found in cart.' });
            }

             let itemSubtotal = 0; // Initialize subtotal

             if (numQuantity === 0) {
                 if(cartItemIndex > -1){ // Only splice if item exists
                     user.cart.splice(cartItemIndex, 1);
                 }
             } else { // numQuantity > 0
                if (product.stock < numQuantity) {
                   return res.status(400).json({ success: false, message: `Insufficient stock. Only ${product.stock} available.` });
                 }
                 if(cartItemIndex > -1){
                     user.cart[cartItemIndex].quantity = numQuantity;
                 } else {
                     // Should not happen if validation is correct, but handle defensively
                     user.cart.push({ productId, quantity: numQuantity });
                 }
                 itemSubtotal = (product.price * numQuantity); // Calculate subtotal only if quantity > 0
            }

            await user.save(); // Save the updated user document

            // Update session cart
            req.session.user.cart = user.cart;

            // Recalculate total AFTER saving and potentially fetching again or using current data
             let cartTotal = 0;
             // Need product prices for recalculation. Fetch populated cart or calculate based on saved data.
             // Easiest might be to calculate from current user.cart if product data is consistent.
             // Let's assume we need prices - fetch populated cart for accurate total.
             const updatedUserPopulated = await User.findById(userId).populate('cart.productId', 'price').lean(); // Fetch only price needed for total
             updatedUserPopulated.cart.forEach(item => {
                if(item.productId){
                    cartTotal += (item.productId.price * item.quantity);
                }
             });

             await req.session.save(); // Ensure session updated before sending response

            res.json({
                 success: true,
                 message: 'Cart updated successfully.',
                 // Return the new quantity from the updated cart data
                 newQuantity: user.cart.find(item => item.productId.toString() === productId.toString())?.quantity ?? 0, // Use nullish coalescing
                 itemSubtotal: itemSubtotal, // Use calculated subtotal
                 cartTotal: cartTotal, // Use recalculated total
                 itemId: productId
             });

        } catch (error) {
            console.error("Cart Update Error:", error);
            res.status(500).json({ success: false, message: 'Error updating cart quantity.' });
        }
};

exports.removeFromCart = async (req, res, next) => {
    // ... (keep existing code)
    const { productId } = req.params; // Get productId from URL params
        const userId = req.session.user._id;

        if (!productId) {
           // This case should ideally not happen if the route is defined correctly
           req.flash('error_msg', 'Product ID is required.');
           // --- FIX: Redirect to the correct cart path ---
           return res.redirect('/user/cart');
           // --- END FIX ---
         }

        try {
            const user = await User.findById(userId);
             if (!user) {
                 req.flash('error_msg', 'User not found.');
                return res.redirect('/auth/login');
            }

             const initialCartLength = user.cart.length;

            // Filter out the item to remove
            user.cart = user.cart.filter(item => item.productId.toString() !== productId.toString());

             // Check if an item was actually removed
             if(user.cart.length === initialCartLength){
                // Item wasn't in the cart in the first place
                req.flash('error_msg', 'Item not found in cart.');
                // --- FIX: Redirect to the correct cart path ---
                return res.redirect('/user/cart');
                // --- END FIX ---
             }

            // Save the user document with the updated cart
            await user.save();

             // Update the session cart
             req.session.user.cart = user.cart;
             await req.session.save(); // Ensure session is saved

             req.flash('success_msg', 'Item removed from cart.');
             // --- FIX: Redirect to the correct cart path ---
             res.redirect('/user/cart');
             // --- END FIX ---

        } catch (error) {
           if (error.name === 'CastError') {
              req.flash('error_msg', 'Invalid product ID format.');
               // --- FIX: Redirect to the correct cart path ---
               return res.redirect('/user/cart');
               // --- END FIX ---
           }
            next(error); // Pass other errors to the handler
        }
};

exports.getCheckoutPage = async (req, res, next) => {
    // ... (keep existing code)
     try {
        const user = await User.findById(req.session.user._id)
                               .populate('cart.productId') // Populate product details
                               .lean(); // Use lean for read-only rendering

        // Check if user exists and has items in cart
        if (!user || !user.cart || user.cart.length === 0) {
            req.flash('error_msg', 'Your cart is empty or user session is invalid.');
            // --- FIX: Redirect to the correct cart path ---
            return res.redirect('/user/cart');
            // --- END FIX ---
        }

        let subTotal = 0;
         let checkoutItems = [];
         let insufficientStock = false;

        // Process cart items for checkout display and stock check
        for (const item of user.cart) {
            if (!item.productId) {
                console.warn(`Invalid product reference in cart for user ${user.email}, item: ${item._id}`);
                // Optionally remove invalid item from cart here before proceeding
                continue; // Skip this invalid item
            }
             // Check stock level against cart quantity
             if(item.productId.stock < item.quantity){
                 insufficientStock = true;
                // Add a specific message for the item with insufficient stock
                req.flash('error_msg', `Insufficient stock for ${item.productId.name}. Available: ${item.productId.stock}, In cart: ${item.quantity}. Please update your cart.`);
             }

             // Calculate item total and add to subtotal
             const itemTotal = item.productId.price * item.quantity;
             subTotal += itemTotal;

             // Prepare item data for rendering in checkout summary
            checkoutItems.push({
                productId: item.productId._id,
                name: item.productId.name,
                price: item.productId.price,
                imageUrl: item.productId.imageUrl,
                quantity: item.quantity,
                stock: item.productId.stock, // Pass stock info if needed in view
                itemTotal: itemTotal
             });
        }

         // If any item has insufficient stock, redirect back to cart with flash messages
         if (insufficientStock) {
             // --- FIX: Redirect to the correct cart path ---
             return res.redirect('/user/cart');
             // --- END FIX ---
         }

         // Calculate total amount (can add shipping, taxes here later if needed)
         const totalAmount = subTotal;


        // Render the checkout page with necessary data
        res.render('user/checkout', {
            title: 'Checkout',
            userAddress: user.address, // Pass saved address (or null if none)
            items: checkoutItems, // Pass processed items for summary
            subTotal: subTotal,
            totalAmount: totalAmount,
            paymentMethod: 'COD' // Default or selected payment method
        });

    } catch (error) {
        next(error); // Pass errors to the main error handler
    }
};


middleware/authMiddleware.js:
const User = require('../models/User');

const isAuthenticated = (req, res, next) => {
    if (req.session && req.session.user) {
        User.findById(req.session.user._id).then(user => {
            if (!user) {
                req.session.destroy(err => {
                    if (err) {
                        console.error('Session destruction error:', err);
                        return next(err);
                    }
                    req.flash('error_msg', 'Session expired or user not found. Please login again.');
                    res.redirect('/auth/login');
                });
            } else {
                req.user = user;
                res.locals.currentUser = user;
                next();
            }
        }).catch(err => {
            console.error("Error checking user authentication:", err);
            req.flash('error_msg', 'An error occurred during authentication.');
            res.redirect('/auth/login');
        });
    } else {
        req.flash('error_msg', 'You must be logged in to view this page.');
        req.session.returnTo = req.originalUrl;
        res.redirect('/auth/login');
    }
};

module.exports = { isAuthenticated };

middleware/deliveryMiddleware.js:
// middleware/deliveryMiddleware.js

const hasPhoneNumber = (req, res, next) => {
    // Check if the user is a delivery_admin and if they have a phone number saved
    if (req.session.user && req.session.user.role === 'delivery_admin') {
      // Access phone number safely using optional chaining
      const phoneNumber = req.session.user.address?.phone;
  
      if (phoneNumber && phoneNumber.trim() !== '') {
        // Phone number exists, allow access
        return next();
      } else {
        // No phone number, redirect to contact page
        // Check if already on the contact page to prevent redirect loop
        if (req.originalUrl !== '/delivery/contact') {
             req.flash('error_msg', 'Please add your phone number before accessing delivery features.');
             return res.redirect('/delivery/contact');
         } else {
             // Already on contact page, just proceed
              return next();
         }
      }
    } else {
      // Not a delivery admin or no session user (should be caught by earlier middleware, but handle defensively)
      req.flash('error_msg', 'Access Denied.');
      res.redirect('/');
    }
  };
  
  module.exports = { hasPhoneNumber };
middleware/errorMiddleware.js:
const notFound = (req, res, next) => {
  const error = new Error(`Not Found - ${req.originalUrl}`);
  res.status(404);
  next(error);
};

const errorHandler = (err, req, res, next) => {
  let statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  let message = err.message;

  if (err.name === 'CastError' && err.kind === 'ObjectId') {
    statusCode = 404;
    message = 'Resource not found';
  }
   if (err.name === 'ValidationError') {
       statusCode = 400;
       const errors = Object.values(err.errors).map(el => el.message);
       message = `Validation Error: ${errors.join(', ')}`;
   }
    if (err.code === 11000) {
       statusCode = 400;
       message = `Duplicate field value entered: ${Object.keys(err.keyValue)} already exists.`;
    }


  console.error("ERROR STACK: ", err.stack);

  if (req.accepts('html')) {
      res.status(statusCode).render('error', {
          title: 'Error',
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
          statusCode: statusCode
      });
  } else {
      res.status(statusCode).json({
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
      });
  }
};

module.exports = { notFound, errorHandler };

middleware/roleMiddleware.js:
const isAdmin = (req, res, next) => {
  if (req.session.user && req.session.user.role === 'admin') {
    next();
  } else {
    req.flash('error_msg', 'Access Denied: Admin privileges required.');
    res.status(403).redirect('/');
  }
};

const isDeliveryAdmin = (req, res, next) => {
  if (req.session.user && req.session.user.role === 'delivery_admin') {
    next();
  } else {
    req.flash('error_msg', 'Access Denied: Delivery Admin privileges required.');
    res.status(403).redirect('/');
  }
};

const isAdminOrDeliveryAdmin = (req, res, next) => {
    if (req.session.user && (req.session.user.role === 'admin' || req.session.user.role === 'delivery_admin')) {
      next();
    } else {
      req.flash('error_msg', 'Access Denied: Admin or Delivery Admin privileges required.');
      res.status(403).redirect('/');
    }
}

module.exports = { isAdmin, isDeliveryAdmin, isAdminOrDeliveryAdmin };

models/Order.js:
// models/Order.js
const mongoose = require('mongoose');

const OrderProductSchema = new mongoose.Schema({
    productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
    name: { type: String, required: true },
    priceAtOrder: { type: Number, required: true },
    quantity: { type: Number, required: true, min: 1 },
    imageUrl: { type: String }
}, { _id: false });

const OrderAddressSchema = new mongoose.Schema({
    name: { type: String, trim: true, required: true },
    phone: { type: String, trim: true, required: true },
    pincode: { type: String, trim: true, required: true },
    cityVillage: { type: String, trim: true, required: true },
    landmarkNearby: { type: String, trim: true },
}, { _id: false });


const OrderSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
    },
    userEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    products: [OrderProductSchema],
    totalAmount: {
        type: Number,
        required: true,
        min: 0,
    },
    shippingAddress: {
        type: OrderAddressSchema,
        required: true
    },
    paymentMethod: {
        type: String,
        enum: ['COD'],
        required: true,
        default: 'COD',
    },
    status: {
        type: String,
        // --- REMOVED 'Order Received' ---
        enum: ['Pending', 'Out for Delivery', 'Delivered', 'Cancelled'],
        // -------------------------------
        default: 'Pending',
    },
    orderDate: {
        type: Date,
        default: Date.now,
    },
    receivedByDate: {
        type: Date,
    },
    assignedTo: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        default: null,
    },
    assignedAdminEmail: {
        type: String,
        lowercase: true,
        trim: true,
        default: null,
    },

    orderOTP: String, // Will now be used for direct admin delivery OR delivery partner delivery
    orderOTPExpires: Date,

    cancellationAllowedUntil: {
        type: Date,
    },
    cancellationReason: {
        type: String,
        trim: true,
    }
}, {
    timestamps: true
});

OrderSchema.pre('save', function(next) {
    // Set customer cancellation window only for new orders
    if (this.isNew && !this.cancellationAllowedUntil) {
        const now = this.orderDate || Date.now();
        // Allow customer cancellation for 1 hour after placement
        this.cancellationAllowedUntil = new Date(now.getTime() + 60 * 60 * 1000);
    }

    // Clear fields when order is cancelled
    if (this.isModified('status') && this.status === 'Cancelled') {
        this.assignedTo = undefined;
        this.assignedAdminEmail = undefined;
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
        this.receivedByDate = undefined;
        this.cancellationAllowedUntil = undefined; // Prevent further user cancellation
    }

    // --- UPDATED: Clear OTP if status changes away from states where *delivery* OTP is relevant ---
    // OTP is relevant in 'Pending' (for potential admin direct delivery) or 'Out for Delivery' (for partner delivery)
    const otpRelevantStatuses = ['Pending', 'Out for Delivery'];
    if (this.isModified('status') && !otpRelevantStatuses.includes(this.status)) {
         this.orderOTP = undefined;
         this.orderOTPExpires = undefined;
    }
    // Clear OTP if status becomes Delivered or Cancelled, even if not modified previously in this save op
    // (e.g., ensures OTP is gone after successful delivery)
    if (this.status === 'Delivered' || this.status === 'Cancelled') {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
    }


    next();
});

const Order = mongoose.model('Order', OrderSchema);

module.exports = Order;
models/Product.js:
const mongoose = require('mongoose');

const RatingSchema = new mongoose.Schema({
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    rating: { type: Number, required: true, min: 1, max: 5 },
    comment: { type: String, trim: true },
}, { _id: false, timestamps: true });


const ProductSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide a product name'],
        trim: true,
    },
    category: {
        type: String,
        required: [true, 'Please provide a product category'],
        trim: true,
    },
    price: {
        type: Number,
        required: [true, 'Please provide a product price'],
        min: 0,
    },
    stock: {
        type: Number,
        required: [true, 'Please provide product stock quantity'],
        min: 0,
        default: 0,
    },
    imageUrl: {
        type: String,
        required: [true, 'Please provide a product image URL'],
        trim: true,
    },
    specifications: {
        type: String,
        trim: true,
    },
    sellerEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    ratings: [RatingSchema],
    averageRating: {
      type: Number,
      default: 0,
    },
    numReviews: {
        type: Number,
        default: 0,
    },
    orderCount: {
        type: Number,
        default: 0,
    }
}, {
    timestamps: true
});

ProductSchema.pre('save', function(next) {
    if (this.ratings && this.ratings.length > 0) {
        this.numReviews = this.ratings.length;
        this.averageRating = this.ratings.reduce((acc, item) => item.rating + acc, 0) / this.ratings.length;
    } else {
        this.numReviews = 0;
        this.averageRating = 0;
    }
    next();
});


const Product = mongoose.model('Product', ProductSchema);

module.exports = Product;

models/User.js:
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const AddressSchema = new mongoose.Schema({
    name: { type: String, trim: true },
    phone: { type: String, trim: true },
    pincode: { type: String, trim: true },
    cityVillage: { type: String, trim: true },
    landmarkNearby: { type: String, trim: true },
}, { _id: false });

const CartItemSchema = new mongoose.Schema({
    productId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Product',
        required: true,
    },
    quantity: {
        type: Number,
        required: true,
        min: 1,
        default: 1,
    }
}, { _id: false });

const UserSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide your name'],
        trim: true,
    },
    email: {
        type: String,
        required: [true, 'Please provide your email'],
        unique: true,
        match: [
            /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            'Please provide a valid email address',
        ],
        lowercase: true,
        trim: true,
    },
    password: {
        type: String,
        required: [true, 'Please provide a password'],
        minlength: 6,
        select: false,
    },
    role: {
        type: String,
        enum: ['user', 'admin', 'delivery_admin'],
        default: 'user',
    },
    isVerified: {
        type: Boolean,
        default: false,
    },
    otp: { type: String },
    otpExpires: { type: Date },
    address: AddressSchema,
    cart: [CartItemSchema],

    resetPasswordToken: String,
    resetPasswordExpires: Date,
}, {
    timestamps: true
});

UserSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();

    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
});

UserSchema.methods.matchPassword = async function(enteredPassword) {
    return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', UserSchema);

module.exports = User;

public/css/style.css:
/* public/css/style.css */

/* --- Base & Resets --- */
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --primary-color: #007bff;
  --primary-hover: #0056b3;
  --secondary-color: #6c757d;
  --secondary-hover: #5a6268;
  --success-color: #28a745;
  --success-hover: #218838;
  --danger-color: #dc3545;
  --danger-hover: #c82333;
  --warning-color: #ffc107;
  --warning-hover: #e0a800;
  --info-color: #17a2b8;
  --info-hover: #138496;
  --light-color: #f8f9fa;
  --dark-color: #343a40;
  --text-color: #333;
  --link-color: var(--primary-color);
  --bg-color: #fff;
  --border-color: #dee2e6;
  --card-bg: #ffffff;
  --card-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  --border-radius: 0.25rem;
  --spacing-unit: 1rem; /* 16px default */
}

html {
  font-size: 16px; /* Base font size */
  scroll-behavior: smooth;
}

body {
  font-family: 'Roboto', sans-serif;
  line-height: 1.6;
  color: var(--text-color);
  background-color: var(--bg-color);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

a {
  color: var(--link-color);
  text-decoration: none;
  transition: color 0.2s ease-in-out;
}

a:hover {
  color: var(--primary-hover);
  text-decoration: underline;
}

img {
  max-width: 100%;
  height: auto;
  display: block;
}

h1, h2, h3, h4, h5, h6 {
  margin-bottom: calc(var(--spacing-unit) * 0.75);
  line-height: 1.3;
  font-weight: 500;
}

p {
  margin-bottom: var(--spacing-unit);
}

ul, ol {
    margin-bottom: var(--spacing-unit);
    padding-left: calc(var(--spacing-unit) * 1.5); /* Indentation for lists */
}

/* --- Utility Classes --- */
.hidden {
  display: none !important;
}
.text-center {
  text-align: center;
}
.text-danger {
  color: var(--danger-color) !important;
}
.text-success {
  color: var(--success-color) !important;
}
.text-warning {
    color: var(--warning-color) !important;
}
.text-info {
    color: var(--info-color) !important;
}
.text-muted {
  color: var(--secondary-color) !important;
}
.mb-1 { margin-bottom: calc(var(--spacing-unit) * 0.25) !important; }
.mb-2 { margin-bottom: calc(var(--spacing-unit) * 0.5) !important; }
.mb-3 { margin-bottom: var(--spacing-unit) !important; }
.mt-1 { margin-top: calc(var(--spacing-unit) * 0.25) !important; }
.mt-2 { margin-top: calc(var(--spacing-unit) * 0.5) !important; }
.mt-3 { margin-top: var(--spacing-unit) !important; }
.d-block { display: block !important; }
.small { font-size: 0.875em; }

/* Make inline forms really inline on larger screens */
.inline-form {
    display: block; /* Stack elements vertically by default */
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.inline-form > * {
    margin-bottom: calc(var(--spacing-unit) * 0.25);
}


/* --- Forms --- */
.form-group {
  margin-bottom: calc(var(--spacing-unit) * 0.8);
}

label {
  display: block;
  margin-bottom: calc(var(--spacing-unit) * 0.3);
  font-weight: 500;
}

input[type="text"],
input[type="email"],
input[type="password"],
input[type="tel"],
input[type="url"],
input[type="number"],
input[type="search"],
textarea,
select {
  width: 100%;
  padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.75);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  font-size: 1rem;
  line-height: 1.5;
  background-color: #fff;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

input[type="number"] {
    appearance: textfield; /* Remove spinners in some browsers */
    -moz-appearance: textfield; /* Firefox */
}
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none; /* Remove spinners in Chrome/Safari */
  margin: 0;
}


textarea {
  resize: vertical;
  min-height: 80px;
}

input:focus,
textarea:focus,
select:focus {
  border-color: var(--primary-color);
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

/* --- Buttons --- */
.btn {
  display: inline-block;
  font-weight: 400;
  color: #fff; /* Default text color for colored buttons */
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  user-select: none;
  background-color: var(--primary-color);
  border: 1px solid var(--primary-color);
  padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit); /* Slightly larger padding for touch */
  font-size: 1rem;
  line-height: 1.5;
  border-radius: var(--border-radius);
  transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
  text-transform: capitalize;
}

.btn:hover {
  color: #fff;
  text-decoration: none;
  background-color: var(--primary-hover);
  border-color: var(--primary-hover);
}

.btn:focus {
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.5);
}

.btn:disabled {
  opacity: 0.65;
  cursor: not-allowed;
}

/* Button Variants */
.btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: #fff;}
.btn-primary:hover { background-color: var(--primary-hover); border-color: var(--primary-hover); }
.btn-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: #fff; }
.btn-secondary:hover { background-color: var(--secondary-hover); border-color: var(--secondary-hover); }
.btn-success { background-color: var(--success-color); border-color: var(--success-color); color: #fff;}
.btn-success:hover { background-color: var(--success-hover); border-color: var(--success-hover); }
.btn-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: #fff;}
.btn-danger:hover { background-color: var(--danger-hover); border-color: var(--danger-hover); }
.btn-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: #212529;}
.btn-warning:hover { background-color: var(--warning-hover); border-color: var(--warning-hover); }
.btn-info { background-color: var(--info-color); border-color: var(--info-color); color: #fff;}
.btn-info:hover { background-color: var(--info-hover); border-color: var(--info-hover); }
.btn-light { background-color: var(--light-color); border-color: var(--light-color); color: #212529;}
.btn-light:hover { background-color: #e2e6ea; border-color: #dae0e5; }
.btn-dark { background-color: var(--dark-color); border-color: var(--dark-color); color: #fff;}
.btn-dark:hover { background-color: #23272b; border-color: #1d2124; }

.btn-outline-secondary { color: var(--secondary-color); border-color: var(--secondary-color); background-color: transparent;}
.btn-outline-secondary:hover { color: #fff; background-color: var(--secondary-color); }

/* Icon-only or text buttons */
.btn-text {
    background-color: transparent;
    border-color: transparent;
    color: var(--link-color); /* Or specific color */
    padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.4);
}
.btn-text:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--primary-hover);
}
.btn-text.btn-danger { color: var(--danger-color); }
.btn-text.btn-danger:hover { color: var(--danger-hover); }


.btn-sm {
  padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.5);
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: calc(var(--border-radius) * 0.8);
}
.btn-lg {
    padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.25);
    font-size: 1.1rem;
}

.btn-block {
    display: block;
    width: 100%;
}

/* Button Spinner */
.btn .fa-spinner {
    margin-right: calc(var(--spacing-unit) * 0.25);
    animation: fa-spin 1s infinite linear;
}
@keyframes fa-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* --- Alerts & Messages --- */
.alert {
  padding: calc(var(--spacing-unit) * 0.8) var(--spacing-unit);
  margin-bottom: var(--spacing-unit);
  border: 1px solid transparent;
  border-radius: var(--border-radius);
  position: relative;
  opacity: 0.95;
}
.alert-success { color: #155724; background-color: #d4edda; border-color: #c3e6cb; }
.alert-danger { color: #721c24; background-color: #f8d7da; border-color: #f5c6cb; }
.alert-warning { color: #856404; background-color: #fff3cd; border-color: #ffeeba; }
.alert-info { color: #0c5460; background-color: #d1ecf1; border-color: #bee5eb; }

.close-alert {
  position: absolute;
  top: 5px;
  right: 10px;
  font-size: 1.2rem;
  background: none;
  border: none;
  color: inherit;
  opacity: 0.7;
  cursor: pointer;
}
.close-alert:hover {
  opacity: 1;
}


/* --- Header & Navigation --- */
.app-header {
  background-color: var( --primary-color);
  color: var(--light-color);
  padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
  position: sticky; /* Make header sticky */
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1200px; /* Limit width on large screens */
  margin: 0 auto; /* Center */
}

.nav-left, .nav-right {
  display: flex;
  align-items: center;
}
.nav-right {
    gap: calc(var(--spacing-unit) * 0.5); /* Spacing between right nav items */
}

.app-logo {
  display: flex;
  align-items: center;
  color: var(--light-color);
  font-size: 1.2rem;
  font-weight: 500;
  margin-right: var(--spacing-unit);
}
.app-logo:hover {
  color: var(--warning-color);
  text-decoration: none;
}
.app-logo i {
  margin-right: calc(var(--spacing-unit) * 0.3);
}

/* Hide text links on mobile initially, show icons */
.nav-link {
  color: var(--light-color);
  padding: calc(var(--spacing-unit) * 0.4) calc(var(--spacing-unit) * 0.6);
  border-radius: var(--border-radius);
  display: flex;
  flex-direction: column; /* Stack icon and text */
  align-items: center;
  font-size: 0.75rem; /* Smaller text for mobile */
  text-decoration: none;
}
.nav-link span {
  display: none; /* Hide text on mobile */
}
.nav-link i {
    font-size: 1.1rem; /* Icon size */
    margin-bottom: 2px;
}

.nav-link:hover,
.nav-link.active {
  background-color: rgba(255, 255, 255, 0.1);
  color: #fff;
  text-decoration: none;
}

.nav-link-cart {
    position: relative;
}
.cart-badge {
  position: absolute;
  top: -2px;
  right: -5px;
  background-color: var(--danger-color);
  color: white;
  border-radius: 50%;
  padding: 1px 5px;
  font-size: 0.7rem;
  font-weight: bold;
  line-height: 1;
}

.btn-login-register { /* Simplify login button */
    font-size: 0.9rem;
    padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.8);
}

/* Header Avatar Link */
.profile-avatar-link {
    display: inline-flex; /* Use flex to center content */
    align-items: center;
    justify-content: center;
    width: 38px; /* Adjust size as needed */
    height: 38px;
    border-radius: 50%; /* Make it circular */
    background-color: var(--light-color); /* Or use a different color */
    color:black;
    font-weight: bold;
    font-size: 0.9rem; /* Adjust font size */
    text-decoration: none;
    transition: background-color 0.2s ease;
    margin-left: calc(var(--spacing-unit) * 0.5); /* Spacing from other nav items */
    border: 1px solid transparent; /* Placeholder for active state */
}

.profile-avatar-link:hover,
.profile-avatar-link.active {
    text-decoration: none;
    border-color: var(--light-color); /* Highlight active */
}

.profile-avatar-initials {
    line-height: 1; /* Helps vertical alignment */
}


/* --- Main Content --- */
.container {
  width: 100%;
  padding: var(--spacing-unit);
  margin: 0 auto;
  flex-grow: 1; /* Allows main content to take up available space */
  /* background-color: #f4f4f4; Add a subtle background if desired */
}

/* --- Footer --- */
.app-footer {
  padding: var(--spacing-unit);
  text-align: center;
  font-size: 0.85rem;
  color: var(--secondary-color);
  background-color: var(--light-color);
  border-top: 1px solid var(--border-color);
  margin-top: auto; /* Push footer to bottom */
}


/* --- Product Grid (Mobile: 2 columns) --- */
.product-index-container h1 {
    font-size: 1.5rem; /* Smaller heading on mobile */
}
.search-bar-container {
    margin-bottom: var(--spacing-unit);
}
.search-form {
    display: flex;
    align-items: center;
}
.search-form input[type="text"] {
    flex-grow: 1;
    border-radius: var(--border-radius) 0 0 var(--border-radius);
    border-right: none;
}
.search-form button {
    border-radius: 0 var(--border-radius) var(--border-radius) 0;
    padding: calc(var(--spacing-unit) * 0.6); /* Match input height */
}
.btn-clear-search {
    margin-left: calc(var(--spacing-unit) * 0.5);
    font-size: 0.9rem;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr); /* 2 columns on mobile */
  gap: calc(var(--spacing-unit) * 0.75);
}

.product-card {
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: var(--card-shadow);
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.product-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.product-link {
  color: inherit;
  text-decoration: none;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}

.product-link:hover{
  color: inherit;
  text-decoration: none;
}

.product-image {
  width: 100%;
  aspect-ratio: 1 / 1; /* Maintain square aspect ratio */
  object-fit: cover; /* Cover the area */
}

.product-info {
  padding: calc(var(--spacing-unit) * 0.6);
  flex-grow: 1; /* Push button to bottom */
}

.product-name {
  font-size: 0.95rem;
  font-weight: 500;
  margin-bottom: calc(var(--spacing-unit) * 0.25);
  line-height: 1.3;
  height: 2.6em; /* Limit to roughly 2 lines */
  overflow: hidden; /* Hide overflow */
}

.product-price {
  font-weight: 500;
  color: var(--success-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
  font-size: 1rem;
}

.product-stock,
.product-rating {
  font-size: 0.8rem;
  color: var(--secondary-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
}
.product-rating .fa-star, .product-rating .fa-star-half-alt {
    color: #f8d347; /* Gold color for stars */
}

.add-to-cart-form {
    padding: 0 calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.6); /* Pad only form */
}
.btn-add-to-cart {
  width: 100%; /* Full width button */
  padding: calc(var(--spacing-unit) * 0.5);
  font-size: 0.9rem;
}
.btn-add-to-cart i {
    margin-right: calc(var(--spacing-unit) * 0.25);
}

/* --- Product Detail --- */
.product-detail-container {
  background-color: var(--card-bg);
  padding: var(--spacing-unit);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
}
.product-detail-main {
    display: flex;
    flex-direction: column; /* Stack image/info vertically */
    gap: var(--spacing-unit);
}
.product-detail-image img {
    border-radius: 10px;
}
.product-detail-info h1 {
    font-size: 1.6rem;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.detail-price {
    font-size: 1.4rem;
    font-weight: bold;
    color: var(--success-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.detail-stock {
    font-size: 0.9rem;
    color: var(--secondary-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.detail-rating {
    margin-bottom: calc(var(--spacing-unit) * 0.75);
    color: var(--secondary-color);
}
.detail-rating i { color: #f8d347; }

.product-actions {
    margin: calc(var(--spacing-unit) * 1.2) 0;
    display: flex;
    flex-direction: column; /* Stack buttons */
    gap: calc(var(--spacing-unit) * 0.5);
}
.quantity-selector {
    display: flex;
    align-items: center;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
    max-width: 150px; /* Limit width */
}
.quantity-selector label {
    margin: 0 calc(var(--spacing-unit) * 0.4) 0 0;
    font-size: 0.9rem;
}
.quantity-selector input {
    text-align: center;
    font-size: 1rem;
    padding: calc(var(--spacing-unit) * 0.4);
}
.product-actions .btn {
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.6) var(--spacing-unit); /* Slightly larger buttons */
    font-size: 1rem;
}

.share-section { margin: calc(var(--spacing-unit) * 1.2) 0; }
.fallback-share-links { margin-top: 0.5rem; }
.fallback-share-links a { margin: 0 0.3rem; font-size: 1.5rem; }

.product-specifications { margin-top: calc(var(--spacing-unit) * 1.5); }
.product-specifications h3 { font-size: 1.1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3rem; margin-bottom: 0.5rem;}
.product-specifications pre {
    white-space: pre-wrap; /* Allow wrapping */
    font-size: 0.9rem;
    background-color: #f8f8f8;
    padding: calc(var(--spacing-unit) * 0.5);
    border-radius: var(--border-radius);
    max-height: 200px;
    overflow-y: auto;
}

.product-rating-section {
    margin-top: var(--spacing-unit);
    border-top: 1px solid var(--border-color);
    padding-top: var(--spacing-unit);
}
.product-rating-section h3 {
    margin-bottom: calc(var(--spacing-unit) * 0.6);
    font-size: 1.2em;
}

/* --- Corrected Rating Stars CSS for LTR Interaction --- */
.rating-stars {
  display: inline-flex; /* Use flexbox */
  flex-direction: row-reverse;
  justify-content: flex-end; /* Align items to the start (effectively left) */
  margin-bottom: calc(var(--spacing-unit) * 0.8);
}

.rating-stars input[type="radio"] {
  display: none; /* Hide the actual radio button */
}

.rating-stars label {
  display: inline-block; /* Needed for flex items */
  cursor: pointer;
  font-size: 1.8rem;
  color: lightgray; /* Default star color */
  padding: 0 0.1em;
  margin: 0;
  transition: color 0.2s ease-in-out;
}

/* Hover effect: Highlight stars up to the hovered one */
.rating-stars label:hover,
.rating-stars label:hover ~ label {
  color: #f8d347; /* Gold color */
}

/* Checked effect: Keep stars highlighted up to the checked one */
.rating-stars input[type="radio"]:checked ~ label {
  color: #f8d347; /* Gold color */
}
/* --- End Corrected Rating Stars CSS --- */


/* --- Auth Pages --- */
.auth-container {
  max-width: 450px; /* Slightly wider on mobile if needed */
  margin: var(--spacing-unit) auto;
  padding: var(--spacing-unit);
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
}
.auth-container h1 {
    font-size: 1.6rem;
    text-align: center;
    margin-bottom: var(--spacing-unit);
}
.auth-form .btn {
    width: 100%;
    margin-top: calc(var(--spacing-unit) * 0.5);
    padding: calc(var(--spacing-unit) * 0.7);
}
.auth-links {
    margin-top: var(--spacing-unit);
    font-size: 0.9rem;
    text-align: center;
}
.auth-links p {
    margin-bottom: calc(var(--spacing-unit) * 0.4);
}

/* Specific for OTP verify/resend */
.auth-container p { text-align: center; margin-bottom: var(--spacing-unit);}
.auth-container form ~ .auth-links { border-top: 1px solid var(--border-color); padding-top: var(--spacing-unit); }
#otp { text-align: center; font-size: 1.2rem; letter-spacing: 4px; }

/* --- Cart Page --- */
.cart-container h1 {
    font-size: 1.5rem;
    margin-bottom: var(--spacing-unit);
}

.cart-items {
  margin-bottom: var(--spacing-unit);
}

.cart-item {
  display: grid;
  grid-template-columns: 80px 1fr auto; /* Image, Details+Qty, Subtotal+Remove */
  grid-template-areas:
    "image details remove"
    "image quantity subtotal";
  gap: calc(var(--spacing-unit) * 0.75);
  background-color: var(--card-bg);
  padding: calc(var(--spacing-unit) * 0.75);
  border-bottom: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  margin-bottom: var(--spacing-unit);
  box-shadow: var(--card-shadow);
}

.cart-item-image { grid-area: image; align-self: center;}
.cart-item-image img {
    width: 80px;
    height: 80px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.5);
}
.cart-item-details { grid-area: details; }
.cart-item-quantity {
    grid-area: quantity;
    display: flex;
    align-items: center;
    gap: 0.3rem;
}
.cart-item-subtotal {
    grid-area: subtotal;
    text-align: right;
    font-weight: 500;
    align-self: center;
}
.cart-item-remove { grid-area: remove; text-align: right; align-self: start;}

.cart-item-name {
    font-size: 1rem;
    font-weight: 500;
    margin-bottom: calc(var(--spacing-unit) * 0.2);
}
.cart-item-price {
    font-size: 0.9rem;
    color: var(--secondary-color);
    margin-bottom: calc(var(--spacing-unit) * 0.2);
}
.cart-item-stock {
    font-size: 0.8rem;
    color: #6c757d;
}

.cart-item-quantity label {
    font-size: 0.9rem;
    margin-bottom: 0; /* Override form default */
    display: none; /* Hide label, implied by input position */
}
.cart-item-quantity input {
    width: 50px; /* Fixed width for qty input */
    padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.4);
    text-align: center;
    font-size: 0.9rem;
}
.cart-item-quantity .btn-update-qty {
    font-size: 0.8rem;
    padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.6);
}

.cart-item-subtotal {
    font-size: 0.9rem;
    white-space: nowrap;
}

.cart-item-remove .btn {
    padding: 0.1rem 0.4rem; /* Make remove smaller */
    font-size: 0.8rem;
    line-height: 1; /* Ensure 'x' fits nicely */
}

.cart-summary {
  margin-top: calc(var(--spacing-unit) * 1.5);
  padding: var(--spacing-unit);
  background-color: #f8f9fa;
  border-top: 2px solid var(--primary-color);
  border-radius: var(--border-radius);
  text-align: right;
}

.cart-summary h2 {
  font-size: 1.3rem;
  margin-bottom: calc(var(--spacing-unit) * 0.75);
}
.btn-checkout {
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.7);
    font-size: 1.1rem;
}

/* --- Checkout Page --- */
.checkout-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit);}

.checkout-grid {
    display: flex; /* Use flex for column layout on mobile */
    flex-direction: column;
    gap: var(--spacing-unit);
}

.checkout-address, .checkout-summary {
    background-color: var(--card-bg);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}
.checkout-address h2, .checkout-summary h2 {
    font-size: 1.2rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: calc(var(--spacing-unit) * 0.4);
    margin-bottom: var(--spacing-unit);
}
.saved-address { font-size: 0.95rem; margin-bottom: var(--spacing-unit); }
.saved-address p { margin-bottom: calc(var(--spacing-unit) * 0.2); line-height: 1.4; }
#edit-address-btn { margin-top: calc(var(--spacing-unit) * 0.5); }

/* The address form itself will use standard .form-group, label, input styles */
.address-form h3 { font-size: 1.1rem; }

.checkout-items {
    max-height: 200px; /* Limit height */
    overflow-y: auto;
    margin-bottom: var(--spacing-unit);
    padding-right: calc(var(--spacing-unit) * 0.5); /* space for scrollbar */
}
.checkout-item {
    display: flex;
    align-items: center;
    gap: calc(var(--spacing-unit) * 0.5);
    margin-bottom: calc(var(--spacing-unit) * 0.5);
    font-size: 0.9rem;
}
.checkout-item-image img {
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: 4px;
}
.checkout-item-info { flex-grow: 1; }
.checkout-item-price { font-weight: 500; white-space: nowrap;}

.checkout-totals { font-size: 0.95rem; }
.checkout-totals p {
    display: flex;
    justify-content: space-between;
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.checkout-totals hr { margin: calc(var(--spacing-unit) * 0.5) 0; border-color: var(--border-color); opacity: 0.5;}
.checkout-totals strong { font-weight: bold; }

.checkout-payment h3 { font-size: 1.1rem; margin: calc(var(--spacing-unit) * 1) 0 calc(var(--spacing-unit) * 0.5) 0; }
.payment-option { padding: 0.5rem; border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: #f0f0f0; opacity: 0.8; margin-bottom: 0.5rem; cursor: pointer;}
.payment-option.selected { border-color: var(--primary-color); opacity: 1; background-color: #e7f3ff; }
.payment-option label { font-weight: normal; display: flex; align-items: center; cursor: pointer; margin-bottom: 0; }
.payment-option input[type="radio"] { margin-right: 0.5rem; }
.payment-option i { margin-right: 0.3rem; color: var(--success-color);}

.place-order-form { margin-top: var(--spacing-unit); }
.btn-place-order {
    width: 100%;
    font-size: 1.1rem;
    padding: calc(var(--spacing-unit) * 0.7);
}

/* --- My Orders Page --- */
.my-orders-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit); }
.order-list {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-unit);
}
.order-card {
  background-color: var(--card-bg);
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color);
  box-shadow: var(--card-shadow);
  overflow: hidden;
}

.order-header {
  background-color: #f8f9fa;
  padding: calc(var(--spacing-unit) * 0.6);
  display: flex;
  flex-wrap: wrap; /* Allow wrapping on small screens */
  justify-content: space-between;
  font-size: 0.85rem;
  color: var(--secondary-color);
  border-bottom: 1px solid var(--border-color);
}
.order-header > div {
    margin-right: calc(var(--spacing-unit) * 0.8); /* Space between header items */
    margin-bottom: calc(var(--spacing-unit) * 0.2); /* Space if wraps */
    white-space: nowrap;
}
.order-header strong { color: var(--text-color); }
/* Use status-badge for consistency */
.order-status {
    display: inline-block;
    /* padding, font-size etc. inherited from status-badge */
}

.order-body {
  padding: calc(var(--spacing-unit) * 0.75);
  display: flex;
  flex-direction: column; /* Stack items/details on mobile */
  gap: calc(var(--spacing-unit) * 0.75);
}

.order-items-preview {
    display: flex;
    gap: calc(var(--spacing-unit) * 0.3);
    flex-wrap: wrap; /* Allow images to wrap */
}
.order-items-preview img {
    width: 50px;
    height: 50px;
    object-fit: cover;
    border-radius: 4px;
    border: 1px solid var(--border-color);
}
.more-items {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 50px;
    height: 50px;
    border: 1px dashed var(--border-color);
    border-radius: 4px;
    font-size: 0.8rem;
    color: var(--secondary-color);
}

.order-details { font-size: 0.9rem; line-height: 1.5;}
.order-details p { margin-bottom: calc(var(--spacing-unit) * 0.3); }

.order-actions {
    padding: 0 calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 0.75); /* Padding below */
    text-align: right;
}

/* --- Status-Specific Styles --- */
.status-badge {
    font-weight: bold;
    padding: 0.2em 0.5em;
    border-radius: var(--border-radius);
    color: white;
    background-color: var(--secondary-color); /* Default */
    font-size: 0.85em;
    display: inline-block;
    vertical-align: middle;
}
.status-pending, .status-badge.status-pending { background-color: rgb(255, 255, 230); color: #000000;}
.status-out-for-delivery, .status-badge.status-out-for-delivery { background-color: rgb(198, 198, 255); }
.status-delivered, .status-badge.status-delivered { background-color: rgb(216, 255, 216); }
.status-cancelled, .status-badge.status-cancelled { background-color: rgb(255, 218, 218); }
.order-card.status-cancelled, .data-table tr.status-cancelled { opacity: 0.9; /* Slightly fade cancelled */ }


/* --- Admin & Delivery Common Styles --- */
.admin-manage-container,
.delivery-dashboard-container,
.delivery-orders-detail-container,
.delivery-contact-container {
    padding: var(--spacing-unit);
}
.admin-manage-container h1,
.delivery-dashboard-container h1,
.delivery-orders-detail-container h1,
.delivery-contact-container h1 {
    font-size: 1.5rem;
    margin-bottom: var(--spacing-unit);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: calc(var(--spacing-unit) * 0.5);
}

/* --- Data Tables (Mobile First) --- */
.table-container { /* Optional wrapper for styling */
    overflow-x: auto; /* Add horizontal scroll on mobile if table content is too wide */
    margin-bottom: var(--spacing-unit);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
}
.data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9rem;
}

.data-table thead {
  display: none; /* Hide header on mobile */
}

.data-table tbody tr {
  display: block; /* Stack rows vertically */
  margin-bottom: calc(var(--spacing-unit) * 1.5);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: calc(var(--spacing-unit) * 0.75);
  background-color: var(--card-bg);
  box-shadow: var(--card-shadow);
}
/* Remove margin/border if inside .table-container */
.table-container .data-table tbody tr {
    margin-bottom: 0;
    border: none;
    border-bottom: 1px solid var(--border-color);
    border-radius: 0;
    box-shadow: none;
    padding: calc(var(--spacing-unit) * 0.5); /* Adjust padding */
}
.table-container .data-table tbody tr:last-child {
    border-bottom: none;
}


.data-table td {
  display: block; /* Stack cells vertically */
  text-align: right; /* Align value to the right */
  padding: calc(var(--spacing-unit) * 0.5) 0;
  position: relative;
  border-bottom: 1px dashed #eee;
}
.data-table td:last-child {
    border-bottom: none;
}

.data-table td::before {
  content: attr(data-label); /* Use data-label for label */
  position: absolute;
  left: 0;
  font-weight: bold;
  text-align: left;
  padding-right: 10px;
  color: #555;
  width: 40%; /* Give label some width */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Special cell styling */
.table-img {
  max-width: 50px; /* Smaller image in mobile table cell */
  border-radius: 4px;
  display: inline-block; /* Adjust display for right align */
  margin-left: 45%; /* Push image past the label space */
}

/* Adjust td padding if it contains specific content types */
.data-table td:has(img) { text-align: right; padding: 5px 0; } /* Keep right align for image */
.data-table td:has(form), .actions-cell { padding: 10px 0;}
.data-table td:has(form) { margin-left: 45%; } /* Push form controls past label */

/* Actions Cell Specific */
.actions-cell form, .actions-cell .btn {
    margin: calc(var(--spacing-unit) * 0.2) 0; /* Space between actions */
    display: block; /* Stack action forms/buttons vertically */
    width: 100%; /* Make actions full width for easier tap */
}
.actions-cell .inline-form { margin-bottom: calc(var(--spacing-unit) * 0.5); } /* More space between form groups */
.action-group {
    border-top: 1px dashed #ccc;
    padding-top: calc(var(--spacing-unit) * 0.5);
    margin-top: calc(var(--spacing-unit) * 0.5);
    text-align: left; /* Align content left within group */
}
.action-group:first-child { border-top: none; margin-top: 0; padding-top: 0; }
.action-group-title {
    font-size: 0.8em;
    font-weight: bold;
    color: var(--secondary-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
    display: block;
    text-align: left; /* Ensure title is left aligned */
}


/* Specific styles for assign/cancel selects */
.actions-cell select.form-control-sm {
    margin-bottom: 5px;
    font-size: 0.9rem;
    padding: calc(var(--spacing-unit)*0.3) calc(var(--spacing-unit)*0.5);
    height: auto;
}
/* Align text left if label is present */
.data-table td:has(label) {
    text-align: left;
}
.data-table td:has(label) > * { /* Ensure content in labeled cell is also aligned left */
    margin-left: 45%;
}

/* Input sizes in table forms */
.verify-otp-form { display: flex; align-items: center; gap: 5px; }
.verify-otp-form input[name="otp"] {
    flex-grow: 1;
    max-width: 120px;
    padding: calc(var(--spacing-unit)*0.3) calc(var(--spacing-unit)*0.5);
    font-size: 0.9rem;
    text-align: center;
}
.verify-otp-form button {
    flex-shrink: 0;
    width: auto;
    padding: calc(var(--spacing-unit)*0.3) calc(var(--spacing-unit)*0.5);
}
.cancel-delivery-form select { width: 100%; }


/* Admin Dashboard Grid */
.admin-actions-grid, .delivery-stats-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 2 columns on mobile */
    gap: var(--spacing-unit);
    margin-top: var(--spacing-unit);
}
.admin-action-card, .stat-card {
    background-color: var(--card-bg);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    text-align: center;
    box-shadow: var(--card-shadow);
    transition: transform 0.2s, box-shadow 0.2s;
    color: var(--text-color);
    text-decoration: none;
}
.admin-action-card:hover, .stat-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    text-decoration: none;
}
.admin-action-card i, .stat-card i {
    font-size: 2rem;
    color: var(--primary-color);
    margin-bottom: 0.5rem;
}
.admin-action-card h3, .stat-card h2 {
    font-size: 1.1rem;
    margin-bottom: 0.3rem;
    color: var(--text-color);
}
.admin-action-card p {
    font-size: 0.85rem;
    color: var(--secondary-color);
    margin-bottom: 0.5rem;
}
.stat-card h2 { /* Make stat number bigger */
    font-size: 1.8rem;
    font-weight: bold;
    color: var(--primary-color);
}
.stat-card p {
    font-size: 0.9rem;
    color: var(--secondary-color);
    margin-bottom: 0.75rem;
}

/* Delivery Specific */
.stat-card a.btn {
    width: 80%;
    margin: 0 auto;
    display: block;
}

/* --- Error Page --- */
.error-container { text-align: center; padding-top: 2rem; }
.error-container h1 { color: var(--danger-color); margin-bottom: 0.5rem; }
.error-container .lead { font-size: 1.1rem; }
.error-container details { text-align: left; }

/* --- Rating Statistics --- */
.rating-stats-container {
  margin-top: 30px;
  padding-top: 20px;
  border-top: 1px solid #eee;
}

.rating-stats-container h3 {
  margin-bottom: 15px;
  font-size: 1.4em;
  color: #333;
}

.rating-summary {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  gap: 15px; /* Spacing between average and total */
}

.rating-average {
  display: flex;
  align-items: center;
}

.rating-average-value {
  font-size: 2.5em; /* Larger font for average */
  font-weight: 500;
  margin-right: 5px;
  color: #222;
}

.rating-average .fa-star {
  font-size: 1.2em; /* Slightly smaller star */
  color: #666; /* Greyish star */
  margin-bottom: 8px; /* Align vertically better */
}

.rating-total {
  font-size: 0.95em;
  color: #555;
}

.rating-bars {
  max-width: 400px; /* Limit width for better appearance */
}

.rating-bar-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
  gap: 10px; /* Spacing between elements in a row */
}

.rating-bar-label {
  width: 45px; /* Fixed width for labels */
  font-size: 0.9em;
  color: #444;
  text-align: right;
  flex-shrink: 0; /* Prevent shrinking */
}
.rating-bar-label .fa-star {
  color: #f8c107; /* Gold star in label */
  font-size: 0.9em;
}


.rating-bar-progress {
  flex-grow: 1; /* Take remaining space */
  height: 8px;
  background-color: #e0e0e0; /* Light grey background */
  border-radius: 4px;
  overflow: hidden; /* Ensure fill stays within bounds */
}

.rating-bar-fill {
  height: 100%;
  background-color: #28a745; /* Green color for fill */
  border-radius: 4px;
  transition: width 0.3s ease-in-out; /* Smooth animation */
}
/* Optional: Different colors per rating */
.rating-bar-row:nth-child(1) .rating-bar-fill { background-color: #28a745; } /* 5 stars */
.rating-bar-row:nth-child(2) .rating-bar-fill { background-color: #84c54c; } /* 4 stars */
.rating-bar-row:nth-child(3) .rating-bar-fill { background-color: #ffc107; } /* 3 stars */
.rating-bar-row:nth-child(4) .rating-bar-fill { background-color: #fd7e14; } /* 2 stars */
.rating-bar-row:nth-child(5) .rating-bar-fill { background-color: #dc3545; } /* 1 star */


.rating-bar-count {
  width: 40px; /* Fixed width for counts */
  font-size: 0.9em;
  color: #555;
  text-align: right;
  flex-shrink: 0; /* Prevent shrinking */
}
/* --- End Rating Statistics --- */


/* --- Profile Page --- */
.profile-container {
    max-width: 800px; /* Adjust as needed */
    margin: var(--spacing-unit) auto;
    padding: calc(var(--spacing-unit) * 1.5);
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    box-shadow: var(--card-shadow);
}

.profile-container h1 {
    font-size: 1.8rem;
    text-align: center;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.profile-container > p.text-muted { /* Target the welcome message */
    text-align: center;
    font-size: 1.1rem;
}


.profile-section {
    margin-top: calc(var(--spacing-unit) * 1.5);
    padding-top: calc(var(--spacing-unit) * 1);
    border-top: 1px solid var(--border-color);
}
.profile-section:first-of-type { /* Remove top border from the first section if needed */
    /* border-top: none; */
    /* padding-top: 0; */
}


.profile-section h2 {
    font-size: 1.4rem;
    margin-bottom: calc(var(--spacing-unit) * 0.8);
    color: var(--primary-color);
}

/* Address Section Specifics */
#saved-address-display p {
    margin-bottom: calc(var(--spacing-unit) * 0.3);
    line-height: 1.5;
    font-size: 1rem;
}
#saved-address-display strong {
    font-weight: 500;
}
#edit-address-btn {
    margin-top: calc(var(--spacing-unit) * 0.5);
}

.address-form {
    max-width: 500px; /* Limit form width within the section */
}
.address-form h3 {
    font-size: 1.2rem;
    margin-bottom: var(--spacing-unit);
    font-weight: 500;
}
#cancel-edit-btn {
    margin-left: calc(var(--spacing-unit) * 0.5);
}

/* Dashboard Links */
.dashboards-section .btn {
    margin-right: 10px;
    margin-bottom: 10px; /* Space between buttons if they wrap */
}

/* Logout Section */
.logout-section .btn {
    min-width: 120px; /* Give logout button some width */
}



/* --- Media Queries (Example: Tablet and Desktop Overrides) --- */

@media (min-width: 768px) {
  :root {
    --spacing-unit: 1rem; /* Could adjust base spacing slightly if needed */
  }
  .container {
    max-width: 960px; /* Max width for content area */
  }

  /* Header */
  .app-logo .app-name { display: inline; } /* Show text logo */
  .nav-link { flex-direction: row; font-size: 0.9rem; } /* Text beside icon */
  .nav-link span { display: inline; } /* Show text */
  .nav-link i { margin-right: 0.4rem; margin-bottom: 0; font-size: 1rem; }
  .nav-right { gap: var(--spacing-unit); } /* Wider gap */


  /* Footer */
  .app-footer { display: block; /* Show footer */}

  /* Product Grid */
  .product-grid { grid-template-columns: repeat(3, 1fr); } /* 3 columns tablet */
  .product-name { height: auto; white-space: normal; } /* Allow wrapping on desktop cards */


  /* Product Detail */
  .product-detail-main {
    flex-direction: row; /* Image beside info */
    align-items: flex-start;
  }
  .product-detail-image { flex: 1 1 40%; } /* Image takes ~40% */
  .product-detail-info { flex: 1 1 60%; } /* Info takes ~60% */
  .product-actions { flex-direction: row; align-items: center; } /* Buttons side-by-side */
  .product-actions .btn { width: auto; }
  .quantity-selector { max-width: 120px; margin-bottom: 0; }

  /* Auth */
  .auth-container { margin: calc(var(--spacing-unit) * 2) auto; }

  /* Cart */
   .cart-item {
        grid-template-columns: 100px 1fr 150px 120px 80px; /* Image, Details, Price, Qty, Remove */
        grid-template-areas: "image details price quantity remove"; /* Simplified grid */
        align-items: center;
        padding: var(--spacing-unit);
   }
   .cart-item-details { grid-area: details; }
   /* Add Price column */
   .cart-item-price {
       display: block; /* Show price on desktop */
       grid-area: price;
       text-align: right;
       font-weight: 500;
       font-size: 1rem; /* Make price more prominent */
       color: var(--text-color); /* Standard text color */
       margin-bottom: 0;
   }
   .cart-item-quantity { grid-area: quantity; justify-content: center; } /* Center qty control */
   .cart-item-subtotal { display: none; /* Subtotal calculated by price*qty, not displayed explicitly here */ }
   .cart-item-remove { grid-area: remove; align-self: center; text-align: center; } /* Center remove btn */


   /* Checkout */
    .checkout-grid {
        flex-direction: row; /* Side-by-side */
        gap: calc(var(--spacing-unit) * 1.5);
        align-items: flex-start;
    }
    .checkout-address { flex: 1 1 55%; }
    .checkout-summary { flex: 1 1 45%; }

   /* Tables */
   .table-container { border: none; border-radius: 0; } /* Remove border from wrapper on desktop */
   .data-table thead { display: table-header-group; } /* Show header */
   .data-table tbody tr {
       display: table-row; /* Standard row layout */
       margin-bottom: 0;
       border: none;
       padding: 0;
       box-shadow: none;
       background-color: transparent; /* Reset mobile background */
       border-bottom: 1px solid var(--border-color); /* Separator between rows */
   }
   .data-table tbody tr:last-child { border-bottom: none; }
   .data-table td {
       display: table-cell; /* Standard cell layout */
       text-align: left; /* Default left align */
       padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.5);
       vertical-align: middle;
       border-bottom: none;
       position: static; /* Reset position */
       margin-left: 0 !important; /* Override mobile margin */
   }
    .data-table td::before { content: none; /* Remove label */} /* Remove labels */
    .data-table td:has(form), .actions-cell {
       text-align: right; /* Often actions are right aligned on desktop */
       white-space: nowrap; /* Prevent actions wrapping */
   }
   .inline-form { display: inline-block; margin: 0 5px 0 0;}
   .inline-form > * { margin-bottom: 0; }
   .action-group { border: none; padding: 0; margin: 0; display: inline-block; vertical-align: middle; margin-right: 10px;} /* Reset action group styles for inline desktop */
   .action-group-title { display: none; } /* Hide titles in desktop table cells */
   .actions-cell > form, .actions-cell > div > form { display: inline-block; } /* Actions inline */
   .actions-cell > a { display: inline-block; margin-right: 5px; vertical-align: middle;}


   /* Center specific columns (example - adjust indices as needed) */
   /* Adjust selectors based on actual table structures */
   .data-table th[data-label*="Price"],
   .data-table td[data-label*="Price"],
   .data-table th[data-label*="Stock"],
   .data-table td[data-label*="Stock"],
   .data-table th[data-label*="Rating"],
   .data-table td[data-label*="Rating"],
   .data-table th[data-label*="Sold"],
   .data-table td[data-label*="Sold"] {
       text-align: center;
   }
    /* Status column */
   .data-table th[data-label="Status"],
   .data-table td[data-label="Status"] {
        text-align: center;
    }
     /* Total Amount column */
   .data-table th[data-label*="Total"],
   .data-table td[data-label*="Total"] {
        text-align: right; /* Totals usually right aligned */
        font-weight: 500; /* Make total bold */
   }
   /* Align Actions Right */
   .data-table th.actions-cell,
   .data-table td.actions-cell { text-align: right !important; }
   .actions-cell form, .actions-cell .btn { display: inline-block; width: auto; margin: 0 0 0 5px;} /* Display actions inline */
   .actions-cell .btn-block { display: inline-block; width: auto; } /* Override block */


   /* Adjust image size */
   .table-img { max-width: 60px; margin-left: 0; }
   .data-table td:has(img) { text-align: left; } /* Image cell left aligned */

    /* Dashboard grids */
    .admin-actions-grid { grid-template-columns: repeat(3, 1fr); }
    .delivery-stats-grid { grid-template-columns: repeat(3, 1fr); }

    /* Rating stats responsiveness */
    .rating-stats-container {
        display: flex;
        align-items: flex-start; /* Align items to top */
        gap: calc(var(--spacing-unit) * 2);
    }
    .rating-summary {
        flex-direction: column;
        align-items: center; /* Center summary items */
        margin-bottom: 0; /* Remove bottom margin */
        flex-basis: 150px; /* Give it some base width */
        flex-shrink: 0;
    }
    .rating-average-value { font-size: 3em; }
    .rating-total { font-size: 1em; }
    .rating-bars {
        max-width: none; /* Remove max width */
        flex-grow: 1; /* Allow bars to take remaining space */
    }

    /* Profile Page */
    .profile-container {
        padding: calc(var(--spacing-unit) * 2);
    }


} /* End 768px */


@media (min-width: 1024px) {
  .container { max-width: 1140px; }
  /* Product Grid */
  .product-grid { grid-template-columns: repeat(4, 1fr); } /* 4 columns desktop */

  /* Increase gaps slightly maybe */
  .product-grid, .admin-actions-grid, .delivery-stats-grid { gap: calc(var(--spacing-unit) * 1); }

  .admin-actions-grid { grid-template-columns: repeat(5, 1fr); } /* Adjust grid for admin dash */

} /* End 1024px */
/* public/css/style.css */

/* ... existing styles ... */

.data-table tbody tr.selected-row {
  background-color: #e7f3ff; /* Light blue background for selected rows */
}
.data-table td {
  /* Add transition for smoother background change */
  transition: background-color 0.2s ease-in-out;
}

/* Bulk Actions Container specific styles */
.bulk-actions-container {
  background-color: #f8f9fa; /* Light background */
  border: 1px solid #dee2e6;
  border-radius: .25rem;
  margin-bottom: 1rem;
  padding: 1rem;
}

.bulk-actions-container h4 {
  margin-bottom: 0.75rem;
  font-size: 1.1rem;
}

/* Better alignment for inline form elements in bulk actions */
.bulk-actions-container .form-inline {
  display: flex;
  align-items: center; /* Align items vertically */
  gap: 0.5rem; /* Add some space between elements */
  flex-wrap: wrap; /* Allow wrapping on smaller screens */
}

.bulk-actions-container .form-inline label {
  margin-bottom: 0; /* Remove default bottom margin for labels */
}

.bulk-actions-container .form-inline select,
.bulk-actions-container .form-inline button {
  flex-shrink: 0; /* Prevent button/select from shrinking too much */
}

.bulk-actions-container .form-inline select {
  min-width: 200px; /* Give the select some minimum width */
}
/* ... rest of the styles ... */


public/js/main.js:
console.log("Main JS loaded.");

document.addEventListener('DOMContentLoaded', () => {

    // --- Cart Update AJAX Logic (Enhanced Spinner) ---
    const updateQtyButtons = document.querySelectorAll('.btn-update-qty');
    updateQtyButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const productId = button.dataset.productId;
            const quantityInput = document.getElementById(`quantity-${productId}`);
            const newQuantity = parseInt(quantityInput.value, 10);

            if (isNaN(newQuantity) || newQuantity < 0) {
                 alert('Invalid quantity');
                 // Revert input if possible? Or just return.
                 // quantityInput.value = button.dataset.previousValue || 1; // Needs previous value storage
                return;
             }
            const maxStock = parseInt(quantityInput.max, 10);
            if(newQuantity > maxStock){
                alert(`Only ${maxStock} items available in stock.`);
                quantityInput.value = maxStock; // Correct input to max stock
                 return;
             }

            updateCartItemQuantityAJAX(productId, newQuantity, button);
        });
        // Store initial value for potential revert on error (optional)
        // const quantityInput = document.getElementById(`quantity-${button.dataset.productId}`);
        // if(quantityInput) button.dataset.previousValue = quantityInput.value;
    });


    // --- Generic Form Submission Spinner ---
    document.querySelectorAll('form.form-submit-spinner').forEach(form => {
        form.addEventListener('submit', (event) => {
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton && !submitButton.disabled) {
                // Basic client-side validation check before showing spinner
                if (typeof form.checkValidity === 'function' && !form.checkValidity()) {
                    // Let browser handle HTML5 validation messages, don't show spinner
                    return;
                }

                const originalText = submitButton.innerHTML;
                // Store original text in case we need to revert *without* page load (e.g., advanced client-side errors)
                submitButton.dataset.originalText = originalText;
                submitButton.disabled = true;
                submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';

                // Spinner will generally be reset by page reload/redirect.
                // No explicit reset here simplifies things for standard forms.
            }
        });
    });


    // --- Responsive Table Logic ---
    function responsiveTables() {
        const tables = document.querySelectorAll('.data-table');
        tables.forEach(table => {
            const headerElements = table.querySelectorAll('thead th');
            if (!headerElements || headerElements.length === 0) return;

            const headers = Array.from(headerElements).map(th => th.textContent.trim());
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                cells.forEach((cell, index) => {
                    // Ensure we don't overwrite data-label if already set or if header is empty
                    if (!cell.hasAttribute('data-label') && headers[index] !== undefined && headers[index] !== '') {
                         cell.setAttribute('data-label', headers[index]);
                    }
                });
            });
        });
    }
     // Run on load and potentially on resize if needed
     if (document.querySelector('.data-table')) {
         responsiveTables();
         // Consider adding resize listener if layout changes dynamically often
         // window.addEventListener('resize', responsiveTables);
     }


    // --- Share Button Logic ---
    const shareButton = document.getElementById('share-product-btn');
    const fallbackLinks = document.getElementById('fallback-share-links');

    if (shareButton && fallbackLinks) {
        shareButton.addEventListener('click', async () => {
            const title = shareButton.dataset.title;
            const text = shareButton.dataset.text;
            const url = shareButton.dataset.url;

            if (navigator.share) {
                try {
                    await navigator.share({ title, text, url });
                    console.log('Product shared successfully!');
                } catch (error) {
                    console.error('Error sharing:', error);
                    if (error.name !== 'AbortError') {
                         fallbackLinks.classList.remove('hidden');
                    }
                }
            } else {
                console.log('Web Share API not supported, showing fallback links.');
                fallbackLinks.classList.remove('hidden');
            }
        });
    }

    // --- Checkout Address Form Toggle ---
    const editBtn = document.getElementById('edit-address-btn');
    const cancelBtn = document.getElementById('cancel-edit-btn');
    const addressForm = document.getElementById('address-form');
    const savedAddressDiv = document.querySelector('.saved-address'); // Should be #saved-address-display? Check profile.ejs if issues
    const profileSavedAddressDiv = document.getElementById('saved-address-display'); // Specific ID for profile page
    const placeOrderBtn = document.querySelector('.btn-place-order');
    const formTitle = addressForm?.querySelector('h3');
    const addressSourceInput = addressForm?.querySelector('input[name="source"]');
    let isProfilePage = addressSourceInput?.value === 'profile'; // Check if on profile page

    let initialAddressDiv = isProfilePage ? profileSavedAddressDiv : savedAddressDiv;
    const hasInitialAddress = initialAddressDiv && !initialAddressDiv.classList.contains('hidden');

    if (editBtn && addressForm && initialAddressDiv) {
        editBtn.addEventListener('click', () => {
            addressForm.classList.remove('hidden');
            initialAddressDiv.classList.add('hidden');
            if(placeOrderBtn) placeOrderBtn.disabled = true; // Disable place order while editing checkout address
            if(formTitle) formTitle.textContent = 'Edit Address';
        });
    }

    if (cancelBtn && addressForm && initialAddressDiv) {
        cancelBtn.addEventListener('click', () => {
            addressForm.classList.add('hidden');
            if (hasInitialAddress) {
                initialAddressDiv.classList.remove('hidden');
                 // Only re-enable place order button if NOT on profile page and address existed
                if(placeOrderBtn && !isProfilePage) placeOrderBtn.disabled = false;
            } else {
                 if(placeOrderBtn && !isProfilePage) placeOrderBtn.disabled = true; // Keep disabled if there was no initial address on checkout
            }
            // Reset form fields? Optional, but good practice
            // addressForm.reset();
        });
    }

     // Initial state check:
     // On Checkout: If no initial address, show form, ensure button is disabled
     if (!isProfilePage && !hasInitialAddress && addressForm && placeOrderBtn) {
         addressForm.classList.remove('hidden');
         placeOrderBtn.disabled = true;
         if (formTitle) formTitle.textContent = 'Add Address';
     } else if (!isProfilePage && hasInitialAddress && placeOrderBtn) {
         placeOrderBtn.disabled = false; // Ensure enabled if address exists initially on checkout
     }
     // On Profile: If no address, show form (cancel button might be hidden by EJS)
      if (isProfilePage && !hasInitialAddress && addressForm) {
         addressForm.classList.remove('hidden');
         if (formTitle) formTitle.textContent = 'Add Address';
     }


    // --- START: Bulk Order Assignment Logic ---
    const selectAllCheckbox = document.getElementById('select-all-orders');
    const orderCheckboxes = document.querySelectorAll('.order-checkbox');
    const bulkActionControls = document.getElementById('bulk-action-controls');
    const selectedCountSpan = document.getElementById('selected-count');
    const bulkAssignForm = document.getElementById('bulk-assign-form'); // Get the form
    const bulkAssignButton = bulkActionControls?.querySelector('button[type="submit"]');
    const bulkDeliveryAdminSelect = document.getElementById('bulkDeliveryAdminId');


    function updateBulkActionVisibility() {
        const selectedCheckboxes = document.querySelectorAll('.order-checkbox:checked');
        const count = selectedCheckboxes.length;

        if (selectedCountSpan) {
            selectedCountSpan.textContent = count;
        }

        if (bulkActionControls) {
            bulkActionControls.style.display = count > 0 ? 'block' : 'none';
        }

        // Enable/disable bulk assign button based on selection and admin choice
        if(bulkAssignButton && bulkDeliveryAdminSelect){
            bulkAssignButton.disabled = count === 0 || bulkDeliveryAdminSelect.value === '';
        }
    }

    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            orderCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
                // Optional: Add/remove a highlight class to the row
                checkbox.closest('tr')?.classList.toggle('selected-row', isChecked);
            });
            updateBulkActionVisibility();
        });
    }

    orderCheckboxes.forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            // Optional: Add/remove a highlight class to the row
             e.target.closest('tr')?.classList.toggle('selected-row', e.target.checked);

            // Check if *all* enabled checkboxes are now checked
            const allChecked = [...orderCheckboxes].every(cb => cb.checked);
             // Check if *any* checkbox is checked
            const anyChecked = [...orderCheckboxes].some(cb => cb.checked);

            if (selectAllCheckbox) {
                selectAllCheckbox.checked = allChecked;
                 // Handle indeterminate state (visual sugar)
                 // If some but not all are checked, set indeterminate
                 selectAllCheckbox.indeterminate = anyChecked && !allChecked;
            }
            updateBulkActionVisibility();
        });
    });

     // Add listener to the delivery admin dropdown in the bulk section
    if(bulkDeliveryAdminSelect){
        bulkDeliveryAdminSelect.addEventListener('change', () => {
            updateBulkActionVisibility(); // Re-check if button should be enabled
        });
     }


    // Initial check in case the page loads with some state or errors
    if (orderCheckboxes.length > 0) {
        updateBulkActionVisibility();
        // Disable select all if no orders are assignable
        const assignableCount = [...orderCheckboxes].length;
        if(selectAllCheckbox) selectAllCheckbox.disabled = assignableCount === 0;

    } else if (selectAllCheckbox) {
        selectAllCheckbox.disabled = true; // Disable if there are no checkboxes at all
    }

     // Optional: Add confirmation before bulk submitting
     if (bulkAssignForm) {
        bulkAssignForm.addEventListener('submit', (e) => {
             const selectedCheckboxes = document.querySelectorAll('.order-checkbox:checked');
             const count = selectedCheckboxes.length;
             const adminSelected = bulkDeliveryAdminSelect && bulkDeliveryAdminSelect.value !== '';

             if (count === 0) {
                 alert('Please select at least one order to assign.');
                 e.preventDefault();
                 return;
             }
             if (!adminSelected) {
                 alert('Please select a Delivery Admin to assign the orders to.');
                 e.preventDefault();
                 return;
             }

             if (!confirm(`Are you sure you want to assign ${count} order(s) to the selected Delivery Admin?`)) {
                 e.preventDefault(); // Stop submission if user cancels
             }
             // Spinner is handled by the generic form spinner logic already attached via class
         });
    }

    // --- END: Bulk Order Assignment Logic ---


}); // End DOMContentLoaded


// --- Cart AJAX Update Function (Revised Spinner/Button Handling) ---
async function updateCartItemQuantityAJAX(productId, quantity, buttonElement) {
     const originalButtonText = 'Update'; // Define original text
     const loadingButtonText = '<i class="fas fa-spinner fa-spin"></i>'; // Just spinner for small button
     const quantityInput = document.getElementById(`quantity-${productId}`); // Get input

     buttonElement.disabled = true;
     buttonElement.innerHTML = loadingButtonText;
     if(quantityInput) quantityInput.readOnly = true; // Make input readonly during update


    try {
        const response = await fetch('/user/cart/update', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                // Include CSRF token header if you implement CSRF protection
            },
            body: JSON.stringify({ productId, quantity })
         });

        if (!response.ok) {
             const errorData = await response.json().catch(() => ({ message: 'Failed to update cart. Server error.' }));
            throw new Error(errorData.message || `Update failed (Status: ${response.status})`);
        }

         const data = await response.json();

         if (data.success) {
            const cartItemDiv = buttonElement.closest('.cart-item'); // Find parent cart item

             if (quantity === 0) {
                if (cartItemDiv) {
                    cartItemDiv.style.transition = 'opacity 0.3s ease';
                    cartItemDiv.style.opacity = '0';
                    setTimeout(() => {
                        cartItemDiv.remove();
                         // Recalculate count and update UI after removing item
                        updateCartTotalAndBadge(data.cartTotal); // Pass the total from response
                        handleEmptyCartDisplay(); // Check if cart became empty
                    }, 300);
                     return; // Exit early as item is being removed
                }
             } else {
                 const subtotalSpan = cartItemDiv?.querySelector('.item-subtotal-value');
                 if (subtotalSpan) subtotalSpan.textContent = data.itemSubtotal.toFixed(2);
                if(quantityInput) {
                     quantityInput.value = data.newQuantity; // Update input with confirmed quantity
                 }

             }
             // Update total and badge for successful updates (non-zero quantity)
             updateCartTotalAndBadge(data.cartTotal);

         } else {
             // Server responded with success: false
             alert(`Update failed: ${data.message}`);
         }

    } catch (error) {
         // Network error or other exception during fetch/processing
         console.error('Error updating cart quantity:', error);
         alert(`Error: ${error.message}`);
    } finally {
         // Always re-enable button and input, restore original text
         buttonElement.disabled = false;
         buttonElement.innerHTML = originalButtonText;
         if(quantityInput) quantityInput.readOnly = false;
     }
}

// --- Helper Function: Update Cart Total Display and Header Badge ---
function updateCartTotalAndBadge(newCartTotal) {
    // Update Cart Total Display
     const cartTotalSpan = document.getElementById('cart-total-value');
     if (cartTotalSpan) cartTotalSpan.textContent = newCartTotal.toFixed(2);

    // Update Header Cart Count (Recalculate based on current DOM input values)
     const newCartItemCount = calculateNewCartCount();
     const cartBadge = document.querySelector('.cart-badge');
     if (cartBadge) {
         if (newCartItemCount > 0) {
             cartBadge.textContent = newCartItemCount;
             cartBadge.style.display = 'inline-block'; // Show badge
         } else {
            cartBadge.textContent = '0';
            cartBadge.style.display = 'none'; // Hide badge
         }
     } else {
         console.warn("Cart badge element not found in header.");
     }
}


// --- Helper function: Calculate cart count from input fields ---
function calculateNewCartCount() {
    const quantityInputs = document.querySelectorAll('.cart-item .quantity-input');
    let count = 0;
    quantityInputs.forEach(input => {
        const value = parseInt(input.value, 10);
        // Only count items with quantity >= 1
        if (!isNaN(value) && value > 0) {
          // Accumulate actual quantity (how many items total), not just number of rows
          count += value;
        }
    });
    return count;
}

// --- Helper function: Check and display empty cart message ---
function handleEmptyCartDisplay() {
    const cartItemsContainer = document.querySelector('.cart-items');
     const cartContainer = document.querySelector('.cart-container'); // Get the parent
     // Check count AFTER potential removal animation finishes
     if (calculateNewCartCount() === 0 && cartContainer && cartItemsContainer) {
         // Replace entire cart content if empty
         cartContainer.innerHTML = '<h1>Your Shopping Cart</h1><p>Your cart is empty. <a href="/">Continue Shopping</a></p>';
         // No need to hide summary as it's removed
     }
}

routes/adminRoutes.js:
// routes/adminRoutes.js
const express = require('express');
const adminController = require('../controllers/adminController');
const { isAuthenticated } = require('../middleware/authMiddleware');
const { isAdmin } = require('../middleware/roleMiddleware');

const router = express.Router();

// Apply authentication and admin role check to all routes in this file
router.use(isAuthenticated, isAdmin);

// Dashboard
router.get('/dashboard', adminController.getAdminDashboard);

// Products
router.get('/upload-product', adminController.getUploadProductPage);
router.post('/upload-product', adminController.uploadProduct);
router.get('/manage-products', adminController.getManageProductsPage);
router.get('/manage-products/edit/:id', adminController.getEditProductPage);
router.post('/manage-products/update/:id', adminController.updateProduct);
router.post('/manage-products/remove/:id', adminController.removeProduct);


// Orders
router.get('/manage-orders', adminController.getManageOrdersPage);
// Direct delivery by Admin actions
router.post('/orders/:orderId/send-direct-delivery-otp', adminController.sendDirectDeliveryOtpByAdmin);
router.post('/orders/:orderId/confirm-direct-delivery', adminController.confirmDirectDeliveryByAdmin);
// Individual Assign/Unassign/Cancel actions
router.post('/orders/:orderId/assign', adminController.assignOrder);
router.post('/orders/:orderId/unassign', adminController.unassignOrderFromAdmin);
router.post('/orders/:orderId/cancel', adminController.cancelOrderByAdmin);
// --- ADDED Bulk Assign Route ---
router.post('/orders/bulk-assign', adminController.bulkAssignOrders);
// --- END ---


// Users
router.get('/manage-users', adminController.getManageUsersPage);
router.post('/users/:id/update-role', adminController.updateUserRole);
router.post('/users/:id/remove', adminController.removeUser);


// Assigned Orders / Delivery Admins
router.get('/manage-assigned-orders', adminController.getManageAssignedOrdersPage);
router.get('/manage-assigned-orders/details/:deliveryAdminId/:type', adminController.getAssignedOrdersDetailForAdmin);
router.post('/manage-assigned-orders/remove/:id', adminController.removeDeliveryAdminAssignment);


module.exports = router;


routes/authRoutes.js:
const express = require('express');
const authController = require('../controllers/authController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.get('/login', authController.getLoginPage);
router.get('/register', authController.getRegisterPage);
router.get('/verify-otp', authController.getVerifyOtpPage);
router.get('/forgot-password', authController.getForgotPasswordPage);
router.get('/reset-password/:token', authController.getResetPasswordPage);

router.post('/register', authController.registerUser);
router.post('/login', authController.loginUser);
 router.post('/logout', isAuthenticated, authController.logoutUser);
router.post('/verify-otp', authController.verifyOtp);
 router.post('/resend-otp', authController.resendOtp);

router.post('/forgot-password', authController.forgotPassword);
router.post('/reset-password/:token', authController.resetPassword);


module.exports = router;

routes/deliveryRoutes.js:
// routes/deliveryRoutes.js
const express = require('express');
const deliveryController = require('../controllers/deliveryController');
const { isAuthenticated } = require('../middleware/authMiddleware');
const { isDeliveryAdmin } = require('../middleware/roleMiddleware');
const { hasPhoneNumber } = require('../middleware/deliveryMiddleware'); // Import the new middleware

const router = express.Router();

// Apply base authentication and role check first
router.use(isAuthenticated, isDeliveryAdmin);

// --- Contact Page Routes (Accessible WITHOUT phone number) ---
router.get('/contact', deliveryController.getContactPage);
router.post('/contact', deliveryController.updateContactInfo);

// --- Routes requiring a phone number (Apply hasPhoneNumber middleware) ---
// Apply the check *after* auth/role but *before* the specific route handlers
router.use(hasPhoneNumber);

// Dashboard
router.get('/dashboard', deliveryController.getDeliveryDashboard);

// View Orders
router.get('/orders/:type', deliveryController.getAssignedOrdersDetail); // type = total, pending, delivered

// Order Actions
router.post('/orders/:orderId/send-delivery-otp', deliveryController.sendDeliveryOtp);
router.post('/orders/:orderId/verify-delivery-otp', deliveryController.verifyDeliveryOtp);
router.post('/orders/:orderId/cancel-delivery', deliveryController.cancelAssignedOrder);
router.post('/orders/:orderId/unassign', deliveryController.unassignOrder);

module.exports = router;
routes/index.js:
const express = require('express');
const authRoutes = require('./authRoutes');
const productRoutes = require('./productRoutes');
const userRoutes = require('./userRoutes');
const orderRoutes = require('./orderRoutes');
const adminRoutes = require('./adminRoutes');
const deliveryRoutes = require('./deliveryRoutes');

const { getHomePage } = require('../controllers/authController');

const router = express.Router();

router.get('/', getHomePage);
router.use('/auth', authRoutes);
router.use('/products', productRoutes);

router.use('/user', userRoutes);
router.use('/orders', orderRoutes);

router.use('/admin', adminRoutes);

router.use('/delivery', deliveryRoutes);


module.exports = router;

routes/orderRoutes.js:
const express = require('express');
const orderController = require('../controllers/orderController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.use(isAuthenticated);

router.post('/place', orderController.placeOrder);

router.get('/my-orders', orderController.getMyOrders);

 router.post('/cancel/:id', orderController.cancelOrder);

module.exports = router;

routes/productRoutes.js:
const express = require('express');
const productController = require('../controllers/productController');
 const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.get('/', productController.getProducts);
router.get('/:id', productController.getProductDetails);

 router.post('/:id/rate', isAuthenticated, productController.rateProduct);

module.exports = router;

routes/userRoutes.js:
// routes/userRoutes.js
const express = require('express');
const userController = require('../controllers/userController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.use(isAuthenticated); // Apply to all user routes

// --- ADD NEW PROFILE ROUTE ---
router.get('/profile', userController.getUserProfilePage);
// --- END NEW ROUTE ---

router.get('/cart', userController.getCart);
router.post('/cart/add', userController.addToCart);
router.post('/cart/update', userController.updateCartQuantity);
router.post('/cart/remove/:productId', userController.removeFromCart);

router.post('/address/save', userController.saveAddress); // Keep existing save route

router.get('/checkout', userController.getCheckoutPage);

module.exports = router;

services/otpService.js:
const crypto = require('crypto');

const generateOTP = (length = 6) => {
  const buffer = crypto.randomBytes(Math.ceil(length / 2));
  let otp = buffer.toString('hex');
  otp = otp.replace(/[^0-9]/g, '');
  otp = otp.slice(0, length);
  while (otp.length < length) {
    otp = '0' + otp;
  }
  return otp;
};

const setOTPExpiration = (minutes = 10) => {
  return Date.now() + minutes * 60 * 1000;
};

module.exports = { generateOTP, setOTPExpiration };


views/admin/assigned-orders-detail.ejs :

<%# views/admin/assigned-orders-detail.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p><a href="/admin/manage-assigned-orders">« Back to Delivery Admin Overview</a></p>

    <% if (orders.length > 0) { %>
        <table class="data-table">
            <thead>
                 <tr>
                    <th>Image</th>
                    <th>Order ID</th>
                    <th>Placed Date</th>
                     <th>Customer Email</th>
                     <th>Address</th>
                     <th>Items</th>
                    <th>Total</th>
                     <th>Status</th>
                     <th>Delivered Date</th>
                 </tr>
             </thead>
            <tbody>
                <% orders.forEach(order => { %>
                    <tr>
                        <td>
                            <% if (order.products && order.products.length > 0 && order.products[0].imageUrl) { %>
                                <a href="/products/<%= order.products[0].productId %>">
                                    <img src="<%= order.products[0].imageUrl %>" alt="<%= order.products[0].name %>" class="table-img">
                                </a>
                            <% } else { %>
                                <span class="text-muted">N/A</span>
                            <% } %>
                        </td>
                         <td><%= order._id %></td>
                         <td><%= order.formattedOrderDate %></td>
                        <td><%= order.userEmail %></td>
                        <td>
                             <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %>
                             <br>Ph: <%= order.shippingAddress.phone %>
                         </td>
                         <td>
                            <% if (order.products && order.products.length > 0) { %>
                                <%= order.products[0].name %> (x<%= order.products[0].quantity %>)
                                <% if (order.products.length > 1) { %>
                                    <br><small>+ <%= order.products.length - 1 %> more item(s)</small>
                                <% } %>
                            <% } else { %>
                                No items found
                            <% } %>
                         </td>
                         <%# --- CURRENCY UPDATE --- %>
                         <td>₹<%= order.totalAmount.toFixed(2) %></td>
                         <%# --- END CURRENCY UPDATE --- %>
                         <td><span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span></td>
                         <td><%= order.formattedReceivedDate %></td>
                    </tr>
                <% }) %>
             </tbody>
        </table>
     <% } else { %>
         <p>No orders found matching this criteria for <%= deliveryAdminEmail %>.</p>
     <% } %>
</div>

<%- include('../partials/footer') %>

 views/admin/dashboard.ejs : 
<%- include('../partials/header', { title: 'Admin Dashboard' }) %>

<div class="admin-dashboard-container">
    <h1>Admin Dashboard</h1>
    <p class="text-muted mb-3">Welcome, <%= currentUser.name %>!</p>

    <div class="admin-actions-grid">
         <a href="/admin/upload-product" class="admin-action-card card"> <%# ADDED .card %>
            <i class="fas fa-upload"></i>
            <h3>Upload Products</h3>
            <p>Add new products to the store.</p>
        </a>
         <a href="/admin/manage-products" class="admin-action-card card"> <%# ADDED .card %>
            <i class="fas fa-edit"></i>
            <h3>Manage Products</h3>
            <p>Edit or remove existing products.</p>
         </a>
        <a href="/admin/manage-orders" class="admin-action-card card"> <%# ADDED .card %>
             <i class="fas fa-clipboard-list"></i>
             <h3>Manage Orders</h3>
             <p>View, verify, and assign orders.</p>
        </a>
        <a href="/admin/manage-users" class="admin-action-card card"> <%# ADDED .card %>
             <i class="fas fa-users-cog"></i>
             <h3>Manage Users</h3>
             <p>Update roles or remove users.</p>
        </a>
         <a href="/admin/manage-assigned-orders" class="admin-action-card card"> <%# ADDED .card %>
            <i class="fas fa-shipping-fast"></i>
            <h3>Manage Assigned Orders</h3>
             <p>Track delivery admin progress.</p>
         </a>
    </div>
</div>

 <%- include('../partials/footer') %>

views/admin/edit-product.ejs :
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>

     <form action="/admin/manage-products/update/<%= product._id %>" method="POST">
        <div class="form-group">
             <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" value="<%= product.name %>" required>
         </div>
        <div class="form-group">
            <label for="category">Category:</label>
             <input type="text" id="category" name="category" value="<%= product.category %>" required>
         </div>
         <div class="form-group">
            <label for="price">Price:</label>
            <input type="number" id="price" name="price" step="0.01" min="0" value="<%= product.price %>" required>
         </div>
        <div class="form-group">
             <label for="stock">Stock Quantity:</label>
             <input type="number" id="stock" name="stock" min="0" value="<%= product.stock %>" required>
        </div>
         <div class="form-group">
             <label for="imageUrl">Image URL:</label>
             <input type="url" id="imageUrl" name="imageUrl" value="<%= product.imageUrl %>" required>
             <% if(product.imageUrl) { %> <img src="<%= product.imageUrl %>" alt="Current Image" style="max-width: 100px; margin-top: 5px;"> <% } %>
         </div>
         <div class="form-group">
             <label for="specifications">Specifications:</label>
             <textarea id="specifications" name="specifications" rows="5"><%= product.specifications %></textarea>
        </div>
         <button type="submit" class="btn btn-primary">Update Product</button>
         <a href="/admin/manage-products" class="btn btn-secondary">Cancel</a>
    </form>
 </div>

 <%- include('../partials/footer') %>

 views/admin/manage-assigned-orders.ejs : 
<%- include('../partials/header', { title: 'Manage Assigned Orders' }) %>

<div class="admin-manage-container">
    <h1>Manage Delivery Admins & Assigned Orders</h1>

    <% if (deliveryAdmins.length > 0) { %>
        <table class="data-table">
            <thead>
               <tr>
                    <th>Delivery Admin</th>
                   <th>Total Assigned</th>
                   <th>Pending Deliveries</th>
                    <th>Delivered</th>
                    <th>Actions</th>
               </tr>
           </thead>
            <tbody>
               <% deliveryAdmins.forEach(admin => { %>
                   <tr>
                        <%# --- MODIFIED: Display email and phone --- %>
                        <td>
                           <%= admin.email %>
                           <% if (admin.address && admin.address.phone) { %>
                               <br><small>(<%= admin.address.phone %>)</small>
                           <% } else { %>
                               <br><small class="text-danger">(No Phone Added)</small>
                           <% } %>
                       </td>
                       <%# --- END MODIFICATION --- %>
                        <td><a href="/admin/manage-assigned-orders/details/<%= admin._id %>/total"><%= admin.totalAssigned %></a></td>
                        <td><a href="/admin/manage-assigned-orders/details/<%= admin._id %>/pending"><%= admin.pendingCount %></a></td>
                        <td><a href="/admin/manage-assigned-orders/details/<%= admin._id %>/delivered"><%= admin.deliveredCount %></a></td>
                       <td class="actions-cell">
                            <form action="/admin/manage-assigned-orders/remove/<%= admin._id %>" method="POST" class="inline-form" onsubmit="return confirm('Are you sure you want to REMOVE Delivery Admin <%= admin.email %>? This will also unassign their active orders.');">
                               <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-user-times"></i> Remove Admin & Unassign</button>
                           </form>
                       </td>
                   </tr>
                <% }) %>
            </tbody>
        </table>
    <% } else { %>
       <p>No users found with the 'delivery_admin' role. <a href="/admin/manage-users">Manage users</a> to assign the role.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/admin/manage-orders.ejs : 
<%# views/admin/manage-orders.ejs %>
<%- include('../partials/header', { title: 'Manage Orders' }) %>

<div class="admin-manage-container">
    <h1>Manage Orders</h1>

    <%# --- START: Bulk Assign Form --- %>
    <form action="/admin/orders/bulk-assign" method="POST" id="bulk-assign-form" class="form-submit-spinner">
        <%# --- Bulk Action Controls (Initially Hidden) --- %>
        <div id="bulk-action-controls" class="bulk-actions-container card mb-3 p-2" style="display: none;">
             <h4>Bulk Assign Selected Orders (<span id="selected-count">0</span> selected)</h4>
             <% if (deliveryAdmins && deliveryAdmins.length > 0) { %>
                <div class="form-inline"> <%# Use form-inline for better layout on desktop %>
                     <label for="bulkDeliveryAdminId" class="mr-2">Assign to:</label>
                     <select name="deliveryAdminId" id="bulkDeliveryAdminId" required class="form-control form-control-sm mr-2" style="width: auto; display: inline-block;">
                         <option value="" disabled selected>Select Delivery Admin...</option>
                         <% deliveryAdmins.forEach(admin => { %>
                             <option value="<%= admin._id %>">
                                <%= admin.email %> <% if (admin.address && admin.address.phone) { %>(<%= admin.address.phone %>)<% } %>
                             </option>
                         <% }) %>
                     </select>
                     <button type="submit" class="btn btn-info btn-sm">Assign Selected</button>
                </div>
             <% } else { %>
                 <p class="text-danger">No delivery admins available for bulk assignment.</p>
             <% } %>
        </div>
        <%# --- End Bulk Action Controls --- %>

        <% if (orders.length > 0) { %>
            <div class="table-container card">
                <table class="data-table">
                    <thead>
                        <tr>
                            <%# --- Add Checkbox Header --- %>
                            <th style="width: 30px;">
                                <input type="checkbox" id="select-all-orders" title="Select all assignable orders">
                            </th>
                            <th>Images</th>
                            <th>Order ID</th>
                            <th>Date</th>
                            <th>Customer</th>
                            <th>Address & Phone</th>
                            <th>Items & Prices</th>
                            <th>Total</th>
                            <th>Status & Assignment</th>
                            <th class="actions-cell" style="text-align: right;">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <% orders.forEach(order => { %>
                            <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %>" data-order-id="<%= order._id %>">
                                <%# --- Add Checkbox Cell --- %>
                                <td>
                                    <% if (order.canBeAssignedByAdmin) { %>
                                        <input type="checkbox" name="orderIds[]" value="<%= order._id %>" class="order-checkbox" aria-label="Select order <%= order._id %> for bulk action">
                                    <% } %>
                                </td>
                                <td data-label="Images">
                                    <% if (order.products && order.products.length > 0) { %>
                                        <% order.products.slice(0, 3).forEach(item => { %>
                                            <% if (item.productId && item.productId._id && item.imageUrl) { %>
                                                <a href="/products/<%= item.productId._id %>" title="View Product: <%= item.name %>">
                                                    <img src="<%= item.imageUrl %>" alt="<%= item.name %>" class="table-img">
                                                </a>
                                            <% } else { %><span class="text-muted" style="font-size: 0.8em;">[?]</span><% } %>
                                        <% }) %>
                                        <% if (order.products.length > 3) { %><br><small class="text-muted" style="white-space: nowrap;">+ <%= order.products.length - 3 %> more</small><% } %>
                                    <% } else { %><span class="text-muted">N/A</span><% } %>
                                </td>
                                <td data-label="Order ID"><%= order._id %></td>
                                <td data-label="Date"><%= order.formattedOrderDate %></td>
                                <td data-label="Customer"><%= order.userEmail %></td>
                                <td data-label="Address & Phone">
                                    <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %>
                                    <br><strong>Ph: <%= order.shippingAddress.phone %></strong>
                                </td>
                                <td data-label="Items & Prices">
                                    <% if (order.products && order.products.length > 0) { %>
                                        <% order.products.forEach((item, index) => { %>
                                            <% if (item.productId) { %>
                                                <%= item.name %> (Qty: <%= item.quantity %>) : ₹<%= item.priceAtOrder.toFixed(2) %>
                                            <% } else { %>
                                                [Removed Product] (Qty: <%= item.quantity %>) : ₹<%= item.priceAtOrder.toFixed(2) %>
                                            <% } %>
                                            <% if (index < order.products.length - 1) { %><br><% } %>
                                        <% }) %>
                                    <% } else { %>No items found<% } %>
                                </td>
                                <td data-label="Total"><strong>₹<%= order.totalAmount.toFixed(2) %></strong></td>
                                <td data-label="Status & Assignment">
                                    <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span>
                                    <% if(order.assignedAdminEmail) { %><br><small>(Assigned: <%= order.assignedAdminEmail %>)</small><% } %>
                                    <% if(order.status === 'Cancelled' && order.cancellationReason) { %><br><small class="text-danger">Reason: <%= order.cancellationReason %></small><% } %>
                                    <% if(order.status === 'Delivered' && order.formattedReceivedDate) { %><br><small class="text-success">Delivered: <%= order.formattedReceivedDate %></small><% } %>
                                </td>
                                <td data-label="Actions" class="actions-cell">
                                    <%# --- Keep existing Individual Actions --- %>

                                    <%# Direct Delivery Confirmation by Admin (Pending orders) %>
                                    <% if (order.canBeDirectlyDeliveredByAdmin) { %>
                                        <div class="action-group">
                                            <p class="action-group-title">Admin Direct Delivery:</p>
                                            <form action="/admin/orders/<%= order._id %>/send-direct-delivery-otp" method="POST" class="inline-form form-submit-spinner">
                                                <button type="submit" class="btn btn-warning btn-sm" title="Send delivery confirmation OTP to customer for direct delivery">
                                                    <i class="fas fa-mobile-alt"></i> Send OTP
                                                </button>
                                            </form>
                                            <form action="/admin/orders/<%= order._id %>/confirm-direct-delivery" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                                <input type="text" name="otp" placeholder="6-Digit OTP" required size="8" pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter the 6-digit OTP from customer">
                                                <button type="submit" class="btn btn-success btn-sm" title="Confirm direct delivery">
                                                    <i class="fas fa-check-double"></i> Confirm
                                                </button>
                                            </form>
                                        </div>
                                    <% } %>

                                    <%# Assign Order to Delivery Admin (Pending orders) - INDIVIDUAL %>
                                    <% if (order.canBeAssignedByAdmin) { %>
                                        <div class="action-group">
                                            <p class="action-group-title">Assign (Individually):</p>
                                            <% if (deliveryAdmins && deliveryAdmins.length > 0) { %>
                                                <form action="/admin/orders/<%= order._id %>/assign" method="POST" class="inline-form assign-order-form form-submit-spinner">
                                                    <select name="deliveryAdminId" required class="form-control form-control-sm">
                                                        <option value="" disabled selected>Assign to...</option>
                                                        <% deliveryAdmins.forEach(admin => { %>
                                                            <option value="<%= admin._id %>">
                                                                <%= admin.email %> <% if (admin.address && admin.address.phone) { %>(<%= admin.address.phone %>)<% } %>
                                                            </option>
                                                        <% }) %>
                                                    </select>
                                                    <button type="submit" class="btn btn-info btn-sm">
                                                        <i class="fas fa-shipping-fast"></i> Assign
                                                    </button>
                                                </form>
                                            <% } else { %>
                                                <small class="text-danger d-block">No delivery admins.</small>
                                            <% } %>
                                        </div>
                                    <% } %>

                                    <%# Unassign Order from Delivery Admin (Out for Delivery orders) %>
                                    <% if (order.canBeUnassignedByAdmin) { %>
                                        <div class="action-group">
                                            <p class="action-group-title">Unassign Delivery:</p>
                                            <form action="/admin/orders/<%= order._id %>/unassign" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to unassign this order from <%= order.assignedAdminEmail %>? It will return to Pending status.');">
                                                <button type="submit" class="btn btn-secondary btn-sm" title="Return order to Pending queue">
                                                    <i class="fas fa-undo"></i> Unassign
                                                </button>
                                            </form>
                                        </div>
                                    <% } %>

                                    <%# Cancel Order (Admin: Pending or Out for Delivery) %>
                                    <% if (order.canBeCancelledByAdmin) { %>
                                        <div class="action-group">
                                            <form action="/admin/orders/<%= order._id %>/cancel" method="POST" class="inline-form cancel-delivery-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to cancel this order? This cannot be undone.');">
                                                <label for="reason-<%= order._id %>" class="action-group-title">Cancel Order:</label>
                                                <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm">
                                                    <option value="" disabled selected>Select Reason...</option>
                                                    <% cancellationReasons.forEach(reason => { %>
                                                        <option value="<%= reason %>"><%= reason %></option>
                                                    <% }) %>
                                                </select>
                                                <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-ban"></i> Cancel Order</button>
                                            </form>
                                        </div>
                                    <% } %>

                                    <%# Fallback %>
                                    <% if (!order.canBeDirectlyDeliveredByAdmin && !order.canBeAssignedByAdmin && !order.canBeUnassignedByAdmin && !order.canBeCancelledByAdmin) { %>
                                        <% if (order.status === 'Delivered') { %><small class="text-success">Completed.</small><% } else if (order.status === 'Cancelled') { %><small class="text-danger">Cancelled.</small><% } else { %><small class="text-muted">No actions available.</small><% } %>
                                    <% } %>
                                    <%# --- End Individual Actions --- %>
                                </td>
                            </tr>
                        <% }) %>
                    </tbody>
                </table>
            </div>
        <% } else { %>
            <p>No orders received yet.</p>
        <% } %>
    </form> <%# --- END: Bulk Assign Form --- %>
</div>

<%- include('../partials/footer') %>

views/admin/manage-products.ejs :
<%# Example: views/admin/manage-products.ejs %>
<%- include('../partials/header', { title: 'Manage Products' }) %>

<div class="admin-manage-container">
    <h1>Manage Products</h1>
    <a href="/admin/upload-product" class="btn btn-primary mb-3"><i class="fas fa-plus"></i> Upload New Product</a>

   <% if (products.length > 0) { %>
       <div class="table-container card"> <%# WRAP with .table-container and .card %>
           <table class="data-table">
               <thead>
                   <tr>
                       <th>Image</th>
                       <th>Name</th>
                       <th>Category</th>
                       <th>Price</th>
                       <th>Stock</th>
                       <th>Sold</th>
                       <th>Rating</th>
                       <th class="actions-cell" style="text-align: right;">Actions</th> <%# Align header right %>
                   </tr>
                </thead>
                <tbody>
                   <% products.forEach(product => { %>
                       <tr>
                           <td data-label="Image"><a href="/products/<%= product._id %>"><img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="table-img"></a></td>
                            <td data-label="Name"><%= product.name %></td>
                            <td data-label="Category"><%= product.category %></td>
                            <td data-label="Price">₹<%= product.price.toFixed(2) %></td>
                            <td data-label="Stock"><%= product.stock %></td>
                            <td data-label="Sold"><%= product.orderCount %></td>
                            <td data-label="Rating"><%= product.averageRating.toFixed(1) %> (<%= product.numReviews %>)</td>
                            <td data-label="Actions" class="actions-cell">
                               <a href="/admin/manage-products/edit/<%= product._id %>" class="btn btn-text btn-sm" title="Edit"><i class="fas fa-edit"></i></a> <%# Text button for icon %>
                               <form action="/admin/manage-products/remove/<%= product._id %>" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to remove this product: <%= product.name %>?');">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove"><i class="fas fa-trash"></i></button> <%# Text button for icon %>
                               </form>
                           </td>
                        </tr>
                    <% }) %>
               </tbody>
            </table>
       </div>
   <% } else { %>
        <p class="text-muted mt-3">No products found. <a href="/admin/upload-product">Upload the first product!</a></p>
   <% } %>
</div>

<%- include('../partials/footer') %>

 views/admin/manage-users.ejs :
<%- include('../partials/header', { title: 'Manage Users' }) %>

<div class="admin-manage-container">
    <h1>Manage Users</h1>

    <% if (users.length > 0) { %>
         <table class="data-table">
             <thead>
                <tr>
                     <th>Name</th>
                    <th>Email / Phone</th> <%# Updated Header %>
                     <th>Role</th>
                     <th>Registered On</th>
                     <th>Verified</th>
                    <th>Actions</th>
                 </tr>
             </thead>
            <tbody>
                <% users.forEach(user => { %>
                    <tr>
                         <td><%= user.name %></td>
                         <%# --- MODIFIED: Display email and phone --- %>
                         <td>
                            <%= user.email %>
                            <% if (user.address && user.address.phone) { %>
                                <br><small>(<%= user.address.phone %>)</small>
                            <% } %>
                         </td>
                         <%# --- END MODIFICATION --- %>
                        <td>
                            <form action="/admin/users/<%= user._id %>/update-role" method="POST" class="inline-form">
                                 <select name="role" onchange="this.form.submit()">
                                     <option value="user" <%= user.role === 'user' ? 'selected' : '' %>>User</option>
                                    <option value="admin" <%= user.role === 'admin' ? 'selected' : '' %>>Admin</option>
                                     <option value="delivery_admin" <%= user.role === 'delivery_admin' ? 'selected' : '' %>>Delivery Admin</option>
                                 </select>
                                 <noscript><button type="submit" class="btn btn-sm btn-primary">Update Role</button></noscript>
                            </form>
                        </td>
                         <td><%= new Date(user.createdAt).toLocaleDateString() %></td>
                         <td><%= user.isVerified ? 'Yes' : 'No' %></td>
                         <td class="actions-cell">
                             <form action="/admin/users/<%= user._id %>/remove" method="POST" class="inline-form" onsubmit="return confirm('Are you sure you want to remove user <%= user.email %>? This is irreversible.');">
                                <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-user-times"></i> Remove</button>
                            </form>
                         </td>
                    </tr>
                 <% }) %>
            </tbody>
        </table>
     <% } else { %>
         <p>No other users registered.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

 views/admin/upload-product.ejs : 
<%- include('../partials/header', { title: 'Upload New Product' }) %>

<div class="admin-manage-container">
    <h1>Upload New Product</h1>

     <form action="/admin/upload-product" method="POST">
        <div class="form-group">
             <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" required>
         </div>
        <div class="form-group">
            <label for="category">Category:</label>
             <input type="text" id="category" name="category" required>
         </div>
         <div class="form-group">
            <label for="price">Price:</label>
            <input type="number" id="price" name="price" step="0.01" min="0" required>
         </div>
        <div class="form-group">
             <label for="stock">Stock Quantity:</label>
             <input type="number" id="stock" name="stock" min="0" required>
        </div>
         <div class="form-group">
             <label for="imageUrl">Image URL:</label>
             <input type="url" id="imageUrl" name="imageUrl" required>
         </div>
         <div class="form-group">
             <label for="specifications">Specifications:</label>
             <textarea id="specifications" name="specifications" rows="5"></textarea>
        </div>
         <button type="submit" class="btn btn-primary">Upload Product</button>
         <a href="/admin/dashboard" class="btn btn-secondary">Cancel</a>
    </form>
 </div>

 <%- include('../partials/footer') %>


views/auth/forgot-password.ejs :
<%- include('../partials/header', { title: 'Forgot Password' }) %>

<div class="auth-container">
    <h1>Forgot Password</h1>
    <p>Enter your email address below. If an account exists, we'll send an OTP to verify your request.</p>

    <form action="/auth/forgot-password" method="POST" class="auth-form">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required>
        </div>
        <button type="submit" class="btn btn-primary">Send Reset OTP</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>


 views/auth/login.ejs :
<%- include('../partials/header', { title: 'Login' }) %>

<div class="auth-container">
    <h1>Login</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/login" method="POST" class="auth-form form-submit-spinner">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" required autocomplete="current-password">
        </div>
        <button type="submit" class="btn btn-primary">Login</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/forgot-password">Forgot Password?</a></p>
        <p>Don't have an account? <a href="/auth/register">Register here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

 views/auth/register.ejs : 
<%- include('../partials/header', { title: 'Register' }) %>

<div class="auth-container">
    <h1>Register</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/register" method="POST" class="auth-form form-submit-spinner">
         <div class="form-group">
            <label for="name">Name:</label>
            <input type="text" id="name" name="name" required autocomplete="name">
        </div>
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" minlength="6" required autocomplete="new-password">
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required autocomplete="new-password">
        </div>
        <button type="submit" class="btn btn-primary">Register</button>
    </form>
    <div class="auth-links">
        <p>Already have an account? <a href="/auth/login">Login here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/reset-password.ejs :
<%- include('../partials/header', { title: 'Reset Password' }) %>

<div class="auth-container">
    <h1>Reset Password</h1>
    <p>Enter your new password below.</p>

    <form action="/auth/reset-password/<%= token %>" method="POST" class="auth-form">
        <div class="form-group">
            <label for="password">New Password:</label>
            <input type="password" id="password" name="password" minlength="6" required>
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm New Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required>
        </div>
        <button type="submit" class="btn btn-primary">Reset Password</button>
    </form>
     <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>


 views/auth/verify-otp.ejs :

<%- include('../partials/header', { title: title || 'Verify OTP' }) %>

<div class="auth-container">
    <h1>Verify OTP</h1>
    <p>An OTP has been sent to <strong><%= email %></strong>. Please enter it below.</p>

    <%# --- Spinner Class Added & Input Attributes Updated --- %>
    <form action="/auth/verify-otp" method="POST" class="auth-form form-submit-spinner">
         <input type="hidden" name="email" value="<%= email %>">
        <div class="form-group">
            <label for="otp">OTP Code:</label>
            <input type="text" <%# Changed type to text for better compatibility %>
                   id="otp"
                   name="otp"
                   required
                   pattern="\d{6}" <%# Ensures exactly 6 digits %>
                   maxlength="6"  <%# Limits input length %>
                   inputmode="numeric" <%# Suggests numeric keyboard on mobile %>
                   autocomplete="one-time-code" <%# Helps password managers/browsers %>
                   title="Enter the 6-digit OTP code received"> <%# Clear hint %>
        </div>
        <button type="submit" class="btn btn-primary">Verify OTP</button>
    </form>
    <div class="auth-links">
        <p>Didn't receive the OTP?</p>
        <form action="/auth/resend-otp" method="POST" style="display:inline;" class="form-submit-spinner">
             <input type="hidden" name="email" value="<%= email %>">
             <button type="submit" class="btn btn-secondary btn-sm">Resend OTP</button>
         </form>
    </div>
</div>

<%- include('../partials/footer') %>

 views/delivery/assigned-orders-detail.ejs :
<%# views/delivery/assigned-orders-detail.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="delivery-orders-detail-container admin-manage-container">
    <h1><%= title %></h1>
     <p><a href="/delivery/dashboard">« Back to Delivery Dashboard</a></p>

    <% if (orders.length > 0) { %>
        <table class="data-table">
            <thead>
                <tr>
                     <th>Image</th>
                     <th>Order ID</th>
                     <th>Placed Date</th>
                    <th>Customer</th>
                     <th>Address & Phone</th>
                    <th>Items</th>
                    <th>Order Total</th> <%# <-- ADDED HEADER %>
                     <th>Status</th>
                     <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <% orders.forEach(order => { %>
                    <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %>">
                        <td data-label="Image"> <%# Added data-label %>
                            <% if (order.products && order.products.length > 0 && order.products[0].imageUrl) { %>
                                <a href="/products/<%= order.products[0].productId %>">
                                    <img src="<%= order.products[0].imageUrl %>" alt="<%= order.products[0].name %>" class="table-img">
                                </a>
                            <% } else { %> <span class="text-muted">N/A</span> <% } %>
                        </td>
                         <td data-label="Order ID"><%= order._id %></td> <%# Added data-label %>
                         <td data-label="Placed Date"><%= order.formattedOrderDate %></td> <%# Added data-label %>
                         <td data-label="Customer"><%= order.shippingAddress.name %></td> <%# Added data-label %>
                         <td data-label="Address & Phone"> <%# Added data-label %>
                            <%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %>
                             <br><strong>Ph: <%= order.shippingAddress.phone %></strong>
                             <% if (order.shippingAddress.landmarkNearby) { %><br><small>Landmark: <%= order.shippingAddress.landmarkNearby %></small><% } %>
                        </td>
                         <td data-label="Items"> <%# Added data-label %>
                            <% if (order.products && order.products.length > 0) { %>
                                <%= order.products[0].name %> (x<%= order.products[0].quantity %>)
                                <% if (order.products.length > 1) { %><br><small>+ <%= order.products.length - 1 %> more item(s)</small><% } %>
                            <% } else { %> No items found <% } %>
                        </td>
                        <%# --- ADDED CELL for Total Amount --- %>
                        <td data-label="Order Total"><strong>₹<%= order.totalAmount.toFixed(2) %></strong></td>
                        <%# --- END ADDED CELL --- %>
                        <td data-label="Status"> <%# Added data-label %>
                            <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span> <%# Added status class %>
                            <% if(order.status === 'Delivered' && order.formattedReceivedDate) { %><br><small>(Delivered: <%= order.formattedReceivedDate %>)</small><% } %>
                            <% if(order.status === 'Cancelled' && order.cancellationReason) { %><br><small class="text-danger">Reason: <%= order.cancellationReason %></small><% } %>
                         </td>
                        <td data-label="Actions" class="actions-cell"> <%# Added data-label %>
                            <%# --- Delivery OTP Controls --- %>
                            <% if (order.canRequestDeliveryOtp) { %>
                                <div class="action-group"> <%# Wrapped in action-group %>
                                    <p class="action-group-title">Confirm Delivery:</p> <%# Optional title %>
                                    <form action="/delivery/orders/<%= order._id %>/send-delivery-otp" method="POST" class="inline-form form-submit-spinner">
                                        <button type="submit" class="btn btn-warning btn-sm" title="Send OTP to customer"><i class="fas fa-mobile-alt"></i> Send OTP</button>
                                    </form>
                                    <form action="/delivery/orders/<%= order._id %>/verify-delivery-otp" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                        <input type="text" <%# Changed type to text %>
                                               inputmode="numeric" <%# Suggest numeric keyboard %>
                                               name="otp"
                                               placeholder="6-Digit OTP"
                                               required
                                               size="8"
                                               maxlength="6" <%# Max length 6 %>
                                               pattern="\d{6}" <%# Exactly 6 digits %>
                                               autocomplete="one-time-code" <%# Helper attribute %>
                                               title="Enter 6-digit OTP from customer" <%# Clear hint %>
                                               class="form-control form-control-sm"> <%# Basic styling %>
                                        <button type="submit" class="btn btn-success btn-sm" title="Confirm delivery"><i class="fas fa-check-double"></i> Confirm</button>
                                    </form>
                                </div>
                            <% } %>

                            <%# --- Cancel Assigned Order (Delivery Admin) --- %>
                             <% if (order.canBeCancelledByDelivery) { %>
                                <div class="action-group"> <%# Wrapped in action-group %>
                                    <form action="/delivery/orders/<%= order._id %>/cancel-delivery" method="POST" class="inline-form cancel-delivery-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to cancel this delivery? This cannot be undone.');">
                                         <label for="reason-<%= order._id %>" class="action-group-title">Cancel Delivery:</label> <%# Label acts as title %>
                                         <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm"> <%# Basic styling %>
                                             <option value="" disabled selected>Select Reason...</option>
                                             <% cancellationReasons.forEach(reason => { %>
                                                 <option value="<%= reason %>"><%= reason %></option>
                                             <% }) %>
                                         </select>
                                        <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-ban"></i> Cancel</button>
                                     </form>
                                </div>
                             <% } %>

                             <%# --- Unassign Order (Delivery Admin) --- %>
                             <% if (order.canBeUnassignedByDelivery) { %>
                                 <div class="action-group"> <%# Wrapped in action-group %>
                                     <p class="action-group-title">Return to Admin:</p> <%# Optional title %>
                                     <form action="/delivery/orders/<%= order._id %>/unassign" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to unassign this order? It will return to the admin pool.');">
                                         <button type="submit" class="btn btn-outline-secondary btn-sm"><i class="fas fa-undo"></i> Unassign</button>
                                     </form>
                                 </div>
                             <% } %>

                            <%# --- Fallback messages for other statuses --- %>
                             <% if (!order.canRequestDeliveryOtp && !order.canBeCancelledByDelivery && !order.canBeUnassignedByDelivery) { %>
                                 <% if (order.status === 'Pending' || order.status === 'Order Received') { %>
                                    <small class="text-muted">Waiting for processing.</small>
                                <% } else if (order.status === 'Delivered') { %>
                                    <small class="text-success">Completed.</small>
                                <% } else if (order.status === 'Cancelled') { %>
                                    <% if (!order.cancellationReason) { %>
                                        <small class="text-danger">Cancelled.</small>
                                    <% } %>
                                <% } else { %>
                                    <small class="text-muted">No actions available.</small>
                                <% } %>
                             <% } %>
                         </td>
                    </tr>
                <% }) %>
            </tbody>
         </table>
     <% } else { %>
         <p>No orders found matching this criteria.</p>
     <% } %>
</div>

<%- include('../partials/footer') %>

 views/delivery/contact.ejs :
<%# views/delivery/contact.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="delivery-contact-container auth-container"> <%# Reusing some auth styles %>
    <h1>My Contact Information</h1>
    <p>Please add or update your phone number. This number will be used for coordination and is required to access delivery features.</p>

    <%# --- Spinner Class Added & Input Attributes Updated --- %>
    <form action="/delivery/contact" method="POST" class="auth-form form-submit-spinner">
        <div class="form-group">
            <label for="phone">Phone Number:</label>
            <input type="tel" <%# Correct semantic type %>
                   id="phone"
                   name="phone"
                   value="<%= currentPhoneNumber %>"
                   required
                   pattern="\d{10,15}" <%# Allow 10-15 digits %>
                   minlength="10"
                   maxlength="15"
                   title="Enter 10 to 15 digit phone number (numbers only)"> <%# Clear hint %>
            <small>Enter numbers only (e.g., 9392567247).</small>
        </div>
        <button type="submit" class="btn btn-primary">Save Phone Number</button>
         <% if (currentPhoneNumber) { %>
            <a href="/delivery/dashboard" class="btn btn-secondary">Back to Dashboard</a>
         <% } %>
    </form>

</div>

<%- include('../partials/footer') %>

 views/delivery/dashboard.ejs :
<%- include('../partials/header', { title: 'Delivery Dashboard' }) %>

<div class="delivery-dashboard-container">
    <h1>My Delivery Dashboard</h1>
    <p>Welcome, <%= currentUser.name %> (<%= assignedAdminEmail %>)!</p>

    <div class="delivery-stats-grid">
         <div class="stat-card">
            <h2><%= totalAssigned %></h2>
            <p>Total Assigned Orders</p>
            <a href="/delivery/orders/total" class="btn btn-primary">View All</a>
         </div>
        <div class="stat-card">
            <h2><%= pendingCount %></h2>
            <p>Pending Deliveries</p>
            <a href="/delivery/orders/pending" class="btn btn-warning">View Pending</a>
         </div>
        <div class="stat-card">
            <h2><%= deliveredCount %></h2>
            <p>Completed Deliveries</p>
            <a href="/delivery/orders/delivered" class="btn btn-success">View Delivered</a>
        </div>
     </div>
</div>

 <%- include('../partials/footer') %>



 views/partials/footer.ejs :
    </main> <%# End Main Content Area %>

    <footer class="app-footer desktop-only">
        <p>© <%= new Date().getFullYear() %> ProShop. All rights reserved.</p>
    </footer>

    <script src="/js/main.js"></script>

</body>
</html>

 views/partials/header.ejs :
<%# views/partials/header.ejs %>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %> | miniapp</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <header class="app-header">
        <nav class="navbar">
            <div class="nav-left">
                <a href="/" class="app-logo">
                   <i class="fas fa-shopping-bag"></i>
                   <span class="app-name">miniapp</span>
                </a>
            </div>
            <div class="nav-right">
                <% if (currentUser) { %>
                    <a href="/" class="nav-link <%= currentUrl === '/' ? 'active' : '' %>" title="Home">
                        <i class="fas fa-home"></i> <span>Home</span>
                    </a>
                     <a href="/user/cart" class="nav-link nav-link-cart <%= currentUrl === '/user/cart' ? 'active' : '' %>" title="Cart">
                         <i class="fas fa-shopping-cart"></i>
                         <% if (cartItemCount > 0) { %>
                             <span class="cart-badge"><%= cartItemCount %></span>
                         <% } else { %>
                             <span class="cart-badge" style="display: none;">0</span>
                         <% } %>
                          <span>Cart</span>
                     </a>
                    <a href="/orders/my-orders" class="nav-link <%= currentUrl === '/orders/my-orders' ? 'active' : '' %>" title="My Orders">
                        <i class="fas fa-box"></i> <span>Orders</span>
                    </a>

                    <%# --- START: Profile Avatar Link --- %>
                    <a href="/user/profile" class="profile-avatar-link <%= currentUrl === '/user/profile' ? 'active' : '' %>" title="My Profile">
                         <span class="profile-avatar-initials"><%= userInitials %></span>
                    </a>
                    <%# --- END: Profile Avatar Link --- %>

                <% } else { %>
                    <a href="/auth/login" class="btn btn-login-register">
                        <i class="fas fa-sign-in-alt"></i> Login / Register
                    </a>
                <% } %>
            </div>
        </nav>
    </header>

     <%- include('messages') %>

    <main class="container">


 views/partials/messages.ejs :
<% if (success_msg && success_msg.length > 0) { %>
  <div class="alert alert-success" role="alert">
    <%= success_msg %>
    <button type="button" class="close-alert" onclick="this.parentElement.style.display='none';">&times;</button>
  </div>
<% } %>

<% if (error_msg && error_msg.length > 0) { %>
  <div class="alert alert-danger" role="alert">
    <%= error_msg %>
     <button type="button" class="close-alert" onclick="this.parentElement.style.display='none';">&times;</button>
  </div>
<% } %>

<% if (error && typeof error !== 'undefined' && error.length > 0) { %>
  <div class="alert alert-danger" role="alert">
    <%= error %>
     <button type="button" class="close-alert" onclick="this.parentElement.style.display='none';">&times;</button>
  </div>
<% } %>



 views/products/detail.ejs :
<%- include('../partials/header', { title: product.name }) %>

<div class="product-detail-container">
   <div class="product-detail-main">
        <div class="product-detail-image">
           <img src="<%= product.imageUrl %>" alt="<%= product.name %>">
        </div>
       <div class="product-detail-info">
            <h1><%= product.name %></h1>
            <p class="detail-price">₹<%= product.price.toFixed(2) %></p>
            <p class="detail-stock">Available Stock: <%= product.stock %></p>

           <% if (product.numReviews > 0) { %>
                <p class="detail-rating">
                    Rating:
                   <% for(let i=1; i<=5; i++) { %>
                       <i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i>
                   <% } %>
                    (<%= product.numReviews %> reviews) | <%= product.orderCount %> Ordered
                </p>
            <% } else { %>
                <p class="detail-rating">No reviews yet | <%= product.orderCount %> Ordered</p>
            <% } %>

            <p>Seller: <%= product.sellerEmail %></p>

           <div class="product-actions">
                <form action="/user/cart/add" method="POST" style="display: inline-block; margin-right: 10px;" class="form-submit-spinner">
                   <input type="hidden" name="productId" value="<%= product._id %>">
                    <div class="quantity-selector">
                       <label for="quantity">Qty:</label>
                        <input type="number" id="quantity" name="quantity" value="1" min="1" max="<%= product.stock %>" required>
                    </div>
                    <button type="submit" class="btn btn-primary" <%= product.stock <= 0 ? 'disabled' : '' %>>
                        <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                    </button>
               </form>

                 <% if (product.stock > 0) { %>
                 <form action="/user/cart/add?redirectTo=checkout" method="POST" style="display: inline-block;" class="form-submit-spinner">
                       <input type="hidden" name="productId" value="<%= product._id %>">
                       <input type="hidden" name="quantity" value="1">
                      <button type="submit" class="btn btn-success">Buy Now</button>
                    </form>
                 <% } else {%>
                   <button class="btn btn-success" disabled>Buy Now</button>
                 <% } %>
           </div>

           <!-- Share Functionality -->
           <div class="share-section">
               <button id="share-product-btn" class="btn btn-secondary btn-sm"
                       data-title="<%= product.name %>"
                       data-text="Check out this product: <%= product.name %>"
                       data-url="<%= fullUrl %>">
                   <i class="fas fa-share-alt"></i> Share
               </button>
               <div id="fallback-share-links" class="fallback-share-links hidden">
                   <span>Share via:</span>
                   <a href="https://www.facebook.com/sharer/sharer.php?u=<%= encodeURIComponent(fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Facebook"><i class="fab fa-facebook-square"></i></a>
                   <a href="https://twitter.com/intent/tweet?url=<%= encodeURIComponent(fullUrl) %>&text=<%= encodeURIComponent('Check out this product: ' + product.name) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Twitter"><i class="fab fa-twitter-square"></i></a>
                   <a href="https://api.whatsapp.com/send?text=<%= encodeURIComponent('Check out this product: ' + product.name + ' ' + fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on WhatsApp"><i class="fab fa-whatsapp-square"></i></a>
                   <a href="mailto:?subject=<%= encodeURIComponent('Check out this product: ' + product.name) %>&body=<%= encodeURIComponent('I thought you might like this product:\n\n' + product.name + '\n' + fullUrl) %>" aria-label="Share via Email"><i class="fas fa-envelope-square"></i></a>
               </div>
           </div>
           <!-- End Share Functionality -->

           <div class="product-specifications">
                <h3>Specifications</h3>
                <pre><%= product.specifications || 'No specifications provided.' %></pre>
            </div>
       </div>
    </div>

   <div class="product-rating-section">
        <h3>Rate This Product</h3>
        <% if (userCanRate) { %>
            <form action="/products/<%= product._id %>/rate" method="POST" class="form-submit-spinner">
                <!-- RATING STARS SECTION (Loop 5 down to 1) -->
                <div class="rating-stars">
                    <% for (let i = 5; i >= 1; i--) { %>
                       <input type="radio" id="star<%= i %>" name="rating" value="<%= i %>" <%= userRating === i ? 'checked' : '' %> required>
                       <label for="star<%= i %>" title="<%= i %> stars"><i class="fas fa-star"></i></label>
                    <% } %>
                </div>
                <!-- END RATING STARS SECTION -->
                <button type="submit" class="btn btn-primary">Submit Rating</button>
            </form>
        <% } else { %>
           <p><a href="/auth/login?returnTo=<%= encodeURIComponent(currentUrl) %>">Login</a> to rate this product.</p>
        <% } %>
   </div>

    <!-- Rating Statistics Section -->
    <div class="rating-stats-container">
        <h3>Ratings & Reviews</h3>
         <% if (totalRatings > 0) { %>
             <div class="rating-summary">
                 <div class="rating-average">
                     <span class="rating-average-value"><%= product.averageRating.toFixed(1) %></span> <i class="fas fa-star"></i>
                 </div>
                 <div class="rating-total">
                     <%= totalRatings %> Rating<%= totalRatings !== 1 ? 's' : '' %>
                 </div>
             </div>

            <div class="rating-bars">
                <% for (let i = 5; i >= 1; i--) { %>
                    <%
                        const count = ratingCounts[i] || 0;
                        const percentage = totalRatings > 0 ? (count / totalRatings) * 100 : 0;
                    %>
                     <div class="rating-bar-row">
                         <span class="rating-bar-label"><%= i %> <i class="fas fa-star"></i></span>
                         <div class="rating-bar-progress">
                             <!-- Instead of inline CSS, we set the computed percentage as a data attribute -->
                             <div class="rating-bar-fill" data-width="<%= percentage.toFixed(1) %>"></div>
                         </div>
                         <span class="rating-bar-count"><%= count %></span>
                     </div>
                 <% } %>
            </div>
        <% } else { %>
            <p>No ratings yet for this product.</p>
         <% } %>
    </div>
    <!-- End Rating Statistics Section -->

</div>

<!-- Script to set dynamic widths for rating bars -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.rating-bar-fill').forEach(function(el) {
        var width = el.getAttribute('data-width');
        if (width) {
            el.style.width = width + '%';
        }
    });
});
</script>

<%- include('../partials/footer') %>



 views/products/index.ejs : 
<%# views/products/index.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="product-index-container">
    <h1><%= title %></h1>

    <div class="search-bar-container">
        <form action="/products" method="GET" class="search-form">
            <input type="text" name="search" placeholder="Search products by name, category..." value="<%= searchTerm %>" aria-label="Search Products">
            <button type="submit" class="btn" aria-label="Submit Search"><i class="fas fa-search"></i></button>
             <% if (searchTerm) { %>
                 <a href="/" class="btn btn-clear-search">Clear</a>
             <% } %>
        </form>
    </div>

    <% if (products.length > 0) { %>
        <div class="product-grid">
            <% products.forEach(product => { %>
                <div class="product-card">
                    <a href="/products/<%= product._id %>" class="product-link">
                        <img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="product-image">
                        <div class="product-info">
                            <h3 class="product-name"><%= product.name %></h3>
                            <%# --- CURRENCY UPDATE --- %>
                            <%# Safely handle potentially missing price before formatting %>
                            <p class="product-price">₹<%= (typeof product.price === 'number' ? product.price : 0).toFixed(2) %></p>
                            <%# --- END CURRENCY UPDATE --- %>
                            <p class="product-stock">Stock: <%= product.stock %></p>
                            <% if (product.numReviews > 0) { %>
                                 <p class="product-rating">
                                    <% for(let i=1; i<=5; i++) { %>
                                        <i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i>
                                    <% } %>
                                    (<%= product.numReviews %>)
                                 </p>
                            <% } else { %>
                                <p class="product-rating"> </p> <%# Keep space for alignment %>
                            <% } %>
                        </div>
                    </a>
                     <%# --- Spinner Class Added --- %>
                     <form action="/user/cart/add" method="POST" class="add-to-cart-form form-submit-spinner">
                         <input type="hidden" name="productId" value="<%= product._id %>">
                         <input type="hidden" name="quantity" value="1">
                        <button type="submit" class="btn btn-primary btn-add-to-cart" <%= product.stock <= 0 ? 'disabled' : '' %>>
                            <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                         </button>
                    </form>
                </div>
            <% }) %>
        </div>
    <% } else { %>
        <p>No products found matching your criteria.</p>
    <% } %>

</div>

<%- include('../partials/footer') %>

views/user/cart.ejs : 
<%# views/user/cart.ejs %>
<%- include('../partials/header', { title: 'Shopping Cart' }) %>

<div class="cart-container">
    <h1>Your Shopping Cart</h1>

    <% if (cart.length > 0) { %>
        <div class="cart-items">
            <% cart.forEach(item => { %>
                <div class="cart-item" data-product-id="<%= item.productId %>">
                    <div class="cart-item-image">
                        <a href="/products/<%= item.productId %>"><img src="<%= item.imageUrl %>" alt="<%= item.name %>"></a>
                    </div>
                    <div class="cart-item-details">
                        <h3 class="cart-item-name"><%= item.name %></h3>
                        <%# --- CURRENCY UPDATE --- %>
                        <%# Safely handle potentially missing item price %>
                        <p class="cart-item-price">₹<%= (typeof item.price === 'number' ? item.price : 0).toFixed(2) %></p>
                        <%# --- END CURRENCY UPDATE --- %>
                         <p class="cart-item-stock">Stock: <%= item.stock %></p>
                    </div>
                    <div class="cart-item-quantity">
                        <label for="quantity-<%= item.productId %>">Qty:</label>
                        <input type="number"
                               id="quantity-<%= item.productId %>"
                               class="quantity-input"
                               name="quantity"
                               value="<%= item.quantity %>"
                               min="0" <%# Allow 0 for removal via update %>
                               max="<%= item.stock %>"
                               data-product-id="<%= item.productId %>"
                               data-item-price="<%= item.price %>"
                               aria-label="Quantity for <%= item.name %>">
                        <button class="btn btn-secondary btn-sm btn-update-qty" data-product-id="<%= item.productId %>">Update</button> <%# Spinner handled by AJAX logic %>
                     </div>
                     <div class="cart-item-subtotal">
                         <%# --- CURRENCY UPDATE --- %>
                         <%# Safely handle potentially missing item subtotal %>
                         Subtotal: ₹<span class="item-subtotal-value"><%= (typeof item.subtotal === 'number' ? item.subtotal : 0).toFixed(2) %></span>
                         <%# --- END CURRENCY UPDATE --- %>
                    </div>
                    <div class="cart-item-remove">
                        <%# --- Spinner Class Added --- %>
                        <form action="/user/cart/remove/<%= item.productId %>" method="POST" class="form-submit-spinner">
                            <button type="submit" class="btn btn-danger btn-sm">× Remove</button>
                         </form>
                     </div>
                </div>
            <% }) %>
        </div>

         <div class="cart-summary">
             <%# --- CURRENCY UPDATE --- %>
             <%# Safely handle potentially missing cart total %>
             <h2>Cart Total: ₹<span id="cart-total-value"><%= (typeof cartTotal === 'number' ? cartTotal : 0).toFixed(2) %></span></h2>
             <%# --- END CURRENCY UPDATE --- %>
             <a href="/user/checkout" class="btn btn-success btn-checkout">Proceed to Checkout</a>
        </div>

    <% } else { %>
        <p>Your cart is empty. <a href="/">Continue Shopping</a></p>
    <% } %>
</div>

 <%- include('../partials/footer') %>

views/user/checkout.ejs : 
<%# views/user/checkout.ejs %>
<%- include('../partials/header', { title: 'Checkout' }) %>

<div class="checkout-container">
    <h1>Checkout</h1>

    <div class="checkout-grid">
        <div class="checkout-address">
            <h2>Shipping Address</h2>
            <% if (userAddress && userAddress.name) { %>
                <div class="saved-address">
                    <p><strong><%= userAddress.name %></strong></p>
                    <p><%= userAddress.phone %></p>
                    <p><%= userAddress.landmarkNearby ? userAddress.landmarkNearby + ', ' : '' %><%= userAddress.cityVillage %></p>
                    <p>Pincode: <%= userAddress.pincode %></p>
                    <button type="button" id="edit-address-btn" class="btn btn-secondary btn-sm">Edit Address</button>
                </div>
             <% } %>

            <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (userAddress && userAddress.name) ? 'hidden' : '' %> form-submit-spinner">
                <h3><%= (userAddress && userAddress.name) ? 'Edit Address' : 'Add Address' %></h3>
                <div class="form-group">
                    <label for="name">Full Name:</label>
                    <input type="text" id="name" name="name" value="<%= userAddress?.name || '' %>" required autocomplete="name">
                </div>
                <div class="form-group">
                    <label for="phone">Phone Number:</label>
                    <input type="tel" <%# Correct semantic type %>
                           id="phone"
                           name="phone"
                           value="<%= userAddress?.phone || '' %>"
                           required
                           pattern="\d{10,15}" <%# Expect 10-15 digits %>
                           minlength="10"  <%# Minimum 10 digits %>
                           maxlength="15" <%# Maximum 15 digits %>
                           title="Enter 10 to 15 digit phone number (numbers only)" <%# Clear hint %>
                           autocomplete="tel"> <%# Standard autocomplete %>
                </div>
                 <div class="form-group">
                    <label for="pincode">Pincode:</label>
                     <input type="text" <%# Use text type, pattern handles format %>
                            id="pincode"
                            name="pincode"
                            value="<%= userAddress?.pincode || '' %>"
                            required
                            pattern="\d{6}" <%# Assuming 6 digit Indian pincode %>
                            maxlength="6"
                            inputmode="numeric"
                            title="Enter 6-digit Pincode"
                            autocomplete="postal-code">
                </div>
                 <div class="form-group">
                    <label for="cityVillage">City / Village:</label>
                     <input type="text" id="cityVillage" name="cityVillage" value="<%= userAddress?.cityVillage || '' %>" required autocomplete="address-level2">
                </div>
                <div class="form-group">
                    <label for="landmarkNearby">Landmark / Nearby (Optional):</label>
                     <input type="text" id="landmarkNearby" name="landmarkNearby" value="<%= userAddress?.landmarkNearby || '' %>">
                </div>
                <button type="submit" class="btn btn-primary">Save Address</button>
                <% if (userAddress && userAddress.name) { %>
                    <button type="button" id="cancel-edit-btn" class="btn btn-secondary">Cancel Edit</button>
                <% } %>
             </form>
        </div>

         <div class="checkout-summary">
             <h2>Order Summary</h2>
             <div class="checkout-items">
                 <% items.forEach(item => { %>
                    <div class="checkout-item">
                         <a href="/products/<%= item.productId %>" class="checkout-item-image">
                            <img src="<%= item.imageUrl %>" alt="<%= item.name %>">
                        </a>
                        <div class="checkout-item-info">
                             <%= item.name %> (Qty: <%= item.quantity %>)
                        </div>
                        <div class="checkout-item-price">₹<%= item.itemTotal.toFixed(2) %></div>
                     </div>
                <% }) %>
            </div>
            <hr>
            <div class="checkout-totals">
                <p>Subtotal: <span>₹<%= subTotal.toFixed(2) %></span></p>
                 <p>Shipping: <span>FREE</span></p>
                <hr>
                 <p><strong>Total: <span>₹<%= totalAmount.toFixed(2) %></span></strong></p>
            </div>

            <div class="checkout-payment">
                <h3>Payment Method</h3>
                 <div class="payment-option selected">
                     <input type="radio" id="cod" name="paymentMethodValue" value="COD" checked disabled>
                     <label for="cod"><i class="fas fa-money-bill-wave"></i> Cash on Delivery (COD)</label>
                 </div>
            </div>

            <form action="/orders/place" method="POST" class="place-order-form form-submit-spinner">
                 <input type="hidden" name="paymentMethod" value="COD">
                 <button type="submit" class="btn btn-success btn-block btn-place-order" <%= (!userAddress || !userAddress.name) ? 'disabled' : '' %>>
                    Place Order
                 </button>
                 <% if (!userAddress || !userAddress.name) { %>
                    <p class="text-danger small">Please add/save your shipping address first.</p>
                 <% } %>
             </form>
         </div>
    </div>
</div>

<%- include('../partials/footer') %>

<%# Checkout specific JS logic was moved to public/js/main.js %>

views/user/my-orders.ejs :
<%# views/user/my-orders.ejs %>
<%- include('../partials/header', { title: 'My Orders' }) %>

<div class="my-orders-container">
    <h1>My Orders</h1>

    <% if (orders.length > 0) { %>
        <div class="order-list">
            <% orders.forEach(order => { %>
                <div class="order-card status-<%= order.status.toLowerCase().replace(/ /g, '-') %>">
                     <div class="order-header">
                         <div><strong>Order ID:</strong> <%= order._id %></div>
                        <div><strong>Placed on:</strong> <%= order.formattedOrderDate %></div>
                         <%# --- CURRENCY UPDATE --- %>
                        <div><strong>Total:</strong> ₹<%= order.totalAmount.toFixed(2) %></div>
                         <%# --- END CURRENCY UPDATE --- %>
                         <div><strong>Status:</strong> <span class="order-status"><%= order.status %></span></div>
                     </div>
                    <div class="order-body">
                         <div class="order-items-preview">
                             <% order.products.slice(0, 3).forEach(item => { %>
                                <a href="/products/<%= item.productId %>" title="<%= item.name %> (Qty: <%= item.quantity %>)"> <%# Added title %>
                                    <img src="<%= item.imageUrl %>" alt="<%= item.name %>">
                                </a>
                             <% }) %>
                             <% if(order.products.length > 3) { %><span class="more-items">+ <%= order.products.length - 3 %> more</span><% } %>
                        </div>
                        <div class="order-details">
                             <p><strong>Shipping To:</strong> <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, Pin: <%= order.shippingAddress.pincode %></p>
                             <p><strong>Delivered On:</strong> <%= order.formattedReceivedDate %></p>
                              <p><strong>Assigned:</strong> <%= order.assignedAdminEmail || 'Not Assigned Yet' %></p>
                              <% if (order.status === 'Cancelled' && order.cancellationReason) { %>
                                <p class="text-danger"><small><strong>Reason:</strong> <%= order.cancellationReason %></small></p>
                              <% } %>
                         </div>
                    </div>
                     <div class="order-actions">
                        <% if (order.isCancellable) { %>
                             <%# --- Spinner Class Added --- %>
                            <form action="/orders/cancel/<%= order._id %>" method="POST" onsubmit="return confirm('Are you sure you want to cancel this order?');" class="form-submit-spinner">
                                <button type="submit" class="btn btn-danger btn-sm">Cancel Order</button>
                             </form>
                         <% } else if (order.status === 'Pending') { %>
                             <small class="text-muted">Cancellation window closed or processing.</small>
                         <% } else if (order.status === 'Out for Delivery') { %>
                             <small class="text-info">Order is out for delivery.</small>
                         <% } else if (order.status === 'Delivered') { %>
                              <small class="text-success">Order delivered.</small>
                         <% } else if (order.status === 'Cancelled') { %>
                              <small class="text-danger">Order was cancelled.</small>
                         <% } %>
                     </div>
                </div>
            <% }) %>
        </div>
    <% } else { %>
        <p>You haven't placed any orders yet. <a href="/">Start Shopping!</a></p>
    <% } %>
</div>

<%- include('../partials/footer') %>


views/user/profile.ejs:
<%# views/user/profile.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="profile-container">
    <h1>My Profile</h1>
    <p class="text-muted mb-3">Welcome, <%= user.name %> (<%= user.email %>)</p>

    <%# --- Conditional Dashboards --- %>
    <div class="profile-section dashboards-section">
        <h2>Dashboards</h2>
        <% if (user.role === 'admin') { %>
            <p><a href="/admin/dashboard" class="btn btn-info"><i class="fas fa-user-shield"></i> Go to Admin Dashboard</a></p>
        <% } %>
        <% if (user.role === 'delivery_admin') { %>
            <p><a href="/delivery/dashboard" class="btn btn-warning"><i class="fas fa-truck"></i> Go to Delivery Dashboard</a></p>
            <p><a href="/delivery/contact" class="btn btn-secondary"><i class="fas fa-phone-alt"></i> Update Delivery Contact</a></p> <%# Link to contact page %>
        <% } %>
        <% if (user.role === 'user') { %>
            <p>You have standard user access.</p>
        <% } %>
    </div>

    <%# --- Address Management --- %>
    <div class="profile-section address-section">
        <h2>My Address</h2>
        <%# Display saved address if it exists %>
        <div id="saved-address-display" class="<%= (!user.address || !user.address.name) ? 'hidden' : '' %>">
            <% if (user.address && user.address.name) { %>
                <p><strong><%= user.address.name %></strong></p>
                <p><%= user.address.phone %></p>
                <p><%= user.address.landmarkNearby ? user.address.landmarkNearby + ', ' : '' %><%= user.address.cityVillage %></p>
                <p>Pincode: <%= user.address.pincode %></p>
                <button type="button" id="edit-address-btn" class="btn btn-secondary btn-sm">Edit Address</button>
            <% } %>
        </div>

        <%# Address form (hidden initially if address exists) %>
        <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (user.address && user.address.name) ? 'hidden' : '' %> form-submit-spinner">
            <h3><%= (user.address && user.address.name) ? 'Edit Address' : 'Add Address' %></h3>
            <input type="hidden" name="source" value="profile"> <%# IMPORTANT: Tells backend where save request came from %>
            <div class="form-group">
                <label for="name">Full Name:</label>
                <input type="text" id="name" name="name" value="<%= user.address?.name || '' %>" required autocomplete="name">
            </div>
            <div class="form-group">
                <label for="phone">Phone Number:</label>
                <input type="tel"
                       id="phone"
                       name="phone"
                       value="<%= user.address?.phone || '' %>"
                       required
                       pattern="\d{10,15}"
                       minlength="10"
                       maxlength="15"
                       title="Enter 10 to 15 digit phone number (numbers only)"
                       autocomplete="tel">
            </div>
            <div class="form-group">
                <label for="pincode">Pincode:</label>
                <input type="text"
                       id="pincode"
                       name="pincode"
                       value="<%= user.address?.pincode || '' %>"
                       required
                       pattern="\d{6}"
                       maxlength="6"
                       inputmode="numeric"
                       title="Enter 6-digit Pincode"
                       autocomplete="postal-code">
            </div>
            <div class="form-group">
                <label for="cityVillage">City / Village:</label>
                <input type="text" id="cityVillage" name="cityVillage" value="<%= user.address?.cityVillage || '' %>" required autocomplete="address-level2">
            </div>
            <div class="form-group">
                <label for="landmarkNearby">Landmark / Nearby (Optional):</label>
                <input type="text" id="landmarkNearby" name="landmarkNearby" value="<%= user.address?.landmarkNearby || '' %>">
            </div>
            <button type="submit" class="btn btn-primary">Save Address</button>
            <button type="button" id="cancel-edit-btn" class="btn btn-secondary <%= (!user.address || !user.address.name) ? 'hidden' : '' %>">Cancel</button> <%# Hide cancel if adding new %>
        </form>
    </div>

    <%# --- Logout Section --- %>
    <div class="profile-section logout-section">
        <h2>Account Actions</h2>
        <form action="/auth/logout" method="POST" class="form-submit-spinner">
            <button type="submit" class="btn btn-danger"><i class="fas fa-sign-out-alt"></i> Logout</button>
        </form>
    </div>

</div>

<%- include('../partials/footer') %>


 views/error.ejs:
<%- include('./partials/header', { title: 'Error' }) %>

<div class="error-container container">
    <h1>Error <%= typeof statusCode !== 'undefined' ? statusCode : '' %></h1>
    <p class="lead text-danger"><%= message %></p>

    <% if (process.env.NODE_ENV === 'development' && stack) { %>
        <details style="white-space: pre-wrap; margin-top: 20px; background: #f1f1f1; padding: 10px; border-radius: 5px; font-size: 0.8em;">
            <summary>Stack Trace (Development Mode)</summary>
            <code><%= stack %></code>
        </details>
    <% } %>

    <p style="margin-top: 20px;"><a href="/" class="btn btn-primary">Go back to Home</a></p>
</div>

<%- include('./partials/footer') %>

.env : NODE_ENV=development
PORT=3000
MONGO_URI=mongodb+srv://ecommerce:ecommerce@cluster0.jcfuk.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
SESSION_SECRET=e6142a6d230d0445c9b050af41bfd1e53ece6270797e546fbdaa97af20f3b77e
SESSION_MAX_AGE=86400000

MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USER=ayyappanallamothu4@gmail.com
MAIL_PASS=yxor nmot lxmq skyc
MAIL_FROM='"Surya Ecom" ayyappanallamothu4@gmail.com'


server.js : 

require('dotenv').config();
const express = require('express');
const path = require('path');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const flash = require('connect-flash');
const methodOverride = require('method-override');

const connectDB = require('./config/database');
const mainRouter = require('./routes/index');
const { notFound, errorHandler } = require('./middleware/errorMiddleware');

connectDB();

const app = express();

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));
app.use(methodOverride('_method'));

app.use(
  session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({
        mongoUrl: process.env.MONGO_URI,
        collectionName: 'sessions'
    }),
    cookie: {
        maxAge: parseInt(process.env.SESSION_MAX_AGE || '86400000', 10),
        httpOnly: true
    }
  })
);

app.use(flash());

app.use((req, res, next) => {
  res.locals.success_msg = req.flash('success_msg');
  res.locals.error_msg = req.flash('error_msg');
  res.locals.error = req.flash('error');
  res.locals.currentUser = req.session.user || null;
  res.locals.currentUrl = req.originalUrl;
  res.locals.fullUrl = `${req.protocol}://${req.get('host')}${req.originalUrl}`;
  res.locals.cartItemCount = req.session.user?.cart?.reduce((count, item) => count + item.quantity, 0) || 0;

  // --- NEW: Calculate User Initials ---
  let userInitials = '??'; // Default fallback
  if (req.session.user && req.session.user.email) {
    try {
      // Try splitting by space first (for names), then fallback to email
      const nameParts = req.session.user.name?.split(' ');
      if (nameParts && nameParts.length > 1) {
          userInitials = (nameParts[0][0] + nameParts[1][0]).toUpperCase();
      } else if (nameParts && nameParts.length === 1 && nameParts[0].length >= 2) {
          userInitials = nameParts[0].substring(0, 2).toUpperCase();
      }
       else {
        // Fallback to email if name didn't work well
        const emailPrefix = req.session.user.email.split('@')[0];
        if (emailPrefix.length >= 2) {
            userInitials = emailPrefix.substring(0, 2).toUpperCase();
        } else if (emailPrefix.length === 1) {
            userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase(); // Double the single letter
        }
      }
    } catch (e) {
      console.error("Error generating initials:", e);
      // Keep default '??'
    }
  }
  res.locals.userInitials = userInitials;
  // --- END: Calculate User Initials ---

  next();
});


app.use('/', mainRouter);


app.use(notFound);
app.use(errorHandler);

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});
