config/database.js:
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error connecting to MongoDB: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;

config/gemini.js:
// config/gemini.js
const { GoogleGenerativeAI } = require("@google/generative-ai");

// Access your API key as an environment variable
if (!process.env.GEMINI_API_KEY) {
    console.warn("GEMINI_API_KEY is not set in .env file. Gemini features will be disabled.");
}

const genAI = process.env.GEMINI_API_KEY ? new GoogleGenerativeAI(process.env.GEMINI_API_KEY) : null;

const textModel = genAI ? genAI.getGenerativeModel({ model: "gemini-2.0-flash"}) : null; // Use appropriate model

if (genAI && textModel) {
    console.log("Gemini AI SDK Initialized successfully.");
} else {
     console.log("Gemini AI SDK could not be initialized (API Key missing?).");
}

module.exports = { textModel }; // Export the model instance

config/mailer.js:
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
  host: process.env.MAIL_HOST,
  port: parseInt(process.env.MAIL_PORT, 10),
  secure: parseInt(process.env.MAIL_PORT, 10) === 465,
  auth: {
    user: process.env.MAIL_USER,
    pass: process.env.MAIL_PASS,
  },
});

transporter.verify((error, success) => {
  if (error) {
    console.error('Error with Nodemailer transporter configuration:', error);
  } else {
    console.log('Nodemailer transporter is ready to send emails');
  }
});

const sendEmail = async (to, subject, text, html) => {
  try {
    await transporter.sendMail({
      from: process.env.MAIL_FROM,
      to: to,
      subject: subject,
      text: text,
      html: html,
    });
    console.log(`Email sent successfully to ${to}`);
    return true;
  } catch (error) {
    console.error(`Error sending email to ${to}:`, error);
    return false;
  }
};

module.exports = { sendEmail };


controllers/adminController.js:
// controllers/adminController.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const BannerConfig = require('../models/BannerConfig');
const Category = require('../models/Category'); // *** IMPORT Category Model ***
const { sendEmail } = require('../config/mailer');
const { reviewProductWithGemini } = require('../services/geminiService');
const {
    generateAndSendDirectDeliveryOTPByAdmin,
    confirmDirectDeliveryByAdmin,
} = require('./orderController'); // Assuming these functions handle OTP logic correctly
const mongoose = require('mongoose');

const cancellationReasons = [
    "ðŸ“ž Unable to contact the customer",
    "â— Out of stock/unavailable item",
    "ðŸ—ºï¸ Address incorrect/incomplete",
    "ðŸš« Customer requested cancellation",
    "â“ Other (Admin)",
];

// --- Admin Dashboard ---
exports.getAdminDashboard = (req, res) => {
    res.render('admin/dashboard', { title: 'Admin Dashboard' });
};

// ======================================
// NEW: Category Management Controllers
// ======================================

exports.getManageCategoriesPage = async (req, res, next) => {
    try {
        const categories = await Category.find({})
                                          .populate('createdBy', 'name email') // Populate user info
                                          .populate('lastUpdatedBy', 'name email')
                                          .sort({ name: 1 }) // Sort alphabetically by name
                                          .lean();
        res.render('admin/manage-categories', {
            title: 'Manage Categories',
            categories: categories
        });
    } catch (error) {
        next(error);
    }
};

exports.getAddCategoryPage = (req, res) => {
    res.render('admin/add-category', {
        title: 'Add New Category',
        category: {} // Empty object for the form value binding
    });
};

exports.addCategory = async (req, res, next) => {
    const { name, imageUrl } = req.body;
    const adminUserId = req.session.user._id;

    if (!name || !imageUrl) {
        req.flash('error_msg', 'Please provide both a category name and an image URL.');
        return res.render('admin/add-category', {
            title: 'Add New Category',
            category: req.body // Repopulate form with entered data
        });
    }

    try {
        // Check if category name already exists (case-insensitive check recommended)
        const existingCategory = await Category.findOne({ name: { $regex: new RegExp('^' + name.trim() + '$', 'i') } });
        if (existingCategory) {
            req.flash('error_msg', `Category "${name.trim()}" already exists.`);
             return res.render('admin/add-category', {
                 title: 'Add New Category',
                 category: req.body
             });
        }

        const newCategory = new Category({
            name: name.trim(),
            imageUrl: imageUrl.trim(),
            createdBy: adminUserId,
            lastUpdatedBy: adminUserId
        });
        await newCategory.save(); // Triggers pre-save hook for slug

        req.flash('success_msg', `Category "${newCategory.name}" added successfully.`);
        res.redirect('/admin/manage-categories');

    } catch (error) {
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
           return res.render('admin/add-category', {
               title: 'Add New Category',
               category: req.body
           });
       } else if (error.code === 11000) { // Handle potential duplicate slug error
             req.flash('error_msg', `A category with a similar name might already exist (duplicate slug). Please choose a different name.`);
             return res.render('admin/add-category', {
                  title: 'Add New Category',
                 category: req.body
             });
         }
        console.error("Error adding category:", error);
        next(error);
    }
};


exports.getEditCategoryPage = async (req, res, next) => {
    try {
        const category = await Category.findById(req.params.id)
                                        .populate('createdBy', 'name email') // Optional: populate creator
                                        .lean();
        if (!category) {
            req.flash('error_msg', 'Category not found.');
            return res.redirect('/admin/manage-categories');
        }
        res.render('admin/edit-category', {
            title: `Edit Category: ${category.name}`,
            category: category
        });
    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid category ID format.');
            return res.redirect('/admin/manage-categories');
        }
        next(error);
    }
};

exports.updateCategory = async (req, res, next) => {
    const categoryId = req.params.id;
    const { name, imageUrl } = req.body;
    const adminUserId = req.session.user._id;
    let categoryDataForRender = null; // For repopulating form on error

     if (!name || !imageUrl) {
        req.flash('error_msg', 'Please provide both a category name and an image URL.');
        try {
            categoryDataForRender = await Category.findById(categoryId).lean();
        } catch (fetchError) {
            console.error("Error fetching category for error render:", fetchError);
        }
        return res.render('admin/edit-category', {
            title: `Edit Category: ${categoryDataForRender?.name || 'Error'}`,
            category: categoryDataForRender ? { ...categoryDataForRender, ...req.body } : { _id: categoryId, ...req.body } // Repopulate form
         });
    }

    try {
        const category = await Category.findById(categoryId); // Fetch full doc for .save()
        if (!category) {
            req.flash('error_msg', 'Category not found.');
            return res.status(404).redirect('/admin/manage-categories');
        }

        // Optional: Check if new name conflicts with ANOTHER existing category (case-insensitive)
        if (category.name.toLowerCase() !== name.trim().toLowerCase()) {
            const existingCategory = await Category.findOne({
                 name: { $regex: new RegExp('^' + name.trim() + '$', 'i') },
                 _id: { $ne: categoryId } // Exclude the current category
            });
             if (existingCategory) {
                 req.flash('error_msg', `Another category with the name "${name.trim()}" already exists.`);
                 // Use lean category data for rendering efficiency
                 categoryDataForRender = category.toObject();
                 return res.render('admin/edit-category', {
                     title: `Edit Category: ${category.name}`,
                     category: { ...categoryDataForRender, ...req.body }
                 });
             }
        }

        category.name = name.trim();
        category.imageUrl = imageUrl.trim();
        category.lastUpdatedBy = adminUserId;

        await category.save(); // Triggers pre-save hook for slug update if name changed
        req.flash('success_msg', `Category "${category.name}" updated successfully.`);
        res.redirect('/admin/manage-categories');

    } catch (error) {
         // Fetch category again for re-rendering form on error
         try {
            categoryDataForRender = await Category.findById(categoryId).lean();
         } catch(fetchError) { console.error("Error fetching category for error render:", fetchError);}

         if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
             req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
             return res.render('admin/edit-category', {
                 title: `Edit Category: ${categoryDataForRender?.name || 'Error'}`,
                 category: categoryDataForRender ? { ...categoryDataForRender, ...req.body } : { _id: categoryId, ...req.body }
             });
         } else if (error.code === 11000) { // Handle potential duplicate slug error
             req.flash('error_msg', `Updating failed: A category with a similar name might already exist (duplicate slug). Please choose a different name.`);
             return res.render('admin/edit-category', {
                 title: `Edit Category: ${categoryDataForRender?.name || 'Error'}`,
                 category: categoryDataForRender ? { ...categoryDataForRender, ...req.body } : { _id: categoryId, ...req.body }
             });
         }
        console.error("Error updating category:", error);
        next(error);
    }
};

exports.deleteCategory = async (req, res, next) => {
    const categoryId = req.params.id;
    try {
        const category = await Category.findById(categoryId);
        if (!category) {
            req.flash('error_msg', 'Category not found.');
            return res.status(404).redirect('/admin/manage-categories');
        }

        // Use instance method deleteOne to trigger 'deleteOne' middleware (checks products)
        await category.deleteOne();

        req.flash('success_msg', `Category "${category.name}" deleted successfully.`);
        res.redirect('/admin/manage-categories');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid category ID format.');
            return res.status(400).redirect('/admin/manage-categories');
        }
        // Catch specific error from pre-delete hook (if products exist)
        if (error.message.startsWith('Cannot delete category')) {
            req.flash('error_msg', error.message);
        } else {
            console.error("Error deleting category:", error);
            req.flash('error_msg', 'Error deleting category. Check server logs.');
        }
        res.redirect('/admin/manage-categories');
    }
};

// ======================================
// End: Category Management Controllers
// ======================================


// --- Admin Product Upload Page ---
// --- UPDATED: Fetch Categories ---
exports.getUploadProductPage = async (req, res, next) => {
    try {
        const categories = await Category.find().sort('name').lean(); // Fetch categories
        res.render('admin/upload-product', {
            title: 'Admin: Upload New Product',
            product: {},
            categories: categories // Pass categories to the view
        });
    } catch (error) {
        console.error("Error fetching categories for upload page:", error);
        // Optionally render with an error message or redirect
         req.flash('error_msg', 'Could not load categories for the upload form.');
         res.redirect('/admin/dashboard');
        // next(error); // Or pass to global error handler
    }
};

// --- Admin Product Upload Action ---
// --- UPDATED: Handle categoryRef ---
exports.uploadProduct = async (req, res, next) => {
    // Get categoryRef instead of category
    const { name, categoryRef, price, stock, imageUrl, description, specifications } = req.body;
    const adminUserId = req.session.user._id;
    const adminUserEmail = req.session.user.email;
    let categories = []; // For re-rendering form on error

    try {
        // Fetch categories first, needed for both success and error paths
        categories = await Category.find().sort('name').lean();

        // Basic Validation
        if (!name || !categoryRef || price === undefined || stock === undefined || !imageUrl) {
            req.flash('error_msg', 'Please fill in all required fields (Name, Category, Price, Stock, Image URL).');
            return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
        }
        if (!mongoose.Types.ObjectId.isValid(categoryRef)) {
             req.flash('error_msg', 'Invalid category selected.');
            return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
        }
        if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
            req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
            return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
        }

        // Verify Category Exists (robustness check)
        const selectedCategory = await Category.findById(categoryRef).lean();
         if (!selectedCategory) {
             req.flash('error_msg', 'Selected category not found.');
             return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
         }


        // Save using categoryRef (categoryName will be added by pre-save hook)
        const newProduct = new Product({
            name: name.trim(),
            categoryRef: categoryRef, // Use categoryRef
            // categoryName will be set by pre-save hook
            description: description ? description.trim() : '',
            price: Number(price),
            stock: Number(stock),
            imageUrl: imageUrl.trim(),
            specifications: specifications ? specifications.trim() : '',
            sellerId: adminUserId,
            sellerEmail: adminUserEmail,
            reviewStatus: 'pending'
        });

        await newProduct.save(); // Pre-save hook runs here to add categoryName
        console.log(`Product ${newProduct._id} (Cat: ${newProduct.categoryName}) saved initially by ADMIN ${adminUserEmail}.`);

        // Send for Gemini Review (Asynchronous) - Make sure this handles the new product structure if needed
        reviewProductWithGemini(newProduct).then(async reviewResult => {
            try {
                // Find the product again *after* save might have triggered async processes
                const productToUpdate = await Product.findById(newProduct._id);
                if (productToUpdate) {
                    productToUpdate.reviewStatus = reviewResult.status;
                    productToUpdate.rejectionReason = reviewResult.reason;
                    await productToUpdate.save();
                    console.log(`Product ${newProduct._id} (Admin Upload) review status updated to ${reviewResult.status}.`);
                } else {
                    console.warn(`Could not find product ${newProduct._id} to update review status after Gemini check.`);
                }
            } catch (updateError) {
                console.error(`Error updating product ${newProduct._id} (Admin Upload) after Gemini review:`, updateError);
            }
        }).catch(reviewError => {
            console.error(`Error in Gemini review promise chain for product ${newProduct._id} (Admin Upload):`, reviewError);
            // Attempt to mark as pending with error reason
             Product.findByIdAndUpdate(newProduct._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed.' }, { new: true })
                  .catch(err => console.error("Failed to mark admin-uploaded product as pending after review error:", err));
        });

        req.flash('success_msg', `Product "${newProduct.name}" uploaded and submitted for review.`);
        res.redirect('/admin/manage-products');

    } catch (error) {
         // Fetch categories if not already fetched in the try block (e.g., error before fetch)
         if (!categories || categories.length === 0) {
              try { categories = await Category.find().sort('name').lean(); }
              catch (catError) { console.error("Failed to fetch categories for error display:", catError); }
         }
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
           return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
       }
        console.error("Error uploading product by Admin:", error);
        next(error); // Pass to generic error handler
    }
};


// --- Manage Products (Admin sees ALL) ---
// --- UPDATED: Populate categoryRef ---
exports.getManageProductsPage = async (req, res, next) => {
    try {
        const products = await Product.find({})
                                    .populate('sellerId', 'name email')
                                    .populate('categoryRef', 'name') // Populate category name
                                    .sort({ createdAt: -1 })
                                    .lean();
        res.render('admin/manage-products', {
            title: 'Manage All Products',
            products: products
        });
    } catch (error) {
        next(error);
    }
};

// --- Edit Product (Admin edits ANY) ---
// --- UPDATED: Fetch categories for dropdown ---
exports.getEditProductPage = async (req, res, next) => {
    try {
        // Fetch product and categories concurrently
        const [product, categories] = await Promise.all([
            Product.findById(req.params.id)
                   .populate('sellerId', 'name email')
                   .populate('categoryRef') // Populate full category object
                   .lean(),
             Category.find().sort('name').lean() // Fetch all categories
        ]);

        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.redirect('/admin/manage-products');
        }

        res.render('admin/edit-product', {
            title: `Admin Edit: ${product.name}`,
            product: product,
            categories: categories, // Pass categories to the view
            isAdminView: true
        });
    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.redirect('/admin/manage-products');
        }
        console.error("Error fetching product/categories for edit:", error);
        next(error);
    }
};


// --- Update Product (Admin updates ANY) ---
// --- UPDATED: Handle categoryRef ---
exports.updateProduct = async (req, res, next) => {
    const productId = req.params.id;
    // Get categoryRef instead of category
    const { name, categoryRef, price, stock, imageUrl, description, specifications, reviewStatus, rejectionReason } = req.body;
    let categories = []; // For re-rendering form on error

    try {
        // Fetch categories first, might be needed for rendering error
        categories = await Category.find().sort('name').lean();

        // Validation
        if (!name || !categoryRef || price === undefined || stock === undefined || !imageUrl) {
            req.flash('error_msg', 'Please fill in all required fields.');
            // Need to redirect back to the edit page which will re-fetch data
            return res.redirect(`/admin/manage-products/edit/${productId}`);
        }
        if (!mongoose.Types.ObjectId.isValid(categoryRef)) {
             req.flash('error_msg', 'Invalid category selected.');
             return res.redirect(`/admin/manage-products/edit/${productId}`);
        }
        if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
            req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
            return res.redirect(`/admin/manage-products/edit/${productId}`);
        }
        const allowedStatus = ['pending', 'approved', 'rejected'];
        if (reviewStatus && !allowedStatus.includes(reviewStatus)) {
            req.flash('error_msg', 'Invalid review status selected.');
            return res.redirect(`/admin/manage-products/edit/${productId}`);
        }
        if (reviewStatus === 'rejected' && !rejectionReason?.trim()) {
            req.flash('error_msg', 'Rejection reason is required when setting status to Rejected.');
            return res.redirect(`/admin/manage-products/edit/${productId}`);
        }

        // Verify Category Exists
         const selectedCategory = await Category.findById(categoryRef).lean();
         if (!selectedCategory) {
             req.flash('error_msg', 'Selected category not found.');
             return res.redirect(`/admin/manage-products/edit/${productId}`);
         }

        // Find product without lean() to use .save()
        const product = await Product.findById(productId);
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('/admin/manage-products');
        }

        // Update fields using categoryRef
        product.name = name.trim();
        product.categoryRef = categoryRef; // Update ref
        // categoryName will be updated by pre-save hook automatically
        product.description = description ? description.trim() : '';
        product.price = Number(price);
        product.stock = Number(stock);
        product.imageUrl = imageUrl.trim();
        product.specifications = specifications ? specifications.trim() : '';

        // Handle review status changes
        if (reviewStatus && allowedStatus.includes(reviewStatus)) {
            // Check if status is actually changing
             const statusChanged = product.reviewStatus !== reviewStatus;
             product.reviewStatus = reviewStatus;
            product.rejectionReason = (reviewStatus === 'rejected') ? rejectionReason.trim() : undefined;

             // Optional: Re-trigger review if changed from rejected/pending to approved?
             // if (statusChanged && reviewStatus === 'approved') {
             //    console.log(`Product ${productId} status manually set to Approved by admin.`);
             // }
        }
        // No else needed - don't change status if not provided in request

        await product.save(); // Triggers pre-save hooks (incl. categoryName update)
        req.flash('success_msg', `Product "${product.name}" updated successfully by admin.`);
        res.redirect('/admin/manage-products');

    } catch (error) {
         // Fetch categories if error occurred before fetch was complete
        if (!categories || categories.length === 0) {
             try { categories = await Category.find().sort('name').lean(); }
             catch (catError) { console.error("Error fetching categories for error display:", catError); }
        }
        if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
            // Re-render the edit page with errors and existing data
             try {
                const productData = await Product.findById(productId).populate('sellerId', 'name email').populate('categoryRef').lean();
                // Repopulate the form with attempted values from req.body
                const repopulatedProduct = { ...productData, ...req.body, _id: productId, categoryRef: req.body.categoryRef }; // ensure req.body overrides for repopulation

                return res.render('admin/edit-product', {
                    title: `Admin Edit: ${productData ? productData.name : 'Error'}`,
                    product: repopulatedProduct, // Use the repopulated object
                    categories: categories,
                    isAdminView: true
                });
             } catch (renderError) {
                console.error("Error fetching product/categories for validation error render:", renderError);
                return res.redirect(`/admin/manage-products/edit/${productId}`);
             }
        }
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid ID format (Product or Category).');
            return res.status(400).redirect('/admin/manage-products');
        }
        console.error("Error updating product by Admin:", error);
        next(error); // Pass to generic error handler
    }
};


// --- Remove Product (Admin removes ANY) ---
exports.removeProduct = async (req, res, next) => {
    const productId = req.params.id;
    try {
        const product = await Product.findByIdAndDelete(productId);
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('/admin/manage-products');
        }
        req.flash('success_msg', `Product "${product.name}" removed successfully by admin.`);
        res.redirect('/admin/manage-products');
    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.status(400).redirect('/admin/manage-products');
        }
        console.error("Error removing product by Admin:", error);
        next(error);
    }
};


// --- Manage Orders (Admin sees ALL) ---
exports.getManageOrdersPage = async (req, res, next) => {
      try {
        const orders = await Order.find({})
                                   .sort({ orderDate: -1 })
                                   .select('-__v -products.__v -shippingAddress._id')
                                   .populate('products.productId', 'name imageUrl _id price sellerId')
                                   .populate('userId', 'name email')
                                   .lean();

        const now = Date.now();

        orders.forEach(order => {
            order.canBeCancelledByAdmin = order.status === 'Pending';
            order.canBeDirectlyDeliveredByAdmin = order.status === 'Pending';
            order.showDeliveryOtp = order.status === 'Pending' && !!order.orderOTP && !!order.orderOTPExpires && new Date(order.orderOTPExpires).getTime() > now;

            // Generate items summary string
            if (order.products && order.products.length > 0) {
                order.itemsSummary = order.products.map(p => {
                    const productName = p.productId?.name || p.name || '[Product Missing]';
                    const price = p.priceAtOrder ?? (p.productId?.price ?? 0); // Use price at order, fallback carefully
                    return `${productName} (Qty: ${p.quantity}) @ â‚¹${price.toFixed(2)}`;
                }).join('<br>');
            } else {
                order.itemsSummary = 'No items found';
            }
        });

        res.render('admin/manage-orders', {
            title: 'Manage All Orders',
            orders: orders,
            cancellationReasons: cancellationReasons
        });
    } catch (error) {
        next(error);
    }
};

// --- Admin Order Actions (sendDirectDeliveryOtpByAdmin, confirmDirectDeliveryByAdmin, cancelOrderByAdmin) ---
// --- These don't interact with category data, so remain unchanged ---
exports.sendDirectDeliveryOtpByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    try {
        // isOrderRelevantToSeller middleware IS NOT USED HERE (Admin context)
        const result = await generateAndSendDirectDeliveryOTPByAdmin(orderId);
        req.flash('success_msg', result.message + ' Ask customer for OTP.');
    } catch (error) {
        req.flash('error_msg', `Admin OTP Send Failed: ${error.message}`);
    }
    res.redirect('/admin/manage-orders');
};

exports.confirmDirectDeliveryByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { otp } = req.body;
    const adminUserId = req.session.user._id;

    if (!otp || !/^\d{6}$/.test(otp.trim())) {
        req.flash('error_msg', 'Please enter the 6-digit OTP.');
        return res.redirect('/admin/manage-orders');
    }

    try {
        // isOrderRelevantToSeller middleware IS NOT USED HERE (Admin context)
        const { order } = await confirmDirectDeliveryByAdmin(orderId, adminUserId, otp.trim(), res); // Pass res for date formatting helper
        req.flash('success_msg', `Order ${orderId} confirmed delivered by Admin.`);
    } catch (error) {
        req.flash('error_msg', `Admin Delivery Confirm Failed: ${error.message}`);
    }
    res.redirect('/admin/manage-orders');
};

exports.cancelOrderByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const adminUserId = req.session.user._id;

    if (!reason || !cancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid admin reason for cancellation.');
        return res.redirect('/admin/manage-orders');
    }

    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction();
    try {
        const order = await Order.findById(orderId)
                                // Populate necessary fields
                                .populate('products.productId', 'name _id') // Keep productId population
                                .populate('userId', 'email')
                                .session(sessionDB);

        if (!order) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/admin/manage-orders');
        }
        if (order.status !== 'Pending') {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', `Order status is '${order.status}'. Only 'Pending' orders can be cancelled.`);
            return res.redirect('/admin/manage-orders');
        }

        // Restore Stock and decrement Order Count for *all* items in the order
        const productStockRestorePromises = order.products.map(item => {
            const quantityToRestore = Number(item.quantity);
            // Robust check for product ID existence before attempting update
            if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                console.warn(`Admin Cancel: Invalid item P.ID ${item.productId?._id} or Qty ${item.quantity} in O.ID ${orderId}. Skipping restore.`);
                return Promise.resolve(); // Gracefully skip invalid items
            }
            return Product.updateOne(
                { _id: item.productId._id },
                { $inc: { stock: quantityToRestore, orderCount: -1 } }, // Restore stock, decrement order count
                { session: sessionDB }
            ).catch(err => {
               console.error(`Admin Cancel: Failed stock/count restore P.ID ${item.productId._id} O.ID ${orderId}: ${err.message}`);
               // Potentially throw error here if stock restoration failure should halt the whole process?
               // Or just log and continue, which is current behavior.
            });
        });
        // Wait for all restoration attempts to complete
        await Promise.allSettled(productStockRestorePromises);

        // Update order status and reason
        order.status = 'Cancelled';
        order.cancellationReason = `Admin Cancelled: ${reason}`; // Prefix reason
        await order.save({ session: sessionDB }); // Will trigger pre-save hook to clear OTP etc.

        await sessionDB.commitTransaction();

        // Send Email Notification (outside transaction)
        try {
            const customerEmail = order.userEmail || order.userId?.email;
            if(customerEmail) {
                const subjectCust = `Your Order (${order._id}) Has Been Cancelled`;
                // Make reason clear it was admin action
                const htmlCust = `<p>Your order (${order._id}) has been cancelled by administration.</p><p><strong>Reason:</strong> ${reason}</p><p>Contact support for questions.</p>`;
                await sendEmail(customerEmail, subjectCust, `Order ${order._id} cancelled by Admin. Reason: ${reason}`, htmlCust);
            } else {
                console.warn(`Admin Cancel: Could not find customer email for order ${orderId} notification.`);
            }
        } catch (emailError) {
            console.error(`Failed sending cancellation email for order ${order._id} (Admin Cancel):`, emailError);
            // Do not fail the request if email fails, but log it.
        }

        req.flash('success_msg', `Order ${orderId} cancelled by admin. Reason: ${reason}.`);
        res.redirect('/admin/manage-orders');

    } catch (error) {
        if (sessionDB.inTransaction()) { // Check if transaction is still active before aborting
             await sessionDB.abortTransaction();
        }
        console.error(`Error cancelling order ${orderId} by admin ${adminUserId}:`, error);
        req.flash('error_msg', 'Failed to cancel order due to an internal error.');
        res.redirect('/admin/manage-orders');
    } finally {
         if (sessionDB.id) { await sessionDB.endSession(); } // Check session exists before ending
    }
};


// --- Manage Users (Admin) ---
exports.getManageUsersPage = async (req, res, next) => {
      try {
        const users = await User.find({ _id: { $ne: req.session.user._id } }) // Exclude self
                                  .select('name email role createdAt isVerified address.phone') // Select necessary fields
                                  .sort({ createdAt: -1 })
                                  .lean();
        res.render('admin/manage-users', {
            title: 'Manage Registered Users',
            users: users
        });
    } catch (error) {
        next(error);
    }
};

// --- Update User Role (Admin) ---
exports.updateUserRole = async (req, res, next) => {
    const userId = req.params.id;
    const { role } = req.body;
    const allowedRoles = ['user', 'admin', 'seller'];

    if (!role || !allowedRoles.includes(role)) {
        req.flash('error_msg', 'Invalid role selected.');
        return res.status(400).redirect('/admin/manage-users');
    }
    if (userId === req.session.user._id.toString()) {
         req.flash('error_msg', 'You cannot change your own role.');
         return res.redirect('/admin/manage-users');
    }

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return res.status(404).redirect('/admin/manage-users');
        }
        // Simple update - Consider adding email notifications for role changes
        user.role = role;
        await user.save();
        req.flash('success_msg', `User ${user.email}'s role updated to ${role}.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid user ID format.');
            return res.status(400).redirect('/admin/manage-users');
        }
        console.error(`Error updating role for user ${userId}:`, error);
        req.flash('error_msg', 'Error updating user role.');
        res.redirect('/admin/manage-users');
    }
};

// --- Remove User (Admin) ---
exports.removeUser = async (req, res, next) => {
    const userId = req.params.id;

    if (userId === req.session.user._id.toString()) {
        req.flash('error_msg', 'You cannot remove yourself.');
        return res.redirect('/admin/manage-users');
    }

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return res.status(404).redirect('/admin/manage-users');
        }

        // Prevent removing the last admin
        if (user.role === 'admin') {
            const adminCount = await User.countDocuments({ role: 'admin' });
            if (adminCount <= 1) {
                req.flash('error_msg', 'Cannot remove the last admin account.');
                return res.redirect('/admin/manage-users');
            }
        }

        // Consider consequences of removing a seller (impact on products)
        if (user.role === 'seller') {
            const productCount = await Product.countDocuments({ sellerId: userId });
            if (productCount > 0) {
                // Option 1: Prevent deletion
                 req.flash('error_msg', `Cannot remove seller ${user.email} as they have ${productCount} product(s). Reassign or remove products first.`);
                 return res.redirect('/admin/manage-users');

                // Option 2: Disable/Hide products (Example)
                // console.warn(`Disabling ${productCount} products for deleted seller ${user.email}.`);
                // await Product.updateMany({ sellerId: userId }, { $set: { stock: 0, reviewStatus: 'rejected', rejectionReason: 'Seller account removed' }});
            }
        }

        // Proceed with deletion
        await User.deleteOne({ _id: userId });
        req.flash('success_msg', `User ${user.email} removed successfully.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid user ID format.');
            return res.status(400).redirect('/admin/manage-users');
        }
        console.error(`Error removing user ${userId}:`, error);
        req.flash('error_msg', 'Error removing user.');
        res.redirect('/admin/manage-users');
    }
};

// --- Banner Management ---
exports.getManageBannersPage = async (req, res, next) => {
      try {
        let bannerConfig = await BannerConfig.findOne({ configKey: 'mainBanners' }).lean();
        if (!bannerConfig) {
            bannerConfig = { configKey: 'mainBanners', banners: [] }; // Default empty structure
        }
        // Standardize to 4 slots for the form, filling with defaults if needed
        const displayBanners = Array.from({ length: 4 }).map((_, index) => {
             return bannerConfig.banners[index] || { imageUrl: '', linkUrl: '', title: '' };
         });
        res.render('admin/manage-banners', {
            title: 'Manage Homepage Banners',
            bannerConfig: { ...bannerConfig, banners: displayBanners } // Pass standardized array
        });
    } catch (error) {
        console.error("Error fetching banner configuration:", error);
        next(error);
    }
};

exports.updateBanners = async (req, res, next) => {
    const { imageUrl1, linkUrl1, title1, imageUrl2, linkUrl2, title2, imageUrl3, linkUrl3, title3, imageUrl4, linkUrl4, title4 } = req.body;
    const adminUserId = req.session.user._id;
    const urlPattern = /^https?:\/\/.+/; // Simple URL validation regex

    // Package inputs
    const bannerInputs = [
        { imageUrl: imageUrl1, linkUrl: linkUrl1, title: title1 },
        { imageUrl: imageUrl2, linkUrl: linkUrl2, title: title2 },
        { imageUrl: imageUrl3, linkUrl: linkUrl3, title: title3 },
        { imageUrl: imageUrl4, linkUrl: linkUrl4, title: title4 }
    ];

    const newBanners = [];
    let validationErrors = []; // Collect multiple errors

    // Validate and filter inputs
    for (let i = 0; i < bannerInputs.length; i++) {
        const input = bannerInputs[i];
        const trimmedImageUrl = input.imageUrl?.trim();
        const trimmedLinkUrl = input.linkUrl?.trim();
        const trimmedTitle = input.title?.trim();

        // Only process if an image URL is provided
        if (trimmedImageUrl) {
            let bannerValid = true;
            if (!urlPattern.test(trimmedImageUrl)) {
                validationErrors.push(`Banner ${i + 1}: Image URL format is invalid.`);
                bannerValid = false;
            }
            if (trimmedLinkUrl && !urlPattern.test(trimmedLinkUrl)) {
                 validationErrors.push(`Banner ${i + 1}: Link URL format is invalid.`);
                 bannerValid = false;
             }
            // Add only valid banners
             if (bannerValid) {
                newBanners.push({
                     imageUrl: trimmedImageUrl,
                     linkUrl: trimmedLinkUrl || undefined, // Ensure empty string becomes undefined
                     title: trimmedTitle || undefined
                 });
             }
        }
    }

    // If validation errors occurred, re-render the form with messages and repopulated data
    if (validationErrors.length > 0) {
         req.flash('error_msg', validationErrors.join(' '));
         // Use the original inputs to repopulate the form
         const displayBannersForError = Array.from({ length: 4 }).map((_, index) => bannerInputs[index]);
         return res.render('admin/manage-banners', {
             title: 'Manage Homepage Banners',
             bannerConfig: { banners: displayBannersForError }
         });
    }

    try {
        // Update or insert the banner configuration
        await BannerConfig.findOneAndUpdate(
            { configKey: 'mainBanners' },
            { banners: newBanners, lastUpdatedBy: adminUserId },
            { new: true, upsert: true, runValidators: true }
        );
        req.flash('success_msg', 'Homepage banners updated successfully.');
        res.redirect('/admin/manage-banners');
    } catch (error) {
        if (error.name === 'ValidationError') { // Handle schema validation errors (e.g., array limit)
            let schemaErrors = Object.values(error.errors).map(el => el.message);
             req.flash('error_msg', `Validation Error: ${schemaErrors.join(', ')}`);
             const displayBannersForError = Array.from({ length: 4 }).map((_, index) => bannerInputs[index]);
             return res.render('admin/manage-banners', {
                  title: 'Manage Homepage Banners',
                 bannerConfig: { banners: displayBannersForError }
             });
         }
        // Handle other potential errors
        console.error("Error updating banners:", error);
        req.flash('error_msg', 'Failed to update banners due to a server error.');
        // Redirect back, form will show previously saved state on next load
        res.redirect('/admin/manage-banners');
    }
};

controllers/authController.js:
// controllers/authController.js
const User = require('../models/User');
const Product = require('../models/Product');
const BannerConfig = require('../models/BannerConfig');
const Category = require('../models/Category'); // *** IMPORT Category Model ***
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { generateOTP, setOTPExpiration } = require('../services/otpService');
const { sendEmail } = require('../config/mailer');

// --- Helper function for escaping Regex characters ---
function escapeRegex(string) {
  return string.replace(/[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

// --- getLoginPage, getRegisterPage, getVerifyOtpPage, etc. ---
exports.getLoginPage = (req, res) => {
    if (req.session.user) {
         return res.redirect('/'); // Redirect if already logged in
    }
    res.render('auth/login', { title: 'Login' });
};

exports.getRegisterPage = (req, res) => {
    if (req.session.user) {
        return res.redirect('/'); // Redirect if already logged in
   }
    res.render('auth/register', { title: 'Register' });
};

exports.getVerifyOtpPage = (req, res) => {
    const email = req.query.email;
    if (!email) {
        req.flash('error_msg', 'Email required for OTP verification.');
        return res.redirect('/auth/register');
    }
     if (req.session.user) { // Redirect if already logged in
        return res.redirect('/');
   }
    res.render('auth/verify-otp', { title: 'Verify Email', email });
};

exports.getForgotPasswordPage = (req, res) => {
     if (req.session.user) {
         return res.redirect('/'); // Redirect if already logged in
    }
    res.render('auth/forgot-password', { title: 'Forgot Password' });
};

exports.getResetPasswordPage = async (req, res, next) => {
     if (req.session.user) { // Should logged-in users be able to reset password this way? Redirect.
         req.flash('info_msg', 'You are already logged in.');
         return res.redirect('/');
    }
    try {
        // Find user by token and check expiration
        const user = await User.findOne({
            resetPasswordToken: req.params.token,
            resetPasswordExpires: { $gt: Date.now() }, // Ensure token is not expired
        });

        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired.');
            return res.redirect('/auth/forgot-password');
        }
        // Token is valid, render the reset form
        res.render('auth/reset-password', { title: 'Reset Password', token: req.params.token });
    } catch (error) {
        next(error); // Pass errors to the error handler
    }
};

// --- registerUser, verifyOtp, resendOtp, loginUser ---
exports.registerUser = async (req, res, next) => {
     if (req.session.user) {
        return res.redirect('/'); // Redirect if already logged in
    }
    const { name, email, password, confirmPassword } = req.body;

    // --- Input Validation ---
    let errors = [];
    if (!name || !email || !password || !confirmPassword) {
        errors.push('Please fill in all fields.');
    }
    if (password !== confirmPassword) {
        errors.push('Passwords do not match.');
    }
    if (password && password.length < 6) {
        errors.push('Password must be at least 6 characters.');
    }
    if (email && !/^\S+@\S+\.\S+$/.test(email)) {
        errors.push('Please enter a valid email address.');
    }

    if (errors.length > 0) {
        req.flash('error_msg', errors.join(' '));
        return res.render('auth/register', {
            title: 'Register',
            name: name,
            email: email,
            error_msg: req.flash('error_msg')
        });
    }

    // --- Registration Logic ---
    try {
        const lowerCaseEmail = email.toLowerCase();
        let user = await User.findOne({ email: lowerCaseEmail });

        if (user && user.isVerified) {
            req.flash('error_msg', 'Email is already registered and verified. Please login.');
            return res.redirect('/auth/login');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10);

        if (user && !user.isVerified) {
            // Update existing unverified user
            user.name = name;
            // Only update password if provided, respecting previous state otherwise
            if (password) { user.password = password; }
            user.otp = otp;
            user.otpExpires = otpExpires;
            user.isVerified = false;
            await user.save({ validateBeforeSave: false }); // Save without re-validating password if not changed
            console.log(`Updating existing unverified user: ${user.email}`);
        } else {
            // Create new user
            user = new User({
                name,
                email: lowerCaseEmail,
                password,
                otp,
                otpExpires,
                isVerified: false, // Starts as unverified
            });
            await user.save();
            console.log(`New user created: ${user.email}`);
        }

        const subject = 'Verify Your Email Address';
        const text = `Your verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
        const html = `<p>Welcome to our store!</p><p>Your verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;

        const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
            req.flash('success_msg', `An OTP has been sent to ${user.email}. Please check your inbox and verify.`);
            res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
        } else {
            // Attempt cleanup only for very recently created users where email failed immediately
            if(!user.createdAt || (Date.now() - user.createdAt.getTime()) < 5000) {
                try {
                    await User.deleteOne({ _id: user._id, isVerified: false });
                    console.log(`Cleaned up unverified user ${user.email} due to failed email send.`);
                } catch (deleteError) {
                    console.error(`Error cleaning up unverified user ${user.email}:`, deleteError);
                }
            }
            req.flash('error_msg', 'Could not send OTP email. Please try registering again or contact support.');
            res.redirect('/auth/register');
        }

    } catch (error) {
        if (error.code === 11000) { // Duplicate email error
            req.flash('error_msg', 'Email already exists. Please login or use a different email.');
            return res.render('auth/register', { title: 'Register', name: name, email: email });
        }
        if (error.name === 'ValidationError') {
           let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', validationErrors.join(' '));
            return res.render('auth/register', { title: 'Register', name: name, email: email });
       }
        // Pass other errors to the main error handler
        next(error);
    }
};

exports.verifyOtp = async (req, res, next) => {
    const { email, otp } = req.body;

     if (req.session.user) { // Already logged in
        return res.redirect('/');
    }

    if (!email || !otp) {
        req.flash('error_msg', 'Email and OTP are required.');
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email || '')}`);
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({
            email: lowerCaseEmail,
            otp: otp.trim(),
            otpExpires: { $gt: Date.now() },
        }).select('+password'); // Need password if logging in immediately after verification

        if (!user) {
            const existingUser = await User.findOne({ email: lowerCaseEmail });
            let errorMessage = 'Invalid or expired OTP. Please try again or resend.';

            // Handle specific cases
            if (existingUser && existingUser.isVerified) {
                 errorMessage = 'This account is already verified. Please login.';
                 req.flash('error_msg', errorMessage);
                 return res.redirect('/auth/login');
            } else if (!existingUser) {
                 // This case might indicate a registration issue or typo
                 errorMessage = 'Verification failed. Account not found. Please register again.';
                 req.flash('error_msg', errorMessage);
                 return res.redirect('/auth/register');
            }
             // Default: OTP incorrect/expired for an unverified account
             req.flash('error_msg', errorMessage);
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email)}`);
        }

         // Check if this OTP verification is part of password reset flow
         const isPasswordReset = user.resetPasswordToken && user.resetPasswordExpires && user.resetPasswordExpires > Date.now();

         // Mark user as verified (always do this on successful OTP match)
         user.isVerified = true;
         user.otp = undefined;
         user.otpExpires = undefined;

         if (isPasswordReset) {
             // Don't clear reset tokens yet, redirect to password setting page
             await user.save({ validateBeforeSave: false }); // Save without full validation
             req.flash('success_msg', 'OTP Verified. Please set your new password.');
             return res.redirect(`/auth/reset-password/${user.resetPasswordToken}`);
         }
         else {
             // Normal email verification: clear reset tokens if they exist, save, log in
            user.resetPasswordToken = undefined; // Clear any potentially stale reset tokens
            user.resetPasswordExpires = undefined;
            await user.save({ validateBeforeSave: false });

             // --- Auto-Login Logic ---
             req.session.regenerate(err => { // Regenerate session for security
                if (err) {
                     console.error("Session regeneration error after OTP verify:", err);
                     // Still verified, but login failed.
                     req.flash('error_msg', 'Verification successful, but auto-login failed. Please login manually.');
                     return res.redirect('/auth/login');
                 }

                 // Store necessary user info in session
                 req.session.user = {
                    _id: user._id,
                    name: user.name,
                    email: user.email,
                    role: user.role,
                    // Convert mongoose subdoc to plain JS object if exists
                    address: user.address ? user.address.toObject() : undefined,
                    // Map cart items to basic info, handle missing productId gracefully
                     cart: user.cart ? user.cart.map(item => ({
                        productId: item.productId?._id, // Use optional chaining
                        quantity: item.quantity
                    })) : []
                 };

                // Ensure session is saved before redirecting
                 req.session.save(err => {
                   if (err) {
                        console.error("Session save error after OTP verify login:", err);
                         req.flash('error_msg', 'Verification successful, but auto-login failed. Please login manually.');
                        return res.redirect('/auth/login');
                    }
                    req.flash('success_msg', 'Email verified successfully! You are now logged in.');
                    const returnTo = req.session.returnTo || '/'; // Handle redirect after login
                    delete req.session.returnTo;
                    res.redirect(returnTo);
                 });
             });
             // --- End Auto-Login Logic ---
         }

    } catch (error) {
        next(error);
    }
};

exports.resendOtp = async (req, res, next) => {
    const { email } = req.body;

     if (req.session.user) { // Already logged in
        return res.redirect('/');
    }

    if (!email) {
        req.flash('error_msg', 'Email is required to resend OTP.');
        // Attempt to preserve email in query string if available
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(req.query.email || '')}`);
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail });

        if (!user) {
            // Don't reveal if email exists or not, generic message
            console.log(`Resend OTP attempt for non-existent email: ${lowerCaseEmail}`);
            req.flash('info_msg', 'If your email is registered, a new OTP will be sent. Please check your inbox.');
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email)}`);
        }

        // Determine if OTP is for password reset or email verification
        const isForReset = user.resetPasswordToken && user.resetPasswordExpires && user.resetPasswordExpires > Date.now();

        // Prevent resending for already verified accounts (unless it's for password reset)
        if(user.isVerified && !isForReset) {
             req.flash('error_msg', 'This account is already verified. Please login.');
            return res.redirect('/auth/login');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10);

        // Update OTP and expiry on the user document
        user.otp = otp;
        user.otpExpires = otpExpires;
        await user.save({ validateBeforeSave: false }); // Save without full validation

        let subject, text, html;
        // Customize email content based on purpose
        if (isForReset) {
            subject = 'Your New Password Reset OTP';
             text = `Your new password reset OTP is: ${otp}\nIt will expire in 10 minutes.\nIf you did not request this, please ignore this email.`;
            html = `<p>Your new password reset OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;
        } else {
             subject = 'Your New Verification OTP';
             text = `Your new verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
            html = `<p>Your new verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;
        }

        // Send the new OTP email
        const emailSent = await sendEmail(user.email, subject, text, html);

        // Redirect back to OTP verification page, indicating reason if it's for reset
        const redirectUrl = `/auth/verify-otp?email=${encodeURIComponent(user.email)}${isForReset ? '&reason=reset' : ''}`;

        if (emailSent) {
            req.flash('success_msg', `A new OTP has been sent to ${user.email}. Please check your inbox.`);
        } else {
            console.error(`Failed to resend OTP email to ${user.email}`);
            req.flash('error_msg', 'Could not resend OTP email. Please try again later or contact support.');
        }
        res.redirect(redirectUrl);

    } catch (error) {
        next(error);
    }
};

exports.loginUser = async (req, res, next) => {
     if (req.session.user) { // Already logged in
        return res.redirect('/');
    }
    const { email, password } = req.body;

    if (!email || !password) {
        req.flash('error_msg', 'Please provide both email and password.');
        return res.render('auth/login', { title: 'Login', email: email });
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        // Find user and explicitly select password, populate cart details needed for session
        const user = await User.findOne({ email: lowerCaseEmail })
                             .select('+password') // Include password for comparison
                              .populate('cart.productId', 'name price imageUrl stock reviewStatus sellerId'); // Populate required product details from cart


        if (!user) {
            // User not found
            req.flash('error_msg', 'Invalid credentials. Please check your email and password.');
            return res.render('auth/login', { title: 'Login', email: email });
        }

        // Check if email is verified
         if (!user.isVerified) {
            req.flash('error_msg', 'Your email is not verified. Please check your inbox for the verification OTP or request a new one.');
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
         }

        // Compare password using the method on the user model
        const isMatch = await user.matchPassword(password);

        if (!isMatch) {
            // Password does not match
            req.flash('error_msg', 'Invalid credentials. Please check your email and password.');
            return res.render('auth/login', { title: 'Login', email: email });
        }

         // --- Successful Login: Set up session ---
         req.session.regenerate(err => {
            if (err) {
                 console.error("Session regeneration error during login:", err);
                 req.flash('error_msg', 'Login failed due to a session error. Please try again.');
                 return res.render('auth/login', { title: 'Login', email: email });
             }

             // Store relevant user data in the session
             req.session.user = {
                _id: user._id,
                name: user.name,
                email: user.email,
                role: user.role,
                 address: user.address ? user.address.toObject() : undefined,
                 // Process cart: filter out invalid/removed products before storing in session
                  cart: user.cart ? user.cart.filter(item => item.productId && item.productId._id) // Ensure product exists
                                          .map(item => ({
                                                productId: item.productId._id,
                                                quantity: item.quantity
                                             })) : []
             };

            // Save the session before redirecting
             req.session.save(err => {
                 if (err) {
                     console.error("Session save error after login:", err);
                     req.flash('error_msg', 'Login successful, but session could not be saved. Please try again.');
                      return res.render('auth/login', { title: 'Login', email: email });
                 }
                 req.flash('success_msg', 'You are now logged in successfully.');
                 const returnTo = req.session.returnTo || '/'; // Handle redirect URL
                 delete req.session.returnTo;
                 res.redirect(returnTo);
            });
        });
         // --- End Session Setup ---

    } catch (error) {
        next(error);
    }
};


exports.logoutUser = (req, res, next) => {
    req.flash('success_msg', 'You have been logged out successfully.');
    // Destroy the session
    req.session.destroy(err => {
        if (err) {
            // Log error but proceed with logout flow
            console.error('Session destruction error:', err);
             req.flash('error_msg', 'Error during logout. Please try again.'); // Inform user
             // Redirect even on error to complete logout flow
            return res.redirect('/auth/login');
        }
        // Clear the session cookie
        res.clearCookie(req.app.get('session cookie name') || 'connect.sid'); // Use configured name or default
        // Redirect to login page
        res.redirect('/auth/login');
    });
};


exports.forgotPassword = async (req, res, next) => {
    const { email } = req.body;
    if (!email) {
        req.flash('error_msg', 'Please provide an email address.');
        return res.redirect('/auth/forgot-password');
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail });

        // Always show generic message regardless of user existence or status for security
        const genericMessage = 'If an account with that email exists and is verified, a password reset OTP will be sent. Please check your inbox.';
        req.flash('info_msg', genericMessage);

        // Only proceed if user exists AND is verified
        if (!user || !user.isVerified) {
            console.log(`Password reset request for ${lowerCaseEmail}: User ${!user ? 'not found' : 'found but not verified'}. Sending generic response.`);
            return res.redirect('/auth/forgot-password'); // Redirect immediately after flashing message
        }

        // Generate OTP and reset token (reset token used to link OTP verification to password setting)
        const otp = generateOTP();
        const resetToken = crypto.randomBytes(20).toString('hex');
        const otpExpires = setOTPExpiration(10); // OTP valid for 10 mins
        const resetExpires = setOTPExpiration(60); // Link/token valid for 60 mins (allows time to receive/enter OTP and set new password)

        // Save tokens and expiry dates to the user document
        user.otp = otp;
        user.otpExpires = otpExpires;
        user.resetPasswordToken = resetToken;
        user.resetPasswordExpires = resetExpires;
        await user.save({ validateBeforeSave: false }); // Save without validation

        // Send email with OTP
        const subject = 'Password Reset Request - Verify OTP';
        const text = `You requested a password reset.\n\nPlease use the following OTP to verify your request: ${otp}\n\nThis OTP will expire in 10 minutes.\n\nIf you did not request this, please ignore this email.`;
        const html = `<p>You requested a password reset.</p><p>Please use the following OTP to verify your request: <strong>${otp}</strong></p><p>This OTP will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;

         const emailSent = await sendEmail(user.email, subject, text, html);

        // Redirect to OTP verification page, passing email and reason=reset
        if (emailSent) {
             console.log(`Password reset OTP sent to verified user: ${user.email}`);
             // Don't redirect immediately after flashing if sending email fails
        } else {
            console.error(`Failed to send password reset OTP email to ${user.email}`);
             // Keep the generic info message, maybe add error? No, stick to generic.
             return res.redirect('/auth/forgot-password'); // Redirect after email failure
         }

         // Redirect AFTER successful email send and flash message set
         res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}&reason=reset`);

    } catch (error) {
        console.error("Error in forgotPassword:", error);
        req.flash('error_msg', 'An error occurred while processing your request. Please try again later.');
        res.redirect('/auth/forgot-password');
    }
};

exports.resetPassword = async (req, res, next) => {
    const { password, confirmPassword } = req.body;
    const token = req.params.token; // The token from the URL, linking back to forgotPassword request

    // --- Input Validation ---
    let errors = [];
    if (!password || !confirmPassword) {
        errors.push('Please enter and confirm your new password.');
    }
    if (password !== confirmPassword) {
        errors.push('Passwords do not match.');
    }
     if (password && password.length < 6) {
         errors.push('Password must be at least 6 characters.');
    }
    if (errors.length > 0) {
         req.flash('error_msg', errors.join(' '));
         // Redirect back to the same reset password page
         return res.redirect(`/auth/reset-password/${token}`);
    }
    // --- End Validation ---

    try {
        // Find the user using the reset token and ensure it hasn't expired
        // Also, ensure OTP was verified (implied by reaching this route, but user.otp check could be added)
        const user = await User.findOne({
            resetPasswordToken: token,
            resetPasswordExpires: { $gt: Date.now() },
             // isVerified should be true if they completed OTP step
             // otp: undefined // Ensure OTP was cleared after verification
         }).select('+password'); // Need password field to update it

        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired. Please request a new reset link.');
            return res.redirect('/auth/forgot-password');
        }

        // Update password and clear all reset/OTP related fields
        user.password = password; // Pre-save hook will hash it
        user.resetPasswordToken = undefined;
        user.resetPasswordExpires = undefined;
        user.otp = undefined; // Ensure OTP is cleared
        user.otpExpires = undefined;
        user.isVerified = true; // Ensure account is marked verified

        await user.save(); // Save the user with the new password

        // --- Auto-Login after successful password reset ---
        req.session.regenerate(err => {
             if (err) {
                console.error("Session regeneration error after password reset:", err);
                // Even if session fails, password reset was successful
                req.flash('success_msg', 'Password reset successful. Please log in with your new password.');
                return res.redirect('/auth/login');
             }
              // Store necessary user info in session
              req.session.user = {
                  _id: user._id, name: user.name, email: user.email, role: user.role,
                  address: user.address ? user.address.toObject() : undefined,
                   cart: user.cart ? user.cart.filter(item => item.productId) // Basic cart structure
                                          .map(item => ({ productId: item.productId, quantity: item.quantity })) : []
              };

             // Save session before redirect
             req.session.save(err => {
                 if(err) {
                    console.error("Session save error after password reset login:", err);
                     // Password reset success, but auto-login failed
                     req.flash('success_msg', 'Password reset successful. Please log in with your new password.');
                    return res.redirect('/auth/login');
                 }
                  // Auto-login and redirect successful
                 req.flash('success_msg', 'Password has been reset successfully. You are now logged in.');
                res.redirect('/'); // Redirect to homepage or dashboard
             });
         });
         // --- End Auto-Login ---

    } catch (error) {
        if (error.name === 'ValidationError') {
            // Handle Mongoose validation errors (e.g., if password has model constraints)
           let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', validationErrors.join(' '));
            return res.redirect(`/auth/reset-password/${token}`);
       }
        // Pass other errors to the main error handler
        next(error);
    }
};


// --- UPDATED getHomePage (includes category handling) ---
exports.getHomePage = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || '';
    const categoryFilterName = req.query.categoryName || ''; // Get category filter from query

    let query = {
        reviewStatus: 'approved',
        stock: { $gt: 0 }
    };
    let sort = { createdAt: -1 }; // Default: newest first

    // Filter by Category if provided
    if (categoryFilterName) {
        // Use the denormalized categoryName for filtering
        query.categoryName = categoryFilterName;
        console.log(`Homepage/Products Filtered by Category: ${categoryFilterName}`);
    }

    // Apply Search Term (Sequential Match)
    if (searchTerm) {
      const escapedSearchTerm = escapeRegex(searchTerm);
      const regex = new RegExp(escapedSearchTerm, 'i');
      // Search name, categoryName, and description
      query.$or = [
        { name: regex },
        { categoryName: regex }, // Search by category name
        { description: regex }
        // { specifications: regex } // Add if needed
      ];
      // Decide if search overrides category: current query combines them.
      console.log(`Homepage Regex Search Query: ${JSON.stringify(query)}`);
    }

    // Fetch Products, Banners, and Categories concurrently
    const [products, bannerConfig, categories] = await Promise.all([
        Product.find(query)
               .sort(sort)
               .lean(),
        BannerConfig.findOne({ configKey: 'mainBanners' }).lean(), // Fetch banners config
        Category.find().sort('name').lean() // Fetch all categories, sorted by name
    ]);

    const banners = bannerConfig?.banners || [];
    const validBanners = banners.filter(banner => banner.imageUrl); // Filter out banners without images


    res.render('products/index', { // Render the main product listing view
      title: categoryFilterName
          ? `Products in ${categoryFilterName}` // Title when category is filtered
          : (searchTerm ? `Search Results for "${searchTerm}"` : 'Home'), // Titles for search/home
      products: products,
      searchTerm: searchTerm, // Pass search term back to view
      homepageBanners: validBanners, // Pass valid banners
      homepageCategories: categories, // *** Pass fetched categories to the view ***
      selectedCategoryName: categoryFilterName // Pass the filtered category name for highlighting etc.
    });
  } catch (error) {
    console.error("Error fetching data for home page:", error);
    next(error);
  }
};

controllers/orderController.js:
// controllers/orderController.js
const Order = require('../models/Order');
const User = require('../models/User');
const Product = require('../models/Product');
const { sendEmail } = require('../config/mailer');
const mongoose = require('mongoose');
const { generateOTP, setOTPExpiration } = require('../services/otpService');

// --- UPDATE placeOrder to include sellerId and check approval/stock within transaction ---
exports.placeOrder = async (req, res, next) => {
    const userId = req.session.user._id;
    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction({ readConcern: { level: 'snapshot' }, writeConcern: { w: 'majority' } }); // Use snapshot isolation if possible

    try {
        const user = await User.findById(userId)
                              // Populate necessary cart product fields including status and seller
                              .populate('cart.productId', 'name price imageUrl stock reviewStatus sellerId')
                              .session(sessionDB); // Use session

        if (!user) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'User session not found. Please log in again.');
            return res.redirect('/auth/login');
        }
        if (!user.cart || user.cart.length === 0) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Your cart is empty.');
            return res.redirect('/user/cart');
        }
        // Ensure address exists
        if (!user.address || !user.address.name || !user.address.phone || !user.address.pincode || !user.address.cityVillage) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Please complete your shipping address before placing the order.');
            return res.redirect('/user/checkout');
        }

        let orderProducts = [];
        let totalAmount = 0;
        const productStockUpdates = [];
        let validationFailed = false;
        let validationErrorMessage = 'An issue occurred with your cart. Please review and try again.';
        const itemsToRemoveFromCart = []; // Track items to remove due to issues

        // --- Validate Cart Items Within Transaction ---
        for (const item of user.cart) {
            // Basic checks
            const itemQuantity = Number(item.quantity);
            if (isNaN(itemQuantity) || !Number.isInteger(itemQuantity) || itemQuantity <= 0) {
                validationErrorMessage = `Invalid quantity found for an item. It has been removed.`;
                itemsToRemoveFromCart.push(item._id);
                validationFailed = true; continue; // Continue checking other items
            }
            if (!item.productId || !item.productId._id) {
                 validationErrorMessage = `An invalid product reference was found and removed.`;
                 itemsToRemoveFromCart.push(item._id);
                 validationFailed = true; continue;
            }

            const currentProduct = item.productId; // Already populated

            // *** Check Approval Status ***
             if (currentProduct.reviewStatus !== 'approved') {
                validationErrorMessage = `Product "${currentProduct.name}" is not available and has been removed from your cart.`;
                itemsToRemoveFromCart.push(item._id);
                validationFailed = true; continue;
            }
            // *** Check Stock Availability ***
            if (currentProduct.stock < itemQuantity) {
                // If stock issue, fail the whole order immediately, don't just remove item
                validationErrorMessage = `Insufficient stock for "${currentProduct.name}". Available: ${currentProduct.stock}. Please update your cart quantity.`;
                validationFailed = true;
                break; // Stop processing on critical stock issue
            }

            // If valid, add to order and prepare update
            orderProducts.push({
                productId: currentProduct._id,
                name: currentProduct.name,
                priceAtOrder: currentProduct.price, // Price at the time of order
                quantity: itemQuantity,
                imageUrl: currentProduct.imageUrl,
                sellerId: currentProduct.sellerId // *** Include Seller ID ***
            });
            totalAmount += currentProduct.price * itemQuantity;
            productStockUpdates.push({
                 productId: currentProduct._id,
                 quantityToDecrement: itemQuantity
             });
        } // End cart loop

        // --- Handle Validation Failures ---
        if (validationFailed) {
             // If items needed removal, perform the removal update
             if (itemsToRemoveFromCart.length > 0) {
                 await User.updateOne(
                    { _id: userId },
                    { $pull: { cart: { _id: { $in: itemsToRemoveFromCart } } } }
                 ).session(sessionDB); // Perform removal within session
                 console.log(`Removed ${itemsToRemoveFromCart.length} invalid items from cart for user ${userId}`);
             }
            await sessionDB.abortTransaction(); sessionDB.endSession(); // Abort the transaction

             // Refresh session cart AFTER DB update
             const updatedUser = await User.findById(userId).select('cart').populate('cart.productId').lean();
             req.session.user.cart = updatedUser ? updatedUser.cart.filter(i => i.productId) : [];
             await req.session.save();

             req.flash('error_msg', validationErrorMessage);
             return res.redirect('/user/cart');
         }

        // --- Proceed with DB Updates if Validation Passed ---

        // Decrement Stock and Increment Order Count
        for (const update of productStockUpdates) {
            const updateResult = await Product.updateOne(
                { _id: update.productId, stock: { $gte: update.quantityToDecrement } }, // Check stock again
                { $inc: { stock: -update.quantityToDecrement, orderCount: 1 } },
                { session: sessionDB }
            );
            if (updateResult.modifiedCount === 0) { // Handle concurrent update failure
                 await sessionDB.abortTransaction(); sessionDB.endSession();
                 req.flash('error_msg', `Checkout failed: Stock changed for a product during checkout. Please try again.`);
                 // Don't remove items here, let user review cart again
                 return res.redirect('/user/cart');
             }
        }

        // Create the Order document
        const order = new Order({
            userId: userId,
            userEmail: user.email,
            products: orderProducts, // Includes sellerId
            totalAmount: totalAmount,
            shippingAddress: user.address,
            paymentMethod: 'COD', // Or from request body if multiple methods allowed
            status: 'Pending',
            // cancellationAllowedUntil is set by pre-save hook
        });
        await order.save({ session: sessionDB });

        // Clear User's Cart
        user.cart = [];
        await user.save({ session: sessionDB });

        // --- Commit Transaction ---
        await sessionDB.commitTransaction();

        // Update session cart AFTER successful commit
        req.session.user.cart = [];
        await req.session.save();

        // --- Send Confirmation Email (Outside Transaction) ---
        try {
            const subject = 'Your Order Has Been Placed!';
            let productListHTML = order.products.map(p => `<li>${p.name} (Qty: ${p.quantity}) - â‚¹${p.priceAtOrder.toFixed(2)}</li>`).join('');
            const formattedOrderDate = res.locals.formatDateIST(order.orderDate);
            const html = `<h2>Thank you for your order!</h2><p>Your Order ID: ${order._id}</p><p>Order Placed: ${formattedOrderDate}</p><p>Total Amount: â‚¹${order.totalAmount.toFixed(2)}</p><p>Shipping To: ${order.shippingAddress.name}, ${order.shippingAddress.cityVillage}</p><h3>Items:</h3><ul>${productListHTML}</ul><p>You can track your order status in the 'My Orders' section.</p>`;
            await sendEmail(user.email, subject, `Your order ${order._id} has been placed. Total: â‚¹${totalAmount.toFixed(2)}`, html);
        } catch (emailError) {
            console.error(`Failed sending order confirmation email for order ${order._id}:`, emailError);
            // Don't fail the request if email fails
        }

        req.flash('success_msg', 'Order placed successfully!');
        res.redirect('/orders/my-orders'); // Redirect to user's order history

    } catch (error) {
        // Ensure transaction is aborted on any unexpected error
        if (sessionDB.inTransaction()) {
             await sessionDB.abortTransaction();
        }
        console.error("Order Placement Transaction Error:", error);
        req.flash('error_msg', `Order placement failed due to a server error. Please review your cart and try again.`);
        res.redirect('/user/cart'); // Redirect to cart
    } finally {
        // Always end the session
        if (sessionDB.id) { // Check if session exists before ending
             await sessionDB.endSession();
        }
    }
};

// --- UPDATE cancelOrder (Uses Transaction) ---
exports.cancelOrder = async (req, res, next) => {
    const orderId = req.params.id;
    const userId = req.session.user._id;
    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction({ writeConcern: { w: 'majority' }}); // Ensure durability

    try {
        // Find the order: Must belong to the user, be 'Pending', and within cancellation window
        const order = await Order.findOne({
             _id: orderId,
             userId: userId, // Belongs to logged-in user
             status: 'Pending', // Only pending orders
             cancellationAllowedUntil: { $gt: Date.now() } // Within allowed time
        })
        .populate('products.productId', '_id name') // Need _id for update
        .session(sessionDB); // Use the transaction session

        if (!order) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
             req.flash('error_msg', 'Order not found, already processed/cancelled, or cancellation period expired.');
            return res.redirect('/orders/my-orders');
        }

        console.log(`User Cancellation: Restoring stock/orderCount for order ${orderId}.`);
        // Restore stock and decrement orderCount for each valid product item
        const productUpdatePromises = order.products.map(item => {
            const quantityToRestore = Number(item.quantity);
            if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                 console.warn(`User Cancel: Invalid item P.ID ${item.productId?._id} or Qty ${item.quantity} in O.ID ${orderId}. Skipping stock restore.`);
                return Promise.resolve(); // Skip invalid items gracefully
             }
            // Update the Product: Increment stock, decrement orderCount
             return Product.updateOne(
                 { _id: item.productId._id },
                 { $inc: { stock: quantityToRestore, orderCount: -1 } },
                 { session: sessionDB } // Use transaction session
             ).catch(err => {
                // Log error, but allow cancellation to continue for the order itself
                console.error(`User Cancel: Failed stock/orderCount restore for P.ID ${item.productId._id} on O.ID ${orderId}: ${err.message}`);
             });
        });
        // Wait for all stock updates to attempt (use allSettled)
        const results = await Promise.allSettled(productUpdatePromises);
        results.forEach((result, index) => {
            if (result.status === 'rejected') {
                console.error(`Failed promise during stock restore for item index ${index} in order ${orderId}: ${result.reason}`);
            }
        });
        console.log(`User Cancel: Stock/OrderCount restoration process completed for order ${orderId}.`);


        // Update the Order status
        order.status = 'Cancelled';
        order.cancellationReason = "Cancelled by customer";
        // OTP fields etc., should be cleared by the pre-save hook in Order model
        await order.save({ session: sessionDB });

        // --- Commit Transaction ---
        await sessionDB.commitTransaction();

        // Send email confirmation (outside transaction)
         try{
             const subject = 'Your Order Has Been Cancelled';
             const html = `<p>Your order (${order._id}) has been successfully cancelled as requested.</p>`;
            await sendEmail(order.userEmail, subject, `Order ${order._id} cancelled.`, html);
         } catch (emailError){
             console.error(`Failed sending cancellation confirmation email for order ${order._id}:`, emailError);
         }

        req.flash('success_msg', 'Order cancelled successfully.');
        res.redirect('/orders/my-orders');

    } catch (error) {
         // Abort transaction on error
         if (sessionDB.inTransaction()) {
             await sessionDB.abortTransaction();
         }
         console.error("Order Cancellation Error:", error);
         req.flash('error_msg', 'Failed to cancel the order due to an internal error.');
         res.redirect('/orders/my-orders');
    } finally {
        // Always end the session
        if (sessionDB.id) { await sessionDB.endSession(); }
    }
};

// --- Get My Orders (Includes OTP display logic) ---
exports.getMyOrders = async (req, res, next) => {
    try {
        const orders = await Order.find({ userId: req.session.user._id })
                                   .select('-__v') // Exclude version key for cleaner output
                                   .sort({ orderDate: -1 })
                                   // Populate products for display
                                   .populate('products.productId', 'name imageUrl _id price')
                                   .lean(); // Use lean for read-only access

        const now = Date.now();
        orders.forEach(order => {
            // Determine if customer can cancel
            order.isCancellable = order.status === 'Pending' && order.cancellationAllowedUntil && now < new Date(order.cancellationAllowedUntil).getTime();

            // Determine if Delivery OTP should be shown
            order.showDeliveryOtp = order.status === 'Pending' &&
                                    !!order.orderOTP &&          // OTP must exist
                                    !!order.orderOTPExpires &&   // Expiry must exist
                                    new Date(order.orderOTPExpires).getTime() > now; // Must not be expired

            // Dates will be formatted in EJS using the formatDateIST helper
        });

        res.render('user/my-orders', {
            title: 'My Orders',
            orders: orders // Pass orders to the view
            // formatDateIST helper is available via res.locals
        });
    } catch (error) {
        console.error("Error fetching user orders:", error);
        next(error); // Pass error to central handler
    }
};

// --- Admin OTP Generation Logic (Remains Largely the Same) ---
exports.generateAndSendDirectDeliveryOTPByAdmin = async (orderId) => {
    try {
        const order = await Order.findById(orderId);
        if (!order) throw new Error('Order not found.');
        if (order.status !== 'Pending') throw new Error(`Cannot generate OTP for order status '${order.status}'. Must be 'Pending'.`);

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(5); // 5 minutes validity
        order.orderOTP = otp;
        order.orderOTPExpires = otpExpires;
        await order.save();

        const user = await User.findById(order.userId).select('email'); // Get user email for logging/potential notification
        const userEmail = user ? user.email : '[User Account Missing]';

        console.log(`ADMIN generated Direct Delivery OTP for O.ID ${orderId}. OTP: ${otp}. (User: ${userEmail})`);
        // Optional: Send email/SMS to user.email here if needed

        return { success: true, message: `OTP generated for order ${orderId}. It is visible on the customer's 'My Orders' page.` };
    } catch (error) {
        console.error(`Error in generateAndSendDirectDeliveryOTPByAdmin for O.ID ${orderId}:`, error);
        throw error; // Re-throw for the calling controller
    }
};

// --- Seller OTP Generation Logic (NEW) ---
exports.generateAndSendDirectDeliveryOTPBySeller = async (orderId, sellerId) => {
    try {
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'sellerId'); // Populate sellerId for verification

        if (!order) throw new Error('Order not found.');
        if (order.status !== 'Pending') throw new Error(`Cannot generate OTP for order status '${order.status}'. Must be 'Pending'.`);

        // Security Check: Ensure the order contains at least one product from this seller
        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
            console.warn(`Seller ${sellerId} attempted OTP generation for unrelated order ${orderId}.`);
            throw new Error('Permission Denied: Order does not contain your products.');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(5); // 5 minutes validity
        order.orderOTP = otp;
        order.orderOTPExpires = otpExpires;
        await order.save();

        const user = await User.findById(order.userId).select('email');
        const userEmail = user ? user.email : '[User Account Missing]';

        console.log(`SELLER (${sellerId}) generated OTP for O.ID ${orderId}. OTP: ${otp}. (User: ${userEmail})`);
        // Optional: Send email/SMS notification

        return { success: true, message: `OTP generated for order ${orderId}. It is visible on the customer's 'My Orders' page.` };
    } catch (error) {
        console.error(`Error in generateAndSendDirectDeliveryOTPBySeller for O.ID ${orderId} by Seller ${sellerId}:`, error);
        throw error; // Re-throw for the calling controller
    }
};

// --- Admin Confirm Delivery Logic (Remains Largely the Same) ---
exports.confirmDirectDeliveryByAdmin = async (orderId, adminUserId, providedOtp, resForHelper = null) => {
    try {
        const order = await Order.findOne({
           _id: orderId,
           status: 'Pending',
           orderOTP: providedOtp,
           orderOTPExpires: { $gt: Date.now() }
        });

        if (!order) {
           // Check specific failure reason
           const checkOrder = await Order.findById(orderId).select('status orderOTP orderOTPExpires');
           if (!checkOrder) throw new Error('Order not found.');
           if (checkOrder.status !== 'Pending') throw new Error(`Order status is '${checkOrder.status}', cannot confirm delivery.`);
           if (checkOrder.orderOTP !== providedOtp) throw new Error('Invalid OTP.');
           if (!checkOrder.orderOTPExpires || checkOrder.orderOTPExpires <= Date.now()) throw new Error('Expired OTP.');
           throw new Error('OTP verification failed.'); // Generic fallback
        }

        // Update Order
        order.status = 'Delivered';
        order.receivedByDate = new Date();
        // Clear OTP fields - Pre-save hook in Order model should handle this, but explicit clear is safe
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined; // Disable cancellation
        await order.save();

        console.log(`Order ${orderId} confirmed delivered by ADMIN ${adminUserId}`);

        // Send Confirmation Email
        try {
            const subject = `Your Order Has Been Delivered!`;
            const formattedDeliveryDate = resForHelper?.locals?.formatDateIST(order.receivedByDate) || new Date(order.receivedByDate).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
            const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed by administration.</p><p>Received Date: ${formattedDeliveryDate}</p><p>Thank you for shopping with us!</p>`;
           await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
        } catch (emailError){
            console.error(`Admin Confirm: Failed sending delivery confirmation email for O.ID ${order._id}:`, emailError);
        }

        return { success: true, order: order };
    } catch (error) {
        console.error(`Error verifying ADMIN Direct Delivery OTP for O.ID ${orderId} by Admin ${adminUserId}:`, error);
        throw error; // Re-throw
   }
};

// --- Seller Confirm Delivery Logic (NEW) ---
exports.confirmDirectDeliveryBySeller = async (orderId, sellerId, providedOtp, resForHelper = null) => {
    try {
        const order = await Order.findOne({
            _id: orderId,
            status: 'Pending',
            orderOTP: providedOtp,
            orderOTPExpires: { $gt: Date.now() }
        }).populate('products.productId', 'sellerId'); // Need sellerId for verification

        if (!order) {
           // Check specific failure reason
           const checkOrder = await Order.findById(orderId).select('status orderOTP orderOTPExpires');
           if (!checkOrder) throw new Error('Order not found.');
           if (checkOrder.status !== 'Pending') throw new Error(`Order status is '${checkOrder.status}'.`);
           if (checkOrder.orderOTP !== providedOtp) throw new Error('Invalid OTP.');
           if (!checkOrder.orderOTPExpires || checkOrder.orderOTPExpires <= Date.now()) throw new Error('Expired OTP.');
           throw new Error('OTP verification failed.');
        }

        // Security Check: Verify order relevance to this seller
        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
           console.warn(`Seller ${sellerId} attempted to confirm unrelated order ${orderId}.`);
           throw new Error('Permission Denied: Order does not contain your products.');
        }

        // Update Order
        order.status = 'Delivered';
        order.receivedByDate = new Date();
        // Clear OTP fields
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined;
        await order.save();

        console.log(`Order ${orderId} confirmed delivered by SELLER ${sellerId}`);

        // Send Confirmation Email
        try {
           const subject = `Your Order Has Been Delivered!`;
           const formattedDeliveryDate = resForHelper?.locals?.formatDateIST(order.receivedByDate) || new Date(order.receivedByDate).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
           const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed by the seller.</p><p>Received Date: ${formattedDeliveryDate}</p><p>Thank you for shopping with us!</p>`;
           await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
        } catch (emailError){
            console.error(`Seller Confirm: Failed sending delivery confirmation email for O.ID ${order._id}:`, emailError);
        }

        return { success: true, order: order };
    } catch (error) {
        console.error(`Error verifying SELLER Direct Delivery OTP for O.ID ${orderId} by Seller ${sellerId}:`, error);
        throw error; // Re-throw
   }
};

controllers/productController.js:
// controllers/productController.js
const Product = require('../models/Product');
const User = require('../models/User');
const Category = require('../models/Category'); // *** IMPORT Category ***
const mongoose = require('mongoose'); // Needed for ObjectId validation if used

/**
 * Escapes special characters in a string for use in a regular expression.
 * @param {string} string - The input string.
 * @returns {string} The escaped string.
 */
function escapeRegex(string) {
  // Simple escape function, consider a more robust one if needed for complex regex
  return string.replace(/[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

// --- UPDATED Get Products (Handles category filter and search) ---
exports.getProducts = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || '';
    // --- NEW: Check for category filter ---
    const categoryFilterName = req.query.categoryName || ''; // Use categoryName

    let query = {
        reviewStatus: 'approved', // Only show approved products
        stock: { $gt: 0 }         // Only show products in stock
    };
    let sort = { createdAt: -1 }; // Default: Newest first
    const projection = {};        // Define if specific fields are needed

    // --- Filter by Category if provided ---
    if (categoryFilterName) {
        // Basic validation for category name format if needed
        // Example: if (!/^[a-zA-Z0-9\s&-]+$/.test(categoryFilterName)) { ... handle error ... }
        query.categoryName = categoryFilterName; // Filter by denormalized name
         console.log(`Filtering products page by category: ${categoryFilterName}`);
         // Optional: Change sort order when filtering by category, e.g., sort by name
         // sort = { name: 1 };
     }

    // --- Handle Search Term (sequential match) ---
    if (searchTerm) {
      const escapedSearchTerm = escapeRegex(searchTerm);
      const regex = new RegExp(escapedSearchTerm, 'i'); // Case-insensitive

      // Update search fields to include name, categoryName, and description
      query.$or = [
        { name: regex },
        { categoryName: regex }, // Search denormalized category name
        { description: regex }
        // { specifications: regex } // Add specifications if needed
      ];
       // Current query combines search AND category filter if both are present.
       // If search should *override* the category filter, uncomment below:
       // if (categoryFilterName) { delete query.categoryName; }
      console.log(`Regex Search Query (getProducts): ${JSON.stringify(query)}`);
      // Optional: Change sort order for search results
      // sort = { name: 1 }; // e.g., Alphabetical
    }

    // Fetch categories as well - useful for displaying sidebar or breadcrumbs
     const [products, categories] = await Promise.all([
        Product.find(query, projection)
                .populate('categoryRef', 'name') // Optionally populate just the name for consistency
                .sort(sort)
                .lean(),
         Category.find().sort('name').lean() // Fetch all categories for display
    ]);

    // Render the main product index view
    res.render('products/index', {
        title: categoryFilterName
            ? `Products in ${categoryFilterName}` // Title for category filtered page
            : (searchTerm ? `Search Results for "${searchTerm}"` : 'Home'), // Dynamic title for search or home
        products: products,
        searchTerm: searchTerm,
        homepageCategories: categories, // Pass all categories (e.g., for category nav display)
        homepageBanners: [], // Pass empty array or fetch banners if needed on this specific route
        selectedCategoryName: categoryFilterName // Pass selected category name for potential highlighting/breadcrumbs
    });
  } catch (error) {
    console.error("Error fetching products:", error);
    next(error); // Pass error to the central handler
  }
};


// --- Get Product Details ---
// --- UPDATED: Populate categoryRef ---
exports.getProductDetails = async (req, res, next) => {
  try {
    // Validate Product ID format first
    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
        const error = new Error('Invalid Product ID format');
        error.status = 400; // Bad Request
        return next(error);
    }

    const product = await Product.findById(req.params.id)
                                    .populate('sellerId', 'name email') // Populate seller details
                                    .populate('categoryRef', 'name slug') // Populate category name/slug
                                    .lean(); // Use lean for performance

    // --- Handle Product Not Found ---
    if (!product) {
       const error = new Error('Product not found');
       error.status = 404; // Not Found
       return next(error);
    }

    // --- Permission checks (Status, Admin, Owner) ---
    const isApproved = product.reviewStatus === 'approved';
    const user = req.session.user;
    const isAdmin = user?.role === 'admin';
    // Safely check owner status (handles cases where sellerId might be missing)
    const isOwner = user && product.sellerId?._id && user._id.toString() === product.sellerId._id.toString();

    // If product is not approved AND user is not admin OR owner, deny access
    if (!isApproved && !isAdmin && !isOwner) {
         const error = new Error('Product not available');
         error.status = 404; // Use 404 to mask existence
         return next(error);
    }

    // --- Prepare Rating Information ---
    let userRating = null;
    if (user && product.ratings && Array.isArray(product.ratings)) { // Check product.ratings exists and is an array
       const ratingData = product.ratings.find(r => r.userId?.toString() === user._id.toString());
       userRating = ratingData ? ratingData.rating : null;
    }

    const ratingCounts = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
    let totalRatings = 0;
    if (product.ratings && product.ratings.length > 0) {
        totalRatings = product.ratings.length;
        product.ratings.forEach(r => {
            if (r.rating >= 1 && r.rating <= 5) { // Ensure rating is valid before counting
                ratingCounts[r.rating]++;
            }
        });
    }
    // Use numReviews (updated by pre-save hook) if available, otherwise fallback to calculated total
     const displayTotalRatings = product.numReviews ?? totalRatings;

    // Render the detail view
    res.render('products/detail', {
      title: product.name,
      product: product, // Pass the lean product object (includes populated categoryRef)
      isApproved: isApproved,
      isAdminView: isAdmin,
      isOwnerView: isOwner,
      userRating: userRating, // User's existing rating (if any)
      userCanRate: user ? true : false, // Can the current viewer rate? (Needs login)
      ratingCounts: ratingCounts, // Counts for each star level (for rating bars)
      totalRatings: displayTotalRatings // Total number of ratings to display
    });
  } catch (error) {
       // Handle potential CastError specifically during findById
       if (error.name === 'CastError') {
           const notFoundError = new Error('Product not found (Invalid ID format)');
           notFoundError.status = 404;
           return next(notFoundError);
       }
    // Pass any other errors to the central handler
    next(error);
  }
};


// --- Rate Product (No changes needed related to category update) ---
 exports.rateProduct = async (req, res, next) => {
    const { rating } = req.body;
    const productId = req.params.id;
    const userId = req.session.user?._id; // Make sure user exists

    // Validation
     if (!userId) {
        // This should ideally be caught by isAuthenticated middleware, but double-check
         req.flash('error_msg', 'You must be logged in to rate products.');
         return res.redirect(`/products/${productId}`);
     }
     if (!mongoose.Types.ObjectId.isValid(productId)) {
        req.flash('error_msg', 'Invalid Product ID.');
        return res.status(400).redirect('/'); // Redirect home or back?
    }
     if (!rating || isNaN(Number(rating)) || rating < 1 || rating > 5) {
         req.flash('error_msg', 'Please provide a valid rating between 1 and 5.');
        return res.redirect('back'); // Go back to the product page
     }

    try {
        // Find product *without* lean() to use .save() and trigger hooks
        const product = await Product.findById(productId);

         if (!product) {
             req.flash('error_msg', 'Product not found.');
             return res.status(404).redirect('/');
         }

          // Ensure product is approved before allowing rating
         if (product.reviewStatus !== 'approved') {
             req.flash('error_msg', 'This product cannot be rated yet.');
             return res.redirect(`/products/${productId}`);
         }

         // Check if user has already rated
         const existingRatingIndex = product.ratings.findIndex(r => r.userId?.toString() === userId.toString());

         if (existingRatingIndex > -1) {
             // Update existing rating
             product.ratings[existingRatingIndex].rating = Number(rating);
         } else {
             // Add new rating object
             product.ratings.push({ userId: userId, rating: Number(rating) });
         }

        // Save the product - this will trigger the pre-save hook in Product.js
        // which recalculates averageRating and numReviews
        await product.save();

         req.flash('success_msg', 'Thank you for your rating!');
         res.redirect(`/products/${productId}`); // Redirect back to product page

     } catch (error) {
        // Redundant CastError check if validation is done above, but safe to keep
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID.');
            return res.status(400).redirect('/');
        }
        console.error("Error rating product:", error);
        next(error); // Pass other errors to the central handler
     }
 };

 // --- Get Product Suggestions (Updated to search categoryName) ---
 exports.getProductSuggestions = async (req, res, next) => {
    const searchTerm = req.query.q;
    const limit = 8; // Max number of suggestions

    // Basic validation for search term length
    if (!searchTerm || searchTerm.trim().length < 2) {
        return res.json([]); // Return empty array if search term is too short
    }

    try {
        // Escape regex characters for safe searching
        const escapedSearchTerm = escapeRegex(searchTerm);
        // Create case-insensitive regex
        const regex = new RegExp(escapedSearchTerm, 'i');

        // Define the search query targeting relevant fields
        const query = {
            $or: [
                { name: regex },         // Match product name
                { categoryName: regex }, // *** Match categoryName ***
                { description: regex }   // Match description
                // { specifications: regex } // Optional: add specs search
            ],
            reviewStatus: 'approved', // Only suggest approved products
            stock: { $gt: 0 }         // Only suggest products in stock
        };

        // Fetch suggestions from the database
        const suggestions = await Product.find(query)
            .select('_id name imageUrl categoryName') // Select fields needed for display
            .limit(limit) // Limit the number of results
            .sort({ name: 1 }) // Sort alphabetically (or consider relevance score later)
            .lean(); // Use lean for performance

        // Return suggestions as JSON
        res.json(suggestions);

    } catch (error) {
        console.error("Error fetching product suggestions:", error);
        // Return an error response (optional, depends on desired frontend handling)
        res.status(500).json({ error: 'Failed to fetch suggestions' });
    }
 };

controllers/sellerController.js:
// controllers/sellerController.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const Category = require('../models/Category'); // *** IMPORT Category Model ***
const { sendEmail } = require('../config/mailer');
const { reviewProductWithGemini } = require('../services/geminiService');
const {
    generateAndSendDirectDeliveryOTPBySeller,
    confirmDirectDeliveryBySeller
} = require('./orderController');
const mongoose = require('mongoose');

const sellerCancellationReasons = [
    "â— Item Out of Stock",
    "ðŸšš Unable to Fulfill/Ship",
    "ðŸ‘¤ Customer Requested Cancellation",
    "â“ Other Reason",
];

// Seller Dashboard
exports.getSellerDashboard = (req, res) => {
    res.render('seller/dashboard', { title: 'Seller Dashboard' });
};

// --- Product Management Pages ---
// --- UPDATED: Fetch Categories for Upload Page ---
exports.getUploadProductPage = async (req, res, next) => {
     try {
         const categories = await Category.find().sort('name').lean(); // Fetch categories
         res.render('seller/upload-product', {
            title: 'Upload New Product',
            product: {}, // Empty product object for form binding
            categories: categories // Pass categories to the view
        });
     } catch (error) {
        console.error("Error fetching categories for seller upload page:", error);
        req.flash('error_msg', 'Could not load category data.');
         res.render('seller/upload-product', { // Render even if category fetch fails
             title: 'Upload New Product',
             product: {},
             categories: []
         });
     }
};

// --- UPDATED: Fetch Categories for Edit Page ---
exports.getEditProductPage = async (req, res, next) => {
     try {
        // isProductOwner middleware ensures ownership
        const [product, categories] = await Promise.all([
             Product.findOne({ _id: req.params.id, sellerId: req.session.user._id })
                    .populate('categoryRef') // Populate category object
                    .lean(), // Fetch the specific product owned by the seller
             Category.find().sort('name').lean() // Fetch all categories
        ]);

        if (!product) {
           req.flash('error_msg', 'Product not found or you do not have permission to edit it.');
           return res.redirect('/seller/products');
        }

        res.render('seller/edit-product', {
           title: `Edit Product: ${product.name}`,
           product: product,
           categories: categories // Pass categories to the view
        });

   } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.redirect('/seller/products');
        }
        console.error("Error fetching product/categories for edit:", error);
        next(error);
    }
};


// --- Product Management Actions ---
// --- UPDATED: Handle categoryRef on Upload ---
exports.uploadProduct = async (req, res, next) => {
    // *** Get categoryRef instead of category ***
    const { name, categoryRef, price, stock, imageUrl, description, specifications } = req.body;
    const sellerId = req.session.user._id;
    const sellerEmail = req.session.user.email;
    let categories = []; // For re-rendering form on error

     try {
         // Fetch categories for validation and error re-rendering
         categories = await Category.find().sort('name').lean();

         // --- Updated Validation ---
        if (!name || !categoryRef || price === undefined || stock === undefined || !imageUrl) { // Check ref
            req.flash('error_msg', 'Please fill in all required fields (Name, Category, Price, Stock, Image URL).');
            return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories });
        }
         if (!mongoose.Types.ObjectId.isValid(categoryRef)) {
            req.flash('error_msg', 'Invalid category selected.');
            return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories });
         }
         if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
            req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
            return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories });
         }
          // Ensure categories are loaded for the check below
          if (!categories || categories.length === 0) {
               throw new Error("Categories could not be loaded for validation.");
          }
          // Verify Category Exists
          const selectedCategory = categories.find(cat => cat._id.toString() === categoryRef);
          if (!selectedCategory) {
              req.flash('error_msg', 'Selected category not found or invalid.');
              return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories });
          }

        // --- Save using categoryRef (categoryName will be added by pre-save hook) ---
        const newProduct = new Product({
            name: name.trim(),
            categoryRef: categoryRef, // Use categoryRef
            // categoryName will be set by pre-save hook using selectedCategory.name
            description: description ? description.trim() : '',
            price: Number(price),
            stock: Number(stock),
            imageUrl: imageUrl.trim(),
            specifications: specifications ? specifications.trim() : '',
            sellerId: sellerId,
            sellerEmail: sellerEmail,
            reviewStatus: 'pending' // Start as pending
        });

        await newProduct.save(); // Pre-save hook runs here to set categoryName
        console.log(`Product ${newProduct._id} (Cat: ${newProduct.categoryName}) saved initially by seller ${sellerEmail}.`);

        // Trigger Gemini review asynchronously (pass the saved product which now has _id)
        reviewProductWithGemini(newProduct).then(async reviewResult => {
             try {
                 const productToUpdate = await Product.findById(newProduct._id);
                 if (productToUpdate) {
                    productToUpdate.reviewStatus = reviewResult.status;
                    productToUpdate.rejectionReason = reviewResult.reason;
                    await productToUpdate.save(); // Save the updated review status
                    console.log(`Product ${newProduct._id} review status updated to ${reviewResult.status}.`);
                 } else {
                     console.warn(`Product ${newProduct._id} not found for status update after Gemini review.`);
                 }
             } catch (updateError) {
                console.error(`Error updating product ${newProduct._id} after Gemini review:`, updateError);
             }
        }).catch(reviewError => {
             console.error(`Error in Gemini review promise chain for product ${newProduct._id}:`, reviewError);
             // Attempt to mark as pending with error reason if review chain fails
              Product.findByIdAndUpdate(newProduct._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed.' }).catch(err => console.error("Failed to mark product as pending after review error:", err));
        });

        req.flash('success_msg', `Product "${newProduct.name}" submitted for review.`);
        res.redirect('/seller/products'); // Redirect to seller's product list

    } catch (error) {
         // Ensure categories are available if an error occurs before or during fetch
         if (!categories || categories.length === 0) {
              try { categories = await Category.find().sort('name').lean(); } catch (catError) { console.error("Failed to fetch categories for error display:", catError); }
         }
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
           return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories || [] });
       }
        console.error("Error uploading product:", error);
        req.flash('error_msg', `Error uploading product: ${error.message}`);
        return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories || [] });
        // Or use next(error);
    }
};

// --- UPDATED: Handle categoryRef on Update ---
exports.updateProduct = async (req, res, next) => {
    const productId = req.params.id;
    const sellerId = req.session.user._id;
    // *** Get categoryRef instead of category ***
    const { name, categoryRef, price, stock, imageUrl, description, specifications } = req.body;
     let categories = []; // For potential re-rendering on error

    try {
        // Fetch categories early for validation/error case
        categories = await Category.find().sort('name').lean();

         // --- Updated Validation ---
         if (!name || !categoryRef || price === undefined || stock === undefined || !imageUrl) { // Check ref
            req.flash('error_msg', 'Please fill in all required fields.');
             // Redirect back to edit page, data will be re-fetched by getEditProductPage
             return res.redirect(`/seller/products/edit/${productId}`);
         }
        if (!mongoose.Types.ObjectId.isValid(categoryRef)) {
             req.flash('error_msg', 'Invalid category selected.');
             return res.redirect(`/seller/products/edit/${productId}`);
          }
         if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
             req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
             return res.redirect(`/seller/products/edit/${productId}`);
         }
          // Ensure categories loaded for check
          if (!categories || categories.length === 0) {
               throw new Error("Categories could not be loaded for validation.");
          }
        // Verify Category Exists using pre-fetched categories
        const selectedCategory = categories.find(cat => cat._id.toString() === categoryRef);
        if (!selectedCategory) {
           req.flash('error_msg', 'Selected category not found or invalid.');
           return res.redirect(`/seller/products/edit/${productId}`);
        }

        // Use findOne to ensure ownership and get non-lean doc for saving
        const product = await Product.findOne({ _id: productId, sellerId: sellerId });
        if (!product) {
            req.flash('error_msg', 'Product not found or access denied.');
            return res.status(404).redirect('/seller/products');
         }

         // Check if core details impacting review have changed
         const detailsChanged = product.name !== name.trim() ||
                               product.categoryRef.toString() !== categoryRef ||
                               product.description !== (description ? description.trim() : '') ||
                               product.imageUrl !== imageUrl.trim();


         // Update product fields
         product.name = name.trim();
         product.categoryRef = categoryRef; // Update Ref
         // categoryName will be updated by pre-save hook using selectedCategory.name
         product.description = description ? description.trim() : '';
         product.price = Number(price);
         product.stock = Number(stock);
         product.imageUrl = imageUrl.trim();
         product.specifications = specifications ? specifications.trim() : '';

         // Only reset review status if relevant details changed
         if (detailsChanged) {
            product.reviewStatus = 'pending'; // Reset status on update of key details
            product.rejectionReason = undefined; // Clear rejection reason
            console.log(`Product ${productId} core details updated by seller, set to pending review.`);
         } else {
            console.log(`Product ${productId} updated by seller (only price/stock/specs?), review status remains ${product.reviewStatus}.`);
         }


         await product.save(); // Pre-save runs to update categoryName if needed

        // Trigger Gemini review only if status was reset to pending
        if (product.reviewStatus === 'pending') {
            reviewProductWithGemini(product).then(async reviewResult => {
                 try {
                     const productToUpdate = await Product.findById(product._id); // Refetch fresh instance
                     if (productToUpdate) {
                        productToUpdate.reviewStatus = reviewResult.status;
                        productToUpdate.rejectionReason = reviewResult.reason;
                        await productToUpdate.save(); // Save review status
                        console.log(`Product ${product._id} review status updated to ${reviewResult.status} after edit.`);
                     }
                 } catch (updateError) {
                    console.error(`Error updating product ${product._id} after Gemini review (post-edit):`, updateError);
                 }
            }).catch(reviewError => {
                 console.error(`Error in Gemini review promise chain for edited product ${product._id}:`, reviewError);
                  Product.findByIdAndUpdate(product._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed after edit.' }).catch(err => console.error("Failed to mark edited product as pending after review error:", err));
             });
        }

         req.flash('success_msg', `Product "${product.name}" updated${product.reviewStatus === 'pending' ? ' and resubmitted for review' : ''}.`);
         res.redirect('/seller/products');

    } catch (error) {
         // Ensure categories available for potential error render (though redirect is preferred)
          if (!categories || categories.length === 0) {
               try { categories = await Category.find().sort('name').lean(); } catch (catErr) {}
           }
        if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
        } else {
             console.error("Error updating product:", error);
            req.flash('error_msg', 'An error occurred while updating the product.');
        }
        // Redirect back to edit page on any error to allow user to fix
        return res.redirect(`/seller/products/edit/${productId}`);
    }
};

// --- UPDATED: Populate category name ---
exports.getManageProductsPage = async (req, res, next) => {
    try {
        const sellerId = req.session.user._id;
        const products = await Product.find({ sellerId: sellerId })
                                    .populate('categoryRef', 'name') // Populate category name via ref
                                    .sort({ createdAt: -1 })
                                    .lean();

        res.render('seller/manage-products', {
            title: 'Manage Your Products',
            products: products
        });
    } catch (error) {
        console.error("Error fetching seller products:", error);
        next(error);
    }
};

exports.removeProduct = async (req, res, next) => {
    const productId = req.params.id;
    const sellerId = req.session.user._id; // Ensure seller ID from session

    try {
         // Find and delete specifically matching the product ID AND seller ID
         const product = await Product.findOneAndDelete({ _id: productId, sellerId: sellerId });

        if (!product) {
             // Product either doesn't exist or doesn't belong to this seller
             req.flash('error_msg', 'Product not found or you do not have permission to remove it.');
             return res.status(404).redirect('/seller/products');
         }
         req.flash('success_msg', `Product "${product.name}" removed successfully.`);
         res.redirect('/seller/products'); // Redirect back to the seller's product list
    } catch (error) {
        if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid product ID format.');
            return res.status(400).redirect('/seller/products');
        }
        console.error("Error removing product:", error);
        req.flash('error_msg', 'Error removing product.');
        res.redirect('/seller/products');
    }
};

// --- Seller Order Management Page ---
exports.getManageOrdersPage = async (req, res, next) => {
    try {
        const sellerId = req.session.user._id;

        // 1. Find product IDs sold by this seller
        const sellerProductRefs = await Product.find({ sellerId: sellerId }).select('_id').lean();
        const sellerProductIds = sellerProductRefs.map(p => p._id);

        // Handle case where seller has no products
        if (sellerProductIds.length === 0) {
             return res.render('seller/manage-orders', {
                 title: 'Manage Your Orders',
                 orders: [],
                 message: 'You have no products listed, so no orders to manage yet.',
                 sellerCancellationReasons: sellerCancellationReasons // Pass reasons even if no orders
             });
        }

        // 2. Find orders containing any of these products
        const orders = await Order.find({ 'products.productId': { $in: sellerProductIds } })
                                   .sort({ orderDate: -1 })
                                   .populate('products.productId', 'name imageUrl _id price sellerId') // Include sellerId here
                                   .populate('userId', 'name email') // Populate user for display if needed
                                   .lean();

        // 3. Add flags specific to seller actions and format items summary
        const now = Date.now();
        orders.forEach(order => {
             order.isRelevantToSeller = true; // Set flag based on the find query
             order.canBeDirectlyDeliveredBySeller = order.status === 'Pending';
             order.canBeCancelledBySeller = order.status === 'Pending';

             order.showDeliveryOtp = order.status === 'Pending' &&
                                     !!order.orderOTP &&
                                     !!order.orderOTPExpires &&
                                     new Date(order.orderOTPExpires).getTime() > now;

            // Format item summary, highlighting seller's items
            if (order.products && order.products.length > 0) {
                order.itemsSummary = order.products.map(p => {
                    const isSellerItem = p.productId?.sellerId?.toString() === sellerId.toString();
                    const price = (p.priceAtOrder !== undefined && p.priceAtOrder !== null) ? p.priceAtOrder : (p.productId?.price ?? 0);
                    const productName = p.productId?.name || p.name || '[Product Name Missing]';
                    // Highlight seller's items using text-success (or other class)
                    return `${isSellerItem ? '<strong class="text-success">' : ''}${productName} (Qty: ${p.quantity}) @ â‚¹${price.toFixed(2)}${isSellerItem ? ' (Your Item)</strong>' : ''}`;
                }).join('<br>');
            } else {
                 order.itemsSummary = 'No items found';
            }
        });

        res.render('seller/manage-orders', {
            title: 'Manage Your Orders',
            orders: orders,
            message: null, // No general message if orders were found
            sellerCancellationReasons: sellerCancellationReasons
        });
    } catch (error) {
        console.error("Error fetching seller orders:", error);
        next(error);
    }
};


// --- Seller Order Actions (send OTP, confirm delivery, cancel order) ---
// These actions don't directly involve category details, so no changes needed here
// assuming relevance is checked via middleware (isOrderRelevantToSeller).

exports.sendDirectDeliveryOtpBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const sellerId = req.session.user._id;

    try {
        // isOrderRelevantToSeller middleware should have already checked relevance
        const order = await Order.findById(orderId); // Fetch order again if needed
        if (!order) throw new Error("Order not found.");
        if (order.status !== 'Pending') throw new Error(`Cannot send OTP for order status ${order.status}.`);

        const result = await generateAndSendDirectDeliveryOTPBySeller(orderId, sellerId);
        req.flash('success_msg', result.message + ' Ask customer for OTP.');
    } catch (error) {
        req.flash('error_msg', `Failed to send delivery OTP: ${error.message}`);
    }
    res.redirect('/seller/orders'); // Redirect back to the orders page
};

exports.confirmDirectDeliveryBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const { otp } = req.body;
    const sellerId = req.session.user._id;

    if (!otp || !/^\d{6}$/.test(otp.trim())) {
        req.flash('error_msg', 'Please enter the 6-digit OTP.');
        return res.redirect('/seller/orders');
    }

    try {
         // isOrderRelevantToSeller middleware checks relevance
         const { order } = await confirmDirectDeliveryBySeller(orderId, sellerId, otp.trim(), res);
        req.flash('success_msg', `Order ${orderId} confirmed delivered by you.`);
    } catch (error) {
        req.flash('error_msg', `Delivery confirmation failed: ${error.message}`);
    }
    res.redirect('/seller/orders'); // Redirect back
};

exports.cancelOrderBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const sellerId = req.session.user._id;
    const sellerEmail = req.session.user.email; // For logging

    if (!reason || !sellerCancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid seller reason for cancellation.');
        return res.redirect('/seller/orders');
    }

    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction();
    try {
        // Middleware ensures relevance, but fetch needed details again for the transaction
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'sellerId name _id') // Include necessary fields
                                .populate('userId', 'email')
                                .session(sessionDB);

        if (!order) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/seller/orders');
        }

        if (order.status !== 'Pending') {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', `Order status is '${order.status}'. Only 'Pending' orders can be cancelled by seller.`);
            return res.redirect('/seller/orders');
        }

        // Double-check relevance inside transaction
        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
             console.warn(`Seller ${sellerEmail} (${sellerId}) attempted cancellation for non-relevant order ${orderId}.`);
             req.flash('error_msg', 'Permission Denied: Order does not contain your products.');
             return res.status(403).redirect('/seller/orders');
        }

        console.log(`Seller Cancel: Restoring stock for seller ${sellerId}'s items in order ${orderId}.`);
        // Filter to only restore stock for THIS seller's items
        const productStockRestorePromises = order.products
            .filter(item => item.productId?.sellerId?.toString() === sellerId.toString())
            .map(item => {
                const quantityToRestore = Number(item.quantity);
                 if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                    console.warn(`Seller Cancel: Invalid P.ID ${item.productId?._id} or Qty ${item.quantity} for seller's item in O.ID ${orderId}. Skipping restore.`);
                    return Promise.resolve(); // Skip invalid items gracefully
                }
                console.log(`Seller Cancel: Restoring ${quantityToRestore} stock for P.ID ${item.productId._id}`);
                 // Update Product stock and decrement order count within transaction
                 return Product.updateOne(
                     { _id: item.productId._id },
                     { $inc: { stock: quantityToRestore, orderCount: -1 } },
                     { session: sessionDB } // Use transaction session
                 ).catch(err => {
                    // Log the error but allow the main cancellation logic to continue
                    console.error(`Seller Cancel: Failed stock/count restore P.ID ${item.productId._id} O.ID ${orderId}: ${err.message}`);
                 });
            });

        await Promise.allSettled(productStockRestorePromises); // Wait for all attempts
        console.log(`Seller Cancel: Stock restoration attempts completed for seller ${sellerId} in order ${orderId}.`);

        // Cancel the entire order (current implementation)
        order.status = 'Cancelled';
        order.cancellationReason = `Cancelled by Seller: ${reason}`;
        // Clear sensitive fields upon cancellation
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined;

        await order.save({ session: sessionDB }); // Save order changes

        await sessionDB.commitTransaction(); // Commit the transaction

        // Send email notification (outside transaction)
        try {
            const customerEmail = order.userEmail || order.userId?.email; // Find customer email
            if(customerEmail) {
                const subjectCust = `Update on Your Order (${order._id})`;
                const htmlCust = `<p>Unfortunately, your order (${order._id}) has been cancelled by the seller.</p>
                                <p><strong>Reason:</strong> ${reason}</p>
                                <p>Any payment made (if applicable) will be refunded according to policy.</p>
                                <p>We apologize for any inconvenience. Please contact support if you have questions.</p>`;
                const textCust = `Your order ${order._id} was cancelled by the seller. Reason: ${reason}. Contact support for questions.`;
                await sendEmail(customerEmail, subjectCust, textCust, htmlCust); // Send email
            } else {
                console.warn(`Seller Cancel: Could not find customer email for order ${orderId} notification.`);
            }
        } catch (emailError) {
            console.error(`Seller Cancel: Failed sending cancellation email for order ${order._id}:`, emailError);
        }

        req.flash('success_msg', `Order ${orderId} cancelled successfully. Reason: ${reason}. Customer notified.`);
        res.redirect('/seller/orders'); // Redirect back

    } catch (error) {
        if (sessionDB.inTransaction()) { // Abort if transaction is still active
            await sessionDB.abortTransaction();
        }
        console.error(`Error cancelling order ${orderId} by seller ${sellerEmail} (${sellerId}):`, error);
        req.flash('error_msg', 'Failed to cancel order due to an internal error.');
        res.redirect('/seller/orders'); // Redirect back
    } finally {
         if (sessionDB.id) { await sessionDB.endSession(); } // Always end the session
    }
};

middleware/authMiddleware.js:
const User = require('../models/User');

const isAuthenticated = (req, res, next) => {
    if (req.session && req.session.user) {
        User.findById(req.session.user._id).then(user => {
            if (!user) {
                req.session.destroy(err => {
                    if (err) {
                        console.error('Session destruction error:', err);
                        return next(err);
                    }
                    req.flash('error_msg', 'Session expired or user not found. Please login again.');
                    res.redirect('/auth/login');
                });
            } else {
                req.user = user;
                res.locals.currentUser = user;
                next();
            }
        }).catch(err => {
            console.error("Error checking user authentication:", err);
            req.flash('error_msg', 'An error occurred during authentication.');
            res.redirect('/auth/login');
        });
    } else {
        req.flash('error_msg', 'You must be logged in to view this page.');
        req.session.returnTo = req.originalUrl;
        res.redirect('/auth/login');
    }
};

module.exports = { isAuthenticated };


middleware/errorMiddleware.js:
const notFound = (req, res, next) => {
  const error = new Error(`Not Found - ${req.originalUrl}`);
  res.status(404);
  next(error);
};

const errorHandler = (err, req, res, next) => {
  let statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  let message = err.message;

  if (err.name === 'CastError' && err.kind === 'ObjectId') {
    statusCode = 404;
    message = 'Resource not found';
  }
   if (err.name === 'ValidationError') {
       statusCode = 400;
       const errors = Object.values(err.errors).map(el => el.message);
       message = `Validation Error: ${errors.join(', ')}`;
   }
    if (err.code === 11000) {
       statusCode = 400;
       message = `Duplicate field value entered: ${Object.keys(err.keyValue)} already exists.`;
    }


  console.error("ERROR STACK: ", err.stack);

  if (req.accepts('html')) {
      res.status(statusCode).render('error', {
          title: 'Error',
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
          statusCode: statusCode
      });
  } else {
      res.status(statusCode).json({
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
      });
  }
};

module.exports = { notFound, errorHandler };


middleware/roleMiddleware.js:
// middleware/roleMiddleware.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const mongoose = require('mongoose');

const isAdmin = (req, res, next) => {
  // Ensure user exists and has the 'admin' role
  if (req.session.user && req.session.user.role === 'admin') {
    return next(); // Use return to avoid executing further code
  } else {
    req.flash('error_msg', 'Access Denied: Admin privileges required.');
    return res.status(403).redirect('/'); // Use return
  }
};

// *** NEW: Middleware to check if user is a seller ***
const isSeller = (req, res, next) => {
  if (req.session.user && req.session.user.role === 'seller') {
    return next();
  } else {
    req.flash('error_msg', 'Access Denied: Seller privileges required.');
    return res.status(403).redirect('/');
  }
};

// *** NEW: Middleware to check if user is admin OR seller ***
const isAdminOrSeller = (req, res, next) => {
   if (req.session.user && (req.session.user.role === 'admin' || req.session.user.role === 'seller')) {
     return next();
   } else {
     req.flash('error_msg', 'Access Denied: Admin or Seller privileges required.');
     return res.status(403).redirect('/');
   }
};


// *** NEW: Middleware to check if the product belongs to the logged-in seller ***
// Apply this AFTER isAuthenticated and isSeller
const isProductOwner = async (req, res, next) => {
    const productId = req.params.id || req.params.productId; // Check common param names
    const sellerId = req.session.user._id;

    if (!mongoose.Types.ObjectId.isValid(productId)) {
         req.flash('error_msg', 'Invalid Product ID format.');
         return res.status(400).redirect('back'); // Redirect back if possible
    }

    try {
        const product = await Product.findById(productId).select('sellerId').lean(); // Only fetch sellerId

        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('back');
        }

        if (product.sellerId.toString() !== sellerId.toString()) {
            req.flash('error_msg', 'Access Denied: You do not own this product.');
            return res.status(403).redirect('/seller/products'); // Redirect to their products page
        }

        // Attach product briefly for potential use later? Maybe not necessary.
        // req.product = product;
        next();
    } catch (error) {
         console.error("Error in isProductOwner middleware:", error);
         // Handle CastError specifically if lean() is removed or select changes
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid Product ID format.');
             return res.status(400).redirect('back');
         }
         req.flash('error_msg', 'An error occurred while verifying product ownership.');
         return res.status(500).redirect('back');
    }
};


// *** NEW: Middleware to check if an order contains products relevant to the logged-in seller ***
// Apply this AFTER isAuthenticated and isSeller
const isOrderRelevantToSeller = async (req, res, next) => {
    const orderId = req.params.orderId || req.params.id;
    const sellerId = req.session.user._id;

     if (!mongoose.Types.ObjectId.isValid(orderId)) {
         req.flash('error_msg', 'Invalid Order ID format.');
         return res.status(400).redirect('back');
    }

    try {
        // 1. Find products sold by this seller
        const sellerProductIds = await Product.find({ sellerId: sellerId }, '_id').lean();
        const sellerProductIdStrings = sellerProductIds.map(p => p._id.toString());

        if (sellerProductIdStrings.length === 0) {
             req.flash('error_msg', 'Access Denied: You have no products listed.');
             return res.status(403).redirect('/seller/orders');
        }

        // 2. Find the order and check if any product matches the seller's products
        // We only need to know IF there's a match, not the full order details yet
        const order = await Order.findOne({
            _id: orderId,
            'products.productId': { $in: sellerProductIdStrings.map(id => new mongoose.Types.ObjectId(id)) } // Convert back to ObjectId for query
        }).select('_id').lean(); // Select minimal field

        if (!order) {
            req.flash('error_msg', 'Order not found or does not contain your products.');
            return res.status(404).redirect('/seller/orders');
        }

        // Order is relevant
        next();

    } catch (error) {
        console.error("Error in isOrderRelevantToSeller middleware:", error);
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid ID format encountered.');
             return res.status(400).redirect('back');
         }
        req.flash('error_msg', 'An error occurred while verifying order relevance.');
        return res.status(500).redirect('back');
    }
};

module.exports = {
    isAdmin,
    isSeller,         // Export new middleware
    isAdminOrSeller,  // Export new middleware
    isProductOwner,   // Export new middleware
    isOrderRelevantToSeller // Export new middleware
};

models/BannerConfig.js:
// models/BannerConfig.js
const mongoose = require('mongoose');

const BannerSchema = new mongoose.Schema({
  imageUrl: { type: String, trim: true, required: true },
  linkUrl: { type: String, trim: true }, // Optional: URL to navigate to when banner is clicked
  title: { type: String, trim: true }, // Optional: Title/Alt text for the banner
}, { _id: false }); // Don't need separate IDs for each banner item in the array

const BannerConfigSchema = new mongoose.Schema({
  // Using a known key to ensure we only have one document (singleton pattern)
  configKey: {
    type: String,
    default: 'mainBanners',
    unique: true, // Enforces only one banner config document
    required: true,
  },
  banners: {
    type: [BannerSchema],
    validate: [arrayLimit, '{PATH} exceeds the limit of 4 banners'] // Custom validator
  },
  lastUpdatedBy: { // Track who last updated it
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true // Adds createdAt and updatedAt
});

// Custom validator function for array limit
function arrayLimit(val) {
  return val.length <= 4;
}

const BannerConfig = mongoose.model('BannerConfig', BannerConfigSchema);

module.exports = BannerConfig;

models/Category.js:
// models/Category.js
const mongoose = require('mongoose');
const slugify = require('slugify'); // You might need to install: npm install slugify

const CategorySchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide a category name'],
        unique: true,
        trim: true,
        maxlength: [50, 'Category name cannot be more than 50 characters']
    },
    imageUrl: {
        type: String,
        required: [true, 'Please provide an image URL for the category'],
        trim: true,
        match: [/^https?:\/\/.+\..+/, 'Please provide a valid URL']
    },
    slug: { // For potential future use in URLs
        type: String,
        unique: true,
        index: true
    },
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    lastUpdatedBy: {
         type: mongoose.Schema.Types.ObjectId,
         ref: 'User'
     }
}, {
    timestamps: true
});

// Pre-save hook to generate slug from name
CategorySchema.pre('save', function(next) {
    if (this.isModified('name') || this.isNew) {
      this.slug = slugify(this.name, { lower: true, strict: true });
    }
    next();
});

// Ensure product references are updated/checked before deleting a category
CategorySchema.pre('deleteOne', { document: true, query: false }, async function(next) {
    console.log(`Checking for products in category: ${this.name} (${this._id}) before deletion.`);
    const Product = mongoose.model('Product'); // Avoid circular dependency issues by requiring here
    try {
        const productCount = await Product.countDocuments({ categoryRef: this._id });
        if (productCount > 0) {
             console.warn(`Deletion aborted: ${productCount} products found in category "${this.name}".`);
             // Throw an error that can be caught in the controller
             const error = new Error(`Cannot delete category "${this.name}" as it contains ${productCount} product(s). Please reassign products first.`);
             error.statusCode = 400; // Bad Request
             return next(error);
        }
        console.log(`No products found for category "${this.name}". Safe to delete.`);
        next();
    } catch (err) {
         console.error("Error checking products before category deletion:", err);
         // Pass the error to the next middleware/error handler
         next(err);
    }
});


const Category = mongoose.model('Category', CategorySchema);

module.exports = Category;

models/Order.js:
// models/Order.js
const mongoose = require('mongoose');

const OrderProductSchema = new mongoose.Schema({
    productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
    name: { type: String, required: true },
    priceAtOrder: { type: Number, required: true },
    quantity: { type: Number, required: true, min: 1 },
    imageUrl: { type: String }
}, { _id: false });

const OrderAddressSchema = new mongoose.Schema({
    name: { type: String, trim: true, required: true },
    phone: { type: String, trim: true, required: true },
    pincode: { type: String, trim: true, required: true },
    cityVillage: { type: String, trim: true, required: true },
    landmarkNearby: { type: String, trim: true },
}, { _id: false });


const OrderSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
    },
    userEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    products: [OrderProductSchema],
    totalAmount: {
        type: Number,
        required: true,
        min: 0,
    },
    shippingAddress: {
        type: OrderAddressSchema,
        required: true
    },
    paymentMethod: {
        type: String,
        enum: ['COD'],
        required: true,
        default: 'COD',
    },
    status: {
        type: String,
        enum: ['Pending', 'Delivered', 'Cancelled'],
        default: 'Pending',
    },
    orderDate: {
        type: Date,
        default: Date.now,
    },
    receivedByDate: {
        type: Date,
    },

    orderOTP: String,
    orderOTPExpires: Date,

    cancellationAllowedUntil: {
        type: Date,
    },
    cancellationReason: {
        type: String,
        trim: true,
    }
}, {
    timestamps: true
});

OrderSchema.pre('save', function(next) {
    if (this.isNew && !this.cancellationAllowedUntil) {
        const now = this.orderDate || Date.now();
        this.cancellationAllowedUntil = new Date(now.getTime() + 60 * 60 * 1000);
    }

    if (this.isModified('status') && this.status === 'Cancelled') {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
        this.receivedByDate = undefined;
        this.cancellationAllowedUntil = undefined;
    }

    if (this.isModified('status') && this.status !== 'Pending') {
         this.orderOTP = undefined;
         this.orderOTPExpires = undefined;
    }
    if (this.status === 'Delivered' || this.status === 'Cancelled') {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
    }

    next();
});

const Order = mongoose.model('Order', OrderSchema);

module.exports = Order;

models/Product.js:
// models/Product.js
const mongoose = require('mongoose');

const RatingSchema = new mongoose.Schema({
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    rating: { type: Number, required: true, min: 1, max: 5 },
    comment: { type: String, trim: true },
}, { _id: false, timestamps: true });


const ProductSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide a product name'],
        trim: true,
        index: true
    },
    description: {
        type: String,
        trim: true,
        default: ''
    },
    // --- MODIFIED: Changed category field ---
    categoryRef: { // Changed from 'category'
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Category', // References the new Category model
        required: [true, 'Please select a product category'],
        index: true
    },
    categoryName: { // Denormalized for easier display/search
        type: String,
        required: [true, 'Category name is missing'],
        trim: true,
        index: true // Index for searching/filtering by name
    },
    // --- End Modification ---
    price: {
        type: Number,
        required: [true, 'Please provide a product price'],
        min: 0,
    },
    stock: {
        type: Number,
        required: [true, 'Please provide product stock quantity'],
        min: 0,
        default: 0,
    },
    imageUrl: {
        type: String,
        required: [true, 'Please provide a product image URL'],
        trim: true,
    },
    specifications: {
        type: String,
        trim: true,
    },
    sellerId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true
    },
    sellerEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    ratings: [RatingSchema],
    averageRating: {
      type: Number,
      default: 0,
    },
    numReviews: {
        type: Number,
        default: 0,
    },
    orderCount: {
        type: Number,
        default: 0,
    },
    reviewStatus: {
        type: String,
        enum: ['pending', 'approved', 'rejected'],
        default: 'pending',
        index: true
    },
    rejectionReason: {
        type: String,
        trim: true
    }
}, {
    timestamps: true
});

// Pre-save hook to handle ratings AND fetch categoryName
ProductSchema.pre('save', async function(next) {
    // --- Update Category Name if categoryRef is modified ---
    if (this.isModified('categoryRef') || this.isNew) {
        try {
            const Category = mongoose.model('Category');
            const categoryDoc = await Category.findById(this.categoryRef).select('name');
            if (categoryDoc) {
                this.categoryName = categoryDoc.name;
            } else {
                 console.warn(`Product Save: Could not find Category with ID ${this.categoryRef}. Setting categoryName to 'Unknown'.`);
                 this.categoryName = 'Unknown Category'; // Or throw an error?
                 // return next(new Error(`Invalid Category selected for product ${this.name}`)); // Option: Fail validation
             }
        } catch (error) {
            console.error(`Product Save: Error fetching category name for ID ${this.categoryRef}:`, error);
             // Consider how to handle this - fail validation or allow save with fallback?
             return next(error);
        }
    }

    // Existing Rating logic
    if (this.isModified('ratings')) {
        if (this.ratings && this.ratings.length > 0) {
            this.numReviews = this.ratings.length;
            this.averageRating = this.ratings.reduce((acc, item) => item.rating + acc, 0) / this.ratings.length;
        } else {
            this.numReviews = 0;
            this.averageRating = 0;
        }
    }

    if (this.isModified('reviewStatus') && this.reviewStatus !== 'rejected') {
        this.rejectionReason = undefined;
    }

    next();
});


// Define text index - REMOVED 'category', added 'categoryName'
ProductSchema.index({ name: 'text', description: 'text', categoryName: 'text', specifications: 'text' });

const Product = mongoose.model('Product', ProductSchema);

module.exports = Product;

models/User.js:
// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const AddressSchema = new mongoose.Schema({
    name: { type: String, trim: true },
    phone: { type: String, trim: true },
    pincode: { type: String, trim: true },
    cityVillage: { type: String, trim: true },
    landmarkNearby: { type: String, trim: true },
}, { _id: false });

const CartItemSchema = new mongoose.Schema({
    productId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Product',
        required: true,
    },
    quantity: {
        type: Number,
        required: true,
        min: 1,
        default: 1,
    }
}, { _id: false }); // Changed _id back to false as per original

const UserSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide your name'],
        trim: true,
    },
    email: {
        type: String,
        required: [true, 'Please provide your email'],
        unique: true,
        match: [
            /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            'Please provide a valid email address',
        ],
        lowercase: true,
        trim: true,
    },
    password: {
        type: String,
        required: [true, 'Please provide a password'],
        minlength: 6,
        select: false, // Keep password hidden by default
    },
    role: {
        type: String,
        // *** UPDATED: Added 'seller' role ***
        enum: ['user', 'admin', 'seller'],
        default: 'user',
    },
    isVerified: {
        type: Boolean,
        default: false,
    },
    otp: { type: String },
    otpExpires: { type: Date },
    address: AddressSchema,
    cart: [CartItemSchema],

    resetPasswordToken: String,
    resetPasswordExpires: Date,
}, {
    timestamps: true
});

// Hash password before saving
UserSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();

    try {
        const salt = await bcrypt.genSalt(10);
        this.password = await bcrypt.hash(this.password, salt);
        next();
    } catch (error) {
        next(error); // Pass error to mongoose error handling
    }
});

// Method to compare entered password with hashed password
UserSchema.methods.matchPassword = async function(enteredPassword) {
    // Need to explicitly select password if it was excluded in the query
    // If the user instance was fetched without `+password`, this.password will be undefined.
    // It's safer to fetch the user with password when matching is needed.
    if (!this.password) {
        const userWithPassword = await mongoose.model('User').findById(this._id).select('+password').exec();
        if (!userWithPassword) return false; // Should not happen if instance exists
        return await bcrypt.compare(enteredPassword, userWithPassword.password);
    }
    return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', UserSchema);

module.exports = User;

public/css/style.css:
/* public/css/style.css */

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* Core Color Palette */
  --primary-color: #007bff;
  --primary-hover: #0056b3;
  --secondary-color: #6c757d;
  --secondary-hover: #5a6268;
  --success-color: #28a745;
  --success-hover: #218838;
  --danger-color: #dc3545;
  --danger-hover: #c82333;
  --warning-color: #ffc107;
  --warning-hover: #e0a800;
  --info-color: #17a2b8;
  --info-hover: #138496;
  --light-color: #f8f9fa;
  --dark-color: #343a40;

  /* Text & Links */
  --text-color: #333;
  --link-color: var(--primary-color);

  /* Layout & Components */
  --card-bg: #ffffff;
  --card-shadow: 0 2px 5px rgba(0, 0, 0, 0.12);
  --border-color: #dee2e6;
  --border-radius: 0.6rem; /* Smoother corners */
  --spacing-unit: 1rem;

  /* Gradient Background Colors */
  --gradient-start: #e9f1ff;
  --gradient-mid1: #d0e0ff;
  --gradient-mid2: #e0ebf7;
  --gradient-end: #f0f5fd;
}

html {
  font-size: 16px;
  scroll-behavior: smooth;
}

body {
  font-family: 'Roboto', sans-serif;
  line-height: 1.6;
  color: var(--text-color);
  background: linear-gradient(135deg,
      var(--gradient-start) 0%,
      var(--gradient-mid1) 25%,
      var(--gradient-mid2) 55%,
      var(--gradient-end) 100%
    );
  background-attachment: fixed;
  background-size: cover;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

a {
  color: var(--link-color);
  text-decoration: none;
  transition: color 0.2s ease-in-out;
}

a:hover {
  color: var(--primary-hover);
  text-decoration: underline;
}

img {
  max-width: 100%;
  height: auto;
  display: block;
}

h1, h2, h3, h4, h5, h6 {
  margin-bottom: calc(var(--spacing-unit) * 0.75);
  line-height: 1.3;
  font-weight: 500;
}

p {
  margin-bottom: var(--spacing-unit);
}

ul, ol {
    margin-bottom: var(--spacing-unit);
    padding-left: calc(var(--spacing-unit) * 1.5);
}

/* Utility Classes */
.hidden { display: none !important; }
.hide { display: none !important; } /* Alias */
.text-center { text-align: center; }
.text-danger { color: var(--danger-color) !important; }
.text-success { color: var(--success-color) !important; }
.text-warning { color: var(--warning-color) !important; }
.text-info { color: var(--info-color) !important; }
.text-muted { color: var(--secondary-color) !important; }
.mb-1 { margin-bottom: calc(var(--spacing-unit) * 0.25) !important; }
.mb-2 { margin-bottom: calc(var(--spacing-unit) * 0.5) !important; }
.mb-3 { margin-bottom: var(--spacing-unit) !important; }
.mb-4 { margin-bottom: calc(var(--spacing-unit) * 1.5) !important; }
.mt-1 { margin-top: calc(var(--spacing-unit) * 0.25) !important; }
.mt-2 { margin-top: calc(var(--spacing-unit) * 0.5) !important; }
.mt-3 { margin-top: var(--spacing-unit) !important; }
.mt-4 { margin-top: calc(var(--spacing-unit) * 1.5) !important; }
.ms-1 { margin-left: calc(var(--spacing-unit) * 0.25) !important; } /* Margin start */
.ms-2 { margin-left: calc(var(--spacing-unit) * 0.5) !important; }
.me-1 { margin-right: calc(var(--spacing-unit) * 0.25) !important; }
.me-2 { margin-right: calc(var(--spacing-unit) * 0.5) !important; } /* Margin end */
.me-3 { margin-right: var(--spacing-unit) !important; }
.p-1 { padding: calc(var(--spacing-unit) * 0.25) !important; }
.p-2 { padding: calc(var(--spacing-unit) * 0.5) !important; }
.p-3 { padding: var(--spacing-unit) !important; }
.pt-1 { padding-top: calc(var(--spacing-unit) * 0.25) !important; }
.pt-2 { padding-top: calc(var(--spacing-unit) * 0.5) !important; }
.pt-3 { padding-top: var(--spacing-unit) !important; }
.pb-1 { padding-bottom: calc(var(--spacing-unit) * 0.25) !important; }
.pb-2 { padding-bottom: calc(var(--spacing-unit) * 0.5) !important; }
.pb-3 { padding-bottom: var(--spacing-unit) !important; }
.d-flex { display: flex !important; }
.d-inline-flex { display: inline-flex !important; }
.d-block { display: block !important; }
.d-inline-block { display: inline-block !important; }
.align-items-center { align-items: center !important; }
.justify-content-between { justify-content: space-between !important; }
.justify-content-center { justify-content: center !important; }
.flex-wrap { flex-wrap: wrap !important; }
.flex-grow-1 { flex-grow: 1 !important; }
.gap-1 { gap: calc(var(--spacing-unit) * 0.25) !important; }
.gap-2 { gap: calc(var(--spacing-unit) * 0.5) !important; }
.gap-3 { gap: var(--spacing-unit) !important; }
.small { font-size: 0.875em; }
.fs-5 { font-size: 1.25rem !important; }
.w-100 { width: 100% !important; }
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
.fw-bold { font-weight: bold !important; }
.fw-normal { font-weight: normal !important; }
.fw-light { font-weight: lighter !important; }
.text-capitalize { text-transform: capitalize !important; }
.border { border: 1px solid var(--border-color) !important; }
.border-top { border-top: 1px solid var(--border-color) !important; }
.border-bottom { border-bottom: 1px solid var(--border-color) !important; }
.rounded { border-radius: var(--border-radius) !important; }


/* Forms */
.inline-form {
    display: inline-block; /* Changed to inline-block for better flow with text buttons */
    margin-bottom: 0; /* Removed default bottom margin */
    vertical-align: middle; /* Align forms vertically */
}
.inline-form > * {
    margin-bottom: 0; /* Remove bottom margin from elements inside */
    vertical-align: middle; /* Align elements inside vertically */
}
.inline-form + .inline-form {
    margin-left: calc(var(--spacing-unit) * 0.3); /* Add space between inline forms */
}


.form-group {
  margin-bottom: calc(var(--spacing-unit) * 0.8);
}

label:not(.form-label-inline) { /* Exclude inline labels */
  display: block;
  margin-bottom: calc(var(--spacing-unit) * 0.3);
  font-weight: 500;
}
label.form-label-inline {
    margin-bottom: 0; /* No margin for inline labels */
    margin-right: calc(var(--spacing-unit) * 0.4);
    font-weight: normal;
}

input[type="text"],
input[type="email"],
input[type="password"],
input[type="tel"],
input[type="url"],
input[type="number"],
input[type="search"],
textarea,
select {
  width: 100%;
  padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.75);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  font-size: 1rem;
  line-height: 1.5;
  background-color: #fff;
  color: var(--text-color); /* Ensure text color is applied */
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}
/* Alias class for consistency */
.form-control {
    display: block; /* Ensure block level */
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.75);
    font-size: 1rem;
    font-weight: 400;
    line-height: 1.5;
    color: var(--text-color);
    background-color: #fff;
    background-clip: padding-box;
    border: 1px solid var(--border-color);
    appearance: none; /* Remove default vendor styling */
    border-radius: var(--border-radius);
    transition: border-color .15s ease-in-out,box-shadow .15s ease-in-out;
}


input[type="number"] {
    appearance: textfield;
    -moz-appearance: textfield;
}
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

textarea {
  resize: vertical;
  min-height: 80px;
}

input:focus,
textarea:focus,
select:focus,
.form-control:focus {
  border-color: var(--primary-color);
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.form-control-sm {
  min-height: calc(1.5em + 0.5rem + 2px); /* Use min-height */
  height: auto; /* Allow height to adjust */
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: calc(var(--border-radius) * 0.75);
}
select.form-control-sm {
  height: calc(1.8125rem + 2px); /* Keep height for select */
}

/* Buttons */
.btn {
  display: inline-block;
  font-weight: 400;
  color: #fff;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  user-select: none;
  background-color: var(--primary-color);
  border: 1px solid var(--primary-color);
  padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
  font-size: 1rem;
  line-height: 1.5;
  border-radius: var(--border-radius);
  transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
  text-transform: capitalize;
}

.btn:hover {
  color: #fff;
  text-decoration: none;
  background-color: var(--primary-hover);
  border-color: var(--primary-hover);
}

.btn:focus {
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.5);
}

.btn:disabled {
  opacity: 0.65;
  cursor: not-allowed;
  pointer-events: none; /* Add this */
}
/* Style for loading state */
.btn.loading {
    opacity: 0.75;
    cursor: wait;
    pointer-events: none;
}


.btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: #fff;}
.btn-primary:hover { background-color: var(--primary-hover); border-color: var(--primary-hover); }
.btn-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: #fff; }
.btn-secondary:hover { background-color: var(--secondary-hover); border-color: var(--secondary-hover); }
.btn-success { background-color: var(--success-color); border-color: var(--success-color); color: #fff;}
.btn-success:hover { background-color: var(--success-hover); border-color: var(--success-hover); }
.btn-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: #fff;}
.btn-danger:hover { background-color: var(--danger-hover); border-color: var(--danger-hover); }
.btn-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: #212529;}
.btn-warning:hover { background-color: var(--warning-hover); border-color: var(--warning-hover); }
.btn-info { background-color: var(--info-color); border-color: var(--info-color); color: #fff;}
.btn-info:hover { background-color: var(--info-hover); border-color: var(--info-hover); }
.btn-light { background-color: var(--light-color); border-color: var(--light-color); color: #212529;}
.btn-light:hover { background-color: #e2e6ea; border-color: #dae0e5; }
.btn-dark { background-color: var(--dark-color); border-color: var(--dark-color); color: #fff;}
.btn-dark:hover { background-color: #23272b; border-color: #1d2124; }

.btn-outline-secondary { color: var(--secondary-color); border-color: var(--secondary-color); background-color: transparent;}
.btn-outline-secondary:hover { color: #fff; background-color: var(--secondary-color); }
.btn-outline-primary { color: var(--primary-color); border-color: var(--primary-color); background-color: transparent;}
.btn-outline-primary:hover { color: #fff; background-color: var(--primary-color); }

.btn-text {
    background-color: transparent;
    border-color: transparent;
    color: var(--link-color);
    padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.4);
    border-radius: var(--border-radius);
    vertical-align: middle; /* Align with other inline elements */
}
.btn-text:hover,
.btn-text:focus {
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--primary-hover);
    text-decoration: none;
    outline: none;
    box-shadow: none;
}
.btn-text.btn-danger { color: var(--danger-color); }
.btn-text.btn-danger:hover,
.btn-text.btn-danger:focus { color: var(--danger-hover); background-color: rgba(220, 53, 69, 0.1); }

.btn-sm {
  padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.5);
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: calc(var(--border-radius) * 0.8);
}
.btn-lg {
    padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.25);
    font-size: 1.1rem;
}

.btn-block {
    display: block;
    width: 100%;
}

.btn .fa-spinner {
    margin-right: calc(var(--spacing-unit) * 0.25);
    animation: fa-spin 1s infinite linear;
}
@keyframes fa-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Alerts */
.alert {
  padding: calc(var(--spacing-unit) * 0.8) var(--spacing-unit);
  margin-bottom: var(--spacing-unit);
  border: 1px solid transparent;
  border-radius: var(--border-radius);
  position: relative;
}
.alert-success { color: #155724; background-color: #d4edda; border-color: #c3e6cb; }
.alert-danger { color: #721c24; background-color: #f8d7da; border-color: #f5c6cb; }
.alert-warning { color: #856404; background-color: #fff3cd; border-color: #ffeeba; }
.alert-info { color: #0c5460; background-color: #d1ecf1; border-color: #bee5eb; }
.alert-link { font-weight: bold; color: inherit; text-decoration: underline; }

.close-alert {
  position: absolute;
  top: 50%;
  right: 10px;
  transform: translateY(-50%);
  font-size: 1.2rem;
  line-height: 1;
  background: none;
  border: none;
  color: inherit;
  opacity: 0.7;
  cursor: pointer;
  padding: 0.2rem 0.4rem;
}
.close-alert:hover { opacity: 1; }

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1055;
  width: auto;
  max-width: 350px;
  pointer-events: none;
}

.toast {
  background-color: var(--card-bg);
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-radius: var(--border-radius);
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  margin-bottom: var(--spacing-unit);
  padding: calc(var(--spacing-unit) * 0.75);
  padding-right: calc(var(--spacing-unit) * 2.5);
  position: relative;
  opacity: 0;
  transform: translateX(110%);
  transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
  width: 100%;
  pointer-events: auto;
  min-height: 50px;
  display: flex;
  align-items: center;
  overflow: hidden;
}

.toast.show {
  opacity: 1;
  transform: translateX(0);
}

.toast.hide {
    opacity: 0;
    transition: opacity 0.3s ease-in, transform 0.3s ease-in;
}

.toast-body {
  flex-grow: 1;
  font-size: 0.9rem;
  line-height: 1.4;
}

.toast-close-btn {
  position: absolute;
  top: 50%;
  right: 15px;
  transform: translateY(-50%);
  background: transparent;
  border: none;
  font-size: 1.4rem;
  line-height: 1;
  font-weight: bold;
  color: inherit;
  opacity: 0.6;
  cursor: pointer;
  padding: 0.1rem 0.4rem;
}
.toast-close-btn:hover {
  opacity: 1;
  text-decoration: none;
}

.toast-success { background-color: #d4edda; color: #155724; border-left: 5px solid var(--success-color); }
.toast-success .toast-close-btn { color: #155724; }
.toast-danger { background-color: #f8d7da; color: #721c24; border-left: 5px solid var(--danger-color); }
.toast-danger .toast-close-btn { color: #721c24; }
.toast-warning { background-color: #fff3cd; color: #856404; border-left: 5px solid var(--warning-color); }
.toast-warning .toast-close-btn { color: #856404; }
.toast-info { background-color: #d1ecf1; color: #0c5460; border-left: 5px solid var(--info-color); }
.toast-info .toast-close-btn { color: #0c5460; }


/* ============================ */
/* Header Styles                */
/* ============================ */

.app-header {
  background-color: var(--primary-color);
  color: var(--light-color);
  padding: calc(var(--spacing-unit) * 0.4) var(--spacing-unit); /* Slightly reduced padding */
  position: sticky;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1200px; /* Max width for content */
  margin: 0 auto;
  gap: calc(var(--spacing-unit) * 0.5);
  min-height: 40px; /* Ensure minimum height */
}

/* Left Side (Logo) */
.nav-left {
  display: flex;
  align-items: center;
  flex-shrink: 0; /* Prevent shrinking */
}

.app-logo {
  display: flex;
  align-items: center;
  color: var(--light-color);
  font-size: 1.1rem; /* Slightly adjusted size */
  font-weight: 500;
  text-decoration: none;
  margin-right: calc(var(--spacing-unit) * 0.5); /* Adjusted margin */
}
.app-logo:hover,
.app-logo:focus {
  color: var(--warning-color); /* Use theme variable for hover */
  text-decoration: none;
}
.app-logo i {
  margin-right: calc(var(--spacing-unit) * 0.3);
  font-size: 1.2em; /* Relative to logo font size */
}

/* Center Section (Search - Desktop/Tablet) */
.search-container-dynamic {
  flex-grow: 1; /* Takes available space on desktop/tablet */
  display: flex;
  justify-content: center; /* Centers the form within */
  margin: 0 calc(var(--spacing-unit) * 0.5);
  max-width: 500px; /* Limit search bar width */
  position: relative; /* For suggestions dropdown */
}

/* --- Search Bar Black & White Styling --- */
.search-form-dynamic {
  display: flex;
  align-items: center;
  width: 100%;
  height: 38px; /* Consistent height */
  background-color: #ffffff; /* White background */
  border: 1px solid #ccc; /* Subtle grey border */
  border-radius: var(--border-radius);
  transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Keep transitions */
  overflow: hidden;
}
/* Remove focus-within styling if input handles it */
.search-form-dynamic:focus-within {
    /* Optional: keep a subtle border change if desired */
    /* border-color: var(--primary-color); */
    /* Rely on input focus style for primary indication */
}


#search-input-dynamic {
  flex-grow: 1;
  padding: 0 calc(var(--spacing-unit) * 0.75);
  border: none; /* No border inside the form */
  background-color: transparent; /* Inherit form background */
  color: var(--dark-color); /* Black text color */
  font-size: 0.9rem;
  height: 100%;
  outline: none; /* Use :focus style from general inputs */
}
#search-input-dynamic::placeholder {
  color: #6c757d; /* Darker gray placeholder */
  opacity: 1;
}

.search-submit-btn-dynamic {
  background: transparent; /* Inherit form background */
  border: none;
  color: var(--dark-color); /* Black icon color */
  padding: 0 calc(var(--spacing-unit) * 0.75);
  cursor: pointer;
  font-size: 1rem;
  height: 100%;
  display: flex;
  align-items: center;
  flex-shrink: 0;
  transition: background-color 0.15s ease-in-out; /* Add transition for hover */
}
.search-submit-btn-dynamic:hover {
  background-color: rgba(0, 0, 0, 0.05); /* Subtle hover effect */
}
/* --- End Search Bar Styling --- */

/* Suggestions Dropdown */
.suggestions-dropdown {
    display: none;
    position: absolute;
    top: 100%; /* Position below the search form */
    left: 0;
    right: 0;
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-top: none;
    border-radius: 0 0 var(--border-radius) var(--border-radius); /* Bottom corners rounded */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    max-height: 400px;
    overflow-y: auto;
    z-index: 1010; /* Above other content */
}
.suggestions-dropdown.active { display: block; }
.suggestion-item {
    display: flex;
    align-items: center;
    padding: calc(var(--spacing-unit) * 0.5) calc(var(--spacing-unit) * 0.75);
    cursor: pointer;
    color: var(--text-color);
    text-decoration: none;
    border-bottom: 1px solid var(--border-color);
    gap: calc(var(--spacing-unit) * 0.5);
}
.suggestion-item:last-child { border-bottom: none; }
.suggestion-item:hover,
.suggestion-item:focus {
    background-color: var(--light-color);
    text-decoration: none;
    color: var(--text-color);
}
.suggestion-item img {
    width: 35px;
    height: 35px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.75);
    flex-shrink: 0;
}
.suggestion-item span {
    font-size: 0.9rem;
    line-height: 1.3;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.suggestion-item i {
    font-style: normal;
    color: var(--secondary-color);
}


/* Right Side (Nav Links, Profile, Login) */
.nav-right {
  display: flex;
  align-items: center;
  flex-shrink: 0; /* Prevent shrinking */
  gap: calc(var(--spacing-unit) * 0.4); /* Base gap for mobile */
}

/* General Nav Link Styling (Mobile Base) */
.nav-link {
  color: var(--light-color);
  padding: calc(var(--spacing-unit) * 0.5) calc(var(--spacing-unit) * 0.6); /* Adjusted padding for touch */
  border-radius: var(--border-radius);
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 0.7rem; /* Small text on mobile */
  text-decoration: none;
  background: none;
  border: none;
  cursor: pointer; /* Ensure cursor indicates clickability */
  transition: background-color 0.2s ease;
  line-height: 1.2; /* Adjust line height */
}
.nav-link span { display: none; } /* Hide text on mobile */
.nav-link i { font-size: 1.2rem; margin-bottom: 2px; } /* Slightly larger icon */

.nav-link:hover,
.nav-link.active,
.nav-link:focus { /* Added focus state */
  background-color: rgba(255, 255, 255, 0.15); /* Slightly more visible hover */
  color: #fff;
  text-decoration: none;
  outline: none; /* Remove default focus outline if custom style is applied */
}

/* Cart Badge */
.nav-link-cart { position: relative; }
.cart-badge {
  position: absolute;
  top: 0px; /* Adjust positioning */
  right: 0px; /* Adjust positioning */
  background-color: var(--danger-color);
  color: white;
  border-radius: 50%;
  padding: 1px 5px;
  font-size: 0.7rem;
  font-weight: bold;
  line-height: 1;
  pointer-events: none; /* Prevent badge interfering with click */
}
.cart-badge.hide { display: none; }

/* Login/Register Button */
.btn-login-register {
    font-size: 0.85rem; /* Adjusted size */
    padding: calc(var(--spacing-unit) * 0.4) calc(var(--spacing-unit) * 0.8);
    background-color: rgba(255, 255, 255, 0.9); /* Brighter button */
    color: var(--primary-color); /* Use primary text color */
    border: none;
    font-weight: 500;
}
.btn-login-register:hover,
.btn-login-register:focus {
    background-color: #fff;
    color: var(--primary-hover);
}
.btn-login-register i {
    margin-right: calc(var(--spacing-unit) * 0.3);
}


/* Profile Avatar */
.profile-avatar-link {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 36px; /* Slightly smaller */
    height: 36px;
    border-radius: 50%;
    background-color: var(--light-color);
    color: var(--primary-color); /* Use primary color for text */
    font-weight: 500; /* Adjusted weight */
    font-size: 0.9rem;
    text-decoration: none;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border: 1px solid transparent;
    margin-left: calc(var(--spacing-unit) * 0.2); /* Adjust margin if needed */
}
.profile-avatar-link:hover,
.profile-avatar-link:focus,
.profile-avatar-link.active {
    text-decoration: none;
    /* Optional: subtle shadow or scale effect */
    /* transform: scale(1.05); */
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
    outline: none;
}
.profile-avatar-initials { line-height: 1; }

/* Mobile Search Toggle Button */
.search-toggle-btn {
    /* Inherits .nav-link styles */
    /* Ensure it's visible only on mobile */
    display: flex;
}

/* Container and Footer */
.container {
  width: 100%;
  padding: var(--spacing-unit);
  margin: 0 auto;
  flex-grow: 1;
}

.app-footer {
  padding: var(--spacing-unit);
  text-align: center;
  font-size: 0.85rem;
  color: var(--secondary-color);
  background-color: rgba(248, 249, 250, 0.9);
  border-top: 1px solid var(--border-color);
  margin-top: auto;
  /* No border-radius on full-width footer */
}


/* Product Index */
.product-index-container h1 { font-size: 1.5rem; }
.search-bar-container { display: none; } /* Kept for potential future use? */

.product-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: calc(var(--spacing-unit) * 0.75);
}

.product-card {
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: var(--card-shadow);
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.product-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.product-link {
  color: inherit;
  text-decoration: none;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}
.product-link:hover{
  color: inherit;
  text-decoration: none;
}

.product-image {
  width: 100%;
  aspect-ratio: 1 / 1;
  object-fit: cover;
}

.product-info {
  padding: calc(var(--spacing-unit) * 0.6);
  flex-grow: 1;
}

.product-name {
  font-size: 0.95rem;
  font-weight: 500;
  margin-bottom: calc(var(--spacing-unit) * 0.25);
  line-height: 1.3;
  height: 2.6em; /* Limit to 2 lines */
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.product-price {
  font-weight: 500;
  color: var(--success-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
  font-size: 1rem;
}

.product-category {
  /* Specific style for category name on product card */
  font-size: 0.8rem;
  color: var(--secondary-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
}

.product-stock,
.product-rating {
  font-size: 0.8rem;
  color: var(--secondary-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
}
.product-rating .fa-star, .product-rating .fa-star-half-alt { color: #f8d347; }
.product-rating .fa-star-regular { color: #e4e5e9; }

.add-to-cart-form { padding: 0 calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.6); }
.btn-add-to-cart {
  width: 100%;
  padding: calc(var(--spacing-unit) * 0.5);
  font-size: 0.9rem;
}
.btn-add-to-cart i { margin-right: calc(var(--spacing-unit) * 0.25); }

/* Product Detail */
.product-detail-container {
  background-color: var(--card-bg);
  padding: var(--spacing-unit);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
}
.product-detail-main {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-unit);
}
.product-detail-image {
    width: 100%;
    max-width: 450px;
    margin: 0 auto var(--spacing-unit) auto;
    aspect-ratio: 1 / 1;
    overflow: hidden;
    border-radius: calc(var(--border-radius) + 2px);
    background-color: #f8f9fa;
    position: relative;
}
.product-detail-image img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
}
.product-detail-info h1 {
    font-size: 1.6rem;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.detail-price {
    font-size: 1.4rem;
    font-weight: bold;
    color: var(--success-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.detail-stock {
    font-size: 0.9rem;
    color: var(--secondary-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.detail-rating { /* Combined rating display style */
    margin-bottom: calc(var(--spacing-unit) * 0.75);
    color: var(--secondary-color);
}
.detail-rating i { color: #f8d347; }
.detail-rating .fa-star-regular { color: #e4e5e9; }
.product-description .description-text {
  white-space: pre-wrap; /* Preserve line breaks from textarea */
}

.product-actions {
    margin: calc(var(--spacing-unit) * 1.2) 0;
    display: flex;
    flex-direction: column;
    gap: calc(var(--spacing-unit) * 0.5);
}
.quantity-selector {
    display: flex;
    align-items: center;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
    max-width: 150px;
}
.quantity-selector label {
    margin: 0 calc(var(--spacing-unit) * 0.4) 0 0;
    font-size: 0.9rem;
}
.quantity-selector input {
    text-align: center;
    font-size: 1rem;
    padding: calc(var(--spacing-unit) * 0.4);
}
.product-actions .btn {
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.6) var(--spacing-unit);
    font-size: 1rem;
}

.share-section { margin: calc(var(--spacing-unit) * 1.2) 0; }
.fallback-share-links { margin-top: 0.5rem; }
.fallback-share-links a { margin: 0 0.3rem; font-size: 1.5rem; }

.product-specifications { margin-top: calc(var(--spacing-unit) * 1.5); }
.product-specifications h3 { font-size: 1.1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3rem; margin-bottom: 0.5rem;}
.product-specifications pre {
    white-space: pre-wrap;
    font-size: 0.9rem;
    background-color: #f8f8f8;
    padding: calc(var(--spacing-unit) * 0.5);
    border-radius: var(--border-radius);
    max-height: 200px;
    overflow-y: auto;
}

/* Rating Section */
.product-rating-section {
    margin-top: var(--spacing-unit);
    border-top: 1px solid var(--border-color);
    padding-top: var(--spacing-unit);
}
.product-rating-section h3 {
    margin-bottom: calc(var(--spacing-unit) * 0.6);
    font-size: 1.2em;
}

.rating-stars { display: inline-flex; flex-direction: row-reverse; justify-content: flex-end; margin-bottom: calc(var(--spacing-unit) * 0.8); }
.rating-stars input[type="radio"] { display: none; }
.rating-stars label { display: inline-block; cursor: pointer; font-size: 1.8rem; color: lightgray; padding: 0 0.1em; margin: 0; transition: color 0.2s ease-in-out; }
.rating-stars label:hover, .rating-stars label:hover ~ label { color: #f8d347; }
.rating-stars input[type="radio"]:checked ~ label { color: #f8d347; }

.rating-stats-container { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; }
.rating-stats-container h3 { margin-bottom: 15px; font-size: 1.4em; color: #333; }
.rating-summary { display: flex; align-items: center; margin-bottom: 20px; gap: 15px; }
.rating-average { display: flex; align-items: center; }
.rating-average-value { font-size: 2.5em; font-weight: 500; margin-right: 5px; color: #222; }
.rating-average .fa-star { font-size: 1.2em; color: #666; margin-bottom: 8px; }
.rating-total { font-size: 0.95em; color: #555; }
.rating-bars { max-width: 400px; }
.rating-bar-row { display: flex; align-items: center; margin-bottom: 8px; gap: 10px; }
.rating-bar-label { width: 45px; font-size: 0.9em; color: #444; text-align: right; flex-shrink: 0; }
.rating-bar-label .fa-star { color: #f8c107; font-size: 0.9em; }
.rating-bar-progress { flex-grow: 1; height: 8px; background-color: #e0e0e0; border-radius: 4px; overflow: hidden; }
.progress { background-color: #e9ecef; border-radius: 4px; display: flex; height: 1rem; overflow: hidden; font-size: .75rem;}
.progress-bar { background-color: var(--primary-color); color: #fff; display: flex; flex-direction: column; justify-content: center; overflow: hidden; text-align: center; white-space: nowrap; transition: width .6s ease;}
.rating-bar-fill { height: 100%; background-color: #28a745; border-radius: 4px; transition: width 0.3s ease-in-out; }
.rating-bar-row:nth-child(1) .rating-bar-fill { background-color: #28a745; } /* 5 stars */
.rating-bar-row:nth-child(2) .rating-bar-fill { background-color: #84c54c; } /* 4 stars */
.rating-bar-row:nth-child(3) .rating-bar-fill { background-color: #ffc107; } /* 3 stars */
.rating-bar-row:nth-child(4) .rating-bar-fill { background-color: #fd7e14; } /* 2 stars */
.rating-bar-row:nth-child(5) .rating-bar-fill { background-color: #dc3545; } /* 1 star */
.rating-bar-count { width: 40px; font-size: 0.9em; color: #555; text-align: right; flex-shrink: 0; }


/* Auth */
.auth-container {
  max-width: 450px;
  margin: var(--spacing-unit) auto;
  padding: var(--spacing-unit);
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
}
.auth-container h1 { font-size: 1.6rem; text-align: center; margin-bottom: var(--spacing-unit); }
.auth-form .btn { width: 100%; margin-top: calc(var(--spacing-unit) * 0.5); padding: calc(var(--spacing-unit) * 0.7); }
.auth-links { margin-top: var(--spacing-unit); font-size: 0.9rem; text-align: center; }
.auth-links p { margin-bottom: calc(var(--spacing-unit) * 0.4); }
.auth-container p { text-align: center; margin-bottom: var(--spacing-unit);}
.auth-container form ~ .auth-links { border-top: 1px solid var(--border-color); padding-top: var(--spacing-unit); }
#otp { text-align: center; font-size: 1.2rem; letter-spacing: 4px; }


/* Cart */
.cart-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit); }
.cart-items { margin-bottom: var(--spacing-unit); }

.cart-item {
  display: grid;
  grid-template-columns: 80px 1fr auto;
  grid-template-areas:
    "image details remove"
    "image quantity subtotal";
  gap: calc(var(--spacing-unit) * 0.75);
  background-color: var(--card-bg);
  padding: calc(var(--spacing-unit) * 0.75);
  border-bottom: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  margin-bottom: var(--spacing-unit);
  box-shadow: var(--card-shadow);
}

.cart-item-image { grid-area: image; align-self: center;}
.cart-item-image img {
    width: 80px;
    height: 80px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.75);
}
.cart-item-details { grid-area: details; }
.cart-item-quantity { grid-area: quantity; display: flex; align-items: center; gap: 0.3rem; }
.cart-item-subtotal { grid-area: subtotal; text-align: right; font-weight: 500; align-self: center; }
.cart-item-remove { grid-area: remove; text-align: right; align-self: start;}
.cart-item-name { font-size: 1rem; font-weight: 500; margin-bottom: calc(var(--spacing-unit) * 0.2); }
.cart-item-price { font-size: 0.9rem; color: var(--secondary-color); margin-bottom: calc(var(--spacing-unit) * 0.2); }
.cart-item-stock { font-size: 0.8rem; color: #6c757d; }
.cart-item-quantity label { font-size: 0.9rem; margin-bottom: 0; display: none; }
.cart-item-quantity input { width: 50px; padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.4); text-align: center; font-size: 0.9rem; }
.cart-item-quantity .btn-update-qty { font-size: 0.8rem; padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.6); }
.cart-item-subtotal { font-size: 0.9rem; white-space: nowrap; }
.cart-item-subtotal .item-subtotal-value { font-weight: 500; }
.cart-item-remove .btn { padding: 0.1rem 0.4rem; font-size: 0.8rem; line-height: 1; }

.cart-summary {
  margin-top: calc(var(--spacing-unit) * 1.5);
  padding: var(--spacing-unit);
  background-color: #f8f9fa;
  border-top: 2px solid var(--primary-color);
  border-radius: var(--border-radius);
  text-align: right;
}
.cart-summary h2 { font-size: 1.3rem; margin-bottom: calc(var(--spacing-unit) * 0.75); }
.btn-checkout { width: 100%; padding: calc(var(--spacing-unit) * 0.7); font-size: 1.1rem; }


/* Checkout */
.checkout-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit);}
.checkout-grid { display: flex; flex-direction: column; gap: var(--spacing-unit); }

.checkout-address, .checkout-summary {
    background-color: var(--card-bg);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}
.checkout-address h2, .checkout-summary h2 { font-size: 1.2rem; border-bottom: 1px solid var(--border-color); padding-bottom: calc(var(--spacing-unit) * 0.4); margin-bottom: var(--spacing-unit); }
.saved-address { font-size: 0.95rem; margin-bottom: var(--spacing-unit); }
.saved-address p { margin-bottom: calc(var(--spacing-unit) * 0.2); line-height: 1.4; }
#edit-address-btn { margin-top: calc(var(--spacing-unit) * 0.5); }
.address-form h3 { font-size: 1.1rem; }

.checkout-items { max-height: 200px; overflow-y: auto; margin-bottom: var(--spacing-unit); padding-right: calc(var(--spacing-unit) * 0.5); }
.checkout-item { display: flex; align-items: center; gap: calc(var(--spacing-unit) * 0.5); margin-bottom: calc(var(--spacing-unit) * 0.5); font-size: 0.9rem; }
.checkout-item-image img {
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.75);
}
.checkout-item-info { flex-grow: 1; }
.checkout-item-price { font-weight: 500; white-space: nowrap;}

.checkout-totals { font-size: 0.95rem; }
.checkout-totals p { display: flex; justify-content: space-between; margin-bottom: calc(var(--spacing-unit) * 0.3); }
.checkout-totals hr { margin: calc(var(--spacing-unit) * 0.5) 0; border-color: var(--border-color); opacity: 0.5;}
.checkout-totals strong { font-weight: bold; }

.checkout-payment h3 { font-size: 1.1rem; margin: calc(var(--spacing-unit) * 1) 0 calc(var(--spacing-unit) * 0.5) 0; }
.payment-option {
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background-color: #f0f0f0;
    opacity: 0.8;
    margin-bottom: 0.5rem;
    cursor: pointer;
}
.payment-option.selected { border-color: var(--primary-color); opacity: 1; background-color: #e7f3ff; }
.payment-option label { font-weight: normal; display: flex; align-items: center; cursor: pointer; margin-bottom: 0; }
.payment-option input[type="radio"] { margin-right: 0.5rem; }
.payment-option i { margin-right: 0.3rem; color: var(--success-color);}

.place-order-form { margin-top: var(--spacing-unit); }
.btn-place-order { width: 100%; font-size: 1.1rem; padding: calc(var(--spacing-unit) * 0.7); }


/* My Orders */
.my-orders-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit); }
.order-list { display: flex; flex-direction: column; gap: var(--spacing-unit); }
.order-card {
  background-color: var(--card-bg);
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color);
  box-shadow: var(--card-shadow);
  overflow: hidden;
}

.order-header {
  background-color: #f8f9fa;
  padding: calc(var(--spacing-unit) * 0.6);
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  font-size: 0.85rem;
  color: var(--secondary-color);
  border-bottom: 1px solid var(--border-color);
}
.order-header > div { margin-right: calc(var(--spacing-unit) * 0.8); margin-bottom: calc(var(--spacing-unit) * 0.2); white-space: nowrap; }
.order-header strong { color: var(--text-color); }
.order-status { display: inline-block; } /* Used within header */

.order-body { padding: calc(var(--spacing-unit) * 0.75); display: flex; flex-direction: column; gap: calc(var(--spacing-unit) * 0.75); }

/* Order Item Images (Shared) */
.order-items-images { display: flex; flex-wrap: wrap; gap: 8px; padding-left: 0; list-style: none; } /* Added list-style: none */
.order-item-thumbnail {
    display: inline-block;
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.75);
    border: 1px solid var(--border-color);
    transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
    vertical-align: middle;
    background-color: #f8f9fa;
}
.order-item-thumbnail:hover { opacity: 0.85; transform: scale(1.05); z-index: 10; }
.order-item-thumbnail-placeholder {
    display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px;
    border-radius: calc(var(--border-radius) * 0.75);
    border: 1px dashed var(--secondary-color); background-color: var(--light-color); color: var(--secondary-color); font-size: 0.6rem; font-weight: bold; text-align: center; text-decoration: none; transition: background-color 0.2s ease-in-out; vertical-align: middle; line-height: 1; padding: 2px;
}
.order-item-thumbnail-placeholder:hover { background-color: #e2e6ea; text-decoration: none; }

.order-details { font-size: 0.9rem; line-height: 1.5;}
.order-details p { margin-bottom: calc(var(--spacing-unit) * 0.3); }
.order-actions { padding: 0 calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 0.75); text-align: right; }


/* Status Badge */
.status-badge {
    font-weight: bold;
    padding: 0.2em 0.5em;
    border-radius: var(--border-radius);
    color: #333;
    background-color: var(--secondary-color);
    font-size: 0.85em;
    display: inline-block;
    vertical-align: middle;
    text-transform: capitalize;
}
.status-pending, .status-badge.status-pending { background-color: #fff3cd; color: #856404; }
.status-out-for-delivery, .status-badge.status-out-for-delivery { background-color: #d1ecf1; color: #0c5460; }
.status-delivered, .status-badge.status-delivered { background-color: #d4edda; color: #155724; }
.status-cancelled, .status-badge.status-cancelled { background-color: #f8d7da; color: #721c24; }
.status-approved, .status-badge.status-approved { background-color: #d4edda; color: #155724; } /* Added for consistency */
.status-rejected, .status-badge.status-rejected { background-color: #f8d7da; color: #721c24; } /* Added for consistency */

.order-card.status-cancelled, .data-table tr.status-cancelled { opacity: 0.9; }
.data-table tr.status-rejected { opacity: 0.85; } /* Slightly different opacity for rejected products */
.data-table tr.status-pending { /* Optional: style pending rows */ }

/* Admin/Seller Pages */
.admin-manage-container, .admin-dashboard-container { padding: var(--spacing-unit); }
.admin-manage-container h1, .admin-dashboard-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit); border-bottom: 1px solid var(--border-color); padding-bottom: calc(var(--spacing-unit) * 0.5); }


/* Responsive Tables */
.table-container { overflow-x: auto; margin-bottom: var(--spacing-unit); }

.data-table {
  width: 100%;
  border-collapse: separate; /* Needed for border-radius effect */
  border-spacing: 0;
  font-size: 0.9rem;
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
  overflow: hidden;
}

.data-table thead {
  display: none; /* Hidden by default for mobile */
  background-color: #f8f9fa;
  font-weight: 500;
  color: var(--dark-color);
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.data-table th { padding: calc(var(--spacing-unit) * 0.7) calc(var(--spacing-unit) * 0.6); text-align: left; border-bottom: 1px solid var(--border-color); }

/* Mobile Table Rows (Card-like) */
.data-table tbody tr {
  display: block;
  margin-bottom: calc(var(--spacing-unit) * 1);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: calc(var(--spacing-unit) * 0.8);
  background-color: var(--card-bg);
  box-shadow: var(--card-shadow);
  transition: box-shadow 0.2s ease-in-out;
}
.data-table tbody tr:last-child { margin-bottom: 0; } /* Remove margin from last card */
.data-table tbody tr:hover { box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1); }

.data-table td { display: block; text-align: right; padding: calc(var(--spacing-unit) * 0.4) 0; position: relative; border-bottom: 1px dashed #eee; }
.data-table td:last-child { border-bottom: none; }
.data-table td::before { content: attr(data-label); position: absolute; left: 0; font-weight: 500; text-align: left; padding-right: 10px; color: var(--secondary-color); width: 40%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.85em; }

.table-img {
    max-width: 50px;
    border-radius: calc(var(--border-radius) * 0.75);
    display: inline-block;
    margin-left: 45%; /* Push image to the right of the label */
    vertical-align: middle;
}
.data-table td:has(img) { text-align: right; padding: 5px 0; } /* Adjust padding for image cells */

/* Mobile Actions Cell */
.data-table td.actions-cell { padding-top: calc(var(--spacing-unit) * 0.6); }
.data-table td.actions-cell::before { display: none; } /* Hide label for actions */
.actions-cell .action-group { border-top: 1px solid #eee; padding-top: calc(var(--spacing-unit) * 0.6); margin-top: calc(var(--spacing-unit) * 0.6); text-align: left; }
.actions-cell .action-group:first-child { border-top: none; margin-top: 0; padding-top: 0; }
.actions-cell .action-group-title { font-size: 0.8em; font-weight: bold; color: var(--secondary-color); margin-bottom: calc(var(--spacing-unit) * 0.4); display: block; text-align: left; }
.actions-cell form, .actions-cell .btn { margin: calc(var(--spacing-unit) * 0.25) 0; display: block; width: 100%; }
.actions-cell .inline-form { display: flex; flex-wrap: wrap; gap: calc(var(--spacing-unit) * 0.4); align-items: center; }
.actions-cell .inline-form input, .actions-cell .inline-form button { width: auto; flex-grow: 1; }
.actions-cell .inline-form button { flex-grow: 0; flex-shrink: 0; }
.actions-cell select.form-control-sm { margin-bottom: 5px; font-size: 0.9rem; padding: calc(var(--spacing-unit)*0.4) calc(var(--spacing-unit)*0.6); height: auto; width: 100%; }
.actions-cell .no-actions-text { display: block; text-align: left; margin-top: calc(var(--spacing-unit) * 0.5); color: var(--secondary-color); font-style: italic; }

/* Mobile Order Table Specifics */
.order-table td[data-label="Items"] .order-items-summary { font-size: 0.85em; line-height: 1.5; margin-bottom: calc(var(--spacing-unit) * 0.5); text-align: left; margin-left: 45%; }
.order-table td[data-label="Items"] .order-items-summary strong { color: var(--dark-color); }
.order-table .order-items-images { margin-top: calc(var(--spacing-unit) * 0.4); justify-content: flex-end; margin-left: 45%; }
.order-table td[data-label="Total"].order-total strong { font-size: 1.1em; color: var(--success-color); }
.order-table td[data-label="Status"] .status-badge { float: right; margin-bottom: 5px; }
.order-table td[data-label="Status"] small { clear: both; display: block; text-align: right; margin-top: calc(var(--spacing-unit) * 0.3); }

/* Mobile Delivery OTP */
.delivery-otp-display {
    margin-top: 10px;
    padding: 8px 12px;
    background-color: #e6ffed;
    border: 1px solid #b7e4c7;
    border-radius: var(--border-radius);
    font-size: 0.9rem;
    text-align: left;
    clear: both;
    margin-left: 45%; /* Align with other mobile table content */
}
.delivery-otp-display p { margin-bottom: 3px !important; }
.delivery-otp-code {
    font-weight: bold;
    color: #2b9348;
    font-size: 1.1em;
    margin: 0 3px;
    letter-spacing: 1px;
    background-color: #fff;
    padding: 1px 4px;
    border-radius: calc(var(--border-radius) * 0.5);
}
.delivery-otp-display small { display: block; margin-top: 3px; color: #555; }
.verify-otp-form { display: flex; align-items: center; gap: 5px; width: 100%; }
.verify-otp-form input[name="otp"] { flex-grow: 1; max-width: 150px; padding: calc(var(--spacing-unit)*0.4) calc(var(--spacing-unit)*0.6); font-size: 0.9rem; text-align: center; border-radius: var(--border-radius); }
.verify-otp-form button { flex-shrink: 0; width: auto; padding: calc(var(--spacing-unit)*0.4) calc(var(--spacing-unit)*0.6); font-size: 0.9rem; line-height: 1.4; }

/* Admin Actions Grid */
.admin-actions-grid { display: grid; grid-template-columns: repeat(1, 1fr); gap: var(--spacing-unit); margin-top: var(--spacing-unit); } /* Default to 1 column */
.admin-action-card {
    background-color: var(--card-bg);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    text-align: center;
    box-shadow: var(--card-shadow);
    transition: transform 0.2s, box-shadow 0.2s;
    color: var(--text-color);
    text-decoration: none;
}
.admin-action-card:hover { transform: translateY(-3px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); text-decoration: none; }
.admin-action-card i { font-size: 2rem; color: var(--primary-color); margin-bottom: 0.5rem; }
.admin-action-card h3 { font-size: 1.1rem; margin-bottom: 0.3rem; color: var(--text-color); }
.admin-action-card p { font-size: 0.85rem; color: var(--secondary-color); margin-bottom: 0.5rem; }


/* Error Page */
.error-container { text-align: center; padding-top: 2rem; }
.error-container h1 { color: var(--danger-color); margin-bottom: 0.5rem; }
.error-container .lead { font-size: 1.1rem; }
.error-container details {
    text-align: left;
    margin-top: 1rem;
    background: #f1f1f1;
    padding: 0.5rem;
    border-radius: var(--border-radius);
}
.error-container details summary { cursor: pointer; font-weight: bold; }
.error-container details pre { white-space: pre-wrap; font-size: 0.8em; margin-top: 0.5rem; }


/* Profile Page */
.profile-container {
    max-width: 800px;
    margin: var(--spacing-unit) auto;
    padding: calc(var(--spacing-unit) * 1.5);
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    box-shadow: var(--card-shadow);
}
.profile-container h1 { font-size: 1.8rem; text-align: center; margin-bottom: calc(var(--spacing-unit) * 0.5); }
.profile-container > p.text-muted { text-align: center; font-size: 1.1rem; }
.profile-section { margin-top: calc(var(--spacing-unit) * 1.5); padding-top: calc(var(--spacing-unit) * 1); border-top: 1px solid var(--border-color); }
.profile-section:first-of-type { border-top: none; padding-top: 0; margin-top: calc(var(--spacing-unit) * 0.8); }
.profile-section h2 { font-size: 1.4rem; margin-bottom: calc(var(--spacing-unit) * 0.8); color: var(--primary-color); }
#saved-address-display p { margin-bottom: calc(var(--spacing-unit) * 0.3); line-height: 1.5; font-size: 1rem; }
#saved-address-display strong { font-weight: 500; }
#edit-address-btn, #add-address-btn { margin-top: calc(var(--spacing-unit) * 0.5); }
.address-form { max-width: 500px; }
.address-form h3 { font-size: 1.2rem; margin-bottom: var(--spacing-unit); font-weight: 500; }
#cancel-edit-btn { margin-left: calc(var(--spacing-unit) * 0.5); }
.dashboards-section .btn,
.orders-section .btn { /* Include orders section buttons */
    margin-right: 10px; margin-bottom: 10px;
}
.logout-section .btn { min-width: 120px; }


/* Banner Slider Styles */
.banner-slider-container {
  position: relative;
  width: 100%;
  aspect-ratio: 24 / 6; /* Default widescreen */
  overflow: hidden;
  border-radius: var(--border-radius);
  background-color: #e0e0e0;
}

.banner-slides {
  position: relative;
  width: 100%;
  height: 100%;
}

.banner-slide {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.6s ease-in-out;
  background-color: #eee;
}

.banner-slide.active {
  opacity: 1;
  visibility: visible;
  z-index: 1;
}

.banner-link {
  display: block;
  width: 100%;
  height: 100%;
}

.banner-image {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Navigation Arrows */
.banner-nav {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background-color: rgba(0, 0, 0, 0.4);
  color: white;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 1rem;
  cursor: pointer;
  z-index: 2;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
  opacity: 0.8;
}

.banner-nav:hover {
  background-color: rgba(0, 0, 0, 0.6);
  opacity: 1;
}

.banner-prev { left: 10px; }
.banner-next { right: 10px; }

/* Navigation Dots */
.banner-dots {
  position: absolute;
  bottom: 15px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 8px;
  z-index: 2;
}

.banner-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.5);
  border: 1px solid rgba(0, 0, 0, 0.2);
  cursor: pointer;
  padding: 0;
  transition: background-color 0.3s ease;
}

.banner-dot.active { background-color: white; }


/* ============================ */
/* Category Display Styles      */
/* ============================ */

.category-display-section {
    padding: 1rem 0; /* Vertical padding */
    margin-bottom: 1.5rem; /* Space below the section */
    border-top: 1px solid var(--border-color); /* Optional separator line */
    padding-top: 1.5rem; /* Space above the heading */
}

.category-display-section h2 {
    font-size: 1.3rem; /* Slightly larger heading */
    margin-bottom: 1rem; /* Space below heading */
    text-align: left; /* Align heading left */
    font-weight: 500;
}

.category-grid {
    display: grid;
    /* Adjust minmax for desired minimum/maximum card width */
    /* Using 110px min ensures slightly larger cards on smaller screens */
    grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
    gap: 1rem; /* Space between category cards */
}

.category-card {
    display: flex; /* Use flexbox for alignment */
    flex-direction: column; /* Stack image and text vertically */
    align-items: center; /* Center items horizontally */
    text-align: center; /* Center the text */
    padding: 0.75rem 0.5rem; /* Padding inside the card */
    text-decoration: none;
    color: var(--text-color);
    border-radius: var(--border-radius);
    transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
    background-color: rgba(255, 255, 255, 0.4); /* Optional: subtle background */
    border: 1px solid transparent; /* Placeholder for hover border */
}

.category-card:hover {
    background-color: rgba(255, 255, 255, 0.7);
    transform: translateY(-2px); /* Slight lift effect */
    text-decoration: none;
    color: var(--primary-color);
    /* border-color: var(--border-color); */ /* Optional hover border */
}

.category-image-wrapper {
    width: 80px; /* Keep size or adjust if needed */
    height: 80px;
    overflow: hidden;
    border-radius: 15%; /* Rounded square */
    margin-bottom: 0.5rem; /* Space between image and name */
    background-color: #f0f0f0; /* Placeholder background */
    border: 1px solid var(--border-color);
    flex-shrink: 0; /* Prevent shrinking if container is small */
    display: flex; /* Center image if it's smaller */
    align-items: center;
    justify-content: center;
}

.category-image {
    width: 100%;
    height: 100%;
    object-fit: cover; /* Cover the area, might crop */
    display: block;
}

.category-name {
    font-size: 0.85rem;
    font-weight: 500;
    line-height: 1.3;
    /* Allow text wrapping */
    word-break: break-word;
    overflow-wrap: break-word;
    /* Limit to max 2 lines (optional) */
    max-height: 2.6em; /* Approx 2 lines based on line-height */
    overflow: hidden;
    /* Can add text-overflow ellipsis if needed, but might look odd when centered */
}

/* ============================ */
/* Media Queries                */
/* ============================ */

/* Mobile Specific Styles (Less than 768px) */
@media (max-width: 767px) {
  .app-footer { display: none; } /* Hide footer on small screens */
  .banner-slider-container { aspect-ratio: 2.5 / 1; } /* Taller banner on mobile */
  .banner-nav { width: 35px; height: 35px; font-size: 0.9rem; }
  .banner-dots { bottom: 10px; }
  .banner-dot { width: 8px; height: 8px; }

  /* Mobile Header Search Bar Handling */
  .search-container-dynamic {
      flex-grow: 0;
      max-width: none;
      order: 1;
      margin: 0;
      position: static;
  }
  .search-toggle-btn { order: 0; display: flex; } /* Ensure toggle is displayed */
  .nav-left { margin-right: auto; }

  .search-form-dynamic {
      position: absolute;
      top: calc(100% + 8px);
      left: var(--spacing-unit);
      right: var(--spacing-unit);
      width: calc(100% - (2 * var(--spacing-unit)));
      background-color: var(--card-bg); /* White background */
      border: 1px solid var(--border-color); /* Standard border */
      box-shadow: 0 3px 6px rgba(0,0,0,0.15);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px) scaleY(0.95);
      transform-origin: top center;
      transition: opacity 0.25s ease, visibility 0s linear 0.25s, transform 0.25s ease;
      z-index: 1005;
      border-radius: var(--border-radius);
      height: 42px;
  }
  /* Ensure mobile search input/button also use black/white */
  #search-input-dynamic {
      color: var(--dark-color); /* Black text */
      background-color: transparent; /* Inherit from form */
  }
  #search-input-dynamic::placeholder {
      color: #6c757d; /* Darker gray placeholder */
  }
  .search-submit-btn-dynamic {
      color: var(--dark-color); /* Black icon */
      background-color: transparent; /* Inherit from form */
  }
   .search-submit-btn-dynamic:hover {
      background-color: rgba(0, 0, 0, 0.05); /* Subtle hover */
  }


  .search-container-dynamic.active .search-form-dynamic {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scaleY(1);
      transition: opacity 0.25s ease, visibility 0s linear 0s, transform 0.25s ease;
  }

  .suggestions-dropdown {
      position: absolute;
      top: calc(100% + 8px + 42px + 4px); /* Adjust based on search bar position */
      left: var(--spacing-unit);
      right: var(--spacing-unit);
      width: calc(100% - (2 * var(--spacing-unit)));
      z-index: 1010;
      border-radius: var(--border-radius);
      border-top: 1px solid var(--border-color);
  }
   .search-container-dynamic.active .suggestions-dropdown.active { display: block; }
}


/* Tablet and Up (768px+) */
@media (min-width: 768px) {
  .container { max-width: 960px; }
  .app-footer { display: block; } /* Show footer */
  .product-grid { grid-template-columns: repeat(3, 1fr); }
  .product-name { height: auto; white-space: normal; display: block; -webkit-line-clamp: unset; -webkit-box-orient: unset; }
  .product-detail-main { flex-direction: row; align-items: flex-start; }
  .product-detail-info { flex: 1 1 60%; }
  .product-detail-image { flex: 1 1 40%; width: auto; max-width: none; margin: 0; }
  .product-actions { flex-direction: row; align-items: center; }
  .product-actions .btn { width: auto; }
  .quantity-selector { max-width: 120px; margin-bottom: 0; }
  .auth-container { margin: calc(var(--spacing-unit) * 2) auto; }
  .cart-item { grid-template-columns: 100px 1fr 100px 150px 80px; grid-template-areas: "image details price quantity remove"; align-items: center; padding: var(--spacing-unit); }
  .cart-item-details { grid-area: details; }
  .cart-item-price { display: block; grid-area: price; text-align: right; font-weight: 500; font-size: 1rem; color: var(--text-color); margin-bottom: 0; }
  .cart-item-quantity { grid-area: quantity; justify-content: center; }
  .cart-item-subtotal { display: none; }
  .cart-item-remove { grid-area: remove; align-self: center; text-align: center; }
  .checkout-grid { flex-direction: row; gap: calc(var(--spacing-unit) * 1.5); align-items: flex-start; }
  .checkout-address { flex: 1 1 55%; }
  .checkout-summary { flex: 1 1 45%; }

  /* --- Desktop Table Refinements --- */
  .data-table thead { display: table-header-group; }
  .data-table tbody tr { display: table-row; margin-bottom: 0; border: none; padding: 0; box-shadow: none; background-color: transparent; border-bottom: 1px solid var(--border-color); border-radius: 0; }
  .data-table tbody tr:last-child { border-bottom: none; }
  .data-table tbody tr:hover { background-color: #f1f5f9; }
  .data-table td { display: table-cell; text-align: left; padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.6); vertical-align: middle; border-bottom: none; position: static; margin-left: 0 !important; }
  .data-table td::before { content: none; }
  .table-img { max-width: 60px; margin-left: 0; }
  .data-table td:has(img) { text-align: left; width: 80px; }
  .data-table th[data-label*="Price"], .data-table td[data-label*="Price"],
  .data-table th[data-label*="Stock"], .data-table td[data-label*="Stock"],
  .data-table th[data-label*="Total"], .data-table td[data-label*="Total"],
  .data-table td.order-total { text-align: right; width: 100px; }
  .data-table th[data-label="Status"], .data-table td[data-label="Status"],
  .data-table td.order-status-cell { text-align: center; width: 150px; }
  .data-table td[data-label="Status"] .status-badge, .order-status-cell .status-badge { float: none; display: inline-block; }
  .order-status-cell small { text-align: center; }
  .data-table th.actions-cell, .data-table td.actions-cell { text-align: right !important; width: 250px; white-space: normal; }
  .actions-cell .action-group { border: none; padding: 0; margin: 0 0 calc(var(--spacing-unit) * 0.5) 0; display: block; text-align: right; }
  .actions-cell .action-group:last-child { margin-bottom: 0; }
  .actions-cell .action-group-title { display: none; }
  .actions-cell form, .actions-cell .btn { display: inline-block; width: auto; margin: 0 0 0 calc(var(--spacing-unit) * 0.3); vertical-align: middle; }
  .actions-cell .inline-form { display: inline-flex; width: auto; margin-left: 0; } /* Adjust inline form display */
  .actions-cell .inline-form + .inline-form { margin-left: calc(var(--spacing-unit) * 0.3); } /* Space between adjacent forms */
  .actions-cell .verify-otp-form input { max-width: 100px; }
  .actions-cell select.form-control-sm { width: auto; display: inline-block; margin-right: 5px;}
  .actions-cell .no-actions-text { display: inline-block; text-align: right; width: 100%;}
  .w-md-auto { width: auto !important; }
  .order-table td[data-label="Items"] .order-items-summary { margin-left: 0; text-align: left; }
  .order-table .order-items-images { justify-content: flex-start; margin-left: 0; }
  .delivery-otp-display { margin-left: 0; margin-top: 5px; padding: 5px 8px; font-size: 0.85rem; display: inline-block; width: auto; text-align: center; }
  .delivery-otp-display p { margin-bottom: 0 !important; }
  .delivery-otp-display small { display: none; } /* Hide verbose text on desktop */

  /* Admin Actions Grid */
  .admin-actions-grid { grid-template-columns: repeat(2, 1fr); } /* 2 columns for tablets */

  /* Rating Stats Layout */
  .rating-stats-container { display: flex; align-items: flex-start; gap: calc(var(--spacing-unit) * 2); }
  .rating-summary { flex-direction: column; align-items: center; margin-bottom: 0; flex-basis: 150px; flex-shrink: 0; }
  .rating-average-value { font-size: 3em; }
  .rating-total { font-size: 1em; }
  .rating-bars { max-width: none; flex-grow: 1; }

  .profile-container { padding: calc(var(--spacing-unit) * 2); }

  /* Desktop Header Search */
  .app-header {
      padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
  }
  .navbar { gap: var(--spacing-unit); }
  .app-logo .app-name { display: inline; }
  .app-logo { font-size: 1.2rem; }
  .search-toggle-btn { display: none; } /* Hide toggle button on desktop */
  .search-container-dynamic { display: flex; } /* Ensure search container is visible */
  /* Ensure desktop search form uses black/white */
  .search-form-dynamic {
      position: relative; /* Override absolute positioning from mobile */
      top: auto; left: auto; right: auto; width: 100%; /* Override mobile positioning */
      background-color: #ffffff; /* White background */
      border: 1px solid #ccc; /* Subtle grey border */
      box-shadow: none; /* Remove mobile shadow */
      opacity: 1; visibility: visible; transform: none; /* Override mobile transitions */
      transition: border-color 0.2s ease, box-shadow 0.2s ease; /* Keep transitions */
      height: 38px;
  }
  #search-input-dynamic {
      color: var(--dark-color); /* Black text */
      background-color: transparent; /* Inherit from form */
  }
  #search-input-dynamic::placeholder {
      color: #6c757d; /* Darker gray placeholder */
  }
  .search-submit-btn-dynamic {
      color: var(--dark-color); /* Black icon */
      background-color: transparent; /* Inherit from form */
  }
  .search-submit-btn-dynamic:hover {
      background-color: rgba(0, 0, 0, 0.05); /* Subtle hover */
  }
  /* --- End Desktop Search Specific Styles --- */

  .nav-link { flex-direction: row; font-size: 0.9rem; align-items: center; padding: calc(var(--spacing-unit) * 0.4) calc(var(--spacing-unit) * 0.8); }
  .nav-link span { display: inline; margin-left: calc(var(--spacing-unit) * 0.3); }
  .nav-link i { font-size: 1rem; margin-bottom: 0; margin-right: 0; }
  .nav-right { gap: calc(var(--spacing-unit) * 0.75); }
  .profile-avatar-link { width: 38px; height: 38px; }
  .btn-login-register { font-size: 0.9rem; }
  .suggestions-dropdown { position: absolute; top: 100%; left: 0; right: 0; width: 100%; }

  /* Responsive adjustments for category grid */
  .category-grid {
      /* Increase gap slightly on larger screens */
      gap: 1.25rem;
  }
   .category-card {
       padding: 1rem 0.75rem;
   }
   .category-image-wrapper {
       width: 90px;
       height: 90px;
       margin-bottom: 0.75rem;
   }
  .category-name {
      font-size: 0.9rem;
  }

} /* End @media (min-width: 768px) */


/* Larger Desktops (1024px+) */
@media (min-width: 1024px) {
  .container { max-width: 1140px; }
  .product-grid { grid-template-columns: repeat(4, 1fr); }
  .product-grid, .admin-actions-grid { gap: calc(var(--spacing-unit) * 1); }
  .admin-actions-grid { grid-template-columns: repeat(3, 1fr); } /* 3 columns for larger screens */
  .navbar { max-width: 1140px; } /* Wider navbar content */

   /* Category Grid on Larger Desktops */
  .category-grid {
       /* Maybe allow more columns implicitly via auto-fit/minmax */
       /* Or explicitly set more columns if preferred */
       /* grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); */
   }
   .category-image-wrapper {
       width: 100px;
       height: 100px;
   }
} /* End @media (min-width: 1024px) */


/* Extra Large Desktops (1200px+) */
@media (min-width: 1200px) {
    .admin-actions-grid { grid-template-columns: repeat(4, 1fr); } /* 4 columns for very large screens */
}

/* public/css/style.css - Add this at the end or within category styles */

/* Category Highlighting Style */
.category-card.active-category {
  border-color: var(--primary-color); /* Add a primary color border */
  background-color: rgba(0, 123, 255, 0.1); /* Subtle primary background tint */
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2); /* Optional focus-like ring */
  transform: translateY(0); /* Override hover lift effect if desired */
}

/* Make the text bold and primary color for the active category */
.category-card.active-category .category-name {
  color: var(--primary-hover);
  font-weight: 600;
}

/* Optional: Adjust hover for active category to keep it distinct */
.category-card.active-category:hover {
  /* Keep the active styles, maybe slightly enhance */
  background-color: rgba(0, 123, 255, 0.15);
  border-color: var(--primary-hover);
  color: var(--primary-hover); /* Ensure text color stays */
}

public/js/main.js:
// public/js/main.js
console.log("Main JS loaded.");

document.addEventListener('DOMContentLoaded', () => {

    // --- Button Spinner Logic ---
    document.querySelectorAll('form.form-submit-spinner').forEach(form => {
        form.addEventListener('submit', (event) => {
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton && !submitButton.disabled) {
                // Basic HTML5 validation check
                if (typeof form.checkValidity === 'function' && !form.checkValidity()) {
                    // If form is invalid, don't disable button or show spinner
                    return;
                }
                const originalText = submitButton.innerHTML;
                submitButton.dataset.originalText = originalText; // Store original HTML
                submitButton.disabled = true;
                submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';

                // Reset button if user navigates back without form submitting (browser specific)
                window.addEventListener('pageshow', function(pageEvent) { // Renamed event variable
                    if (pageEvent.persisted && submitButton.disabled) {
                        // Restore button only if it still has the loading state
                        if (submitButton.dataset.originalText) {
                            submitButton.innerHTML = submitButton.dataset.originalText;
                        }
                        submitButton.disabled = false;
                    }
                });
            }
        });
    });

    // --- Responsive Table Logic ---
    function responsiveTables() {
        const tables = document.querySelectorAll('.data-table');
        tables.forEach(table => {
            const headerElements = table.querySelectorAll('thead th');
            if (!headerElements || headerElements.length === 0) return;

            const headers = Array.from(headerElements).map(th => th.textContent.trim());
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                cells.forEach((cell, index) => {
                    // Add data-label only if it doesn't exist and header exists
                    if (!cell.hasAttribute('data-label') && headers[index] !== undefined && headers[index] !== '') {
                         cell.setAttribute('data-label', headers[index]);
                    }
                });
            });
        });
    }
     if (document.querySelector('.data-table')) {
         responsiveTables();
     }

    // --- Share Button Logic ---
    const shareButton = document.getElementById('share-product-btn');
    const fallbackLinks = document.getElementById('fallback-share-links');
    if (shareButton && fallbackLinks) {
        shareButton.addEventListener('click', async () => {
            const title = shareButton.dataset.title || document.title; // Fallback to page title
            const text = shareButton.dataset.text || `Check out ${title}`; // Fallback text
            const url = shareButton.dataset.url || window.location.href; // Fallback url

            if (navigator.share) {
                try {
                    await navigator.share({ title, text, url });
                    console.log('Product shared successfully!');
                    showToast('Link shared!', 'success'); // Optional feedback
                } catch (error) {
                    console.error('Error sharing:', error);
                    // Don't show fallback if user explicitly cancelled (AbortError)
                    if (error.name !== 'AbortError') {
                         fallbackLinks.classList.remove('hidden');
                         showToast('Sharing failed, use fallback links.', 'warning');
                    }
                }
            } else {
                console.log('Web Share API not supported, showing fallback links.');
                fallbackLinks.classList.remove('hidden');
                showToast('Web Share not supported, use link options.', 'info');
            }
        });
    }

    // --- Profile Address Toggle Logic ---
    const profilePage = document.querySelector('.profile-container'); // Check if we are on profile page
    if (profilePage) {
        const profileEditBtn = profilePage.querySelector('#edit-address-btn');
        const profileAddBtn = profilePage.querySelector('#add-address-btn');
        const profileCancelBtn = profilePage.querySelector('#cancel-edit-btn');
        const profileAddressForm = profilePage.querySelector('#address-form');
        const profileSavedAddressDiv = profilePage.querySelector('#saved-address-display');

        const showProfileForm = () => {
            if (!profileAddressForm || !profileSavedAddressDiv) return; // Safety check
            profileAddressForm.classList.remove('hidden');
            // Check if saved address has actual content besides the button
            const hasSavedContent = profileSavedAddressDiv.querySelector('p strong');
            profileAddressForm.querySelector('h3').textContent = hasSavedContent ? 'Edit Address' : 'Add Address';
            profileSavedAddressDiv.classList.add('hidden');
            if (profileCancelBtn && hasSavedContent) {
                profileCancelBtn.classList.remove('hidden'); // Show cancel only when editing existing
            } else if (profileCancelBtn) {
                profileCancelBtn.classList.add('hidden'); // Hide cancel when adding new
            }
            if (profileAddBtn) profileAddBtn.classList.add('hidden'); // Hide Add button when form is shown
        };

        const hideProfileForm = () => {
            if (!profileAddressForm || !profileSavedAddressDiv) return; // Safety check
            profileAddressForm.classList.add('hidden');
            profileSavedAddressDiv.classList.remove('hidden'); // Always show the container (it shows "No address" or the address)
            if (profileCancelBtn) profileCancelBtn.classList.add('hidden');
            // Show Add button only if no address content exists
            if (!profileSavedAddressDiv.querySelector('p strong') && profileAddBtn) {
                 profileAddBtn.classList.remove('hidden');
            } else if(profileAddBtn) {
                 profileAddBtn.classList.add('hidden'); // Ensure add button is hidden if address exists
            }
        };

        if (profileEditBtn) {
            profileEditBtn.addEventListener('click', showProfileForm);
        }
        if (profileAddBtn) {
             profileAddBtn.addEventListener('click', () => {
                 if(profileAddressForm) profileAddressForm.reset(); // Clear form fields when adding new
                showProfileForm();
             });
        }
        if (profileCancelBtn) {
            profileCancelBtn.addEventListener('click', hideProfileForm);
        }

        // Initial state check
        if (profileAddressForm && profileSavedAddressDiv && profileAddBtn) {
            if (!profileSavedAddressDiv.querySelector('p strong') && profileAddressForm.classList.contains('hidden')) {
                profileAddBtn.classList.remove('hidden'); // Show add button if no address
            } else {
                profileAddBtn.classList.add('hidden'); // Hide add button if address exists or form is shown
            }
        }

        // Name Edit Logic (Profile Page Only)
        const editNameBtn = document.getElementById('edit-name-btn');
        const cancelNameBtn = document.getElementById('cancel-edit-name-btn');
        const nameForm = document.getElementById('name-form');
        const savedNameDisplaySpan = document.getElementById('saved-name-display'); // The span containing the welcome text
        const nameInput = document.getElementById('name-input'); // The input field
        const displayUserNameStrong = document.getElementById('display-user-name'); // The strong tag holding the name

        const showNameForm = () => {
            if (!nameForm || !savedNameDisplaySpan || !editNameBtn) return;
            nameForm.classList.remove('hidden');        // Show the form
            savedNameDisplaySpan.classList.add('hidden'); // Hide the "Welcome, Name" span
            editNameBtn.classList.add('hidden');        // Hide the edit icon button
            nameInput.focus();                          // Focus the input field
        };

        const hideNameForm = () => {
            if (!nameForm || !savedNameDisplaySpan || !editNameBtn || !displayUserNameStrong) return;
            nameForm.classList.add('hidden');            // Hide the form
            savedNameDisplaySpan.classList.remove('hidden'); // Show the "Welcome, Name" span
            editNameBtn.classList.remove('hidden');      // Show the edit icon button again
            // Reset input value to the currently displayed name when cancelling
            if(displayUserNameStrong) nameInput.value = displayUserNameStrong.textContent;
        };

        if (editNameBtn) {
            editNameBtn.addEventListener('click', showNameForm);
        }

        if (cancelNameBtn) {
            cancelNameBtn.addEventListener('click', hideNameForm);
        }
    }

    // --- Checkout Address Toggle Logic ---
    const checkoutPage = document.querySelector('.checkout-container'); // Check if on checkout page
    if (checkoutPage) {
        const checkoutEditBtn = checkoutPage.querySelector('.checkout-address #edit-address-btn');
        const checkoutCancelBtn = checkoutPage.querySelector('.checkout-address #cancel-edit-btn');
        const checkoutAddressForm = checkoutPage.querySelector('.checkout-address #address-form');
        const checkoutSavedAddressDiv = checkoutPage.querySelector('.checkout-address .saved-address');
        const placeOrderBtn = checkoutPage.querySelector('.btn-place-order');

        // Check if an address is initially displayed (not hidden)
        const hasInitialAddress = checkoutSavedAddressDiv && !checkoutSavedAddressDiv.classList.contains('hidden');

        if (checkoutEditBtn) {
            checkoutEditBtn.addEventListener('click', () => {
                if (!checkoutAddressForm || !checkoutSavedAddressDiv) return;
                checkoutAddressForm.classList.remove('hidden');
                checkoutSavedAddressDiv.classList.add('hidden');
                if(placeOrderBtn) placeOrderBtn.disabled = true; // Disable place order when editing
                checkoutAddressForm.querySelector('h3').textContent = 'Edit Address';
                if (checkoutCancelBtn) checkoutCancelBtn.classList.remove('hidden'); // Show cancel button
            });
        }

        if (checkoutCancelBtn) {
            checkoutCancelBtn.addEventListener('click', () => {
                if (!checkoutAddressForm || !checkoutSavedAddressDiv) return;
                checkoutAddressForm.classList.add('hidden');
                if (hasInitialAddress) { // Only show saved div if it existed initially
                    checkoutSavedAddressDiv.classList.remove('hidden');
                    if(placeOrderBtn) placeOrderBtn.disabled = false; // Re-enable place order
                } else {
                    // If there was no initial address, cancelling means keep form hidden and button disabled
                    if(placeOrderBtn) placeOrderBtn.disabled = true;
                }
                checkoutCancelBtn.classList.add('hidden'); // Hide cancel button again
            });
        }

        // Initial state for checkout page
        if (!hasInitialAddress && checkoutAddressForm) {
            checkoutAddressForm.classList.remove('hidden'); // Show form if no address saved
            if (placeOrderBtn) placeOrderBtn.disabled = true; // Disable place order
            checkoutAddressForm.querySelector('h3').textContent = 'Add Shipping Address'; // Clearer label
            if (checkoutCancelBtn) checkoutCancelBtn.classList.add('hidden'); // Hide cancel btn if adding new
        } else if (hasInitialAddress && checkoutAddressForm) {
            checkoutAddressForm.classList.add('hidden'); // Ensure form is hidden initially
            if (placeOrderBtn) placeOrderBtn.disabled = false; // Enable if address exists
            if (checkoutCancelBtn) checkoutCancelBtn.classList.add('hidden'); // Ensure cancel is hidden initially
        }
    }


    // --- Cart Update AJAX Logic ---
    const updateQtyButtons = document.querySelectorAll('.btn-update-qty');
    updateQtyButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            e.preventDefault();
            const productId = button.dataset.productId;
            const quantityInput = document.getElementById(`quantity-${productId}`);
            if (!quantityInput) return;
            const newQuantity = parseInt(quantityInput.value, 10);

            // Store original value in case of error
            if (!quantityInput.dataset.originalValue) {
                quantityInput.dataset.originalValue = quantityInput.value;
            }


            if (isNaN(newQuantity) || newQuantity < 0) {
                 showToast('Invalid quantity entered.', 'danger');
                 quantityInput.value = quantityInput.dataset.originalValue; // Restore original
                return;
             }
            const maxStock = parseInt(quantityInput.max, 10);
            if (!isNaN(maxStock) && newQuantity > maxStock) {
                showToast(`Only ${maxStock} items available in stock.`, 'warning');
                quantityInput.value = maxStock; // Correct to max stock, don't restore original
                 return; // Don't proceed with AJAX call yet, let user confirm or re-update
             }
            updateCartItemQuantityAJAX(productId, newQuantity, button, quantityInput); // Pass input element
        });
    });


    // ========================================
    // Dynamic Search Bar Logic
    // ========================================
    const searchContainer = document.getElementById('dynamic-search-container');
    const searchToggleBtn = document.getElementById('search-toggle-btn');
    const searchForm = document.getElementById('dynamic-search-form');
    const searchInput = document.getElementById('search-input-dynamic');
    const suggestionsDropdown = document.getElementById('suggestions-dropdown');
    let suggestionFetchTimeout;

    // --- Toggle Search Bar (Mobile) ---
    if (searchToggleBtn && searchContainer) {
        searchToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            searchContainer.classList.toggle('active');
            if (searchContainer.classList.contains('active')) {
                requestAnimationFrame(() => { if(searchInput) searchInput.focus(); });
            } else {
                if(suggestionsDropdown) suggestionsDropdown.classList.remove('active');
            }
        });
    }

    // --- Handle Search Input ---
    if (searchInput && suggestionsDropdown) {
        searchInput.addEventListener('input', () => {
            const query = searchInput.value.trim();
            clearTimeout(suggestionFetchTimeout);

            if (query.length >= 2) {
                suggestionsDropdown.innerHTML = '<div class="suggestion-item"><i>Loading...</i></div>';
                suggestionsDropdown.classList.add('active');
                suggestionFetchTimeout = setTimeout(() => {
                    fetchSuggestions(query);
                }, 300); // Debounce
            } else {
                suggestionsDropdown.innerHTML = '';
                suggestionsDropdown.classList.remove('active');
            }
        });

        // Keep suggestions open on focus if suggestions exist
        searchInput.addEventListener('focus', () => {
             const query = searchInput.value.trim();
              const hasActualSuggestions = suggestionsDropdown.querySelector('a.suggestion-item');
              if (query.length >= 2 && hasActualSuggestions) {
                 suggestionsDropdown.classList.add('active');
             }
        });
    }

     // --- Fetch Suggestions ---
     async function fetchSuggestions(query) {
         if (!suggestionsDropdown) return;
         try {
             const response = await fetch(`/products/suggestions?q=${encodeURIComponent(query)}`);
             if (!response.ok) {
                 let errorMsg = `HTTP error! status: ${response.status}`;
                 try { const errorData = await response.json(); errorMsg = errorData.error || errorMsg; } catch (parseError) {}
                 throw new Error(errorMsg);
             }
             const suggestions = await response.json();
             displaySuggestions(suggestions);
         } catch (error) {
             console.error('Error fetching suggestions:', error);
             suggestionsDropdown.innerHTML = `<div class="suggestion-item text-danger"><i>Error: ${error.message || 'Failed to fetch'}</i></div>`;
             suggestionsDropdown.classList.add('active');
         }
     }

     // --- Display Suggestions ---
     function displaySuggestions(suggestions) {
          if (!suggestionsDropdown) return;
         suggestionsDropdown.innerHTML = '';
         if (suggestions.length > 0) {
             suggestions.forEach(product => {
                 const item = document.createElement('a');
                 item.classList.add('suggestion-item');
                 item.href = `/products/${product._id}`;
                 // Basic sanitization for display
                 const safeName = product.name ? product.name.replace(/</g, "<").replace(/>/g, ">") : '[No Name]';
                 const safeImageUrl = product.imageUrl ? product.imageUrl.replace(/</g, "<").replace(/>/g, ">") : '/images/placeholder.png';
                 item.innerHTML = `
                    <img src="${safeImageUrl}" alt="${safeName}" loading="lazy">
                    <span>${safeName}</span>
                 `;
                 suggestionsDropdown.appendChild(item);
             });
             suggestionsDropdown.classList.add('active');
         } else {
              suggestionsDropdown.innerHTML = '<div class="suggestion-item text-muted"><i>No matching products found.</i></div>';
              suggestionsDropdown.classList.add('active');
         }
     }

     // --- Close Search/Suggestions on Outside Click ---
     document.addEventListener('click', (e) => {
         // Ensure all elements exist before checking contains
         if (searchContainer && suggestionsDropdown && searchToggleBtn && !searchContainer.contains(e.target) && !searchToggleBtn.contains(e.target)) {
             searchContainer.classList.remove('active');
             suggestionsDropdown.classList.remove('active');
         }
     });

     // --- Handle Clicks Inside Suggestions ---
     if(suggestionsDropdown) {
         suggestionsDropdown.addEventListener('click', (e) => {
             const link = e.target.closest('a');
             if (!link) {
                 e.stopPropagation(); // Don't close if click is not on a link itself
             } else {
                 // Hide dropdown after clicking a link
                 suggestionsDropdown.classList.remove('active');
                 if (searchContainer && window.innerWidth < 768) { // Also hide mobile search bar
                    searchContainer.classList.remove('active');
                 }
             }
         });
     }
    // ========================================
    // End Dynamic Search Bar Logic
    // ========================================


    // ========================================
    // Toast Notification Logic (FASTER APPEARANCE)
    // ========================================
    const toastContainer = document.querySelector('.toast-container');
    if (toastContainer) {
        const toastElements = toastContainer.querySelectorAll('.toast');

        toastElements.forEach((toastElement) => { // No index needed now
            const closeButton = toastElement.querySelector('.toast-close-btn');
            const autoHideDelay = 5000; // 5 seconds
            let hideTimeoutId;

            const dismissToast = () => {
                clearTimeout(hideTimeoutId);
                if (toastElement.classList.contains('hide') || !toastElement.parentNode) return; // Already hiding or removed
                toastElement.classList.remove('show');
                toastElement.classList.add('hide');
                toastElement.addEventListener('transitionend', (event) => {
                    // Check propertyName to ensure it's the opacity/transform transition
                    if ((event.propertyName === 'opacity' || event.propertyName === 'transform') && toastElement.classList.contains('hide') && toastElement.parentNode) {
                        toastElement.remove();
                    }
                }, { once: true });
            };

            // --- Show Animation (IMMEDIATE TRIGGER using setTimeout 0) ---
            setTimeout(() => {
                // Check if element is still in DOM before showing
                if (toastElement.parentNode) {
                   toastElement.classList.add('show');
                }
            }, 0); // Minimal delay to allow rendering initial state

            // --- Auto Hide Timer ---
             hideTimeoutId = setTimeout(dismissToast, autoHideDelay);

            // --- Manual Close Button ---
            if (closeButton) {
                closeButton.addEventListener('click', dismissToast);
            }

             // --- Prevent auto-hide on hover ---
             toastElement.addEventListener('mouseenter', () => clearTimeout(hideTimeoutId));
             toastElement.addEventListener('mouseleave', () => hideTimeoutId = setTimeout(dismissToast, autoHideDelay / 2)); // Restart timer on mouse out

        });
    }
    // ========================================
    // End Toast Notification Logic
    // ========================================

    // --- Rating Stats Bar Animation ---
    document.querySelectorAll('.rating-bar-fill').forEach(function(el) {
        var width = el.getAttribute('data-width');
        if (width) {
            // Allow the browser a moment to render before starting animation
            requestAnimationFrame(() => {
                 if(el.parentNode) { // Check if element still exists
                    el.style.width = width + '%';
                 }
            });
        }
    });

    // ========================================
    // Loading State for Non-Form Actions (e.g., Proceed to Checkout Link)
    // ========================================
    const proceedCheckoutBtn = document.getElementById('btn-proceed-checkout');
    if (proceedCheckoutBtn) {
        const originalCheckoutText = proceedCheckoutBtn.innerHTML;
        // Retrieve loading text safely, provide default
        const loadingCheckoutText = proceedCheckoutBtn.dataset.loadingText || '<i class="fas fa-spinner fa-spin"></i> Loading...';

        proceedCheckoutBtn.addEventListener('click', function(event) {
            // Check if already loading
            if (proceedCheckoutBtn.classList.contains('loading')) {
                return;
            }

            // Apply loading state
            proceedCheckoutBtn.classList.add('loading');
            proceedCheckoutBtn.innerHTML = loadingCheckoutText;
            proceedCheckoutBtn.style.pointerEvents = 'none'; // Visually disable link
            proceedCheckoutBtn.setAttribute('aria-disabled', 'true'); // Accessibility

            // Allow navigation to proceed naturally
        });

        // Reset button on page show (e.g., back navigation)
        window.addEventListener('pageshow', function(pageEvent) {
            if (pageEvent.persisted && proceedCheckoutBtn.classList.contains('loading')) {
                proceedCheckoutBtn.classList.remove('loading');
                proceedCheckoutBtn.innerHTML = originalCheckoutText;
                proceedCheckoutBtn.style.pointerEvents = 'auto';
                proceedCheckoutBtn.removeAttribute('aria-disabled');
            }
        });
    }
    // ========================================
    // End Loading State for Non-Form Actions
    // ========================================

    // ========================================
    // Homepage Banner Slider Logic            <--- NEW SECTION
    // ========================================
    const sliderContainer = document.querySelector('[data-slider-container]');
    if (sliderContainer) {
        const slides = sliderContainer.querySelectorAll('[data-slide]');
        const prevBtn = sliderContainer.querySelector('[data-slider-prev]');
        const nextBtn = sliderContainer.querySelector('[data-slider-next]');
        const dotsContainer = sliderContainer.querySelector('[data-slider-dots]');
        const dots = dotsContainer ? dotsContainer.querySelectorAll('[data-slide-to]') : [];

        let currentSlideIndex = 0;
        let autoSlideInterval = null;
        const slideIntervalTime = 5000; // Time in ms (e.g., 5 seconds)

        function showSlide(index) {
            if (!slides || slides.length === 0) return; // Exit if no slides

            // Wrap index around if it goes out of bounds
            const newIndex = (index + slides.length) % slides.length;

            slides.forEach((slide, i) => {
                slide.classList.remove('active');
            });
            dots.forEach(dot => {
                dot.classList.remove('active');
            });

            slides[newIndex].classList.add('active');
            if (dots[newIndex]) {
                dots[newIndex].classList.add('active');
            }
            currentSlideIndex = newIndex;
        }

        function nextSlide() {
            showSlide(currentSlideIndex + 1);
        }

        function prevSlide() {
            showSlide(currentSlideIndex - 1);
        }

        function startAutoSlide() {
            // Clear any existing interval before starting a new one
            clearInterval(autoSlideInterval);
            if (slides.length > 1) { // Only auto-slide if more than one banner
                autoSlideInterval = setInterval(nextSlide, slideIntervalTime);
            }
        }

        // Initial setup
        if (slides.length > 0) {
             showSlide(0); // Show the first slide initially
             startAutoSlide(); // Start automatic sliding
        }

        // Event Listeners for Arrows
        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                nextSlide();
                startAutoSlide(); // Reset interval on manual click
            });
        }
        if (prevBtn) {
            prevBtn.addEventListener('click', () => {
                prevSlide();
                startAutoSlide(); // Reset interval on manual click
            });
        }

        // Event Listener for Dots
        if (dotsContainer) {
            dotsContainer.addEventListener('click', (e) => {
                const targetDot = e.target.closest('[data-slide-to]');
                if (targetDot) {
                    const index = parseInt(targetDot.dataset.slideTo, 10);
                    if (!isNaN(index)) {
                        showSlide(index);
                        startAutoSlide(); // Reset interval on manual click
                    }
                }
            });
        }

        // Pause on Hover
        sliderContainer.addEventListener('mouseenter', () => {
            clearInterval(autoSlideInterval);
        });

        sliderContainer.addEventListener('mouseleave', () => {
            startAutoSlide();
        });

    } // End if (sliderContainer)
    // ========================================
    // End Homepage Banner Slider Logic
    // ========================================


}); // End DOMContentLoaded


// --- Cart Update AJAX Function ---
async function updateCartItemQuantityAJAX(productId, quantity, buttonElement, quantityInputElement) { // Pass input el
     const originalButtonText = 'Update';
     const loadingButtonText = '<i class="fas fa-spinner fa-spin"></i>';
     const cartItemDiv = buttonElement.closest('.cart-item');

     buttonElement.disabled = true;
     buttonElement.innerHTML = loadingButtonText;
     if(quantityInputElement) quantityInputElement.readOnly = true;

    try {
        const response = await fetch('/user/cart/update', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', },
            body: JSON.stringify({ productId, quantity })
         });

        const data = await response.json(); // Always parse response

        if (!response.ok) {
            throw new Error(data.message || `Update failed (Status: ${response.status})`);
        }

         // --- Show toast AFTER response is received ---
         if (data.success) {
             // Update original value dataset if successful
             if(quantityInputElement) quantityInputElement.dataset.originalValue = data.newQuantity;

             if (quantity === 0) {
                 // Handle removal animation and DOM update
                if (cartItemDiv) {
                    cartItemDiv.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease, border 0.3s ease';
                    cartItemDiv.style.opacity = '0';
                    cartItemDiv.style.height = '0';
                    cartItemDiv.style.paddingTop = '0';
                    cartItemDiv.style.paddingBottom = '0';
                    cartItemDiv.style.marginBottom = '0';
                    cartItemDiv.style.borderWidth = '0';
                    setTimeout(() => {
                        if (cartItemDiv.parentNode) {
                           cartItemDiv.remove();
                        }
                        updateCartTotalAndBadge(data.cartTotal);
                        handleEmptyCartDisplay();
                        showToast('Item removed from cart.', 'success'); // Show toast after removing
                    }, 300); // Wait for CSS transition
                     return; // Exit early
                }
             } else {
                 // Update quantity input and subtotal
                 const subtotalSpan = cartItemDiv?.querySelector('.item-subtotal-value');
                 if (subtotalSpan) subtotalSpan.textContent = (data.itemSubtotal !== undefined ? data.itemSubtotal : 0).toFixed(2);
                if(quantityInputElement) quantityInputElement.value = data.newQuantity;
                 // Update total and badge
                 updateCartTotalAndBadge(data.cartTotal);
                 // showToast('Cart quantity updated.', 'success'); // Optional success message
             }
         } else {
              // Show failure toast using backend message
              showToast(`Update failed: ${data.message || 'Unknown error'}`, 'danger');
              // Restore original value on backend failure
              if(quantityInputElement && quantityInputElement.dataset.originalValue) {
                  quantityInputElement.value = quantityInputElement.dataset.originalValue;
              }
         }

    } catch (error) {
         console.error('Error updating cart quantity:', error);
          // Show error toast
          showToast(`Error: ${error.message}`, 'danger');
          // Restore original value on fetch error
          if(quantityInputElement && quantityInputElement.dataset.originalValue) {
            quantityInputElement.value = quantityInputElement.dataset.originalValue;
          }

    } finally {
         // Re-enable button and input (unless item was removed)
         // Ensure this runs only if the item wasn't removed
         if (cartItemDiv && (!cartItemDiv.style.opacity || parseFloat(cartItemDiv.style.opacity) !== 0)) {
             buttonElement.disabled = false;
             buttonElement.innerHTML = originalButtonText;
             if(quantityInputElement) quantityInputElement.readOnly = false;
         }
     }
}

// --- Helper Function to Show Toasts Dynamically (FASTER APPEARANCE) ---
function showToast(message, type = 'info') {
    const toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
        console.error("Toast container not found! Falling back to alert.");
        alert(message); // Fallback
        return;
    }

    // Create elements
    const toastElement = document.createElement('div');
    toastElement.className = `toast toast-${type}`; // Apply classes
    toastElement.setAttribute('role', 'alert');
    toastElement.setAttribute('aria-live', 'assertive');
    toastElement.setAttribute('aria-atomic', 'true');

    // Basic sanitization - Replace with a more robust library (like DOMPurify) if needed for complex user-generated content
    const sanitizedMessage = typeof message === 'string'
        ? message.replace(/</g, "<").replace(/>/g, ">")
        : 'An unexpected error occurred.'; // Default message for non-strings

    // Set inner HTML safely
    toastElement.innerHTML = `
        <div class="toast-body">
            ${sanitizedMessage}
            <button type="button" class="toast-close-btn" aria-label="Close">Ã—</button>
        </div>
    `;

    const closeButton = toastElement.querySelector('.toast-close-btn');
    toastContainer.appendChild(toastElement);

    // --- Logic to show and hide the new toast ---
    const autoHideDelay = 5000;
    let hideTimeoutId;

    const dismissToast = () => {
        clearTimeout(hideTimeoutId);
        // Check if already hiding or removed to prevent errors/multiple executions
        if (toastElement.classList.contains('hide') || !toastElement.parentNode) return;
        toastElement.classList.remove('show');
        toastElement.classList.add('hide');
        toastElement.addEventListener('transitionend', (event) => {
            // Ensure transition is for opacity/transform and element still exists with 'hide' class
            if ((event.propertyName === 'opacity' || event.propertyName === 'transform') && toastElement.classList.contains('hide') && toastElement.parentNode) {
                toastElement.remove();
            }
        }, { once: true }); // Use 'once' to ensure listener is removed after firing
    };

    // Show animation (using setTimeout 0 for immediate trigger)
    setTimeout(() => {
        // Check if element is still in DOM before adding 'show'
        if (toastElement.parentNode) {
           toastElement.classList.add('show');
        }
    }, 0); // Minimal delay

    // Auto Hide Timer
    hideTimeoutId = setTimeout(dismissToast, autoHideDelay);

    // Manual Close Button
    if (closeButton) { // Check if button exists
        closeButton.addEventListener('click', dismissToast);
    }

    // Prevent auto-hide on hover
    toastElement.addEventListener('mouseenter', () => clearTimeout(hideTimeoutId));
    toastElement.addEventListener('mouseleave', () => hideTimeoutId = setTimeout(dismissToast, autoHideDelay / 2)); // Restart timer on mouse out
}


// --- Helper Functions for Cart Badge and Empty Display ---
function updateCartTotalAndBadge(newCartTotal) {
     const cartTotalSpan = document.getElementById('cart-total-value');
     if (cartTotalSpan) cartTotalSpan.textContent = (newCartTotal !== undefined ? newCartTotal : 0).toFixed(2);

     const newCartItemCount = calculateNewCartCount();
     const cartBadge = document.querySelector('.cart-badge');
     if (cartBadge) {
         if (newCartItemCount > 0) {
             cartBadge.textContent = newCartItemCount;
             cartBadge.classList.remove('hide');
         } else {
            cartBadge.textContent = '0';
            cartBadge.classList.add('hide');
         }
     }
}

function calculateNewCartCount() {
    // Count only items currently visible and not marked for removal
    const cartItems = document.querySelectorAll('.cart-item');
    let count = 0;
    cartItems.forEach(item => {
        // Check opacity style directly for cross-browser compatibility during transition
        const style = window.getComputedStyle(item);
        if (style.display !== 'none' && parseFloat(style.opacity) > 0) {
            const quantityInput = item.querySelector('input[name="quantity"]');
            if (quantityInput) {
                const value = parseInt(quantityInput.value, 10);
                if (!isNaN(value) && value > 0) {
                    // Update count based on the QUANTITY of each item
                    count += value; // THIS IS THE KEY CHANGE - SUM QUANTITIES, NOT ITEMS
                }
            }
        }
    });
    return count;
}

function handleEmptyCartDisplay() {
    const cartItemsContainer = document.querySelector('.cart-items');
     const cartContainer = document.querySelector('.cart-container');
     const cartSummary = document.querySelector('.cart-summary');

     // Check if the items container exists and has no *cart-item* children left
     // or only children that are hidden/fading out
     if (cartItemsContainer && cartContainer) {
         const visibleItems = Array.from(cartItemsContainer.querySelectorAll('.cart-item')).filter(item => {
             const style = window.getComputedStyle(item);
             return style.display !== 'none' && parseFloat(style.opacity) > 0;
         });

         if (visibleItems.length === 0) {
             // Use innerHTML carefully, ensure no user input is directly included here
             cartContainer.innerHTML = `
                <h1>Your Shopping Cart</h1>
                <p class="alert alert-info mt-3">
                    Your cart is empty. <a href="/" class="alert-link">Continue Shopping</a>
                </p>`;
             if(cartSummary) cartSummary.remove();
         }
     }
}

routes/adminRoutes.js:
// routes/adminRoutes.js
const express = require('express');
const adminController = require('../controllers/adminController');
const { isAuthenticated } = require('../middleware/authMiddleware');
const { isAdmin } = require('../middleware/roleMiddleware'); // Use specific admin check

const router = express.Router();

// Apply authentication and admin check to ALL routes in this file
router.use(isAuthenticated, isAdmin);

// Dashboard
router.get('/dashboard', adminController.getAdminDashboard);

// --- Category Management (Admin - NEW) ---
router.get('/manage-categories', adminController.getManageCategoriesPage); // List categories
router.get('/categories/new', adminController.getAddCategoryPage);         // Show add form
router.post('/categories/new', adminController.addCategory);               // Handle add form submission
router.get('/categories/edit/:id', adminController.getEditCategoryPage);    // Show edit form
router.post('/categories/update/:id', adminController.updateCategory);      // Handle edit form submission
router.post('/categories/delete/:id', adminController.deleteCategory);      // Handle delete category

// --- Product Management (Admin) ---
router.get('/upload-product', adminController.getUploadProductPage);
router.post('/upload-product', adminController.uploadProduct);
router.get('/manage-products', adminController.getManageProductsPage);
router.get('/manage-products/edit/:id', adminController.getEditProductPage);
router.post('/manage-products/update/:id', adminController.updateProduct);
router.post('/manage-products/remove/:id', adminController.removeProduct);

// --- Order Management (Admin) ---
router.get('/manage-orders', adminController.getManageOrdersPage);
router.post('/orders/:orderId/send-direct-delivery-otp', adminController.sendDirectDeliveryOtpByAdmin);
router.post('/orders/:orderId/confirm-direct-delivery', adminController.confirmDirectDeliveryByAdmin);
router.post('/orders/:orderId/cancel', adminController.cancelOrderByAdmin);

// --- User Management ---
router.get('/manage-users', adminController.getManageUsersPage);
router.post('/users/:id/update-role', adminController.updateUserRole);
router.post('/users/:id/remove', adminController.removeUser);

// --- Banner Management ---
router.get('/manage-banners', adminController.getManageBannersPage);
router.post('/manage-banners', adminController.updateBanners);


module.exports = router;

routes/authRoutes.js:
const express = require('express');
const authController = require('../controllers/authController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.get('/login', authController.getLoginPage);
router.get('/register', authController.getRegisterPage);
router.get('/verify-otp', authController.getVerifyOtpPage);
router.get('/forgot-password', authController.getForgotPasswordPage);
router.get('/reset-password/:token', authController.getResetPasswordPage);

router.post('/register', authController.registerUser);
router.post('/login', authController.loginUser);
 router.post('/logout', isAuthenticated, authController.logoutUser);
router.post('/verify-otp', authController.verifyOtp);
 router.post('/resend-otp', authController.resendOtp);

router.post('/forgot-password', authController.forgotPassword);
router.post('/reset-password/:token', authController.resetPassword);


module.exports = router;


routes/index.js:
// routes/index.js
const express = require('express');
const authRoutes = require('./authRoutes');
const productRoutes = require('./productRoutes');
const userRoutes = require('./userRoutes');
const orderRoutes = require('./orderRoutes');
const adminRoutes = require('./adminRoutes');
const sellerRoutes = require('./sellerRoutes'); // *** IMPORT Seller Routes ***
const { getHomePage } = require('../controllers/authController'); // Home page controller

const router = express.Router();

// --- Public Routes ---
router.get('/', getHomePage);           // Home page (shows approved products)
router.use('/auth', authRoutes);        // Login, Register, Forgot Pwd, OTP Verify, etc.
router.use('/products', productRoutes); // Public product list (approved) & details (permission checked)

// --- Authenticated User Routes ---
// Middleware inside these route files ensure user is logged in
router.use('/user', userRoutes);        // Profile, Cart, Checkout, Address
router.use('/orders', orderRoutes);     // Place Order, My Orders

// --- Role-Specific Routes ---
// Middleware inside these files ensures correct role (and authentication)
router.use('/admin', adminRoutes);      // Admin actions
router.use('/seller', sellerRoutes);    // *** USE Seller Routes ***

module.exports = router;

routes/orderRoutes.js:
const express = require('express');
const orderController = require('../controllers/orderController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.use(isAuthenticated);

router.post('/place', orderController.placeOrder);

router.get('/my-orders', orderController.getMyOrders);

 router.post('/cancel/:id', orderController.cancelOrder);

module.exports = router;


routes/productRoutes.js:
// routes/productRoutes.js
const express = require('express');
const productController = require('../controllers/productController');
 const { isAuthenticated } = require('../middleware/authMiddleware'); // Needed only for rating

const router = express.Router();

// --- NEW: Route for product suggestions ---
// Needs to be defined BEFORE the '/:id' route
router.get('/suggestions', productController.getProductSuggestions);

// Public routes - controllers ensure visibility rules (e.g., only 'approved')
router.get('/', productController.getProducts);         // List/Search approved, in-stock products
router.get('/:id', productController.getProductDetails); // Show product details (controller checks status/permissions)

// Rating requires user to be logged in
router.post('/:id/rate', isAuthenticated, productController.rateProduct);

module.exports = router;

routes/userRoutes.js:
// routes/userRoutes.js
const express = require('express');
const userController = require('../controllers/userController');
const { isAuthenticated } = require('../middleware/authMiddleware'); // Protect user-specific routes

const router = express.Router();

// Apply isAuthenticated middleware to all routes in this file
router.use(isAuthenticated);

// User Profile
router.get('/profile', userController.getUserProfilePage);
router.post('/profile/update-name', userController.updateUserName); // *** ADDED THIS LINE ***

// User Cart Management
router.get('/cart', userController.getCart);                // View cart (controller filters unapproved)
router.post('/cart/add', userController.addToCart);         // Add to cart (controller checks approval)
router.post('/cart/update', userController.updateCartQuantity); // Update quantity (controller checks approval/stock)
router.post('/cart/remove/:productId', userController.removeFromCart); // Remove from cart

// Address Management
router.post('/address/save', userController.saveAddress); // Save shipping address

// Checkout Process
router.get('/checkout', userController.getCheckoutPage);  // View checkout page (controller validates cart)

module.exports = router;

routes/sellerRoutes.js:
// routes/sellerRoutes.js
const express = require('express');
const sellerController = require('../controllers/sellerController');
const { isAuthenticated } = require('../middleware/authMiddleware');
// Import relevant role/ownership middleware
const { isSeller, isProductOwner, isOrderRelevantToSeller } = require('../middleware/roleMiddleware');

const router = express.Router();

// Apply authentication and seller check to ALL routes in this file
router.use(isAuthenticated, isSeller);

// Seller Dashboard
router.get('/dashboard', sellerController.getSellerDashboard);

// Seller Product Management
router.get('/products/upload', sellerController.getUploadProductPage); // Page to show upload form
router.post('/products/upload', sellerController.uploadProduct); // Handle product submission (triggers review)
router.get('/products', sellerController.getManageProductsPage); // List *only* this seller's products (incl. status)

// Actions requiring ownership of the specific product ID
// isProductOwner middleware runs AFTER isAuthenticated and isSeller
router.get('/products/edit/:id', isProductOwner, sellerController.getEditProductPage); // Get edit form for OWN product
router.post('/products/update/:id', isProductOwner, sellerController.updateProduct); // Handle update of OWN product (triggers re-review)
router.post('/products/remove/:id', isProductOwner, sellerController.removeProduct); // Handle removal of OWN product

// Seller Order Management
router.get('/orders', sellerController.getManageOrdersPage); // List orders containing *any* of this seller's products

// Actions requiring relevance to the specific order ID
// isOrderRelevantToSeller middleware runs AFTER isAuthenticated and isSeller
router.post('/orders/:orderId/send-otp', isOrderRelevantToSeller, sellerController.sendDirectDeliveryOtpBySeller); // Seller sends OTP for relevant orders
router.post('/orders/:orderId/confirm-delivery', isOrderRelevantToSeller, sellerController.confirmDirectDeliveryBySeller); // Seller confirms delivery for relevant orders

// --- NEW: Seller Cancel Order Route ---
router.post('/orders/:orderId/cancel', isOrderRelevantToSeller, sellerController.cancelOrderBySeller);

module.exports = router;

services/otpService.js:
// services/otpService.js
const crypto = require('crypto');

/**
 * Generates a random numeric OTP code of a specified length.
 * @param {number} [length=6] - The desired length of the OTP.
 * @returns {string} The generated OTP code.
 */
const generateOTP = (length = 6) => {
  // More robust generation ensuring target length even with non-numeric hex chars
  if (length <= 0) throw new Error('OTP length must be positive');
  const chars = '0123456789';
  let otp = '';
  const randomBytes = crypto.randomBytes(length); // Generate sufficient random bytes
  for (let i = 0; i < length; i++) {
    const randomIndex = randomBytes[i] % chars.length;
    otp += chars[randomIndex];
  }
  return otp;
};

/**
 * Calculates the expiration timestamp for an OTP.
 * @param {number} [minutes=10] - The duration in minutes until the OTP expires.
 * @returns {Date} The expiration date object.
 */
const setOTPExpiration = (minutes = 10) => {
  // Returns a Date object representing the expiration time
  return new Date(Date.now() + minutes * 60 * 1000);
};

module.exports = { generateOTP, setOTPExpiration };

services/geminiService.js:
// services/geminiService.js
const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = require("@google/generative-ai");
const axios = require('axios');
// ** IMPORT the Category model **
const Category = require('../models/Category');

const API_KEY = process.env.GEMINI_API_KEY;

if (!API_KEY) {
    console.warn("GEMINI_API_KEY is not set in .env file. Gemini features will be disabled.");
}

const genAI = API_KEY ? new GoogleGenerativeAI(API_KEY) : null;
// ** Make sure you're using a vision-capable model **
const visionModel = genAI ? genAI.getGenerativeModel({ model: "gemini-2.0-flash" }) : null; // Using gemini-1.5-flash as it's generally available and vision capable

// Standard Safety Settings (Adjust thresholds as needed for your specific use case)
const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
];


if (genAI && visionModel) {
    console.log("Gemini AI SDK Initialized successfully with Vision model.");
} else {
     console.log("Gemini AI SDK Vision model could not be initialized (API Key missing or configuration error?).");
}

/**
 * Fetches an image from a URL and converts it to a Gemini GenerativePart object.
 * @param {string} url The URL of the image.
 * @returns {Promise<object|null>} A promise that resolves to the GenerativePart object or null on error.
 */
async function urlToGenerativePart(url) {
    console.log(`Fetching image from: ${url}`);
    try {
        const response = await axios.get(url, {
            responseType: 'arraybuffer', // Get image data as a buffer
            timeout: 15000 // Increased timeout to 15 seconds
        });

        // Check status first
        if (response.status !== 200) {
            console.warn(`urlToGenerativePart: HTTP error status ${response.status} for URL: ${url}`);
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const contentType = response.headers['content-type']?.toLowerCase();
        const supportedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/heic', 'image/heif'];

        // Check content type validity
        if (!contentType || !supportedTypes.includes(contentType)) {
            console.warn(`urlToGenerativePart: Invalid or unsupported image Content-Type: ${contentType} from URL: ${url}`);
            throw new Error(`Unsupported image type: ${contentType || 'Unknown'}. Supported types: ${supportedTypes.join(', ')}`);
        }

        // Check buffer size (e.g., limit to ~4MB, Gemini API limit)
        const MAX_SIZE_BYTES = 4 * 1024 * 1024; // ~4MB
        if (response.data.length > MAX_SIZE_BYTES) {
            console.warn(`urlToGenerativePart: Image size (${(response.data.length / (1024 * 1024)).toFixed(2)}MB) exceeds limit for URL: ${url}`);
            throw new Error(`Image size exceeds the limit of ${MAX_SIZE_BYTES / (1024 * 1024)}MB.`);
        }
        if (response.data.length === 0) {
            console.warn(`urlToGenerativePart: Image data buffer is empty for URL: ${url}`);
             throw new Error(`Image data is empty.`);
         }


        const base64Data = Buffer.from(response.data).toString('base64');

        return {
            inlineData: {
                data: base64Data,
                mimeType: contentType,
            },
        };
    } catch (error) {
         // Log specific Axios error details if available
         console.error(`Error processing image from ${url}: ${error.message}`);
         if (axios.isAxiosError(error)) {
             let detail = '';
             if (error.response) {
                 detail = `Server responded with status ${error.response.status}`;
             } else if (error.request) {
                  detail = `No response received (Timeout: ${error.config?.timeout}ms or network issue)`;
             } else {
                 detail = `Request setup error (${error.message})`;
             }
              console.error(`Axios Error Detail: ${detail}`);
              // Throw a more specific error message
              throw new Error(`Failed to fetch/process image: ${detail}`);
         } else {
              // Re-throw generic errors or errors from size/type checks
              throw error;
         }
    }
}

/**
 * Reviews a product's details and image using Gemini Vision model.
 * @param {object} product The product object from MongoDB (should ideally have categoryName populated).
 * @returns {Promise<{status: string, reason: string|null}>} Object with review status ('approved', 'rejected', 'pending') and optional reason.
 */
const reviewProductWithGemini = async (product) => {
    // Guard clause if Gemini is not initialized
    if (!visionModel) {
        console.log("Gemini Vision model not available. Skipping review, defaulting to 'pending'.");
        return { status: 'pending', reason: 'Gemini Vision service unavailable.' };
    }

    // Destructure product fields - categoryRef is needed as fallback
    const { _id, name, categoryRef, categoryName, price, description, specifications, imageUrl } = product;

    // Log entry point
    console.log(`Starting Gemini Vision review for product "${name}" (ID: ${_id})`);

    let imagePart;
    try {
        imagePart = await urlToGenerativePart(imageUrl);
        // We already throw errors inside urlToGenerativePart if critical issues occur
        console.log(`Successfully prepared image part for "${name}" (${_id}).`);
    } catch (imageError) {
        console.error(`Cannot review product "${name}" (${_id}) due to image processing error: ${imageError.message}`);
        // Provide a user-friendly reason for rejection
        return { status: 'rejected', reason: `Image Error: Failed to load or process image. ${imageError.message}` };
    }

    // --- Determine Category Name for Review ---
    let categoryNameToReview = categoryName; // Prefer the name already on the product object

    // Fallback: If categoryName isn't populated/available, fetch it using categoryRef
    if (!categoryNameToReview && categoryRef) {
        console.warn(`Product "${name}" (${_id}) provided without categoryName populated. Fetching from DB using ref: ${categoryRef}`);
        try {
            const categoryDoc = await Category.findById(categoryRef).select('name').lean();
            if (categoryDoc && categoryDoc.name) {
                 categoryNameToReview = categoryDoc.name;
                 console.log(`Successfully fetched category name "${categoryNameToReview}" for product "${name}" (${_id}).`);
            } else {
                // Category ID exists but document not found or has no name
                console.error(`Gemini Review: Category document not found or missing name for ID ${categoryRef} (Product: "${name}", ID: ${_id})`);
                 categoryNameToReview = 'Invalid/Missing Category'; // Use a clear fallback
                 // Optionally, could reject immediately here
                 // return { status: 'rejected', reason: 'Invalid category associated with product.' };
            }
        } catch (catError) {
            console.error(`Gemini Review: Error fetching category ${categoryRef} for product "${name}" (${_id}):`, catError);
            // Consider this a temporary failure - mark as pending? Or reject?
            // Let's default to pending with a note about the category fetch error.
             return { status: 'pending', reason: `AI review failed: Could not verify category (${catError.message}).` };
        }
    } else if (!categoryNameToReview && !categoryRef) {
         console.error(`Gemini Review: Product "${name}" (${_id}) has neither categoryName nor categoryRef.`);
         categoryNameToReview = 'No Category Specified';
         // Could reject immediately:
         // return { status: 'rejected', reason: 'Product is missing required category information.' };
     }

    // --- Construct the Text Prompt ---
    const textPrompt = `
        Analyze the following product details AND the provided image for an e-commerce store. Act as a strict content moderator.

        **Instructions:**
        1. Examine the IMAGE CONTENT closely for prohibited items, safety concerns, and relevance.
        2. Examine the TEXT DETAILS (Name, Category, Description, Price, Specifications) for appropriateness, legitimacy, and relevance.
        3. **Crucially Verify:** Does the image VISUALLY AND CLEARLY MATCH the product described by the text (name, category: "${categoryNameToReview || 'N/A'}", key features in description/specs)? Misleading images are grounds for rejection.
        4. Check BOTH image and text strictly for:
            - Explicit content (nudity, graphic violence).
            - Real weapons (unless the category is strictly controlled, like 'Hunting Gear', and depicted appropriately; toy weapons must be clearly identifiable as toys in image AND text/category).
            - Illegal items or substances.
            - Hate speech, hateful symbols, harassment.
            - Content promoting dangerous acts.
            - Counterfeit indicators (if obvious from text/image).
            - Generally unsafe or harmful content.
        5. Check if the text details are legitimate:
            - Is the name/description coherent, relevant, and not misleading or nonsensical?
            - Is the price realistic for the item described in "${categoryNameToReview || 'N/A'}" category (reject clearly absurd prices like â‚¹1 for a car, but allow sale prices)?
            - Does the provided Category ("${categoryNameToReview || 'N/A'}") accurately fit the product shown in the image and described in the text?
        6. **Bias Check**: Ensure the review is based on policy violation, not personal preference or cultural bias.
        7. **Response Format**: Respond ONLY with "APPROVE" or "REJECT: [BRIEF_REASON]". The reason should be concise and informative.
        8. **Default to Rejection**: If unsure about safety, legitimacy, or image match, lean towards REJECT with a clear reason.

        **Product Details (Text):**
        - Name: ${name || '[MISSING NAME]'}
        - Category: ${categoryNameToReview || '[MISSING CATEGORY]'}
        - Description: ${description || 'Not provided'}
        - Price: â‚¹${typeof price === 'number' ? price.toFixed(2) : '[MISSING PRICE]'}
        - Specifications: ${specifications || 'Not provided'}
        - Provided Image URL: ${imageUrl || '[MISSING IMAGE URL]'}

        **Analysis Task:** Based on ALL instructions and checks above:
        Respond ONLY with "APPROVE" or "REJECT: [CONCISE_REASON]".

        Your response:`;

    const textPart = { text: textPrompt };
    const generationConfig = {
        // temperature: 0.3, // Lower temperature for more deterministic classification
        maxOutputTokens: 100 // Limit response length
    };

    // --- Perform Gemini API Call ---
    try {
        console.log(`Sending product "${name}" (ID: ${_id}) for Gemini Vision review with final category: "${categoryNameToReview}"...`);
        const result = await visionModel.generateContent(
            [textPart, imagePart], // Ensure imagePart is valid here
            { safetySettings, generationConfig } // Pass safety settings and config
        );
        const response = result?.response; // Optional chaining

        // Handle potential safety blocks from the API response
        if (!response || response.promptFeedback?.blockReason) {
           const blockReason = response?.promptFeedback?.blockReason || 'Unknown safety reason';
           const safetyRatings = response?.promptFeedback?.safetyRatings || []; // Might provide more detail
           console.warn(`Gemini review for "${name}" (ID: ${_id}) blocked by API. Reason: ${blockReason}. Ratings: ${JSON.stringify(safetyRatings)}`);
           return { status: 'rejected', reason: `Content blocked by AI safety filters (${blockReason}). Please revise content.` };
        }

        // Get the text response and clean it
        const reviewText = response?.text()?.trim().toUpperCase() || '';
        console.log(`Gemini Vision Raw Response for "${name}" (ID: ${_id}): ${reviewText}`);

        // Parse the response
        if (reviewText.startsWith('APPROVE')) {
            console.log(`Gemini Vision APPROVED product: "${name}" (ID: ${_id})`);
            return { status: 'approved', reason: null };
        } else if (reviewText.startsWith('REJECT')) {
            // Extract reason, provide a fallback if formatting is unexpected
            const reason = reviewText.substring('REJECT:'.length).trim() || 'Rejected by AI model (no specific reason provided).';
            console.log(`Gemini Vision REJECTED product: "${name}" (ID: ${_id}). Reason: ${reason}`);
            return { status: 'rejected', reason: reason };
        } else {
            // Handle unexpected response format
            console.warn(`Unexpected Gemini Vision response format for "${name}" (ID: ${_id}): "${reviewText}". Defaulting to pending.`);
            return { status: 'pending', reason: 'AI review result unclear or response format unexpected.' };
        }

    } catch (error) {
        // Handle errors during the API call itself
        console.error(`Error during Gemini Vision API call for product "${name}" (ID: ${_id}):`, error);
        let reason = 'AI review failed due to an API error.';
        // Check if it's a safety-related error from the client library/API
        if (error.message && (error.message.includes('SAFETY') || error.message.includes('blocked'))) {
            reason = 'Content blocked by AI safety filters during API call. Please revise content.';
        } else if (error.message) {
            // Provide a snippet of the error message
            reason = `AI API Error: ${error.message.substring(0, 150)}${error.message.length > 150 ? '...' : ''}`;
        }
        // Default to rejecting if the AI review process fails critically
        return { status: 'rejected', reason: reason };
    }
};

module.exports = { reviewProductWithGemini };

views/admin/dashboard.ejs:
<%- include('../partials/header', { title: 'Admin Dashboard' }) %>

<div class="admin-dashboard-container">
    <h1>Admin Dashboard</h1>
    <p class="text-muted mb-3">System-wide management access. Welcome, <%= currentUser.name %>!</p>

    <div class="admin-actions-grid">
        <%# --- NEW: Manage Categories Card --- %>
        <a href="/admin/manage-categories" class="admin-action-card">
             <i class="fas fa-tags text-purple"></i> <%# Example color class, define in CSS %>
             <h3>Manage Categories</h3>
             <p>Add, edit, or remove product categories.</p>
        </a>

         <a href="/admin/upload-product" class="admin-action-card">
            <i class="fas fa-upload text-primary"></i>
            <h3>Upload Product</h3>
            <p>Add a product directly to the system.</p>
        </a>
         <a href="/admin/manage-products" class="admin-action-card">
            <i class="fas fa-edit text-success"></i>
            <h3>Manage All Products</h3>
            <p>View, edit, remove products from any seller.</p>
         </a>
        <a href="/admin/manage-orders" class="admin-action-card">
             <i class="fas fa-clipboard-list text-info"></i>
             <h3>Manage All Orders</h3>
             <p>View, confirm delivery, or cancel any customer order.</p>
        </a>
        <a href="/admin/manage-users" class="admin-action-card">
             <i class="fas fa-users-cog text-warning"></i>
             <h3>Manage Users</h3>
             <p>Update roles (User, Seller, Admin), remove users.</p>
        </a>
         <a href="/admin/manage-banners" class="admin-action-card">
             <i class="fas fa-images text-secondary"></i>
             <h3>Manage Banners</h3>
             <p>Update the promotional banners on the homepage.</p>
         </a>
    </div>
</div>

<%# --- Optional CSS for new icon color --- %>
<style> .text-purple { color: #6f42c1; } </style>

 <%- include('../partials/footer') %>

views/admin/add-category.ejs:
<%# views/admin/add-category.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>

    <form action="/admin/categories/new" method="POST" class="form-submit-spinner" style="max-width: 600px;">
        <div class="form-group">
            <label for="name">Category Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= typeof category !== 'undefined' ? category.name : '' %>" required maxlength="50">
        </div>

        <div class="form-group">
            <label for="imageUrl">Image URL:</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" placeholder="https://example.com/category-image.jpg" value="<%= typeof category !== 'undefined' ? category.imageUrl : '' %>" required>
             <%# Optional: Add simple image preview on change/load %>
             <img id="imagePreview" src="#" alt="Image Preview" style="max-width: 100px; margin-top: 10px; display: none; border:1px solid #ccc; padding:2px;"/>
        </div>

        <button type="submit" class="btn btn-primary"><i class="fas fa-plus"></i> Add Category</button>
        <a href="/admin/manage-categories" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<script>
    // Simple image preview
    const imageUrlInput = document.getElementById('imageUrl');
    const imagePreview = document.getElementById('imagePreview');

    function updatePreview() {
        const url = imageUrlInput.value;
        if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
            imagePreview.src = url;
            imagePreview.style.display = 'block';
             // Optional: Check if image loads
            imagePreview.onerror = function() {
                 imagePreview.style.display = 'none';
                console.warn("Preview failed to load image URL.");
            }
        } else {
            imagePreview.style.display = 'none';
        }
    }

    if(imageUrlInput) {
         imageUrlInput.addEventListener('input', updatePreview);
        // Show preview on page load if URL exists
         if (imageUrlInput.value) {
            updatePreview();
         }
    }
</script>

<%- include('../partials/footer') %>

views/admin/edit-category.ejs:
<%# views/admin/edit-category.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>

    <form action="/admin/categories/update/<%= category._id %>" method="POST" class="form-submit-spinner" style="max-width: 600px;">
        <div class="form-group">
            <label for="name">Category Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= category.name %>" required maxlength="50">
        </div>

        <div class="form-group">
            <label for="imageUrl">Image URL:</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" value="<%= category.imageUrl %>" required>
             <img id="imagePreview" src="<%= category.imageUrl %>" alt="Current Image Preview" style="max-width: 100px; margin-top: 10px; display: block; border:1px solid #ccc; padding:2px;"/>
        </div>

         <p class="small text-muted">Created By: <%= category.createdBy?.name || 'N/A' %> on <%= formatDateIST(category.createdAt) %></p>

        <button type="submit" class="btn btn-primary"><i class="fas fa-save"></i> Update Category</button>
        <a href="/admin/manage-categories" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<script>
    // Simple image preview (same as add form)
    const imageUrlInput = document.getElementById('imageUrl');
    const imagePreview = document.getElementById('imagePreview');

    function updatePreview() {
        const url = imageUrlInput.value;
        if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
            imagePreview.src = url;
            imagePreview.style.display = 'block';
             imagePreview.onerror = function() {
                 imagePreview.style.display = 'none';
                 console.warn("Preview failed to load image URL.");
            }
        } else {
            imagePreview.style.display = 'none';
        }
    }
    if(imageUrlInput) {
         imageUrlInput.addEventListener('input', updatePreview);
    }
</script>

<%- include('../partials/footer') %>

views/admin/manage-categories.ejs:
<%# views/admin/manage-categories.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <a href="/admin/categories/new" class="btn btn-primary mb-3"><i class="fas fa-plus"></i> Add New Category</a>

    <% if (categories.length > 0) { %>
        <div class="table-container card">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Image</th>
                        <th>Name</th>
                        <th>Created By</th>
                        <th>Last Updated</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% categories.forEach(category => { %>
                        <tr>
                            <td data-label="Image">
                                <img src="<%= category.imageUrl %>" alt="<%= category.name %>" class="table-img" style="width: 50px; height: 50px; object-fit: cover;">
                            </td>
                            <td data-label="Name">
                                <%= category.name %> <br>
                                <small class="text-muted">Slug: <%= category.slug %></small>
                            </td>
                            <td data-label="Created By">
                                <% if (category.createdBy) { %>
                                    <%= category.createdBy.name %> <br>
                                    <small class="text-muted"><%= category.createdBy.email %></small>
                                <% } else { %>
                                    N/A
                                <% } %>
                            </td>
                            <td data-label="Last Updated">
                                <small>
                                    <%= formatDateIST(category.updatedAt) %><br>
                                    By: <%= category.lastUpdatedBy && category.lastUpdatedBy.name ? category.lastUpdatedBy.name : 'N/A' %>
                                </small>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <a href="/admin/categories/edit/<%= category._id %>" class="btn btn-text btn-sm" title="Edit Category">
                                    <i class="fas fa-edit"></i> Edit
                                </a>
                                <form action="/admin/categories/delete/<%= category._id %>" method="POST" class="inline-form form-submit-spinner"
                                    data-category-name="<%= category.name.replace(/"/g, '&quot;').replace(/'/g, '&#39;') %>"
                                    onsubmit="return confirmDeleteCategory(this);">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove Category">
                                        <i class="fas fa-trash"></i> Remove
                                    </button>
                                </form>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="alert alert-info mt-3">No categories found. <a href="/admin/categories/new">Add the first one!</a></p>
    <% } %>
</div>

<script>
    function confirmDeleteCategory(form) {
        const name = form.getAttribute('data-category-name');
        return confirm(`ADMIN ACTION: Are you sure you want to remove category "${name}"? This might fail if products are associated with it.`);
    }
</script>

<%- include('../partials/footer') %>


views/admin/manage-banners.ejs:
<%# views/admin/manage-banners.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Enter direct URLs for the images. Banners will appear on the homepage if URLs are provided.</p>

    <form action="/admin/manage-banners" method="POST" class="form-submit-spinner">
        <% bannerConfig.banners.forEach((banner, index) => { %>
            <fieldset class="mb-4 border p-3 rounded"> <%# Group banner fields %>
                <legend class="h5">Banner <%= index + 1 %></legend>
                <div class="form-group">
                    <label for="imageUrl<%= index + 1 %>">Image URL <%= index + 1 %>:</label>
                    <input type="url" id="imageUrl<%= index + 1 %>" name="imageUrl<%= index + 1 %>" class="form-control" value="<%= banner.imageUrl %>" placeholder="https://example.com/banner<%= index + 1 %>.jpg">
                    <% if (banner.imageUrl) { %>
                        <img src="<%= banner.imageUrl %>" alt="Banner <%= index + 1 %> Preview" style="max-width: 200px; max-height: 75px; margin-top: 10px; border: 1px solid #ddd; padding: 2px; object-fit: contain;">
                    <% } else { %>
                         <small class="d-block mt-1 text-muted">No image set</small>
                    <% } %>
                </div>
                <div class="form-group">
                    <label for="linkUrl<%= index + 1 %>">Link URL <%= index + 1 %> (Optional):</label>
                    <input type="url" id="linkUrl<%= index + 1 %>" name="linkUrl<%= index + 1 %>" class="form-control" value="<%= banner.linkUrl %>" placeholder="https://example.com/category/offers">
                    <% if (banner.linkUrl) { %>
                       <small class="d-block mt-1 text-muted">Clicks to: <%= banner.linkUrl %></small>
                   <% } %>
                </div>
                <div class="form-group">
                    <label for="title<%= index + 1 %>">Title/Alt Text <%= index + 1 %> (Optional):</label>
                    <input type="text" id="title<%= index + 1 %>" name="title<%= index + 1 %>" class="form-control" value="<%= banner.title %>" placeholder="e.g., Special Summer Sale">
                </div>
             </fieldset>
        <% }) %>

        <button type="submit" class="btn btn-primary"><i class="fas fa-save"></i> Save Banners</button>
        <a href="/admin/dashboard" class="btn btn-secondary">Back to Dashboard</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/admin/edit-product.ejs:
<%# views/admin/edit-product.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p>Admin editing view for product originally uploaded by <%= product.sellerId ? product.sellerId.email : 'Unknown Seller' %>.</p>

    <form action="/admin/manage-products/update/<%= product._id %>" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= product.name %>" required>
        </div>

        <%# --- MODIFIED: Category Dropdown --- %>
        <div class="form-group">
            <label for="categoryRef">Category:</label>
            <select id="categoryRef" name="categoryRef" class="form-control" required>
                <option value="" disabled>-- Select a Category --</option>
                 <% if (locals.categories && categories.length > 0) { %>
                    <% categories.forEach(cat => { %>
                        <%# IMPORTANT: Compare categoryRef._id if populated, otherwise compare strings %>
                        <% const currentCategoryId = product.categoryRef?._id?.toString() || product.categoryRef?.toString(); %>
                        <option value="<%= cat._id %>" <%= (currentCategoryId === cat._id.toString()) ? 'selected' : '' %>>
                             <%= cat.name %>
                         </option>
                    <% }) %>
                 <% } else { %>
                      <option value="" disabled>No categories available</option>
                  <% } %>
            </select>
             <% if (!locals.categories || categories.length === 0) { %>
                 <small class="text-danger d-block mt-1">Cannot update products without categories. Please <a href="/admin/manage-categories">add categories</a> first.</small>
             <% } %>
        </div>
        <%# --- End Modification --- %>

        <div class="form-group">
            <label for="description">Description:</label>
            <textarea id="description" name="description" class="form-control" rows="4"><%= product.description || '' %></textarea>
        </div>
        <div class="form-group">
            <label for="price">Price (â‚¹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= product.price %>" required>
        </div>
        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= product.stock %>" required>
        </div>
        <div class="form-group">
            <label for="imageUrl">Image URL:</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" value="<%= product.imageUrl %>" required>
            <% if (product.imageUrl) { %>
                <img src="<%= product.imageUrl %>" alt="Current Image" style="max-width: 100px; margin-top: 5px; border:1px solid #ccc; padding:2px;">
            <% } %>
        </div>
        <div class="form-group">
            <label for="specifications">Specifications:</label>
            <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= product.specifications || '' %></textarea>
        </div>

        <hr>
        <h4>Admin Review Control</h4>
        <div class="form-group">
            <label for="reviewStatus">Review Status:</label>
            <select id="reviewStatus" name="reviewStatus" class="form-control" onchange="toggleRejectionReason(this.value)">
                <option value="pending" <%= product.reviewStatus === 'pending' ? 'selected' : '' %>>Pending</option>
                <option value="approved" <%= product.reviewStatus === 'approved' ? 'selected' : '' %>>Approved</option>
                <option value="rejected" <%= product.reviewStatus === 'rejected' ? 'selected' : '' %>>Rejected</option>
            </select>
        </div>
        <div class="form-group" id="rejectionReasonGroup" <%= product.reviewStatus !== 'rejected' ? 'style="display: none;"' : '' %>>
            <label for="rejectionReason">Rejection Reason (Required if Rejected):</label>
            <textarea id="rejectionReason" name="rejectionReason" rows="3" class="form-control"><%= product.rejectionReason || '' %></textarea>
        </div>

        <button type="submit" class="btn btn-primary" <%= (!locals.categories || categories.length === 0) ? 'disabled' : '' %>>
            Update Product (Admin)
        </button>
        <a href="/admin/manage-products" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<script>
    function toggleRejectionReason(status) { /* Keep existing script */ }
    document.addEventListener('DOMContentLoaded', () => { /* Keep existing script */ });
</script>

<%- include('../partials/footer') %>


views/admin/manage-orders.ejs:
<%# views/admin/manage-orders.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container order-manage-page"> <%# Added 'order-manage-page' class %>
    <h1><%= title %></h1>

    <% if (orders.length > 0) { %>
        <div class="table-container">
            <table class="data-table order-table">
                <thead>
                    <tr>
                        <th>Details</th>
                        <th>Customer</th>
                        <th>Items</th>
                        <th>Total</th>
                        <th>Status</th>
                        <th class="actions-cell">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% orders.forEach(order => { %>
                        <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %>" data-order-id="<%= order._id %>">
                            <td data-label="Details">
                                <strong>ID:</strong> <%= order._id %><br>
                                <small class="text-muted"><%= formatDateIST(order.orderDate) %></small><br>
                                <% if (order.products && order.products.length > 0 && order.products[0].productId && order.products[0].productId.sellerId) { %>
                                    <small class="text-muted">Contains items from seller(s)</small>
                                <% } %>
                            </td>
                            <td data-label="Customer">
                                <strong><%= order.shippingAddress.name %></strong><br>
                                <small class="text-muted"><%= order.userEmail || order.userId?.email %></small><br>
                                <small><%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %></small><br>
                                <small><strong>Ph:</strong> <%= order.shippingAddress.phone %></small>
                            </td>
                            <td data-label="Items">
                                <div class="order-items-summary">
                                    <%- order.itemsSummary %>
                                </div>
                                <% if (order.products && order.products.length > 0) { %>
                                    <div class="order-items-images">
                                        <% order.products.forEach(item => { %>
                                            <% if (item.productId && item.productId._id && item.productId.imageUrl) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" title="View <%= item.productId.name || 'Product' %>">
                                                    <img src="<%= item.productId.imageUrl %>"
                                                         alt="<%= item.productId.name || 'Product Image' %>"
                                                         class="order-item-thumbnail" loading="lazy">
                                                </a>
                                            <% } else if (item.productId && item.productId._id) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" class="order-item-thumbnail-placeholder" title="View <%= item.productId.name || 'Product' %>">[No Img]</a>
                                            <% } else { %>
                                                <span class="order-item-thumbnail-placeholder" title="Product data missing">[N/A]</span>
                                            <% } %>
                                        <% }) %>
                                    </div>
                                <% } %>
                            </td>
                            <td data-label="Total" class="order-total"><strong>â‚¹<%= order.totalAmount.toFixed(2) %></strong></td>
                            <td data-label="Status" class="order-status-cell">
                                <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span>
                                <%# Display cancellation reason, whether from admin or seller %>
                                <% if(order.status === 'Cancelled' && order.cancellationReason) { %><br><small class="text-danger mt-1 d-block">Reason: <%= order.cancellationReason %></small><% } %>
                                <% if(order.status === 'Delivered' && order.receivedByDate) { %><br><small class="text-success mt-1 d-block">Delivered:<br><%= formatDateIST(order.receivedByDate) %></small><% } %>

                                <%# Display OTP Hint conditionally %>
                                <% if (order.showDeliveryOtp) { %>
                                  <div class="delivery-otp-display mt-1">
                                    <p>Customer OTP Sent</p>
                                    <%# Display partial OTP for security hint %>
                                    <small class="text-muted">Ask customer for code: <strong class="delivery-otp-code">****<%= order.orderOTP ? order.orderOTP.slice(-2) : 'XX' %></strong></small>
                                     <%# Display expiry time %>
                                     <% if (order.orderOTPExpires) { %>
                                         <small class="text-muted d-block">Expires: <%= formatDateIST(order.orderOTPExpires) %></small>
                                     <% } %>
                                  </div>
                                <% } %>
                                <%# End: Display OTP Hint %>

                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Admin Direct Delivery Confirmation %>
                                <% if (order.canBeDirectlyDeliveredByAdmin) { %>
                                    <div class="action-group mb-2">
                                        <p class="action-group-title">Direct Delivery:</p>
                                        <% if (!order.showDeliveryOtp) { %>
                                            <form action="/admin/orders/<%= order._id %>/send-direct-delivery-otp" method="POST" class="inline-form form-submit-spinner mb-1">
                                                <button type="submit" class="btn btn-warning btn-sm w-100 w-md-auto" title="Send OTP to customer for admin delivery">
                                                    <i class="fas fa-mobile-alt"></i> Send OTP
                                                </button>
                                            </form>
                                        <% } %>
                                        <form action="/admin/orders/<%= order._id %>/confirm-direct-delivery" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                            <input type="text" name="otp" placeholder="Enter OTP" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit OTP from customer">
                                            <button type="submit" class="btn btn-success btn-sm" title="Confirm direct delivery">
                                                <i class="fas fa-check-double"></i> Confirm
                                            </button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Admin Order Cancellation %>
                                <% if (order.canBeCancelledByAdmin) { %>
                                    <div class="action-group">
                                        <form action="/admin/orders/<%= order._id %>/cancel" method="POST" class="cancel-delivery-form form-submit-spinner" onsubmit="return confirm('ADMIN ACTION: Are you sure you want to cancel order <%= order._id %>? This cannot be undone.');">
                                            <label for="reason-<%= order._id %>" class="action-group-title">Cancel Order:</label>
                                            <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm d-block mb-1">
                                                <option value="" disabled selected>Select Admin Reason...</option>
                                                <% if (typeof cancellationReasons !== 'undefined' && cancellationReasons.length > 0) { %>
                                                    <% cancellationReasons.forEach(reason => { %>
                                                        <option value="<%= reason %>"><%= reason %></option>
                                                    <% }) %>
                                                <% } else { %>
                                                     <option value="Other (Admin)" selected>Other (Admin)</option> <%# Fallback %>
                                                <% } %>
                                            </select>
                                            <button type="submit" class="btn btn-danger btn-sm w-100 w-md-auto"><i class="fas fa-ban"></i> Cancel Order</button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Fallback for no actions %>
                                <% if (!order.canBeDirectlyDeliveredByAdmin && !order.canBeCancelledByAdmin) { %>
                                    <small class="text-muted no-actions-text">
                                        <% if (order.status === 'Delivered') { %>Completed<% } else if (order.status === 'Cancelled') { %>Cancelled<% } else { %>No admin actions<% } %>
                                    </small>
                                <% } %>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="alert alert-info">No orders received yet.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/admin/manage-products.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Showing all products from all sellers.</p>

    <% if (products.length > 0) { %>
        <div class="table-container card">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Image</th>
                        <th>Name / Category</th>
                        <th>Seller</th>
                        <th>Price / Stock</th>
                        <th>Status</th>
                        <th>Reason</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% products.forEach(product => { 
                        const productNameEsc = product.name.replace(/'/g, "\\'");
                        const sellerEmail = product.sellerId?.email || product.sellerEmail || 'Unknown';
                        const sellerEmailEsc = sellerEmail.replace(/'/g, "\\'");
                    %>
                        <tr class="status-<%= product.reviewStatus %>">
                            <td data-label="Image">
                                <a href="/products/<%= product._id %>">
                                    <img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="table-img">
                                </a>
                            </td>
                            <td data-label="Name / Category">
                                <%= product.name %><br>
                                <small class="text-muted"><%= product.category %></small>
                            </td>
                            <td data-label="Seller"><%= sellerEmail %></td>
                            <td data-label="Price / Stock">
                                â‚¹<%= product.price.toFixed(2) %><br>
                                <small>Stock: <%= product.stock %></small>
                            </td>
                            <td data-label="Status">
                                <span class="status-badge status-<%= product.reviewStatus %> text-capitalize">
                                    <%= product.reviewStatus %>
                                </span>
                            </td>
                            <td data-label="Reason">
                                <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %>
                                    <small class="text-danger" title="Rejection Reason"><%= product.rejectionReason %></small>
                                <% } else { %>
                                    <span class="text-muted">--</span>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <a href="/admin/manage-products/edit/<%= product._id %>" class="btn btn-text btn-sm" title="Edit Product (Admin)">
                                    <i class="fas fa-edit"></i> Edit
                                </a>
                                <form action="/admin/manage-products/remove/<%= product._id %>" method="POST" class="inline-form form-submit-spinner"
                                    onsubmit="return confirmAdminRemove('<%= productNameEsc %>', '<%= sellerEmailEsc %>')">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove Product (Admin)">
                                        <i class="fas fa-trash"></i> Remove
                                    </button>
                                </form>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="text-muted mt-3">No products found in the system.</p>
    <% } %>
</div>

<script>
    function confirmAdminRemove(productName, sellerEmail) {
        return confirm(`ADMIN ACTION: Remove product ${productName} (Seller: ${sellerEmail})?`);
    }
</script>

<%- include('../partials/footer') %>


views/admin/manage-users.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>

    <% if (users.length > 0) { %>
        <div class="table-container card">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Email / Phone</th>
                        <th>Role</th>
                        <th>Registered On</th>
                        <th>Verified</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% users.forEach(user => { %>
                        <tr>
                            <td data-label="Name"><%= user.name %></td>
                            <td data-label="Email / Phone">
                                <%= user.email %>
                                <% if (user.address && user.address.phone) { %>
                                    <br><small>(Ph: <%= user.address.phone %>)</small>
                                <% } %>
                            </td>
                            <td data-label="Role">
                                <form action="/admin/users/<%= user._id %>/update-role" method="POST" class="inline-form form-submit-spinner">
                                    <select name="role" onchange="this.form.submit()" class="form-control form-control-sm" style="display: inline-block; width: auto; vertical-align: middle;"> <%# Inline style for select %>
                                        <option value="user" <%= user.role === 'user' ? 'selected' : '' %>>User</option>
                                        <option value="seller" <%= user.role === 'seller' ? 'selected' : '' %>>Seller</option> <%# ADD SELLER %>
                                        <option value="admin" <%= user.role === 'admin' ? 'selected' : '' %>>Admin</option>
                                    </select>
                                    <noscript><button type="submit" class="btn btn-sm btn-primary ml-1">Update</button></noscript> <%# Fallback button %>
                                </form>
                            </td>
                            <td data-label="Registered On"><small><%= formatDateIST(user.createdAt) %></small></td>
                            <td data-label="Verified"><%= user.isVerified ? 'Yes' : 'No' %></td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Prevent removing self or last admin in controller logic %>
                                <form action="/admin/users/<%= user._id %>/remove" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('ADMIN ACTION: Are you sure you want to remove user <%= user.email %>? This is irreversible.');">
                                    <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-user-times"></i> Remove</button>
                                </form>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="text-muted mt-3">No other registered users found.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/admin/upload-product.ejs:
<%# views/admin/upload-product.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1>Admin: Upload New Product</h1>
    <p class="text-muted small mb-3">Product will be submitted for automatic review upon upload.</p>

    <form action="/admin/upload-product" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= locals.product?.name || '' %>" required>
        </div>

        <%# --- MODIFIED: Category Dropdown --- %>
        <div class="form-group">
            <label for="categoryRef">Category:</label>
            <select id="categoryRef" name="categoryRef" class="form-control" required>
                <option value="" disabled <%= !locals.product?.categoryRef ? 'selected' : '' %>>-- Select a Category --</option>
                <% if (locals.categories && categories.length > 0) { %>
                    <% categories.forEach(cat => { %>
                        <option value="<%= cat._id %>" <%= (locals.product?.categoryRef === cat._id.toString()) ? 'selected' : '' %>>
                            <%= cat.name %>
                        </option>
                    <% }) %>
                <% } else { %>
                    <option value="" disabled>No categories available</option>
                <% } %>
            </select>
            <% if (!locals.categories || categories.length === 0) { %>
                 <small class="text-danger d-block mt-1">Cannot upload products without categories. Please <a href="/admin/manage-categories">add categories</a> first.</small>
             <% } %>
        </div>
        <%# --- End Modification --- %>

        <div class="form-group">
            <label for="description">Description (Optional):</label>
            <textarea id="description" name="description" class="form-control" rows="4"><%= locals.product?.description || '' %></textarea>
        </div>
        <div class="form-group">
            <label for="price">Price (â‚¹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= locals.product?.price ?? '' %>" required>
        </div>
        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= locals.product?.stock ?? '' %>" required>
        </div>
        <div class="form-group">
            <label for="imageUrl">Image URL:</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" placeholder="https://example.com/image.jpg" value="<%= locals.product?.imageUrl || '' %>" required>
        </div>
        <div class="form-group">
            <label for="specifications">Specifications (Optional):</label>
            <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= locals.product?.specifications || '' %></textarea>
        </div>
        <button type="submit" class="btn btn-primary" <%= (!locals.categories || categories.length === 0) ? 'disabled' : '' %>>
            Upload & Submit for Review
        </button>
        <a href="/admin/dashboard" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/auth/forgot-password.ejs:
<%- include('../partials/header', { title: 'Forgot Password' }) %>

<div class="auth-container">
    <h1>Forgot Password</h1>
    <p>Enter your email address below. If an account exists, we'll send an OTP to verify your request.</p>

    <form action="/auth/forgot-password" method="POST" class="auth-form">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required>
        </div>
        <button type="submit" class="btn btn-primary">Send Reset OTP</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>


views/auth/login.ejs:
<%- include('../partials/header', { title: 'Login' }) %>

<div class="auth-container">
    <h1>Login</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/login" method="POST" class="auth-form form-submit-spinner">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" required autocomplete="current-password">
        </div>
        <button type="submit" class="btn btn-primary">Login</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/forgot-password">Forgot Password?</a></p>
        <p>Don't have an account? <a href="/auth/register">Register here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/register.ejs:
<%- include('../partials/header', { title: 'Register' }) %>

<div class="auth-container">
    <h1>Register</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/register" method="POST" class="auth-form form-submit-spinner">
         <div class="form-group">
            <label for="name">Name:</label>
            <input type="text" id="name" name="name" required autocomplete="name">
        </div>
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" minlength="6" required autocomplete="new-password">
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required autocomplete="new-password">
        </div>
        <button type="submit" class="btn btn-primary">Register</button>
    </form>
    <div class="auth-links">
        <p>Already have an account? <a href="/auth/login">Login here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/reset-password.ejs:
<%- include('../partials/header', { title: 'Reset Password' }) %>

<div class="auth-container">
    <h1>Reset Password</h1>
    <p>Enter your new password below.</p>

    <form action="/auth/reset-password/<%= token %>" method="POST" class="auth-form">
        <div class="form-group">
            <label for="password">New Password:</label>
            <input type="password" id="password" name="password" minlength="6" required>
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm New Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required>
        </div>
        <button type="submit" class="btn btn-primary">Reset Password</button>
    </form>
     <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>


views/auth/verify-otp.ejs:
<%- include('../partials/header', { title: title || 'Verify OTP' }) %>

<div class="auth-container">
    <h1>Verify OTP</h1>
    <p>An OTP has been sent to <strong><%= email %></strong>. Please enter it below.</p>

    <%# --- Spinner Class Added & Input Attributes Updated --- %>
    <form action="/auth/verify-otp" method="POST" class="auth-form form-submit-spinner">
         <input type="hidden" name="email" value="<%= email %>">
        <div class="form-group">
            <label for="otp">OTP Code:</label>
            <input type="text" <%# Changed type to text for better compatibility %>
                   id="otp"
                   name="otp"
                   required
                   pattern="\d{6}" <%# Ensures exactly 6 digits %>
                   maxlength="6"  <%# Limits input length %>
                   inputmode="numeric" <%# Suggests numeric keyboard on mobile %>
                   autocomplete="one-time-code" <%# Helps password managers/browsers %>
                   title="Enter the 6-digit OTP code received"> <%# Clear hint %>
        </div>
        <button type="submit" class="btn btn-primary">Verify OTP</button>
    </form>
    <div class="auth-links">
        <p>Didn't receive the OTP?</p>
        <form action="/auth/resend-otp" method="POST" style="display:inline;" class="form-submit-spinner">
             <input type="hidden" name="email" value="<%= email %>">
             <button type="submit" class="btn btn-secondary btn-sm">Resend OTP</button>
         </form>
    </div>
</div>

<%- include('../partials/footer') %>

views/partials/footer.ejs:
    </main> <%# End Main Content Area %>

    <footer class="app-footer desktop-only">
        <p>Â© <%= new Date().getFullYear() %> ProShop. All rights reserved.</p>
    </footer>

    <script src="/js/main.js"></script>

</body>
</html>

views/partials/header.ejs:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <% const pageTitle = typeof title !== 'undefined' ? title + ' - miniapp' : 'miniapp'; %>
  <% const siteName = typeof defaultSiteName !== 'undefined' ? defaultSiteName : 'miniapp'; %>
  <% const currentMetaTitle = typeof metaTitle !== 'undefined' ? metaTitle : pageTitle; %>
  <% const currentMetaDesc = typeof metaDescription !== 'undefined' ? metaDescription : 'Check out our products on ' + siteName; %>
  <% const currentMetaImage = typeof metaImageUrl !== 'undefined' ? metaImageUrl : '/images/default-logo.png'; %>
  <% const currentMetaUrl = typeof fullUrl !== 'undefined' ? fullUrl : ''; %>
  <% const currentMetaType = typeof metaType !== 'undefined' ? metaType : 'website'; %>

  <title><%= pageTitle %></title>
  <meta name="description" content="<%= currentMetaDesc %>">
  <meta property="og:title" content="<%= currentMetaTitle %>" />
  <meta property="og:description" content="<%= currentMetaDesc %>" />
  <meta property="og:image" content="<%= currentMetaImage %>" />
  <% if (currentMetaUrl) { %><meta property="og:url" content="<%= currentMetaUrl %>" /><% } %>
  <meta property="og:type" content="<%= currentMetaType %>" />
  <meta property="og:site_name" content="<%= siteName %>" />
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="<%= currentMetaTitle %>">
  <meta name="twitter:description" content="<%= currentMetaDesc %>">
  <meta name="twitter:image" content="<%= currentMetaImage %>">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <header class="app-header">
    <nav class="navbar">
      <div class="nav-left">
        <a href="/" class="app-logo">
          <i class="fas fa-shopping-bag"></i>
          <span class="app-name">miniapp</span>
        </a>
      </div>

      <%# --- NEW Dynamic Search Bar Container --- %>
      <div class="search-container-dynamic" id="dynamic-search-container">
          <form action="/products" method="GET" class="search-form-dynamic" id="dynamic-search-form">
              <input type="search"
                     id="search-input-dynamic"
                     name="search"
                     placeholder="Search products..."
                     aria-label="Search Products"
                     autocomplete="off">
              <button type="submit" class="search-submit-btn-dynamic" aria-label="Submit Search">
                  <i class="fas fa-search"></i>
              </button>
          </form>
           <div class="suggestions-dropdown" id="suggestions-dropdown">
              <%# Suggestions will be populated here by JS %>
          </div>
      </div>
      <%# --- END Dynamic Search Bar Container --- %>

      <div class="nav-right">
          <%# Search Icon Toggle (controls the container above) %>
          <button class="nav-link search-toggle-btn" id="search-toggle-btn" aria-label="Toggle Search Bar">
              <i class="fas fa-search"></i>
              <span>Search</span>
          </button>

        <%# Rest of the nav items %>
        <% if (currentUser) { %>
          <a href="/" class="nav-link <%= currentUrl === '/' ? 'active' : '' %>" title="Home Page">
            <i class="fas fa-home"></i> <span>Home</span>
          </a>
          <a href="/user/cart" class="nav-link nav-link-cart <%= currentUrl === '/user/cart' ? 'active' : '' %>" title="Cart Page">
            <i class="fas fa-shopping-cart"></i>
            <span class="cart-badge <%= cartItemCount > 0 ? '' : 'hide' %>"><%= cartItemCount %></span>
            <span>Cart</span>
          </a>

          <%# --- ORDERS LINK HAS BEEN REMOVED FROM HERE --- %>

          <%# --- REMOVED Admin and Seller Dashboard Links --- %>

          <a href="/user/profile" class="profile-avatar-link <%= currentUrl === '/user/profile' ? 'active' : '' %>" title="My Profile Page">
            <span class="profile-avatar-initials"><%= userInitials %></span>
          </a>
        <% } else { %>
          <a href="/auth/login" class="btn btn-login-register">
            <i class="fas fa-sign-in-alt"></i> Login / Register
          </a>
        <% } %>
      </div>
    </nav>
  </header>

  <%- include('messages') %>

  <main class="container">

views/partials/messages.ejs:
<%# views/partials/messages.ejs %>

<%# --- NEW: Toast Container --- %>
<div class="toast-container">
    <% if (success_msg && success_msg.length > 0) { %>
      <div class="toast toast-success" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-body">
          <%= success_msg %>
          <button type="button" class="toast-close-btn" aria-label="Close">Ã—</button>
        </div>
      </div>
    <% } %>

    <% if (error_msg && error_msg.length > 0) { %>
       <div class="toast toast-danger" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-body">
          <%= error_msg %>
           <button type="button" class="toast-close-btn" aria-label="Close">Ã—</button>
        </div>
      </div>
    <% } %>

    <% if (error && typeof error !== 'undefined' && error.length > 0) { %>
      <div class="toast toast-danger" role="alert" aria-live="assertive" aria-atomic="true">
         <div class="toast-body">
           <%= error %>
            <button type="button" class="toast-close-btn" aria-label="Close">Ã—</button>
         </div>
       </div>
    <% } %>

    <%# Add other flash message types (info, warning) here if needed %>

</div>
<%# --- End Toast Container --- %>

<%# The old alert divs are removed %>

views/products/detail.ejs:
<%# views/products/detail.ejs %>

<%# --- Meta Description Preparation --- %>
<% let metaDesc = product.description ? product.description.substring(0, 155) + '...' : `Check out ${product.name} on miniapp. Available now for â‚¹${product.price.toFixed(2)}.`; %>
<% if (metaDesc.length > 160) { metaDesc = metaDesc.substring(0, 157) + '...'; } %>

<%- include('../partials/header', {
    title: product.name,
    metaTitle: product.name + ' - ' + defaultSiteName,
    metaDescription: metaDesc,
    metaImageUrl: product.imageUrl,
    metaUrl: fullUrl,
    metaType: 'product'
}) %>

<div class="product-detail-container">

   <%# --- Status Banner (Keep existing) --- %>
   <% if (!isApproved && (isAdminView || isOwnerView)) { %>
     <div class="alert alert-<%= product.reviewStatus === 'rejected' ? 'danger' : 'warning' %> mb-3" role="alert">
       <strong>Status:</strong> <span class="text-capitalize fw-bold"><%= product.reviewStatus %></span>
       <% if (product.reviewStatus === 'rejected' && product.rejectionReason) { %>
         <br><strong>Reason:</strong> <%= product.rejectionReason %>
       <% } else if (product.reviewStatus === 'pending') { %>
          - This product is awaiting review and is not visible to customers.
       <% } %>
       <% if (isOwnerView && product.reviewStatus !== 'approved') { %>
          <br><a href="/seller/products/edit/<%= product._id %>" class="alert-link">Edit and Resubmit for Review</a>
        <% } else if (isAdminView && product.reviewStatus !== 'approved') { %>
           <br><a href="/admin/manage-products/edit/<%= product._id %>" class="alert-link">Admin: Edit Status/Details</a>
       <% } %>
     </div>
   <% } else if (!isApproved && !isAdminView && !isOwnerView) { %>
      <div class="alert alert-danger">This product is currently unavailable.</div>
      </div>
      <%- include('../partials/footer') %>
      <% return; %>
   <% } %>

   <div class="product-detail-main">
        <div class="product-detail-image">
           <img src="<%= product.imageUrl %>" alt="<%= product.name %>">
        </div>
       <div class="product-detail-info">
            <h1><%= product.name %></h1>

            <%# *** MOVED Description Display HERE *** %>
            <% if (product.description) { %>
            <div class="product-description mb-2"> <%# Removed mt-3, added mb-2 %>
                <%# REMOVED h3 title, description flows directly from product name %>
                <%# Use CSS white-space: pre-wrap to preserve line breaks entered in textarea %>
                <p class="description-text text-muted small"><%= product.description %></p> <%# Added text-muted and small class for style %>
            </div>
            <% } %>
            <%# *** End Moved Block *** %>

            <p class="detail-price">â‚¹<%= product.price.toFixed(2) %></p>
            <p class="detail-stock">
                <% if (product.stock > 0) { %>
                    Available Stock : <%= product.stock %>
                <% } else { %>
                    <span class="text-danger fw-bold">Out of Stock</span>
                <% } %>
            </p>

            <%# Share Button (Keep existing position) %>
            <div class="share-section mt-2">
                <button id="share-product-btn" class="btn btn-outline-secondary btn-sm"
                        data-title="<%= product.name %>"
                        data-text="Check out this product: <%= product.name %>"
                        data-url="<%= fullUrl %>">
                    <i class="fas fa-share-alt"></i> Share
                </button>
                <div id="fallback-share-links" class="fallback-share-links hidden">
                     <small>Share via:</small>
                     <a href="https://www.facebook.com/sharer/sharer.php?u=<%= encodeURIComponent(fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Facebook"><i class="fab fa-facebook-square"></i></a>
                     <a href="https://twitter.com/intent/tweet?url=<%= encodeURIComponent(fullUrl) %>&text=<%= encodeURIComponent('Check out this product: ' + product.name) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Twitter"><i class="fab fa-twitter-square"></i></a>
                     <a href="https://api.whatsapp.com/send?text=<%= encodeURIComponent('Check out this product: ' + product.name + ' ' + fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on WhatsApp"><i class="fab fa-whatsapp-square"></i></a>
                     <a href="mailto:?subject=<%= encodeURIComponent('Check out this product: ' + product.name) %>&body=<%= encodeURIComponent('I thought you might like this product:\n\n' + product.name + '\n' + fullUrl) %>" aria-label="Share via Email"><i class="fas fa-envelope-square"></i></a>
                 </div>
            </div>

           <%# Purchase Actions (Keep existing) %>
           <% if (isApproved) { %>
               <div class="product-actions">
                   <form action="/user/cart/add" method="POST" style="display: inline-block; margin-right: 10px;" class="form-submit-spinner">
                      <input type="hidden" name="productId" value="<%= product._id %>">
                       <div class="quantity-selector mb-2 d-inline-flex align-items-center">
                           <label for="quantity" class="me-1 mb-0 text-muted">Quantity </label>
                           <input type="number" id="quantity" name="quantity" value="1" min="1" max="<%= product.stock %>" required aria-label="Quantity" class="form-control form-control-sm" style="width: 70px;">
                       </div>
                       <button type="submit" class="btn btn-primary btn-sm" <%= product.stock <= 0 ? 'disabled' : '' %>>
                           <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                       </button>
                  </form>
                    <% if (product.stock > 0) { %>
                    <form action="/user/cart/add?redirectTo=checkout" method="POST" style="display: inline-block;" class="form-submit-spinner">
                          <input type="hidden" name="productId" value="<%= product._id %>">
                          <input type="hidden" name="quantity" value="1">
                         <button type="submit" class="btn btn-success btn-sm">Buy Now</button>
                       </form>
                    <% } else {%>
                      <button class="btn btn-success btn-sm" disabled>Buy Now</button>
                    <% } %>
               </div>
            <% } else { %>
                <div class="product-actions">
                     <button class="btn btn-primary btn-sm" disabled><i class="fas fa-cart-plus"></i> Add to Cart</button>
                     <button class="btn btn-success btn-sm" disabled>Buy Now</button>
                     <p class="text-muted small mt-2">This product is currently under review or unavailable.</p>
                 </div>
            <% } %>

            <%# Description Block REMOVED from here %>

            <%# Specifications (Keep existing) %>
            <div class="product-specifications mt-3">
                 <h3>Specifications</h3>
                 <pre class="border p-2 bg-light small"><%= product.specifications || 'No specifications provided.' %></pre>
            </div>

            <%# Seller Info (Keep existing) %>
            <p class="small text-muted mt-3">Seller Info : <%= product.sellerEmail || 'Unknown Seller' %></p>

       </div> <%# End product-detail-info %>
    </div> <%# End product-detail-main %>

   <%# --- Remaining Sections (Rating, Stats) Keep existing --- %>
   <div class="product-rating-section mt-4 border-top pt-3">
        <h3>Rate This Product</h3>
        <% if (isApproved) { %>
            <% if (userCanRate) { %>
                <form action="/products/<%= product._id %>/rate" method="POST" class="form-submit-spinner">
                    <div class="rating-stars">
                        <% for (let i = 5; i >= 1; i--) { %><input type="radio" id="star<%= i %>" name="rating" value="<%= i %>" <%= userRating === i ? 'checked' : '' %> required><label for="star<%= i %>" title="<%= i %> stars"><i class="fas fa-star"></i></label><% } %>
                    </div>
                    <button type="submit" class="btn btn-primary btn-sm">Submit Rating</button>
                </form>
            <% } else { %>
               <p><a href="/auth/login?returnTo=<%= encodeURIComponent(currentUrl) %>">Login</a> to rate this product.</p>
            <% } %>
         <% } else { %>
             <p class="text-muted">Rating is unavailable until the product is approved.</p>
         <% } %>
   </div>

    <div class="mb-3">
        <% if (product.numReviews > 0) { %>
            <p class="detail-rating">
                Rating:
               <% for(let i=1; i<=5; i++) { %><i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i><% } %>
                (<%= product.numReviews %> reviews) | <%= product.orderCount %> Ordered
            </p>
        <% } else { %>
            <p class="detail-rating">No reviews yet | <%= product.orderCount %> Ordered</p>
        <% } %>
    </div>

    <div class="rating-stats-container mt-4 border-top pt-3">
        <h3>Ratings & Reviews Summary</h3>
         <% if (totalRatings > 0) { %>
             <div class="rating-summary mb-3">
                 <div class="rating-average">
                     <span class="rating-average-value"><%= product.averageRating.toFixed(1) %></span> <i class="fas fa-star text-warning"></i>
                 </div>
                 <div class="rating-total text-muted small">
                     Based on <%= totalRatings %> Rating<%= totalRatings !== 1 ? 's' : '' %>
                 </div>
             </div>
            <div class="rating-bars">
                <% for (let i = 5; i >= 1; i--) {
                      const count = ratingCounts[i] || 0;
                      const percentage = totalRatings > 0 ? (count / totalRatings) * 100 : 0;
                 %>
                     <div class="rating-bar-row">
                         <span class="rating-bar-label small"><%= i %> <i class="fas fa-star text-warning"></i></span>
                         <div class="rating-bar-progress progress" style="height: 8px;">
                             <div class="rating-bar-fill progress-bar bg-success" role="progressbar" data-width="<%= percentage.toFixed(1) %>" aria-valuenow="<%= percentage.toFixed(1) %>" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"></div>
                         </div>
                         <span class="rating-bar-count small text-muted"><%= count %></span>
                     </div>
                 <% } %>
            </div>
        <% } else { %>
            <p>No ratings yet for this product.</p>
         <% } %>
    </div>

</div> <%# End product-detail-container %>

<script>
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.rating-bar-fill').forEach(function(el) {
        var width = el.getAttribute('data-width');
        if (width) {
            setTimeout(() => {
                 el.style.width = width + '%';
            }, 100);
        }
    });
});
</script>

<%- include('../partials/footer') %>

views/products/index.ejs:
<%# views/products/index.ejs %>
<%- include('../partials/header', { title: title }) %>

<%# --- Banner Slider --- %>
<% if (typeof homepageBanners !== 'undefined' && homepageBanners.length > 0) { %>
    <div class="banner-slider-container mb-4" data-slider-container>
        <div class="banner-slides" data-slides>
             <% homepageBanners.forEach((banner, index) => { %>
                <div class="banner-slide <%= index === 0 ? 'active' : '' %>" data-slide>
                     <% if (banner.linkUrl) { %>
                        <a href="<%= banner.linkUrl %>" rel="noopener noreferrer" class="banner-link">
                            <img src="<%= banner.imageUrl %>" alt="<%= banner.title || `Promotional Banner ${index + 1}` %>" class="banner-image" loading="lazy">
                        </a>
                    <% } else { %>
                         <img src="<%= banner.imageUrl %>" alt="<%= banner.title || `Promotional Banner ${index + 1}` %>" class="banner-image" loading="lazy">
                     <% } %>
                </div>
             <% }) %>
         </div>
        <% if (homepageBanners.length > 1) { %><button class="banner-nav banner-prev" data-slider-prev aria-label="Previous Banner"><i class="fas fa-chevron-left"></i></button><button class="banner-nav banner-next" data-slider-next aria-label="Next Banner"><i class="fas fa-chevron-right"></i></button><% } %>
         <% if (homepageBanners.length > 1) { %><div class="banner-dots" data-slider-dots><% homepageBanners.forEach((_, index) => { %><button class="banner-dot <%= index === 0 ? 'active' : '' %>" data-slide-to="<%= index %>" aria-label="Go to banner <%= index + 1 %>"></button><% }) %></div><% } %>
    </div>
<% } %>

<%# --- Dynamic Categories Section --- %>
<% if (typeof homepageCategories !== 'undefined' && homepageCategories.length > 0) { %>
    <div class="category-display-section mb-4">
        <h2 class="h4">Categories</h2>
        <div class="category-grid">
            <% homepageCategories.forEach(category => { %>
                <%# --- MODIFICATION: Added conditional 'active-category' class --- %>
                <a href="/products?categoryName=<%= encodeURIComponent(category.name) %>"
                   class="category-card <%= (typeof selectedCategoryName !== 'undefined' && selectedCategoryName === category.name) ? 'active-category' : '' %>"
                   title="Shop <%= category.name %>">
                    <div class="category-image-wrapper">
                         <img src="<%= category.imageUrl %>" alt="<%= category.name %>" class="category-image" loading="lazy">
                    </div>
                    <span class="category-name"><%= category.name %></span>
                 </a>
            <% }) %>
         </div>
     </div>
 <% } %>
<%# --- End: Dynamic Categories Section --- %>


<div class="product-index-container">
    <%# Update heading based on context %>
    <h1 class="h2 mb-3"> <%# Used h2 for better hierarchy %>
        <% if (selectedCategoryName) { %>
            <%= title %> <%# Already contains "Products in Category" %>
         <% } else if (searchTerm) { %>
            <%= title %> <%# Already contains "Search Results" %>
        <% } else { %>
             New Launches <%# Default homepage title %>
         <% } %>
     </h1>

    <% if (products.length > 0) { %>
        <div class="product-grid">
            <% products.forEach(product => { %>
                <div class="product-card">
                     <a href="/products/<%= product._id %>" class="product-link">
                        <img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="product-image" loading="lazy">
                        <div class="product-info">
                             <h3 class="product-name"><%= product.name %></h3>
                            <p class="product-category small text-muted"><%= product.categoryName %></p> <%# Display category name %>
                             <p class="product-price">â‚¹<%= (typeof product.price === 'number' ? product.price : 0).toFixed(2) %></p>
                            <% if (product.stock > 0) { %>
                                <p class="product-stock small">Stock: <%= product.stock %></p>
                            <% } else { %>
                                <p class="product-stock small text-danger fw-bold">Out of Stock</p>
                            <% } %>
                            <% if (product.numReviews > 0) { %>
                                 <p class="product-rating small">
                                     <% for(let i=1; i<=5; i++) { %><i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i><% } %>
                                     (<%= product.numReviews %>)
                                  </p>
                             <% } else { %>
                                 <p class="product-rating small"> </p> <%# Keep empty p for structure %>
                             <% } %>
                         </div>
                     </a>
                     <form action="/user/cart/add" method="POST" class="add-to-cart-form form-submit-spinner">
                         <input type="hidden" name="productId" value="<%= product._id %>">
                         <input type="hidden" name="quantity" value="1">
                        <button type="submit" class="btn btn-primary btn-add-to-cart" <%= product.stock <= 0 ? 'disabled' : '' %>>
                            <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                         </button>
                    </form>
                 </div>
            <% }) %>
        </div>
    <% } else { %>
         <p class="alert alert-info">
              <% if (typeof searchTerm !== 'undefined' && searchTerm) { %>
                  No products found matching your search "<%= searchTerm %>".
             <% } else if (typeof selectedCategoryName !== 'undefined' && selectedCategoryName) { %>
                 No products found in the category "<%= selectedCategoryName %>".
              <% } else { %>
                  No products are currently available. Check back soon!
             <% } %>
         </p>
    <% } %>
</div>

<%- include('../partials/footer') %>

seller/dashboard.ejs:
<%- include('../partials/header', { title: 'Seller Dashboard' }) %>

<div class="admin-dashboard-container"> <%# Re-use admin style container %>
    <h1>Seller Dashboard</h1>
    <p class="text-muted mb-3">Manage your products and orders.</p>

    <div class="admin-actions-grid"> <%# Re-use admin style grid %>
         <a href="/seller/products/upload" class="admin-action-card">
            <i class="fas fa-upload text-primary"></i> <%# Added color class %>
            <h3>Upload Product</h3>
            <p>Add a new product to your listings.</p>
        </a>
         <a href="/seller/products" class="admin-action-card">
            <i class="fas fa-edit text-success"></i> <%# Added color class %>
            <h3>Manage Products</h3>
            <p>View status, edit, or remove your products.</p>
         </a>
        <a href="/seller/orders" class="admin-action-card">
             <i class="fas fa-clipboard-list text-info"></i> <%# Added color class %>
             <h3>Manage Orders</h3>
             <p>View and manage orders containing your products.</p>
        </a>

    </div>
</div>

<%- include('../partials/footer') %>

seller/edit-product.ejs:
<%# views/seller/edit-product.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Updating the product will reset its status to 'pending' and trigger a new review.</p>

     <form action="/seller/products/update/<%= product._id %>" method="POST" class="form-submit-spinner">
         <div class="alert alert-<%= product.reviewStatus === 'approved' ? 'success' : (product.reviewStatus === 'rejected' ? 'danger' : 'warning') %>" role="alert">
           <strong>Current Status:</strong> <span class="text-capitalize"><%= product.reviewStatus %></span>
           <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %><br><strong>Reason:</strong> <%= product.rejectionReason %><% } %>
         </div>

        <div class="form-group">
             <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= product.name %>" required>
         </div>

         <%# --- MODIFIED: Category Dropdown --- %>
        <div class="form-group">
             <label for="categoryRef">Category:</label>
             <select id="categoryRef" name="categoryRef" class="form-control" required>
                <option value="" disabled>-- Select a Category --</option>
                <% if (locals.categories && categories.length > 0) { %>
                     <% categories.forEach(cat => { %>
                        <% const currentCategoryId = product.categoryRef?._id?.toString() || product.categoryRef?.toString(); %>
                        <option value="<%= cat._id %>" <%= (currentCategoryId === cat._id.toString()) ? 'selected' : '' %>>
                              <%= cat.name %>
                          </option>
                      <% }) %>
                  <% } else { %>
                      <option value="" disabled>No categories available</option>
                 <% } %>
            </select>
            <% if (!locals.categories || categories.length === 0) { %>
                 <small class="text-danger d-block mt-1">Cannot update products without categories.</small>
            <% } %>
         </div>
         <%# --- End Modification --- %>

         <div class="form-group">
            <label for="description">Description:</label>
            <textarea id="description" name="description" class="form-control" rows="4"><%= product.description || '' %></textarea>
        </div>
         <div class="form-group">
            <label for="price">Price (â‚¹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= product.price %>" required>
         </div>
        <div class="form-group">
             <label for="stock">Stock Quantity:</label>
             <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= product.stock %>" required>
        </div>
         <div class="form-group">
             <label for="imageUrl">Image URL:</label>
             <input type="url" id="imageUrl" name="imageUrl" class="form-control" value="<%= product.imageUrl %>" required>
             <% if(product.imageUrl) { %><img src="<%= product.imageUrl %>" alt="Current Image" style="max-width: 100px; margin-top: 5px; border: 1px solid #ddd; padding: 2px;"><% } %>
         </div>
         <div class="form-group">
             <label for="specifications">Specifications (Optional):</label>
             <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= product.specifications || '' %></textarea>
        </div>
         <button type="submit" class="btn btn-primary" <%= (!locals.categories || categories.length === 0) ? 'disabled' : '' %>>
             Update & Resubmit for Review
         </button>
         <a href="/seller/products" class="btn btn-secondary">Cancel</a>
    </form>
 </div>

 <%- include('../partials/footer') %>

seller/manage-orders.ejs:
<%# views/seller/manage-orders.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container order-manage-page"> <%# Added 'order-manage-page' class %>
    <h1>Manage Your Orders</h1>
    <p class="text-muted small mb-3">Showing orders that contain one or more of your products.</p>

    <% if (message) { %>
        <p class="alert alert-info"><%= message %></p>
    <% } %>

    <% if (orders.length > 0) { %>
        <div class="table-container"> <%# Removed 'card' class %>
            <table class="data-table order-table"> <%# Added 'order-table' class %>
                <thead>
                    <tr>
                        <th>Order ID / Date</th>
                        <th>Customer / Address</th>
                        <th>Items (Your items highlighted)</th>
                        <th>Total</th>
                        <th>Status</th>
                        <th class="actions-cell">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% orders.forEach(order => { %>
                        <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %>" data-order-id="<%= order._id %>">
                            <td data-label="Order ID / Date">
                                <%= order._id %><br>
                                <small class="text-muted"><%= formatDateIST(order.orderDate) %></small>
                            </td>
                            <td data-label="Customer / Address">
                                <strong><%= order.shippingAddress.name %></strong><br>
                                <small class="text-muted"><%= order.userEmail || order.userId?.email %></small><br> <%# Added null check for email %>
                                <small class="text-muted"><%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %></small><br>
                                <small><strong>Ph:</strong> <%= order.shippingAddress.phone %></small>
                            </td>
                            <td data-label="Items">
                                <div class="order-items-summary">
                                    <%- order.itemsSummary %> <%# Raw HTML summary %>
                                </div>
                                <% if (order.products && order.products.length > 0) { %>
                                    <div class="order-items-images">
                                        <% order.products.forEach(item => { %>
                                            <% if (item.productId && item.productId._id && item.productId.imageUrl) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" title="View <%= item.productId.name || 'Product' %>">
                                                    <img src="<%= item.productId.imageUrl %>"
                                                         alt="<%= item.productId.name || 'Product Image' %>"
                                                         class="order-item-thumbnail" loading="lazy"> <%# Added lazy loading %>
                                                </a>
                                            <% } else if (item.productId && item.productId._id) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" class="order-item-thumbnail-placeholder" title="View <%= item.productId.name || 'Product' %>">[No Img]</a>
                                            <% } else { %>
                                                <span class="order-item-thumbnail-placeholder" title="Product data missing">[N/A]</span>
                                            <% } %>
                                        <% }) %>
                                    </div>
                                <% } %>
                            </td>
                            <td data-label="Total" class="order-total"><strong>â‚¹<%= order.totalAmount.toFixed(2) %></strong></td>
                            <td data-label="Status" class="order-status-cell">
                                <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span>
                                <%# Display cancellation reason including seller prefix %>
                                <% if(order.status === 'Cancelled' && order.cancellationReason) { %>
                                    <br><small class="text-danger mt-1 d-block">Reason:<br><%= order.cancellationReason %></small>
                                <% } %>
                                <% if(order.status === 'Delivered' && order.receivedByDate) { %><br><small class="text-success mt-1 d-block">Delivered:<br><%= formatDateIST(order.receivedByDate) %></small><% } %>
                                <% if (order.showDeliveryOtp && order.status === 'Pending') { %>
                                  <div class="delivery-otp-display mt-1"> <%# Reusing user style %>
                                    <p>Customer OTP Sent</p>
                                    <small class="text-muted">Ask customer for code: <strong class="delivery-otp-code">****<%= order.orderOTP ? order.orderOTP.slice(-2) : 'XX' %></strong></small>
                                  </div>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Seller Direct Delivery Confirmation %>
                                <% if (order.canBeDirectlyDeliveredBySeller) { %>
                                    <div class="action-group mb-2"> <%# Added mb-2 for spacing %>
                                        <p class="action-group-title">Confirm Delivery:</p>
                                        <% if (!order.showDeliveryOtp) { %>
                                            <form action="/seller/orders/<%= order._id %>/send-otp" method="POST" class="inline-form form-submit-spinner mb-1">
                                                <button type="submit" class="btn btn-warning btn-sm w-100 w-md-auto" title="Send OTP to customer to confirm delivery"> <%# Control width %>
                                                    <i class="fas fa-mobile-alt"></i> Send OTP
                                                </button>
                                            </form>
                                        <% } %>
                                        <form action="/seller/orders/<%= order._id %>/confirm-delivery" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                            <input type="text" name="otp" placeholder="Enter OTP" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit OTP from customer">
                                            <button type="submit" class="btn btn-success btn-sm" title="Confirm delivery using customer's OTP">
                                                <i class="fas fa-check-double"></i> Confirm
                                            </button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# --- NEW: Seller Order Cancellation Form --- %>
                                <% if (order.canBeCancelledBySeller) { %>
                                    <div class="action-group">
                                        <form action="/seller/orders/<%= order._id %>/cancel" method="POST" class="cancel-delivery-form form-submit-spinner" onsubmit="return confirm('SELLER ACTION: Are you sure you want to cancel your items in order <%= order._id %>? This action cannot be undone.');">
                                            <label for="reason-<%= order._id %>" class="action-group-title">Cancel Your Items:</label>
                                            <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm d-block mb-1">
                                                <option value="" disabled selected>Select Seller Reason...</option>
                                                <% if (typeof sellerCancellationReasons !== 'undefined' && sellerCancellationReasons.length > 0) { %>
                                                    <% sellerCancellationReasons.forEach(reason => { %>
                                                        <option value="<%= reason %>"><%= reason %></option>
                                                    <% }) %>
                                                <% } else { %>
                                                    <option value="Other Reason (Seller)" selected>Other Reason (Seller)</option> <%# Fallback %>
                                                <% } %>
                                            </select>
                                            <button type="submit" class="btn btn-danger btn-sm w-100 w-md-auto"><i class="fas fa-ban"></i> Cancel Items</button>
                                        </form>
                                    </div>
                                <% } %>
                                <%# --- End: Seller Order Cancellation Form --- %>

                                <%# Fallback for no actions %>
                                <% if (!order.canBeDirectlyDeliveredBySeller && !order.canBeCancelledBySeller) { %>
                                     <small class="text-muted no-actions-text">
                                         <% if (order.status === 'Delivered') { %>Completed<% } else if (order.status === 'Cancelled') { %>Cancelled<% } else { %>No actions available<% } %>
                                    </small>
                                <% } %>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else if (!message) { %>
        <p class="alert alert-info">No orders containing your products found.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

seller/manage-products.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1>Manage Your Products</h1>
    <a href="/seller/products/upload" class="btn btn-primary mb-3"><i class="fas fa-plus"></i> Upload New Product</a>

   <% if (products.length > 0) { %>
       <div class="table-container card">
           <table class="data-table">
               <thead>
                   <tr>
                       <th>Image</th>
                       <th>Name</th>
                       <th>Price</th>
                       <th>Stock</th>
                       <th>Status</th> <%# NEW %>
                       <th>Reason</th> <%# NEW %>
                       <th class="actions-cell" style="text-align: right;">Actions</th>
                   </tr>
                </thead>
                <tbody>
                   <% products.forEach(product => { %>
                       <tr class="status-<%= product.reviewStatus %>"> <%# Add status class %>
                           <td data-label="Image"><a href="/products/<%= product._id %>"><img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="table-img"></a></td>
                            <td data-label="Name"><%= product.name %><br><small class="text-muted"><%= product.category %></small></td>
                            <td data-label="Price">â‚¹<%= product.price.toFixed(2) %></td>
                            <td data-label="Stock"><%= product.stock %></td>
                            <td data-label="Status">
                                <span class="status-badge status-<%= product.reviewStatus %> text-capitalize">
                                    <%= product.reviewStatus %>
                                </span>
                            </td>
                             <td data-label="Reason">
                                <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %>
                                    <small class="text-danger"><%= product.rejectionReason %></small>
                                <% } else { %>
                                    <span class="text-muted">--</span>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                               <%# Edit button always available, triggers re-review %>
                               <a href="/seller/products/edit/<%= product._id %>" class="btn btn-text btn-sm" title="Edit Product"><i class="fas fa-edit"></i> Edit</a>

                               <form action="/seller/products/remove/<%= product._id %>" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to permanently remove this product: <%= product.name %>?');">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove Product"><i class="fas fa-trash"></i> Remove</button>
                               </form>
                           </td>
                        </tr>
                    <% }) %>
               </tbody>
            </table>
       </div>
   <% } else { %>
        <p class="text-muted mt-3">You haven't uploaded any products yet. <a href="/seller/products/upload">Upload your first product!</a></p>
   <% } %>
</div>

<%- include('../partials/footer') %>

seller/upload-product.ejs:
<%# views/seller/upload-product.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1>Upload New Product</h1>
    <p class="text-muted small mb-3">Your product will be submitted for automatic review upon upload.</p>

    <form action="/seller/products/upload" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= locals.product?.name || '' %>" required>
        </div>

        <%# --- MODIFIED: Category Dropdown --- %>
        <div class="form-group">
            <label for="categoryRef">Category:</label>
            <select id="categoryRef" name="categoryRef" class="form-control" required>
                 <option value="" disabled <%= !locals.product?.categoryRef ? 'selected' : '' %>>-- Select a Category --</option>
                 <% if (locals.categories && categories.length > 0) { %>
                    <% categories.forEach(cat => { %>
                         <option value="<%= cat._id %>" <%= (locals.product?.categoryRef === cat._id.toString()) ? 'selected' : '' %>>
                             <%= cat.name %>
                         </option>
                     <% }) %>
                 <% } else { %>
                     <option value="" disabled>No categories available</option>
                 <% } %>
            </select>
            <% if (!locals.categories || categories.length === 0) { %>
                 <small class="text-danger d-block mt-1">Cannot upload products as no categories are defined by the admin yet.</small>
            <% } %>
        </div>
        <%# --- End Modification --- %>

        <div class="form-group">
            <label for="description">Description (Optional):</label>
            <textarea id="description" name="description" class="form-control" rows="4"><%= locals.product?.description || '' %></textarea>
        </div>
        <div class="form-group">
            <label for="price">Price (â‚¹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= locals.product?.price ?? '' %>" required>
        </div>
        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= locals.product?.stock ?? '' %>" required>
        </div>
        <div class="form-group">
            <label for="imageUrl">Image URL:</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" placeholder="https://example.com/image.jpg" value="<%= locals.product?.imageUrl || '' %>" required>
        </div>
        <div class="form-group">
            <label for="specifications">Specifications (Optional):</label>
            <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= locals.product?.specifications || '' %></textarea>
        </div>
        <button type="submit" class="btn btn-primary" <%= (!locals.categories || categories.length === 0) ? 'disabled' : '' %>>
            Upload & Submit for Review
        </button>
        <a href="/seller/dashboard" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/user/cart.ejs:
<%# views/user/cart.ejs %>
<%- include('../partials/header', { title: 'Shopping Cart' }) %>

<div class="cart-container">
    <h1>Your Shopping Cart</h1>

    <% if (cart.length > 0) { %>
        <div class="cart-items">
            <% cart.forEach(item => { %>
                <div class="cart-item" data-product-id="<%= item.productId %>">
                    <div class="cart-item-image">
                        <a href="/products/<%= item.productId %>"><img src="<%= item.imageUrl %>" alt="<%= item.name %>"></a>
                    </div>
                    <div class="cart-item-details">
                        <h3 class="cart-item-name"><%= item.name %></h3>
                        <p class="cart-item-price">â‚¹<%= (typeof item.price === 'number' ? item.price : 0).toFixed(2) %></p>
                        <p class="cart-item-stock">Stock: <%= item.stock %></p>
                    </div>
                    <div class="cart-item-quantity">
                        <label for="quantity-<%= item.productId %>" class="visually-hidden">Quantity for <%= item.name %></label> <%# Added visually-hidden label %>
                        <input type="number"
                               id="quantity-<%= item.productId %>"
                               class="quantity-input" <%# Use class for consistency %>
                               name="quantity"
                               value="<%= item.quantity %>"
                               min="0"
                               max="<%= item.stock %>"
                               data-product-id="<%= item.productId %>"
                               data-item-price="<%= item.price %>"
                               aria-label="Quantity for <%= item.name %>">
                        <button class="btn btn-secondary btn-sm btn-update-qty" data-product-id="<%= item.productId %>">Update</button> <%# Spinner handled by AJAX logic %>
                     </div>
                     <div class="cart-item-subtotal">
                         Subtotal: â‚¹<span class="item-subtotal-value"><%= (typeof item.subtotal === 'number' ? item.subtotal : 0).toFixed(2) %></span>
                    </div>
                    <div class="cart-item-remove">
                        <form action="/user/cart/remove/<%= item.productId %>" method="POST" class="form-submit-spinner">
                            <button type="submit" class="btn btn-danger btn-sm">Ã— Remove</button>
                         </form>
                     </div>
                </div>
            <% }) %>
        </div>

         <div class="cart-summary">
             <h2>Cart Total: â‚¹<span id="cart-total-value"><%= (typeof cartTotal === 'number' ? cartTotal : 0).toFixed(2) %></span></h2>
             <%# --- ADDED ID and loading state attributes --- %>
             <a href="/user/checkout"
                id="btn-proceed-checkout" <%# ADDED ID %>
                class="btn btn-success btn-checkout"
                data-loading-text="<i class='fas fa-spinner fa-spin'></i> Proceeding..." <%# ADDED loading text data attribute %>
                >Proceed to Checkout</a>
        </div>

    <% } else { %>
        <%# Updated empty cart message to use alert style %>
        <p class="alert alert-info mt-3">Your cart is empty. <a href="/" class="alert-link">Continue Shopping</a></p>
    <% } %>
</div>

 <%- include('../partials/footer') %>

views/user/checkout.ejs:
<%# views/user/checkout.ejs %>
<%- include('../partials/header', { title: 'Checkout' }) %>

<div class="checkout-container">
    <h1>Checkout</h1>

    <div class="checkout-grid">
        <div class="checkout-address">
            <h2>Shipping Address</h2>
            <% if (userAddress && userAddress.name) { %>
                <div class="saved-address">
                    <p><strong><%= userAddress.name %></strong></p>
                    <p><%= userAddress.phone %></p>
                    <p><%= userAddress.landmarkNearby ? userAddress.landmarkNearby + ', ' : '' %><%= userAddress.cityVillage %></p>
                    <p>Pincode: <%= userAddress.pincode %></p>
                    <button type="button" id="edit-address-btn" class="btn btn-secondary btn-sm">Edit Address</button>
                </div>
             <% } %>

            <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (userAddress && userAddress.name) ? 'hidden' : '' %> form-submit-spinner">
                <h3><%= (userAddress && userAddress.name) ? 'Edit Address' : 'Add Address' %></h3>
                <div class="form-group">
                    <label for="name">Full Name:</label>
                    <input type="text" id="name" name="name" value="<%= userAddress?.name || '' %>" required autocomplete="name">
                </div>
                <div class="form-group">
                    <label for="phone">Phone Number:</label>
                    <input type="tel" <%# Correct semantic type %>
                           id="phone"
                           name="phone"
                           value="<%= userAddress?.phone || '' %>"
                           required
                           pattern="\d{10,15}" <%# Expect 10-15 digits %>
                           minlength="10"  <%# Minimum 10 digits %>
                           maxlength="15" <%# Maximum 15 digits %>
                           title="Enter 10 to 15 digit phone number (numbers only)" <%# Clear hint %>
                           autocomplete="tel"> <%# Standard autocomplete %>
                </div>
                 <div class="form-group">
                    <label for="pincode">Pincode:</label>
                     <input type="text" <%# Use text type, pattern handles format %>
                            id="pincode"
                            name="pincode"
                            value="<%= userAddress?.pincode || '' %>"
                            required
                            pattern="\d{6}" <%# Assuming 6 digit Indian pincode %>
                            maxlength="6"
                            inputmode="numeric"
                            title="Enter 6-digit Pincode"
                            autocomplete="postal-code">
                </div>
                 <div class="form-group">
                    <label for="cityVillage">City / Village:</label>
                     <input type="text" id="cityVillage" name="cityVillage" value="<%= userAddress?.cityVillage || '' %>" required autocomplete="address-level2">
                </div>
                <div class="form-group">
                    <label for="landmarkNearby">Landmark / Nearby (Optional):</label>
                     <input type="text" id="landmarkNearby" name="landmarkNearby" value="<%= userAddress?.landmarkNearby || '' %>">
                </div>
                <button type="submit" class="btn btn-primary">Save Address</button>
                <% if (userAddress && userAddress.name) { %>
                    <button type="button" id="cancel-edit-btn" class="btn btn-secondary">Cancel Edit</button>
                <% } %>
             </form>
        </div>

         <div class="checkout-summary">
             <h2>Order Summary</h2>
             <div class="checkout-items">
                 <% items.forEach(item => { %>
                    <div class="checkout-item">
                         <a href="/products/<%= item.productId %>" class="checkout-item-image">
                            <img src="<%= item.imageUrl %>" alt="<%= item.name %>">
                        </a>
                        <div class="checkout-item-info">
                             <%= item.name %> (Qty: <%= item.quantity %>)
                        </div>
                        <div class="checkout-item-price">â‚¹<%= item.itemTotal.toFixed(2) %></div>
                     </div>
                <% }) %>
            </div>
            <hr>
            <div class="checkout-totals">
                <p>Subtotal: <span>â‚¹<%= subTotal.toFixed(2) %></span></p>
                 <p>Shipping: <span>FREE</span></p>
                <hr>
                 <p><strong>Total: <span>â‚¹<%= totalAmount.toFixed(2) %></span></strong></p>
            </div>

            <div class="checkout-payment">
                <h3>Payment Method</h3>
                 <div class="payment-option selected">
                     <input type="radio" id="cod" name="paymentMethodValue" value="COD" checked disabled>
                     <label for="cod"><i class="fas fa-money-bill-wave"></i> Cash on Delivery (COD)</label>
                 </div>
            </div>

            <form action="/orders/place" method="POST" class="place-order-form form-submit-spinner">
                 <input type="hidden" name="paymentMethod" value="COD">
                 <button type="submit" class="btn btn-success btn-block btn-place-order" <%= (!userAddress || !userAddress.name) ? 'disabled' : '' %>>
                    Place Order
                 </button>
                 <% if (!userAddress || !userAddress.name) { %>
                    <p class="text-danger small">Please add/save your shipping address first.</p>
                 <% } %>
             </form>
         </div>
    </div>
</div>

<%- include('../partials/footer') %>

<%# Checkout specific JS logic was moved to public/js/main.js %>

views/user/my-orders.ejs:
<%# views/user/my-orders.ejs %>
<%- include('../partials/header', { title: 'My Orders' }) %>

<div class="my-orders-container">
    <h1>My Orders</h1>

    <% if (orders.length > 0) { %>
        <div class="order-list">
            <% orders.forEach(order => { %>
                <div class="order-card status-<%= order.status.toLowerCase().replace(/ /g, '-') %> mb-3"> <%# Add mb-3 for spacing %>
                     <div class="order-header">
                         <div><strong>Order ID:</strong><br><%= order._id %></div>
                         <div><strong>Placed on:</strong><br><%= formatDateIST(order.orderDate) %></div>
                         <div><strong>Total:</strong><br>â‚¹<%= order.totalAmount.toFixed(2) %></div>
                         <div><strong>Status:</strong><br><span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span></div>
                     </div>
                    <div class="order-body">
                         <%# Simplified item display (text) %>
                         <p class="mb-1"><strong>Items:</strong></p>
                         <div class="order-items-list mb-2">
                            <% order.products.forEach((item, index) => { %>
                                <small><%= item.name || '[Product Name Missing]' %> (Qty: <%= item.quantity %>) <% if(index < order.products.length - 1) { %> | <% } %></small>
                            <% }) %>
                         </div>

                         <%# --- NEW: Display Product Images --- %>
                         <div class="order-items-images mt-2">
                            <% order.products.forEach(item => { %>
                                <%# Check if product was populated and has necessary info %>
                                <% if (item.productId && item.productId._id && item.imageUrl) { %>
                                    <a href="/products/<%= item.productId._id %>" title="View <%= item.name || 'Product' %>">
                                        <img src="<%= item.imageUrl %>"
                                             alt="<%= item.name || 'Product Image' %>"
                                             class="order-item-thumbnail">
                                    </a>
                                <% } else if (item.productId && item.productId._id) { %>
                                    <%# Fallback if image URL is missing but product exists %>
                                    <a href="/products/<%= item.productId._id %>" class="order-item-thumbnail-placeholder" title="View <%= item.name || 'Product' %>">[No Img]</a>
                                <% } else { %>
                                    <%# Very basic fallback if productId is missing entirely %>
                                    <span class="order-item-thumbnail-placeholder">[Item NA]</span>
                                <% } %>
                            <% }) %>
                         </div>
                         <%# --- End: Display Product Images --- %>

                        <div class="order-details mt-3"> <%# Add margin-top for spacing %>
                             <p class="mb-1"><strong>Shipping To:</strong> <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, Pin: <%= order.shippingAddress.pincode %></p>
                             <% if (order.status === 'Delivered' && order.receivedByDate) { %>
                                <p class="text-success mb-1"><small><strong>Delivered On:</strong> <%= formatDateIST(order.receivedByDate) %></small></p>
                              <% } %>
                              <%# Display cancellation reason if present %>
                              <% if (order.status === 'Cancelled' && order.cancellationReason) { %>
                                <p class="text-danger mb-1"><small><strong>Reason:</strong> <%= order.cancellationReason %></small></p>
                              <% } %>

                              <%# Display Delivery OTP for Customer %>
                              <% if (order.showDeliveryOtp) { %>
                                <div class="delivery-otp-display mt-2 p-2 border rounded bg-light">
                                    <p class="mb-1">
                                        <strong>Delivery OTP:</strong>
                                        <strong class="delivery-otp-code ms-1"><%= order.orderOTP %></strong> <%# Display full OTP %>
                                    </p>
                                    <small class="text-muted d-block">Provide this code to the delivery person (Seller/Admin).</small>
                                    <% if (order.orderOTPExpires) { %>
                                        <small class="text-muted d-block">Expires: <%= formatDateIST(order.orderOTPExpires) %></small>
                                    <% } %>
                                </div>
                              <% } %>
                              <%# End: Display Delivery OTP %>
                         </div>
                    </div>
                     <div class="order-actions text-end p-2 border-top"> <%# Adjusted padding/border %>
                        <% if (order.isCancellable) { %>
                            <form action="/orders/cancel/<%= order._id %>" method="POST" onsubmit="return confirm('Are you sure you want to cancel this order?');" class="form-submit-spinner d-inline-block">
                                <button type="submit" class="btn btn-danger btn-sm">Cancel Order</button>
                             </form>
                         <% } else if (order.status === 'Pending' && !order.showDeliveryOtp && order.cancellationAllowedUntil && new Date(order.cancellationAllowedUntil).getTime() < Date.now()) { %>
                             <small class="text-muted">Cancellation window closed.</small>
                         <% } else if (order.status === 'Pending' && !order.showDeliveryOtp) { %>
                            <small class="text-muted">Processing...</small>
                        <% } else if (order.status === 'Pending' && order.showDeliveryOtp) { %>
                             <small class="text-info">Awaiting delivery confirmation...</small>
                         <% } else if (order.status === 'Delivered') { %>
                              <small class="text-success">Order Completed.</small>
                         <% } else if (order.status === 'Cancelled') { %>
                              <small class="text-danger">Order Cancelled.</small>
                         <% } %>
                     </div>
                </div>
            <% }) %>
        </div>
    <% } else { %>
        <p>You haven't placed any orders yet. <a href="/">Start Shopping!</a></p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/user/profile.ejs:
<%# views/user/profile.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="profile-container">
    <%# --- Combine Welcome and Name Edit --- %>
    <div class="profile-header mb-4 d-flex align-items-center justify-content-center flex-wrap"> <%# Flex container %>
        <h1 class="mb-0 me-3">My Profile</h1> <%# Removed bottom margin from h1 %>
        <div class="d-flex align-items-center">
             <%# Display current name - initially visible %>
             <span id="saved-name-display" class="fs-5 me-2">Welcome, <strong id="display-user-name"><%= user.name %></strong></span>
             <%# Edit button (icon) - initially visible %>
            <button type="button" id="edit-name-btn" class="btn btn-text btn-sm" title="Edit Name"><i class="fas fa-edit"></i></button>

             <%# Name edit form - initially hidden %>
             <form action="/user/profile/update-name" method="POST" id="name-form" class="hidden inline-form align-items-center ms-2 form-submit-spinner">
                 <label for="name-input" class="visually-hidden">New Name:</label>
                 <input type="text" id="name-input" name="name" class="form-control form-control-sm me-2" value="<%= user.name %>" required minlength="2" placeholder="Enter new name">
                 <button type="submit" class="btn btn-primary btn-sm me-1">Save</button>
                 <button type="button" id="cancel-edit-name-btn" class="btn btn-secondary btn-sm">Cancel</button>
             </form>
         </div>
    </div>
    <p class="text-muted text-center small mb-3">Email: <%= user.email %></p> <%# Moved email below %>

    <%# --- NEW: My Orders Section --- %>
    <div class="profile-section orders-section mb-4">
        <h2>My Orders</h2>
        <div class="d-flex flex-wrap gap-2">
            <a href="/orders/my-orders" class="btn btn-secondary"> <%# Using btn-secondary style %>
                <i class="fas fa-box"></i> View My Orders
            </a>
        </div>
    </div>
    <%# --- End: My Orders Section --- %>

    <%# --- Conditional Dashboards Section --- %>
    <div class="profile-section dashboards-section mb-4">
        <h2>Dashboards</h2>
        <div class="d-flex flex-wrap gap-2"> <%# Use flex for button layout %>
            <% if (user.role === 'admin') { %>
                <a href="/admin/dashboard" class="btn btn-info"><i class="fas fa-user-shield"></i> Admin Dashboard</a>
            <% } %>
             <% if (user.role === 'seller') { %>
                 <a href="/seller/dashboard" class="btn btn-success"><i class="fas fa-store"></i> Seller Dashboard</a>
             <% } %>
             <% if (user.role === 'user') { %> <%# Explicitly show user status %>
                 <p class="mb-0 align-self-center">Standard User Account</p>
            <% } %>
         </div>
    </div>

    <%# --- Address Management Section --- %>
    <div class="profile-section address-section mb-4">
        <h2>My Address</h2>
        <%# Display Saved Address %>
        <div id="saved-address-display" class="<%= (!user.address || !user.address.name) ? 'hidden' : '' %>">
            <% if (user.address && user.address.name) { %>
                <p class="mb-1"><strong><%= user.address.name %></strong></p>
                <p class="mb-1"><%= user.address.phone %></p>
                <p class="mb-1"><%= user.address.landmarkNearby ? user.address.landmarkNearby + ', ' : '' %><%= user.address.cityVillage %>, Pincode: <%= user.address.pincode %></p>
                <button type="button" id="edit-address-btn" class="btn btn-outline-secondary btn-sm mt-2">Edit Address</button>
            <% } else { %>
                <p class="text-muted">No address saved yet.</p>
                 <button type="button" id="add-address-btn" class="btn btn-outline-primary btn-sm mt-2">Add Address</button>
            <% } %>
        </div>

        <%# Address Form (Initially hidden if address exists) %>
        <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (user.address && user.address.name) ? 'hidden' : '' %> form-submit-spinner mt-3">
             <h3 class="h5"><%= (user.address && user.address.name) ? 'Edit Address' : 'Add Address' %></h3>
             <input type="hidden" name="source" value="profile">
             <div class="form-group">
                 <label for="name" class="form-label small">Full Name:</label>
                 <input type="text" id="name" name="name" class="form-control" value="<%= user.address?.name || '' %>" required autocomplete="name">
             </div>
             <div class="form-group">
                 <label for="phone" class="form-label small">Phone Number:</label>
                 <input type="tel" id="phone" name="phone" class="form-control" value="<%= user.address?.phone || '' %>" required pattern="\d{10,15}" minlength="10" maxlength="15" title="Enter 10 to 15 digit phone number" autocomplete="tel">
             </div>
             <div class="form-group">
                 <label for="pincode" class="form-label small">Pincode:</label>
                 <input type="text" id="pincode" name="pincode" class="form-control" value="<%= user.address?.pincode || '' %>" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit Pincode" autocomplete="postal-code">
             </div>
             <div class="form-group">
                 <label for="cityVillage" class="form-label small">City / Village:</label>
                 <input type="text" id="cityVillage" name="cityVillage" class="form-control" value="<%= user.address?.cityVillage || '' %>" required autocomplete="address-level2">
             </div>
             <div class="form-group">
                 <label for="landmarkNearby" class="form-label small">Landmark / Nearby (Optional):</label>
                 <input type="text" id="landmarkNearby" name="landmarkNearby" class="form-control" value="<%= user.address?.landmarkNearby || '' %>">
             </div>
             <button type="submit" class="btn btn-primary me-2">Save Address</button>
             <button type="button" id="cancel-edit-btn" class="btn btn-secondary <%= (!user.address || !user.address.name) ? 'hidden' : '' %>">Cancel Edit</button>
        </form>
    </div>

    <%# --- Logout Section --- %>
    <div class="profile-section logout-section mt-4 pt-3 border-top">
        <h2>Account Actions</h2>
        <form action="/auth/logout" method="POST" class="form-submit-spinner">
            <button type="submit" class="btn btn-danger"><i class="fas fa-sign-out-alt"></i> Logout</button>
        </form>
    </div>

</div>

<%# --- Consolidated Script for Profile Page --- %>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Address Edit Logic (Existing) ---
    const editAddressBtn = document.getElementById('edit-address-btn');
    const addAddressBtn = document.getElementById('add-address-btn');
    const cancelAddressBtn = document.getElementById('cancel-edit-btn');
    const addressForm = document.getElementById('address-form');
    const savedAddressDiv = document.getElementById('saved-address-display');

    const showAddressForm = () => {
        if (!addressForm || !savedAddressDiv) return;
        addressForm.classList.remove('hidden');
        addressForm.querySelector('h3').textContent = savedAddressDiv.querySelector('strong') ? 'Edit Address' : 'Add Address';
        savedAddressDiv.classList.add('hidden');
        if (cancelAddressBtn) cancelAddressBtn.classList.remove('hidden');
    };

    const hideAddressForm = () => {
        if (!addressForm || !savedAddressDiv) return;
        addressForm.classList.add('hidden');
        if (savedAddressDiv.querySelector('strong')) { // Check if address actually exists
            savedAddressDiv.classList.remove('hidden');
        } else {
            savedAddressDiv.classList.remove('hidden'); // Still show "No address" message
            if (cancelAddressBtn) cancelAddressBtn.classList.add('hidden');
        }
    };

    if (editAddressBtn) {
        editAddressBtn.addEventListener('click', showAddressForm);
    }
    if (addAddressBtn) {
         addAddressBtn.addEventListener('click', () => {
            if(addressForm) addressForm.reset();
            showAddressForm();
            if(cancelAddressBtn) cancelAddressBtn.classList.add('hidden');
         });
    }
    if (cancelAddressBtn) {
        cancelAddressBtn.addEventListener('click', hideAddressForm);
    }

    // Initial Address State
    if (savedAddressDiv && addressForm && addAddressBtn) {
        if (!savedAddressDiv.querySelector('strong') && addressForm.classList.contains('hidden')) {
           addAddressBtn.classList.remove('hidden');
        } else {
             addAddressBtn.classList.add('hidden');
        }
    }


    // --- Name Edit Logic (New) ---
    const editNameBtn = document.getElementById('edit-name-btn');
    const cancelNameBtn = document.getElementById('cancel-edit-name-btn');
    const nameForm = document.getElementById('name-form');
    const savedNameDisplaySpan = document.getElementById('saved-name-display'); // The span containing the welcome text
    const nameInput = document.getElementById('name-input'); // The input field
    const displayUserNameStrong = document.getElementById('display-user-name'); // The strong tag holding the name

    const showNameForm = () => {
        if (!nameForm || !savedNameDisplaySpan || !editNameBtn) return;
        nameForm.classList.remove('hidden');        // Show the form
        savedNameDisplaySpan.classList.add('hidden'); // Hide the "Welcome, Name" span
        editNameBtn.classList.add('hidden');        // Hide the edit icon button
        nameInput.focus();                          // Focus the input field
    };

    const hideNameForm = () => {
        if (!nameForm || !savedNameDisplaySpan || !editNameBtn || !displayUserNameStrong) return;
        nameForm.classList.add('hidden');            // Hide the form
        savedNameDisplaySpan.classList.remove('hidden'); // Show the "Welcome, Name" span
        editNameBtn.classList.remove('hidden');      // Show the edit icon button again
        // Reset input value to the currently displayed name when cancelling
        nameInput.value = displayUserNameStrong.textContent;
    };

    if (editNameBtn) {
        editNameBtn.addEventListener('click', showNameForm);
    }

    if (cancelNameBtn) {
        cancelNameBtn.addEventListener('click', hideNameForm);
    }
});
</script>

<%- include('../partials/footer') %>

views/error.ejs:
<%- include('./partials/header', { title: 'Error' }) %>

<div class="error-container container">
    <h1>Error <%= typeof statusCode !== 'undefined' ? statusCode : '' %></h1>
    <p class="lead text-danger"><%= message %></p>

    <%# Use NODE_ENV from res.locals now %>
    <% if (NODE_ENV === 'development' && typeof stack !== 'undefined' && stack) { %>
        <details style="white-space: pre-wrap; margin-top: 20px; background: #f1f1f1; padding: 10px; border-radius: 5px; font-size: 0.8em;">
            <summary>Stack Trace (Development Mode)</summary>
            <code><%= stack %></code>
        </details>
    <% } %>

    <p style="margin-top: 20px;"><a href="/" class="btn btn-primary">Go back to Home</a></p>
</div>

<%- include('./partials/footer') %>

.env:
NODE_ENV=development
PORT=3000
MONGO_URI=mongodb+srv://ecommerce:ecommerce@cluster0.jcfuk.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
SESSION_SECRET=e6142a6d230d0445c9b050af41bfd1e53ece6270797e546fbdaa97af20f3b77e # Use a strong, random secret
SESSION_MAX_AGE=86400000 # 1 day in milliseconds

# Email Configuration
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USER=ayyappanallamothu4@gmail.com
MAIL_PASS=yxor nmot lxmq skyc # Use an App Password if using Gmail 2FA
MAIL_FROM='"Surya Ecom" <ayyappanallamothu4@gmail.com>' # Ensure format is correct

# --- NEW: Add your Gemini API Key ---
GEMINI_API_KEY=AIzaSyCX31vkQ9Qf7t-ytSeDZUGR8hK4XZUHQT0

server.js:
// server.js
require('dotenv').config();
const express = require('express');
const path = require('path');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const flash = require('connect-flash');
const methodOverride = require('method-override');

const connectDB = require('./config/database');
const mainRouter = require('./routes/index');
const { notFound, errorHandler } = require('./middleware/errorMiddleware');


connectDB();

const app = express();


app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));


app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));
app.use(methodOverride('_method'));


app.use(
  session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({
        mongoUrl: process.env.MONGO_URI,
        collectionName: 'sessions'
    }),
    cookie: {
        maxAge: parseInt(process.env.SESSION_MAX_AGE || '86400000', 10),
        httpOnly: true
        // secure: process.env.NODE_ENV === 'production',
        // sameSite: 'lax'
    }
  })
);


app.use(flash());


app.use((req, res, next) => {

  res.locals.success_msg = req.flash('success_msg');
  res.locals.error_msg = req.flash('error_msg');
  res.locals.error = req.flash('error');


  res.locals.currentUser = req.session.user || null;


  res.locals.currentUrl = req.originalUrl;
  res.locals.fullUrl = `${req.protocol}://${req.get('host')}${req.originalUrl}`;


  res.locals.cartItemCount = req.session.user?.cart?.reduce((count, item) => count + (item.quantity || 0), 0) || 0;


  let userInitials = '??';
  if (req.session.user && req.session.user.name) {
    try {
      const nameParts = req.session.user.name.trim().split(' ');
      if (nameParts.length > 1 && nameParts[0] && nameParts[1]) {
          userInitials = (nameParts[0][0] + nameParts[nameParts.length - 1][0]).toUpperCase();
      } else if (nameParts.length === 1 && nameParts[0].length >= 2) {
          userInitials = nameParts[0].substring(0, 2).toUpperCase();
      } else if (nameParts.length === 1 && nameParts[0].length === 1) {
           userInitials = (nameParts[0][0] + nameParts[0][0]).toUpperCase();
      }
       else if (req.session.user.email) {
            const emailPrefix = req.session.user.email.split('@')[0];
            if (emailPrefix.length >= 2) {
                userInitials = emailPrefix.substring(0, 2).toUpperCase();
            } else if (emailPrefix.length === 1) {
                userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
            }
       }
    } catch (e) {
      console.error("Error generating initials:", e);
       if (req.session.user.email) {
            const emailPrefix = req.session.user.email.split('@')[0];
            if (emailPrefix.length >= 2) {
                userInitials = emailPrefix.substring(0, 2).toUpperCase();
            } else if (emailPrefix.length === 1) {
                userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
            }
       }
    }
  } else if (req.session.user && req.session.user.email) {
        const emailPrefix = req.session.user.email.split('@')[0];
        if (emailPrefix.length >= 2) {
            userInitials = emailPrefix.substring(0, 2).toUpperCase();
        } else if (emailPrefix.length === 1) {
            userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
        }
  }
  res.locals.userInitials = userInitials;


  res.locals.formatDateIST = (dateInput) => {
      if (!dateInput) return 'N/A';
      try {
          const date = new Date(dateInput);
          if (isNaN(date.getTime())) {
              console.warn(`formatDateIST received invalid dateInput: ${dateInput}`);
              return 'Invalid Date';
          }

          const options = {
              timeZone: 'Asia/Kolkata',
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              // second: '2-digit',
              hour12: true
          };
          return date.toLocaleString('en-IN', options);
      } catch (error) {
          console.error("Error formatting date to IST:", error, "Input:", dateInput);
          return 'Date Error';
      }
  };


  res.locals.defaultSiteName = 'miniapp';


  res.locals.NODE_ENV = process.env.NODE_ENV;

  next();
});


app.use('/', mainRouter);


app.use(notFound);
app.use(errorHandler);


const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});