config/database.js:
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error connecting to MongoDB: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;

config/mailer.js:
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
  host: process.env.MAIL_HOST,
  port: parseInt(process.env.MAIL_PORT, 10),
  secure: parseInt(process.env.MAIL_PORT, 10) === 465,
  auth: {
    user: process.env.MAIL_USER,
    pass: process.env.MAIL_PASS,
  },
});

transporter.verify((error, success) => {
  if (error) {
    console.error('Error with Nodemailer transporter configuration:', error);
  } else {
    console.log('Nodemailer transporter is ready to send emails');
  }
});

const sendEmail = async (to, subject, text, html) => {
  try {
    await transporter.sendMail({
      from: process.env.MAIL_FROM,
      to: to,
      subject: subject,
      text: text,
      html: html,
    });
    console.log(`Email sent successfully to ${to}`);
    return true;
  } catch (error) {
    console.error(`Error sending email to ${to}:`, error);
    return false;
  }
};

module.exports = { sendEmail };

controllers/adminController.js:
// controllers/adminController.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const { sendEmail } = require('../config/mailer');
const {
    generateAndSendDirectDeliveryOTPByAdmin,
    confirmDirectDeliveryByAdmin,
} = require('./orderController'); // Make sure path is correct
const mongoose = require('mongoose'); // Needed for transactions


// Keep cancellationReasons array (ensure it matches your needs)
const cancellationReasons = [
    "📞 Unable to contact the customer",
    "❗ Out of stock/unavailable item",
    "🗺️ Address incorrect/incomplete",
    "🚫 Customer requested cancellation",
    "❓ Other (Admin)",
];

// =======================
// Dashboard & Page Getters
// =======================
exports.getAdminDashboard = (req, res) => {
    // Simple render, no date formatting needed here
    res.render('admin/dashboard', { title: 'Admin Dashboard' });
};

exports.getUploadProductPage = (req, res) => {
    // Simple render
    res.render('admin/upload-product', { title: 'Upload New Product' });
};

exports.getManageProductsPage = async (req, res, next) => {
    try {
        // Fetch products, dates formatted in EJS view
        const products = await Product.find({}).sort({ createdAt: -1 }).lean();
        res.render('admin/manage-products', {
            title: 'Manage Products',
            products: products
        });
    } catch (error) {
        next(error);
    }
};

exports.getEditProductPage = async (req, res, next) => {
     try {
        const product = await Product.findById(req.params.id);
         if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.redirect('/admin/manage-products');
        }
        // Render edit page, no date formatting needed here
        res.render('admin/edit-product', {
            title: `Edit Product: ${product.name}`,
            product: product
        });
    } catch (error) {
         if (error.name === 'CastError') {
           req.flash('error_msg', 'Invalid product ID format.');
            return res.redirect('/admin/manage-products');
       }
        next(error);
     }
 };

// --- getManageOrdersPage ---
// No changes needed here, date formatting happens in the EJS template
exports.getManageOrdersPage = async (req, res, next) => {
    try {
        const orders = await Order.find({})
                                   .sort({ orderDate: -1 })
                                   .populate('products.productId', 'name imageUrl _id price') // Populate necessary fields
                                   .lean(); // Use lean for better performance

        orders.forEach(order => {
            // No manual date formatting needed here
            // Determine capabilities based on status
            order.canBeCancelledByAdmin = order.status === 'Pending';
            order.canBeDirectlyDeliveredByAdmin = order.status === 'Pending';

            // Pre-calculate items summary (optional improvement)
            if (order.products && order.products.length > 0) {
                order.itemsSummary = order.products.map(p =>
                    `${p.name || '[Product Name Missing]'} (Qty: ${p.quantity}) @ ₹${(p.priceAtOrder || 0).toFixed(2)}`
                ).join('<br>');
            } else {
                order.itemsSummary = 'No items found';
            }
        });

        res.render('admin/manage-orders', {
            title: 'Manage Orders',
            orders: orders, // Pass orders with raw dates
            cancellationReasons: cancellationReasons
        });
    } catch (error) {
        next(error);
    }
};
// --- END getManageOrdersPage function ---

// --- getManageUsersPage ---
// No changes needed here, date formatting happens in the EJS template
exports.getManageUsersPage = async (req, res, next) => {
    try {
        const users = await User.find({ _id: { $ne: req.session.user._id } }) // Exclude current admin
                                  .select('name email role createdAt isVerified address.phone') // Select fields needed
                                  .sort({ createdAt: -1 })
                                  .lean();
        res.render('admin/manage-users', {
            title: 'Manage Registered Users',
            users: users // Pass users with raw createdAt date
        });
    } catch (error) {
        next(error);
    }
};

// =======================
// Product Actions
// =======================
exports.uploadProduct = async (req, res, next) => {
    const { name, category, price, stock, imageUrl, specifications } = req.body;
    const sellerEmail = req.session.user.email; // Assuming admin's email acts as seller

    // Basic validation
     if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields (Name, Category, Price, Stock, Image URL).');
        return res.redirect('/admin/upload-product');
    }
     if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
        req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
        return res.redirect('/admin/upload-product');
     }

    try {
        const newProduct = new Product({
            name: name.trim(),
            category: category.trim(),
            price: Number(price),
            stock: Number(stock),
            imageUrl: imageUrl.trim(),
            specifications: specifications ? specifications.trim() : '',
            sellerEmail // Store who uploaded it
        });

        await newProduct.save();
        req.flash('success_msg', `Product "${newProduct.name}" uploaded successfully.`);
        res.redirect('/admin/manage-products');

    } catch (error) {
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
           return res.redirect('/admin/upload-product');
       }
        next(error); // Pass other errors to the handler
    }
};

 exports.updateProduct = async (req, res, next) => {
    const productId = req.params.id;
    const { name, category, price, stock, imageUrl, specifications } = req.body;

     // Basic validation
     if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields.');
        return res.redirect(`/admin/manage-products/edit/${productId}`);
    }
     if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
         req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
        return res.redirect(`/admin/manage-products/edit/${productId}`);
    }

    try {
        const product = await Product.findById(productId);
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('/admin/manage-products');
         }

         // Update fields
         product.name = name.trim();
         product.category = category.trim();
         product.price = Number(price);
         product.stock = Number(stock);
         product.imageUrl = imageUrl.trim();
         product.specifications = specifications ? specifications.trim() : '';
         // sellerEmail likely shouldn't change on update unless intended

         await product.save(); // Mongoose validation runs here
         req.flash('success_msg', `Product "${product.name}" updated successfully.`);
         res.redirect('/admin/manage-products');

    } catch (error) {
         if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
             req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
             return res.redirect(`/admin/manage-products/edit/${productId}`);
         }
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid product ID format.');
             return res.status(400).redirect('/admin/manage-products');
         }
        next(error); // Pass other errors to the handler
     }
 };

exports.removeProduct = async (req, res, next) => {
    const productId = req.params.id;
    try {
         // Consider if product is in active orders before deleting? Maybe just mark as inactive?
         // For now, direct deletion:
         const product = await Product.findByIdAndDelete(productId);
        if (!product) {
             req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('/admin/manage-products');
         }
         // TODO: Consider implications if product is in someone's cart or an unfulfilled order.
         // Maybe prevent deletion if orderCount > 0 and status isn't Delivered/Cancelled?
         req.flash('success_msg', `Product "${product.name}" removed successfully.`);
         res.redirect('/admin/manage-products');
    } catch (error) {
        if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid product ID format.');
             return res.status(400).redirect('/admin/manage-products');
         }
        next(error); // Pass other errors to the handler
    }
};

// =======================
// Order Actions
// =======================

exports.sendDirectDeliveryOtpByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    try {
        // Call the logic from orderController
        const result = await generateAndSendDirectDeliveryOTPByAdmin(orderId);
        // Flash the success message returned by the service function
        req.flash('success_msg', result.message + ' Ask customer for OTP to confirm delivery.');
    } catch (error) {
        // Flash the error message from the service function
        req.flash('error_msg', `Failed to send direct delivery OTP: ${error.message}`);
    }
    // Redirect back regardless of success/failure
    res.redirect('/admin/manage-orders');
};

exports.confirmDirectDeliveryByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { otp } = req.body;
    const adminUserId = req.session.user._id; // Identify which admin confirmed

    // Validate OTP format
    if (!otp || !/^\d{6}$/.test(otp.trim())) {
        req.flash('error_msg', 'Please enter the 6-digit OTP received by the customer.');
        return res.redirect('/admin/manage-orders');
    }

    try {
        // --- Pass 'res' object to the underlying function ---
        // This allows the function in orderController to access res.locals.formatDateIST
        const { order } = await confirmDirectDeliveryByAdmin(orderId, adminUserId, otp.trim(), res);
        // --- End Passing 'res' ---
        req.flash('success_msg', `Order ${orderId} confirmed delivered successfully (Directly by Admin).`);
    } catch (error) {
        // Flash the specific error message from the service function
        req.flash('error_msg', `Direct delivery confirmation failed: ${error.message}`);
    }
    // Redirect back regardless of success/failure
    res.redirect('/admin/manage-orders');
};

// --- UPDATED cancelOrderByAdmin ---
exports.cancelOrderByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const adminUserId = req.session.user._id; // Log which admin cancelled

    // Validate reason
    if (!reason || !cancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid reason for cancellation.');
        return res.redirect('/admin/manage-orders');
    }

    const sessionDB = await mongoose.startSession(); // Use transaction
    sessionDB.startTransaction();
    try {
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'name _id') // Need _id for stock restore
                                .session(sessionDB); // Add session to find

        if (!order) {
            req.flash('error_msg', 'Order not found.');
            await sessionDB.abortTransaction(); sessionDB.endSession();
            return res.status(404).redirect('/admin/manage-orders');
        }
        // Only allow cancellation if order is 'Pending'
        if (order.status !== 'Pending') {
            req.flash('error_msg', `Order cannot be cancelled by admin in its current status ('${order.status}'). Must be 'Pending'.`);
            await sessionDB.abortTransaction(); sessionDB.endSession();
            return res.redirect('/admin/manage-orders');
        }

        // Stock Restoration Logic (within transaction)
        console.log(`Admin Cancellation (${adminUserId}): Attempting to restore stock for cancelled order ${orderId}.`);
        const productStockRestorePromises = order.products.map(item => {
              const quantityToRestore = Number(item.quantity);
             if (isNaN(quantityToRestore) || quantityToRestore <= 0) {
                console.warn(`Admin Cancel: Invalid quantity ${item.quantity} for product ${item.productId?._id || 'Unknown ID'} in order ${orderId}, skipping stock restore.`);
                return Promise.resolve(); // Resolve successfully, don't block
            }
            if (!item.productId?._id) { // Check populated ID
                console.warn(`Admin Cancel: Missing or invalid productId for an item in order ${orderId}, skipping stock restore.`);
                return Promise.resolve(); // Resolve successfully
            }
             // Add session to stock update
             return Product.updateOne(
                { _id: item.productId._id },
                { $inc: { stock: quantityToRestore, orderCount: -1 } },
                { session: sessionDB }
            ).catch(err => {
               // Log error but allow transaction to proceed
               console.error(`Admin Cancel: Failed restore stock/orderCount for product ${item.productId._id} (${item.productId.name}) on order ${orderId}: ${err.message}`);
            });
        });
        await Promise.all(productStockRestorePromises);
        console.log(`Admin Cancel: Stock restoration attempted for order ${orderId}.`);

        // Update order status and reason
        order.status = 'Cancelled';
        order.cancellationReason = reason;
        // Pre-save hook should clear OTP, delivery date, cancellation window
        await order.save({ session: sessionDB }); // Save order within transaction

        await sessionDB.commitTransaction(); // Commit cancellation and stock restore

        // Notifications (Best Effort - outside transaction) - Customer
        try {
            const subjectCust = `Your Order (${order._id}) Has Been Cancelled`;
            // Email does not need date formatting for cancellation
            const htmlCust = `<p>Your order (${order._id}) has been cancelled by administration.</p><p><strong>Reason:</strong> ${order.cancellationReason}</p><p>Please contact support if you have questions regarding this cancellation.</p>`;
            await sendEmail(order.userEmail, subjectCust, `Your order ${order._id} has been cancelled. Reason: ${order.cancellationReason}`, htmlCust);
        } catch (emailError) {
            console.error(`Failed sending cancellation email to customer for order ${order._id}:`, emailError);
        }

        req.flash('success_msg', `Order ${orderId} cancelled successfully with reason: ${reason}.`);
        res.redirect('/admin/manage-orders');

    } catch (error) {
        await sessionDB.abortTransaction(); // Abort transaction on error
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid Order ID format.');
        } else {
            console.error(`Error cancelling order ${orderId} by admin ${adminUserId}:`, error);
            req.flash('error_msg', 'Failed to cancel the order due to an internal error.');
        }
        res.redirect('/admin/manage-orders');
    } finally {
        sessionDB.endSession(); // Always end session
    }
};
// --- END UPDATED cancelOrderByAdmin ---

// =======================
// User Management Actions
// =======================
exports.updateUserRole = async (req, res, next) => {
    const userId = req.params.id;
    const { role } = req.body;
     const allowedRoles = ['user', 'admin']; // Define allowed roles explicitly

     // Validate input role
     if (!role || !allowedRoles.includes(role)) {
        req.flash('error_msg', 'Invalid role selected.');
         return res.status(400).redirect('/admin/manage-users');
     }

    try {
        // Prevent admin from changing their own role
        if (req.params.id === req.session.user._id.toString()) {
             req.flash('error_msg', 'You cannot change your own role.');
             return res.redirect('/admin/manage-users');
         }

        const user = await User.findById(userId);
         if (!user) {
            req.flash('error_msg', 'User not found.');
             return res.status(404).redirect('/admin/manage-users');
         }

         // Change role and save
         user.role = role;
        await user.save(); // Mongoose validation runs here

        req.flash('success_msg', `User ${user.email}'s role updated to ${role}.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid user ID format.');
             return res.status(400).redirect('/admin/manage-users');
         } else {
             console.error(`Error updating role for user ${userId}:`, error);
            req.flash('error_msg', 'Error updating user role.');
            res.redirect('/admin/manage-users');
         }
    }
};

exports.removeUser = async (req, res, next) => {
    const userId = req.params.id;
    try {
        // Prevent admin from removing themselves
        if (req.params.id === req.session.user._id.toString()) {
            req.flash('error_msg', 'You cannot remove yourself.');
            return res.redirect('/admin/manage-users');
        }

         const user = await User.findById(userId);
         if (!user) {
            req.flash('error_msg', 'User not found.');
             return res.status(404).redirect('/admin/manage-users');
         }

         // Prevent removal of the last admin
         if (user.role === 'admin') {
             const adminCount = await User.countDocuments({ role: 'admin' });
             if (adminCount <= 1) {
                 req.flash('error_msg', 'Cannot remove the last admin account.');
                return res.redirect('/admin/manage-users');
             }
         }

         // TODO: Consider implications if user has pending/active orders.
         // Maybe prevent deletion or anonymize orders first?
         // For now, direct deletion:
        await User.deleteOne({ _id: userId });

        req.flash('success_msg', `User ${user.email} removed successfully.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid user ID format.');
             return res.status(400).redirect('/admin/manage-users');
         } else {
             console.error(`Error removing user ${userId}:`, error);
            req.flash('error_msg', 'Error removing user.');
            res.redirect('/admin/manage-users');
         }
     }
 };
controllers/authController.js:
// controllers/authController.js
const User = require('../models/User');
const Product = require('../models/Product');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { generateOTP, setOTPExpiration } = require('../services/otpService');
const { sendEmail } = require('../config/mailer');

// --- Login/Register Page Getters ---
exports.getLoginPage = (req, res) => {
    if (req.session.user) {
         return res.redirect('/'); // Redirect if already logged in
    }
    res.render('auth/login', { title: 'Login' });
};

exports.getRegisterPage = (req, res) => {
    if (req.session.user) {
        return res.redirect('/'); // Redirect if already logged in
   }
    res.render('auth/register', { title: 'Register' });
};

// --- OTP Page Getters ---
exports.getVerifyOtpPage = (req, res) => {
    const email = req.query.email;
    if (!email) {
        req.flash('error_msg', 'Email required for OTP verification.');
        return res.redirect('/auth/register'); // Or login? Register makes more sense if they lack email.
    }
     if (req.session.user) {
        // Already logged in, shouldn't be verifying OTP typically
        return res.redirect('/');
   }
    res.render('auth/verify-otp', { title: 'Verify Email', email });
};

// --- Password Reset Page Getters ---
exports.getForgotPasswordPage = (req, res) => {
     if (req.session.user) {
         // Don't show forgot password if logged in
         return res.redirect('/');
    }
    res.render('auth/forgot-password', { title: 'Forgot Password' });
};

exports.getResetPasswordPage = async (req, res, next) => {
    try {
        const user = await User.findOne({
            resetPasswordToken: req.params.token,
            resetPasswordExpires: { $gt: Date.now() },
        });

        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired.');
            return res.redirect('/auth/forgot-password');
        }
        // Token is valid, render the reset page
        res.render('auth/reset-password', { title: 'Reset Password', token: req.params.token });
    } catch (error) {
        next(error); // Pass errors to the handler
    }
};

// --- Registration Logic ---
exports.registerUser = async (req, res, next) => {
    const { name, email, password, confirmPassword } = req.body;

    // --- Input Validation ---
    let errors = [];
    if (!name || !email || !password || !confirmPassword) {
        errors.push('Please fill in all fields.');
    }
    if (password !== confirmPassword) {
        errors.push('Passwords do not match.');
    }
    if (password && password.length < 6) {
        errors.push('Password must be at least 6 characters.');
    }
    // Basic email format check (more robust check in schema)
    if (email && !/^\S+@\S+\.\S+$/.test(email)) {
        errors.push('Please enter a valid email address.');
    }

    if (errors.length > 0) {
        req.flash('error_msg', errors.join(' '));
        // Persist input values (except passwords) back to the form
        return res.render('auth/register', {
            title: 'Register',
            name: name,
            email: email,
            // Don't send back passwords
        });
    }
    // --- End Validation ---

    try {
        const lowerCaseEmail = email.toLowerCase();
        let user = await User.findOne({ email: lowerCaseEmail });

        if (user && user.isVerified) {
            req.flash('error_msg', 'Email is already registered and verified.');
            return res.redirect('/auth/login');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10); // OTP expires in 10 minutes

        if (user && !user.isVerified) {
            // Found unverified user - update details and resend OTP
            user.name = name;
            // Re-hash password if provided (pre-save hook handles hashing)
            if (password) { user.password = password; }
            user.otp = otp;
            user.otpExpires = otpExpires;
            user.isVerified = false;
            // Save without full validation if only updating OTP/password on unverified doc
            await user.save({ validateBeforeSave: false });
        } else {
            // Create a brand new user instance
            user = new User({
                name,
                email: lowerCaseEmail,
                password, // Will be hashed by pre-save hook
                otp,
                otpExpires,
                isVerified: false, // Start as unverified
            });
            await user.save(); // Full validation runs here
        }

        // Send Verification Email
        const subject = 'Verify Your Email Address';
        const text = `Your verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
        const html = `<p>Welcome to our store!</p><p>Your verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;

        const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
            req.flash('success_msg', `An OTP has been sent to ${user.email}. Please check your inbox and verify.`);
            res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
        } else {
            // Optional: Clean up newly created unverified user if email fails
            // This check is heuristic: if created within the last few seconds.
             if(!user.createdAt || (Date.now() - user.createdAt.getTime()) < 5000) {
                try {
                    await User.deleteOne({ _id: user._id, isVerified: false });
                    console.log(`Cleaned up unverified user ${user.email} due to failed email send.`);
                } catch (deleteError) {
                    console.error(`Error cleaning up user ${user.email}:`, deleteError);
                }
             }
            req.flash('error_msg', 'Could not send OTP email. Please try registering again or contact support.');
            res.redirect('/auth/register');
        }

    } catch (error) {
        if (error.code === 11000) { // Handle MongoDB duplicate key error (email unique)
            req.flash('error_msg', 'Email already exists. Please login or use a different email.');
            return res.render('auth/register', { title: 'Register', name: name, email: email });
        }
        if (error.name === 'ValidationError') {
           let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', validationErrors.join(' '));
            return res.render('auth/register', { title: 'Register', name: name, email: email });
       }
        // Pass other unexpected errors to the global error handler
        next(error);
    }
};

// --- OTP Verification Logic ---
exports.verifyOtp = async (req, res, next) => {
    const { email, otp } = req.body;

    if (!email || !otp) {
        req.flash('error_msg', 'Email and OTP are required.');
         // Ensure email is passed back even on error
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email || '')}`);
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({
            email: lowerCaseEmail,
            otp: otp,
            otpExpires: { $gt: Date.now() }, // Check if OTP is still valid
        }).select('+password'); // Include password for potential immediate login

        if (!user) {
            // Check if user exists but OTP is wrong/expired
            const existingUser = await User.findOne({ email: lowerCaseEmail });
            if (existingUser && !existingUser.isVerified) {
                req.flash('error_msg', 'Invalid or expired OTP. Please try again or resend.');
            } else if (existingUser && existingUser.isVerified) {
                 req.flash('error_msg', 'This account is already verified. Please login.');
                 return res.redirect('/auth/login');
            } else {
                 // Should not happen if register flow is correct, but handle defensively
                 req.flash('error_msg', 'Verification failed. Please try registering again.');
                 return res.redirect('/auth/register');
            }
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email)}`);
        }

         // OTP is valid. Determine if it's for registration or password reset.
         const isPasswordReset = user.resetPasswordToken && user.resetPasswordExpires && user.resetPasswordExpires > Date.now();

         // Mark user as verified (if not already) and clear OTP fields in both cases
         user.isVerified = true;
         user.otp = undefined;
         user.otpExpires = undefined;

         if(isPasswordReset){
             // OTP was for password reset verification. Proceed to reset page.
             // Don't clear the reset token yet, it's needed for the next step.
             await user.save({ validateBeforeSave: false }); // Save quickly without full validation if needed

             req.flash('success_msg', 'OTP Verified. Please set your new password.');
             res.redirect(`/auth/reset-password/${user.resetPasswordToken}`);
         } else {
            // OTP was for registration verification. Log the user in.
            await user.save(); // Save changes (isVerified=true, cleared OTP)

            // --- Login User Immediately ---
            // Regenerate session ID for security
             req.session.regenerate(err => {
                if (err) {
                     console.error("Session regeneration error after OTP verify:", err);
                     return next(err); // Pass error to handler
                 }

                // Store essential user data in the new session
                req.session.user = {
                    _id: user._id,
                    name: user.name,
                    email: user.email,
                    role: user.role,
                    address: user.address, // Include address if available
                    cart: user.cart || [] // Initialize cart if necessary
                 };

                // Save the session before redirecting
                req.session.save(err => {
                   if (err) {
                        console.error("Session save error after OTP verify login:", err);
                        return next(err); // Pass error to handler
                    }
                    // Successful login after verification
                    req.flash('success_msg', 'Email verified successfully! You are now logged in.');
                    const returnTo = req.session.returnTo || '/'; // Redirect to intended page or home
                    delete req.session.returnTo; // Clean up returnTo URL
                    res.redirect(returnTo);
                 });
             });
            // --- End Immediate Login ---
         }

    } catch (error) {
        next(error); // Pass errors to the global error handler
    }
};

// --- Resend OTP Logic ---
exports.resendOtp = async (req, res, next) => {
    const { email } = req.body;

    if (!email) {
        req.flash('error_msg', 'Email is required to resend OTP.');
         // Try to get email from query if available for redirect back to verify page
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(req.query.email || '')}`);
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail });

        if (!user) {
            // Don't reveal if user exists or not for security.
            // Redirect to register page as a neutral action.
            req.flash('error_msg', 'If your email is registered, an OTP will be sent. Please check your inbox.');
            return res.redirect('/auth/register');
        }

        // Determine context: is it for registration verification or password reset?
        const isForReset = user.resetPasswordToken && user.resetPasswordExpires && user.resetPasswordExpires > Date.now();

        // If already verified AND it's not a password reset request, redirect to login
        if(user.isVerified && !isForReset) {
             req.flash('error_msg', 'This account is already verified. Please login.');
            return res.redirect('/auth/login');
        }
        // If not verified OR it IS for a password reset, proceed to send new OTP

        // Generate new OTP and expiry time
        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10); // New OTP valid for 10 minutes

        user.otp = otp;
        user.otpExpires = otpExpires;
        // We don't need validateBeforeSave: false here usually, unless hitting issues
        await user.save(); // Save the new OTP details

        // Prepare email content based on context
        let subject, text, html;
        if (isForReset) {
            subject = 'Your New Password Reset OTP';
             text = `Your new password reset OTP is: ${otp}\nIt will expire in 10 minutes.\nIf you did not request this, please ignore this email.`;
            html = `<p>Your new password reset OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;
        } else {
             subject = 'Your New Verification OTP';
             text = `Your new verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
            html = `<p>Your new verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;
        }

        // Send the email with the new OTP
        const emailSent = await sendEmail(user.email, subject, text, html);

        // Redirect back to the verify OTP page
        const redirectUrl = `/auth/verify-otp?email=${encodeURIComponent(user.email)}${isForReset ? '&reason=reset' : ''}`;

        if (emailSent) {
            req.flash('success_msg', `A new OTP has been sent to ${user.email}. Please check your inbox.`);
        } else {
            req.flash('error_msg', 'Could not resend OTP email. Please try again or contact support.');
        }
        res.redirect(redirectUrl);

    } catch (error) {
        next(error); // Pass errors to the global error handler
    }
};

// --- Login Logic ---
exports.loginUser = async (req, res, next) => {
    const { email, password } = req.body;

    if (!email || !password) {
        req.flash('error_msg', 'Please provide both email and password.');
        return res.render('auth/login', { title: 'Login', email: email }); // Render with email filled
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        // Find user, ensure password field is selected, and populate cart details
        const user = await User.findOne({ email: lowerCaseEmail })
                             .select('+password') // Explicitly request the password field
                             .populate('cart.productId'); // Populate cart for session

        if (!user) {
            req.flash('error_msg', 'Invalid credentials. Please check your email and password.');
            return res.render('auth/login', { title: 'Login', email: email });
        }

         // Check if user's email is verified
         if (!user.isVerified) {
            req.flash('error_msg', 'Your email is not verified. Please check your inbox for the verification OTP or request a new one.');
            // Redirect to OTP page, passing email
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
         }

        // Compare submitted password with the stored hash using the method on the user model
        const isMatch = await user.matchPassword(password);

        if (!isMatch) {
            req.flash('error_msg', 'Invalid credentials. Please check your email and password.');
            return res.render('auth/login', { title: 'Login', email: email });
        }

        // Password matched, credentials valid, proceed with session setup
        // Regenerate session ID to prevent session fixation attacks
         req.session.regenerate(err => {
            if (err) {
                 console.error("Session regeneration error during login:", err);
                 return next(err); // Pass error to handler
             }

            // Store essential, non-sensitive user data in the new session
            req.session.user = {
                _id: user._id,
                name: user.name,
                email: user.email,
                role: user.role,
                address: user.address, // Include address if available
                cart: user.cart // Include populated cart details
            };

             // Save the newly regenerated session
             req.session.save(err => {
                 if (err) {
                     console.error("Session save error after login:", err);
                     return next(err); // Pass error to handler
                 }
                 // Successful login
                 req.flash('success_msg', 'You are now logged in successfully.');
                 const returnTo = req.session.returnTo || '/'; // Redirect to intended page or home
                 delete req.session.returnTo; // Clean up returnTo URL
                 res.redirect(returnTo);
            });
        });

    } catch (error) {
        next(error); // Pass errors to the global error handler
    }
};

// --- Logout Logic ---
exports.logoutUser = (req, res, next) => {
    // Set the flash message *before* destroying the session
    req.flash('success_msg', 'You have been logged out successfully.');

    req.session.destroy(err => {
        if (err) {
            console.error('Session destruction error:', err);
            // Attempt to redirect even if destroy fails, but log the error
            req.flash('error_msg', 'Could not fully logout. Please clear your browser cookies.'); // Inform user
            return res.redirect('/auth/login');
            // Alternatively, pass to error handler: return next(err);
        }
        // Clear the session cookie on the client side
        // Use the default 'connect.sid' or your configured cookie name
        res.clearCookie('connect.sid');

        // Redirect to login page after successful destruction and cookie clearing
        res.redirect('/auth/login');
    });
};

// --- Forgot Password Logic ---
exports.forgotPassword = async (req, res, next) => {
    const { email } = req.body;
    if (!email) {
        req.flash('error_msg', 'Please provide an email address.');
        return res.redirect('/auth/forgot-password');
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail });

        // Security: Always show a generic success message regardless of whether the user exists or is verified.
        // This prevents attackers from enumerating registered/verified emails.
        const genericMessage = 'If an account with that email exists and is verified, a password reset OTP will be sent. Please check your inbox.';
        req.flash('success_msg', genericMessage); // Flash the message immediately

        if (!user || !user.isVerified) {
            // If user doesn't exist, or exists but isn't verified, we still show the generic message.
            // Log internally for debugging if needed, but don't reveal status to the client.
            console.log(`Password reset request for ${lowerCaseEmail}: User ${!user ? 'not found' : 'found but not verified'}. Sending generic response.`);
            return res.redirect('/auth/forgot-password'); // Redirect back
        }

         // User exists and is verified, proceed with OTP generation
         const otp = generateOTP();
         const resetToken = crypto.randomBytes(20).toString('hex'); // Token for the reset link itself (after OTP verify)
        const otpExpires = setOTPExpiration(10); // OTP valid for 10 mins
        const resetExpires = setOTPExpiration(60); // Link valid for 60 mins after OTP verification

        // Store OTP, token, and expiry times on the user document
        user.otp = otp;
        user.otpExpires = otpExpires;
        user.resetPasswordToken = resetToken;
        user.resetPasswordExpires = resetExpires;
        await user.save();

        // Prepare email content for OTP verification step
        const subject = 'Password Reset Request - Verify OTP';
        const text = `You requested a password reset.\n\nPlease use the following OTP to verify your request: ${otp}\n\nThis OTP will expire in 10 minutes.\n\nIf you did not request this, please ignore this email.`;
        const html = `<p>You requested a password reset.</p><p>Please use the following OTP to verify your request: <strong>${otp}</strong></p><p>This OTP will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;

         // Send the email containing the OTP
         const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
            // The generic success message is already flashed. Redirect to OTP page.
             console.log(`Password reset OTP sent to verified user: ${user.email}`);
             // Redirect to OTP verification page, indicating it's for reset
             res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}&reason=reset`);
        } else {
            // If email fails, clear the OTP/token fields to prevent misuse
            user.otp = undefined;
            user.otpExpires = undefined;
            user.resetPasswordToken = undefined;
            user.resetPasswordExpires = undefined;
            await user.save(); // Save the cleared fields

            console.error(`Failed to send password reset OTP email to ${user.email}`);
            // Keep the generic success message flashed earlier, but maybe add an error log or specific admin alert.
            // Don't flash an error_msg here as it contradicts the generic success message.
            res.redirect('/auth/forgot-password'); // Redirect back
        }

    } catch (error) {
        console.error("Error in forgotPassword:", error);
        // Show a generic error message in case of unexpected issues
        req.flash('error_msg', 'An error occurred while processing your request. Please try again later.');
        res.redirect('/auth/forgot-password');
        // Or pass to global handler: next(error);
    }
};

// --- Reset Password Logic ---
exports.resetPassword = async (req, res, next) => {
    const { password, confirmPassword } = req.body;
    const token = req.params.token;

    // --- Input Validation ---
    let errors = [];
    if (!password || !confirmPassword) {
        errors.push('Please enter and confirm your new password.');
    }
    if (password !== confirmPassword) {
        errors.push('Passwords do not match.');
    }
     if (password && password.length < 6) {
         errors.push('Password must be at least 6 characters.');
    }
    if (errors.length > 0) {
         req.flash('error_msg', errors.join(' '));
         return res.redirect(`/auth/reset-password/${token}`); // Redirect back to the form
    }
    // --- End Validation ---

    try {
        // Find user by the valid reset token and ensure it hasn't expired
        const user = await User.findOne({
            resetPasswordToken: token,
            resetPasswordExpires: { $gt: Date.now() }, // Check expiry
         });

        if (!user) {
            // Token is invalid or expired
            req.flash('error_msg', 'Password reset token is invalid or has expired. Please request a new reset link.');
            return res.redirect('/auth/forgot-password'); // Send back to start of process
        }

        // Token is valid, update the password
        user.password = password; // Pre-save hook in User.js will hash it
        // Clear reset token and OTP fields after successful reset
        user.resetPasswordToken = undefined;
        user.resetPasswordExpires = undefined;
        user.otp = undefined; // Ensure OTP used for verification is also cleared
        user.otpExpires = undefined;

        await user.save(); // Save the user with new password and cleared tokens

        // --- Log the user in automatically after successful password reset ---
        req.session.regenerate(err => {
             if (err) {
                console.error("Session regeneration error after password reset:", err);
                // Try to proceed even if regeneration fails, but flash a message?
                req.flash('error_msg', 'Password reset but failed to log you in automatically. Please log in with your new password.');
                return res.redirect('/auth/login');
                // Or pass to handler: return next(err);
             }
            // Store essential user data in the new session
             req.session.user = {
                _id: user._id,
                name: user.name,
                email: user.email,
                role: user.role,
                address: user.address,
                cart: user.cart // Assuming cart might be needed immediately
            };
            // Save the session
            req.session.save(err => {
                if(err) {
                    console.error("Session save error after password reset login:", err);
                    req.flash('error_msg', 'Password reset but failed to log you in automatically. Please log in with your new password.');
                    return res.redirect('/auth/login');
                    // Or pass to handler: return next(err);
                 }
                 // Success: Password reset and logged in
                 req.flash('success_msg', 'Password has been reset successfully. You are now logged in.');
                res.redirect('/'); // Redirect to homepage or dashboard
             });
         });
        // --- End Automatic Login ---

    } catch (error) {
        if (error.name === 'ValidationError') {
           let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', validationErrors.join(' '));
            return res.redirect(`/auth/reset-password/${token}`);
       }
        next(error); // Pass other errors to the global error handler
    }
};


// ======================================
// Home Page Controller Action
// ======================================
exports.getHomePage = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || '';
    // --- REMOVED STOCK FILTER ---
    let query = {}; // Initialize query object - show ALL products by default

    // Apply search filter if searchTerm exists
    if (searchTerm) {
      // Build search query using regex (case-insensitive)
      // Escape special regex characters in the search term for safety
      const escapedSearchTerm = searchTerm.replace(/[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
      const regex = new RegExp(escapedSearchTerm, 'i');
      query.$or = [
         { name: regex },
         { category: regex },
         { specifications: regex }
         // Add more fields to search if needed (e.g., description, sellerEmail)
      ];
    }

    // Fetch products based on the query (either empty or with search terms)
    // Sort by newest first
    const products = await Product.find(query).sort({ createdAt: -1 }).lean(); // Use lean()

    // Render the main product listing page (index.ejs)
    res.render('products/index', {
      title: searchTerm ? `Search Results for "${searchTerm}"` : 'Home', // Dynamic title
      products: products, // Pass the fetched products (including out-of-stock)
      searchTerm: searchTerm // Pass searchTerm back to view for the search input field
    });
  } catch (error) {
    console.error("Error fetching products for home page:", error);
    next(error); // Pass errors to the global error handler
  }
};
controllers/orderController.js:
// controllers/orderController.js
const Order = require('../models/Order');
const User = require('../models/User');
const Product = require('../models/Product');
const { sendEmail } = require('../config/mailer');
const mongoose = require('mongoose');
const { generateOTP, setOTPExpiration } = require('../services/otpService');

// --- UPDATED placeOrder ---
exports.placeOrder = async (req, res, next) => {
    try {
        const userId = req.session.user._id;
        const user = await User.findById(userId).populate('cart.productId');

        if (!user) {
            req.flash('error_msg', 'User session not found. Please log in again.');
            return res.redirect('/auth/login');
        }
        if (!user.cart || user.cart.length === 0) {
            req.flash('error_msg', 'Your cart is empty.');
            return res.redirect('/user/cart');
        }
        if (!user.address || !user.address.name || !user.address.phone || !user.address.pincode || !user.address.cityVillage) {
            req.flash('error_msg', 'Please save your shipping address before placing the order.');
            return res.redirect('/user/checkout');
        }

        let orderProducts = [];
        let totalAmount = 0;
        const productUpdates = [];
        let validationFailed = false;

        // 1. Validate stock AND quantity, prepare order data
        for (const item of user.cart) {
            const itemQuantity = Number(item.quantity);
            if (isNaN(itemQuantity) || !Number.isInteger(itemQuantity) || itemQuantity <= 0) {
                console.error(`Invalid quantity found in cart for user ${userId}, product ID ${item.productId?._id || 'N/A'}: ${item.quantity}`);
                req.flash('error_msg', `An item in your cart has an invalid quantity (${item.quantity || 'empty'}). Please remove or update it.`);
                validationFailed = true;
                break; // Stop processing cart
            }
            if (!item.productId || typeof item.productId !== 'object') {
                console.warn(`User ${userId} cart contains invalid item reference: ${item._id}. Removing.`);
                // Attempt to remove the invalid item from the user's cart in the DB
                await User.updateOne({ _id: userId }, { $pull: { cart: { _id: item._id } } });
                req.flash('error_msg', `An invalid item was detected and removed from your cart. Please review your cart and checkout again.`);
                validationFailed = true;
                break; // Stop processing cart
            }
            // Fetch the product again to ensure the latest stock and details
            const currentProduct = await Product.findById(item.productId._id).select('stock name price imageUrl');
            if (!currentProduct) {
                req.flash('error_msg', `Product "${item.productId.name || 'ID: '+item.productId._id}" is no longer available. Please remove it from your cart.`);
                validationFailed = true;
                 // Attempt to remove the now-missing product from the user's cart
                await User.updateOne({ _id: userId }, { $pull: { cart: { productId: item.productId._id } } });
                break; // Stop processing cart
            }
            if (currentProduct.stock < itemQuantity) {
                req.flash('error_msg', `Insufficient stock for "${currentProduct.name}". Available: ${currentProduct.stock}. Your cart has ${itemQuantity}. Please update your cart.`);
                validationFailed = true;
                break; // Stop processing cart
            }
            orderProducts.push({
                productId: currentProduct._id,
                name: currentProduct.name,
                priceAtOrder: currentProduct.price,
                quantity: itemQuantity,
                imageUrl: currentProduct.imageUrl,
            });
            totalAmount += currentProduct.price * itemQuantity;
            productUpdates.push({
                productId: currentProduct._id,
                quantityToDecrement: itemQuantity
            });
        }

        // If validation failed, reload cart (session will be updated) and redirect
        if (validationFailed) {
            // Refresh session cart data after potential DB removals
            const updatedUser = await User.findById(userId).select('cart').populate('cart.productId').lean();
            req.session.user.cart = updatedUser ? updatedUser.cart : [];
            await req.session.save();
            return res.redirect('/user/cart');
        }

        // 2. Perform Operations within a transaction for atomicity (Optional but recommended)
        const sessionDB = await mongoose.startSession();
        sessionDB.startTransaction();
        try {
            // Decrement stock and increment orderCount
            for (const update of productUpdates) {
                const updateResult = await Product.updateOne(
                    { _id: update.productId, stock: { $gte: update.quantityToDecrement } },
                    { $inc: { stock: -update.quantityToDecrement, orderCount: 1 } },
                    { session: sessionDB } // Add session to operation
                );
                // Check if stock was sufficient *at the time of update*
                if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 1) {
                     throw new Error(`Stock level changed concurrently for a product (ID: ${update.productId}). Please try again.`);
                 }
                 if(updateResult.matchedCount === 0) {
                      throw new Error(`A product (ID: ${update.productId}) was not found or removed during checkout. Please review your cart.`);
                 }
            }

            // Create the order
            const order = new Order({
                userId: userId,
                userEmail: user.email,
                products: orderProducts,
                totalAmount: totalAmount,
                shippingAddress: user.address,
                paymentMethod: 'COD', // Assuming COD only for now
                status: 'Pending',
                // orderDate and cancellationAllowedUntil are set by default/pre-save hook
            });
            await order.save({ session: sessionDB }); // Add session to save

            // Clear user's cart
            user.cart = [];
            await user.save({ session: sessionDB }); // Add session to save

            // Commit the transaction
            await sessionDB.commitTransaction();

            // Update session cart *after* successful transaction
            req.session.user.cart = [];
            await req.session.save();

            // Send Confirmation Email (Best Effort - outside transaction)
            try {
                const subject = 'Your Order Has Been Placed!';
                let productListHTML = order.products.map(p => `<li>${p.name} (Qty: ${p.quantity}) - ₹${p.priceAtOrder.toFixed(2)}</li>`).join('');
                // --- USE formatDateIST from res.locals ---
                const formattedOrderDate = res.locals.formatDateIST(order.orderDate); // Access helper via res.locals
                const html = `<h2>Thank you for your order!</h2><p>Your Order ID: ${order._id}</p><p>Order Placed: ${formattedOrderDate}</p><p>Total Amount: ₹${order.totalAmount.toFixed(2)}</p><p>Shipping To: ${order.shippingAddress.name}, ${order.shippingAddress.cityVillage}</p><h3>Items:</h3><ul>${productListHTML}</ul><p>You can track your order status in the 'My Orders' section.</p>`;
                await sendEmail(user.email, subject, `Your order ${order._id} has been placed. Total: ₹${totalAmount.toFixed(2)}`, html);
            } catch (emailError) {
                console.error(`Failed to send order confirmation email for order ${order._id}:`, emailError);
                // Don't fail the entire request if email fails, but log it.
            }

            req.flash('success_msg', 'Order placed successfully!');
            res.redirect('/orders/my-orders');

        } catch (error) {
            // If any error occurs, abort the transaction
            await sessionDB.abortTransaction();
            console.error("Error during order transaction:", error);
            req.flash('error_msg', `Order placement failed: ${error.message}. Your cart has not been modified. Please try again.`);
            // Redirect back to cart as the order failed
            res.redirect('/user/cart');
        } finally {
            // End the session
            sessionDB.endSession();
        }

    } catch (error) {
        // Handle errors outside the transaction block (e.g., initial user/cart fetch)
        console.error("Outer Order Placement Error:", error);
        next(error); // Pass to the main error handler
    }
};
// --- END UPDATED placeOrder ---

// --- cancelOrder (User) ---
exports.cancelOrder = async (req, res, next) => {
    const sessionDB = await mongoose.startSession(); // Use transaction for stock restore + order update
    sessionDB.startTransaction();
    try {
        const orderId = req.params.id;
        const userId = req.session.user._id;

        const order = await Order.findOne({
             _id: orderId,
            userId: userId,
            status: 'Pending',
             cancellationAllowedUntil: { $gt: Date.now() }
        }).populate('products.productId', '_id').session(sessionDB); // Add session

        if (!order) {
             req.flash('error_msg', 'Order not found, already processed, or cancellation period expired.');
            await sessionDB.abortTransaction(); sessionDB.endSession();
            return res.redirect('/orders/my-orders');
        }

        // Restore stock (best effort within transaction)
        console.log(`User Cancellation: Attempting to restore stock for order ${orderId}.`);
        const productStockRestorePromises = order.products.map(item => {
             const quantityToRestore = Number(item.quantity);
             if (isNaN(quantityToRestore) || quantityToRestore <= 0) return Promise.resolve();
              if (!item.productId?._id) {
                  console.error(`User Cancel: Missing or invalid productId for item in order ${orderId}`);
                  return Promise.resolve();
              }
             // Add session to stock update
             return Product.updateOne(
                 { _id: item.productId._id },
                 { $inc: { stock: quantityToRestore, orderCount: -1 } },
                 { session: sessionDB }
             ).catch(err => {
                // Log error but don't necessarily fail transaction if one product fails? Depends on requirements.
                // For now, we let it proceed, but log the failure.
                console.error(`User Cancel: Failed to restore stock/orderCount for product ${item.productId._id} on cancelling order ${orderId}: ${err.message}`);
             });
        });
        await Promise.all(productStockRestorePromises);
        console.log(`User Cancel: Stock restoration attempted for order ${orderId}.`);

        order.status = 'Cancelled';
        order.cancellationReason = "Cancelled by customer";
        await order.save({ session: sessionDB }); // Save order within transaction

        await sessionDB.commitTransaction(); // Commit successful cancellation and stock restore

         // Send email (best effort, outside transaction)
         try{
             const subject = 'Your Order Has Been Cancelled';
             const html = `<p>Your order (${order._id}) has been successfully cancelled as requested.</p>`;
            await sendEmail(order.userEmail, subject, `Order ${order._id} cancelled.`, html);
         } catch (emailError){
             console.error(`Failed to send cancellation email for order ${order._id}:`, emailError);
         }

        req.flash('success_msg', 'Order cancelled successfully.');
        res.redirect('/orders/my-orders');

    } catch (error) {
         await sessionDB.abortTransaction(); // Abort transaction on any error
         console.error("Order Cancellation Error:", error);
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid order ID format.');
         } else {
            req.flash('error_msg', 'Failed to cancel the order due to an internal error.');
         }
         res.redirect('/orders/my-orders');
    } finally {
        sessionDB.endSession(); // Always end session
    }
};

// --- Get User's Orders ---
exports.getMyOrders = async (req, res, next) => {
    try {
        const orders = await Order.find({ userId: req.session.user._id })
                                   .select('+cancellationReason') // Keep reason if needed
                                   .sort({ orderDate: -1 })
                                   .lean(); // Use lean for performance

         const now = Date.now();
        orders.forEach(order => {
            // Determine if the order is cancellable by the user
            order.isCancellable = order.status === 'Pending' && order.cancellationAllowedUntil && now < new Date(order.cancellationAllowedUntil).getTime();
            // Dates will be formatted in the EJS template using the helper
         });

        res.render('user/my-orders', {
            title: 'My Orders',
            orders: orders // Pass orders with raw dates
        });
    } catch (error) {
        console.error("Error fetching user orders:", error);
        next(error); // Pass to global error handler
    }
};

// --- Admin Direct Delivery OTP ---
// This function doesn't interact with `res`, so it remains unchanged regarding date helpers
exports.generateAndSendDirectDeliveryOTPByAdmin = async (orderId) => {
     try {
         const order = await Order.findById(orderId);
         if (!order) throw new Error('Order not found.');
         if (order.status !== 'Pending') throw new Error(`Cannot send OTP for order with status '${order.status}'. Must be 'Pending'.`);

         const otp = generateOTP();
         const otpExpires = setOTPExpiration(5); // 5 mins expiry for delivery OTP
         order.orderOTP = otp;
         order.orderOTPExpires = otpExpires;
         await order.save(); // Save OTP to order

         const user = await User.findById(order.userId).select('email');
         if (!user) {
             // Clean up OTP if user not found
             order.orderOTP = undefined; order.orderOTPExpires = undefined; await order.save();
             throw new Error('Customer user account not found for sending OTP.');
         }

         // Email to CUSTOMER containing the OTP
         const subject = 'Confirming Delivery - Action Required';
         const text = `An administrator is ready to complete the delivery for your order (${order._id}).\nPlease provide them with the following OTP to confirm you have received your items: ${otp}\nIt will expire in 5 minutes.\nDo not share if you haven't received your items.`;
         const html = `<p>An administrator is ready to complete the delivery for your order (${order._id}).</p><p>Please provide the administrator with the following OTP to confirm you have received your items: <strong>${otp}</strong></p><p>The OTP will expire in 5 minutes.</p><p><strong>Only share this OTP once you have received your items from the administrator.</strong></p>`;

        const emailSent = await sendEmail(user.email, subject, text, html);
        if (!emailSent) {
            // Clean up OTP if email fails
            order.orderOTP = undefined; order.orderOTPExpires = undefined; await order.save();
            throw new Error('Failed to send direct delivery confirmation OTP email to the customer.');
         }
        // Return success message to be flashed by the caller controller
        return { success: true, message: `Direct delivery confirmation OTP sent to customer ${user.email}.` };
    } catch (error) {
         console.error(`Error sending ADMIN Direct Delivery OTP for order ${orderId}:`, error);
         // Re-throw the error to be caught by the caller controller
         throw error;
     }
 };

// --- Verify OTP and Confirm Delivery Directly By Admin ---
// Added 'resForHelper' parameter to access the date formatter
exports.confirmDirectDeliveryByAdmin = async (orderId, adminUserId, providedOtp, resForHelper) => {
     try {
         const order = await Order.findOne({
            _id: orderId,
            status: 'Pending', // Can only confirm delivery if Pending
             orderOTP: providedOtp,
             orderOTPExpires: { $gt: Date.now() } // Check OTP expiry
         });

         if (!order) {
            // Provide more specific feedback if OTP is wrong vs order status changed
            const checkOrder = await Order.findById(orderId);
            if (!checkOrder) throw new Error('Order not found.');
            if (checkOrder.status !== 'Pending') throw new Error(`Order status is '${checkOrder.status}', cannot confirm direct delivery from this state.`);
            // If order exists and is Pending, the OTP must be wrong/expired
            throw new Error('Invalid or expired OTP.');
        }

        // OTP is valid: Update Order
        order.status = 'Delivered';
        order.receivedByDate = new Date(); // Set delivery time
        // OTP fields should be cleared by the pre-save hook in Order.js when status changes
        await order.save();

        // Send Delivery Confirmation Email (Best Effort)
        try {
             const subject = `Your Order Has Been Delivered!`;
             // --- USE formatDateIST from resForHelper.locals (if available) ---
             const formattedDeliveryDate = (resForHelper && resForHelper.locals && typeof resForHelper.locals.formatDateIST === 'function')
                 ? resForHelper.locals.formatDateIST(order.receivedByDate)
                 : new Date(order.receivedByDate).toLocaleString(); // Fallback to default locale string

             const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed by administration.</p><p>Received Date: ${formattedDeliveryDate}</p><p>Thank you for shopping with us!</p>`;
            await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
         } catch (emailError){
             // Log error but don't fail the confirmation
             console.error(`Failed sending direct delivery confirmation email for order ${order._id}:`, emailError);
         }
        // Return the updated order object
        return { success: true, order: order };
     } catch (error) {
         // Log the error and re-throw to be handled by the calling controller
         console.error(`Error verifying ADMIN Direct Delivery OTP for order ${orderId}:`, error);
        throw error;
    }
};
controllers/productController.js:
// controllers/productController.js
const Product = require('../models/Product');
const User = require('../models/User');

// getProducts remains the same...
exports.getProducts = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || '';
    let query = { stock: { $gt: 0 } };

    if (searchTerm) {
      // Escape regex special characters for safety
      const escapedSearchTerm = searchTerm.replace(/[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
      const regex = new RegExp(escapedSearchTerm, 'i');
      query.$or = [
         { name: regex },
         { category: regex },
         { specifications: regex }
      ];
    }

    const products = await Product.find(query).sort({ createdAt: -1 });

    res.render('products/index', {
      title: searchTerm ? `Search Results for "${searchTerm}"` : 'Home',
      products: products,
      searchTerm: searchTerm
    });
  } catch (error) {
    next(error);
  }
};


exports.getProductDetails = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) {
       const error = new Error('Product not found');
       error.status = 404;
       return next(error);
    }

    let userRating = null;
    if (req.session.user) {
       const ratingData = product.ratings.find(r => r.userId.toString() === req.session.user._id.toString());
       userRating = ratingData ? ratingData.rating : null;
    }

    // --- Calculate Rating Counts ---
    const ratingCounts = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
    let totalRatings = 0;
    if (product.ratings && product.ratings.length > 0) {
        totalRatings = product.ratings.length; // Use the actual array length for calculation
        product.ratings.forEach(r => {
            if (ratingCounts.hasOwnProperty(r.rating)) {
                ratingCounts[r.rating]++;
            }
        });
    }
    // Ensure totalRatings used for percentage calculation matches numReviews if available
    // This handles potential small discrepancies if numReviews wasn't updated perfectly
    const displayTotalRatings = product.numReviews || totalRatings;
    // --- End Calculation ---

    res.render('products/detail', {
      title: product.name,
      product: product,
      userRating: userRating,
      userCanRate: req.session.user ? true : false,
      ratingCounts: ratingCounts, // Pass the counts
      totalRatings: displayTotalRatings // Pass the total count for percentage calculation
    });
  } catch (error) {
       if (error.name === 'CastError') {
           const notFoundError = new Error('Product not found');
           notFoundError.status = 404;
           return next(notFoundError);
       }
    next(error);
  }
};

// rateProduct remains the same...
 exports.rateProduct = async (req, res, next) => {
     const { rating } = req.body;
    const productId = req.params.id;
    const userId = req.session.user._id;

     if (!rating || rating < 1 || rating > 5) {
         req.flash('error_msg', 'Please provide a valid rating between 1 and 5.');
        return res.redirect(`/products/${productId}`);
     }

    try {
        const product = await Product.findById(productId);

         if (!product) {
             req.flash('error_msg', 'Product not found.');
             return res.status(404).redirect('/');
         }

         const existingRatingIndex = product.ratings.findIndex(r => r.userId.toString() === userId.toString());

         if (existingRatingIndex > -1) {
            // Update existing rating
            product.ratings[existingRatingIndex].rating = Number(rating);
             // Optionally update timestamp if RatingSchema has timestamps:true
             // product.ratings[existingRatingIndex].updatedAt = new Date();
         } else {
            // Add new rating
            product.ratings.push({ userId, rating: Number(rating) });
        }

        // Pre-save hook in Product.js will recalculate averageRating and numReviews
        await product.save();

         req.flash('success_msg', 'Thank you for your rating!');
         res.redirect(`/products/${productId}`);

     } catch (error) {
        next(error);
     }
 };
controllers/userController.js:
// controllers/userController.js
const User = require('../models/User');
const Product = require('../models/Product');

// --- UPDATED: Get User Profile Page ---
exports.getUserProfilePage = async (req, res, next) => {
    try {
        const userId = req.session.user._id;
        // Select necessary fields including role and address
        const user = await User.findById(userId).select('name email role address').lean();

        if (!user) {
            req.flash('error_msg', 'User not found. Please log in again.');
            return req.session.destroy(err => {
                if (err) return next(err);
                res.redirect('/auth/login');
            });
        }

        res.render('user/profile', {
            title: 'My Profile',
            user: user // Pass the user object to the view
            // No need to check for delivery role here anymore
        });

    } catch (error) {
        next(error);
    }
};
// --- END UPDATED FUNCTION ---

// --- saveAddress remains the same, source logic is still useful ---
exports.saveAddress = async (req, res, next) => {
    const { name, phone, pincode, cityVillage, landmarkNearby, source } = req.body;
    const userId = req.session.user._id;

    const redirectPath = (source === 'profile') ? '/user/profile' : '/user/checkout';

    if (!name || !phone || !pincode || !cityVillage) {
        req.flash('error_msg', 'Please provide Name, Phone, Pincode, and City/Village.');
        return res.redirect(redirectPath);
    }
    if (!/^\d{10,15}$/.test(phone.trim())) {
        req.flash('error_msg', 'Please enter a valid phone number (10-15 digits, numbers only).');
        return res.redirect(redirectPath);
    }
     if (!/^\d{6}$/.test(pincode.trim())) {
        req.flash('error_msg', 'Please enter a valid 6-digit pincode.');
        return res.redirect(redirectPath);
    }

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return res.redirect('/auth/login');
        }
        user.address = {
            name: name.trim(),
            phone: phone.trim(),
            pincode: pincode.trim(),
            cityVillage: cityVillage.trim(),
            landmarkNearby: landmarkNearby ? landmarkNearby.trim() : ''
        };
        await user.save();
        req.session.user.address = user.address;
        await req.session.save();
        req.flash('success_msg', 'Address saved successfully.');
        res.redirect(redirectPath);
    } catch (error) {
        if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', errors.join(' '));
            return res.redirect(redirectPath);
        }
        next(error);
    }
};

// --- Existing Cart functions remain the same ---
exports.getCart = async (req, res, next) => {
    try {
        const user = await User.findById(req.session.user._id)
                                    .populate('cart.productId')
                                    .lean();

        if (!user) {
           req.flash('error_msg', 'User not found.');
           return req.session.destroy(err => {
                if(err) return next(err);
                res.redirect('/auth/login');
           });
         }

        let cartTotal = 0;
        const populatedCart = user.cart.map(item => {
             if (!item.productId) {
                 console.warn(`Cart item refers to a non-existent product ID: ${item._id} for user: ${user.email}`);
                 // Optionally remove invalid item from cart here
                 // User.updateOne({ _id: user._id }, { $pull: { cart: { _id: item._id } } }).catch(console.error);
                 return null;
             }
            const itemSubtotal = item.productId.price * item.quantity;
            cartTotal += itemSubtotal;
            return {
                _id: item._id,
                productId: item.productId._id,
                name: item.productId.name,
                price: item.productId.price,
                imageUrl: item.productId.imageUrl,
                stock: item.productId.stock,
                quantity: item.quantity,
                subtotal: itemSubtotal
            };
         }).filter(item => item !== null); // Filter out null items

         // Update session cart
         req.session.user.cart = user.cart.filter(item => item.productId);

        res.render('user/cart', {
          title: 'Your Shopping Cart',
          cart: populatedCart,
          cartTotal: cartTotal
        });
      } catch (error) {
        next(error);
      }
};

exports.addToCart = async (req, res, next) => {
    const { productId, quantity = 1 } = req.body;
      const userId = req.session.user._id;
       const numQuantity = parseInt(quantity, 10);

        if (!productId || isNaN(numQuantity) || numQuantity < 1) {
           req.flash('error_msg', 'Invalid product or quantity.');
           return res.redirect(req.headers.referer && req.headers.referer.includes('/products/') ? req.headers.referer : '/');
       }

      try {
          const product = await Product.findById(productId);
          const user = await User.findById(userId);

          if (!user) {
              req.flash('error_msg', 'User session error. Please log in again.');
              return res.redirect('/auth/login');
          }
          if (!product) {
              req.flash('error_msg', 'Product not found.');
              return res.redirect(req.headers.referer && req.headers.referer.includes('/products/') ? req.headers.referer : '/');
          }

         if (product.stock < numQuantity) {
              req.flash('error_msg', `Insufficient stock for ${product.name}. Only ${product.stock} available.`);
              return res.redirect(`/products/${productId}`);
          }

         const existingCartItemIndex = user.cart.findIndex(item => item.productId.toString() === productId.toString());

         if (existingCartItemIndex > -1) {
             const existingQuantity = user.cart[existingCartItemIndex].quantity;
             const newQuantity = existingQuantity + numQuantity;
              if (product.stock < newQuantity) {
                 req.flash('error_msg', `Cannot add ${numQuantity} more ${product.name}. Only ${product.stock} available in total, you have ${existingQuantity} in cart.`);
                  return res.redirect(`/products/${productId}`);
             }
              user.cart[existingCartItemIndex].quantity = newQuantity;
         } else {
             user.cart.push({ productId, quantity: numQuantity });
         }

          await user.save();

         req.session.user.cart = user.cart;
         await req.session.save();

          req.flash('success_msg', `${product.name} added to cart!`);

           if(req.query.redirectTo === 'checkout') {
              return res.redirect('/user/checkout');
          }
          res.redirect('/user/cart');

      } catch (error) {
           if (error.name === 'CastError') {
              req.flash('error_msg', 'Invalid product ID format.');
               return res.redirect('/');
            }
          next(error);
      }
};

exports.updateCartQuantity = async (req, res, next) => {
         const { productId, quantity } = req.body;
         const userId = req.session.user._id;
        const numQuantity = parseInt(quantity, 10);

          if (!productId || isNaN(numQuantity) || numQuantity < 0) { // Allow 0 for removal
              return res.status(400).json({ success: false, message: 'Invalid product ID or quantity.' });
         }

        try {
            const user = await User.findById(userId);
             const product = await Product.findById(productId).select('stock price');

             if (!user || !product) {
                return res.status(404).json({ success: false, message: 'User or Product not found.' });
             }

             const cartItemIndex = user.cart.findIndex(item => item.productId.toString() === productId.toString());

            if (cartItemIndex === -1 && numQuantity > 0) {
                return res.status(404).json({ success: false, message: 'Item not found in cart.' });
            }

             let itemSubtotal = 0;

             if (numQuantity === 0) {
                 if(cartItemIndex > -1){
                     user.cart.splice(cartItemIndex, 1);
                 }
             } else {
                if (product.stock < numQuantity) {
                   return res.status(400).json({ success: false, message: `Insufficient stock. Only ${product.stock} available.` });
                 }
                 if(cartItemIndex > -1){
                     user.cart[cartItemIndex].quantity = numQuantity;
                 } else {
                     user.cart.push({ productId, quantity: numQuantity });
                 }
                 itemSubtotal = (product.price * numQuantity);
            }

            await user.save();

            req.session.user.cart = user.cart;

            const updatedUserPopulated = await User.findById(userId).populate('cart.productId', 'price').lean();
             let cartTotal = 0;
             updatedUserPopulated.cart.forEach(item => {
                if(item.productId){
                    cartTotal += (item.productId.price * item.quantity);
                }
             });

             await req.session.save();

            res.json({
                 success: true,
                 message: 'Cart updated successfully.',
                 newQuantity: user.cart.find(item => item.productId.toString() === productId.toString())?.quantity ?? 0,
                 itemSubtotal: itemSubtotal,
                 cartTotal: cartTotal,
                 itemId: productId
             });

        } catch (error) {
            console.error("Cart Update Error:", error);
            res.status(500).json({ success: false, message: 'Error updating cart quantity.' });
        }
};

exports.removeFromCart = async (req, res, next) => {
    const { productId } = req.params;
        const userId = req.session.user._id;

        if (!productId) {
           req.flash('error_msg', 'Product ID is required.');
           return res.redirect('/user/cart');
         }

        try {
            const user = await User.findById(userId);
             if (!user) {
                 req.flash('error_msg', 'User not found.');
                return res.redirect('/auth/login');
            }

             const initialCartLength = user.cart.length;
            user.cart = user.cart.filter(item => item.productId.toString() !== productId.toString());

             if(user.cart.length === initialCartLength){
                req.flash('error_msg', 'Item not found in cart.');
                return res.redirect('/user/cart');
             }

            await user.save();

             req.session.user.cart = user.cart;
             await req.session.save();

             req.flash('success_msg', 'Item removed from cart.');
             res.redirect('/user/cart');

        } catch (error) {
           if (error.name === 'CastError') {
              req.flash('error_msg', 'Invalid product ID format.');
               return res.redirect('/user/cart');
           }
            next(error);
        }
};

exports.getCheckoutPage = async (req, res, next) => {
     try {
        const user = await User.findById(req.session.user._id)
                               .populate('cart.productId')
                               .lean();

        if (!user || !user.cart || user.cart.length === 0) {
            req.flash('error_msg', 'Your cart is empty or user session is invalid.');
            return res.redirect('/user/cart');
        }

        let subTotal = 0;
         let checkoutItems = [];
         let insufficientStock = false;

        for (const item of user.cart) {
            if (!item.productId) {
                console.warn(`Invalid product reference in cart for user ${user.email}, item: ${item._id}`);
                continue;
            }
             if(item.productId.stock < item.quantity){
                 insufficientStock = true;
                req.flash('error_msg', `Insufficient stock for ${item.productId.name}. Available: ${item.productId.stock}, In cart: ${item.quantity}. Please update your cart.`);
             }

             const itemTotal = item.productId.price * item.quantity;
             subTotal += itemTotal;

            checkoutItems.push({
                productId: item.productId._id,
                name: item.productId.name,
                price: item.productId.price,
                imageUrl: item.productId.imageUrl,
                quantity: item.quantity,
                stock: item.productId.stock,
                itemTotal: itemTotal
             });
        }

         if (insufficientStock) {
             return res.redirect('/user/cart');
         }

         const totalAmount = subTotal;

        res.render('user/checkout', {
            title: 'Checkout',
            userAddress: user.address,
            items: checkoutItems,
            subTotal: subTotal,
            totalAmount: totalAmount,
            paymentMethod: 'COD'
        });

    } catch (error) {
        next(error);
    }
};
middleware/authMiddleware.js:
const User = require('../models/User');

const isAuthenticated = (req, res, next) => {
    if (req.session && req.session.user) {
        User.findById(req.session.user._id).then(user => {
            if (!user) {
                req.session.destroy(err => {
                    if (err) {
                        console.error('Session destruction error:', err);
                        return next(err);
                    }
                    req.flash('error_msg', 'Session expired or user not found. Please login again.');
                    res.redirect('/auth/login');
                });
            } else {
                req.user = user;
                res.locals.currentUser = user;
                next();
            }
        }).catch(err => {
            console.error("Error checking user authentication:", err);
            req.flash('error_msg', 'An error occurred during authentication.');
            res.redirect('/auth/login');
        });
    } else {
        req.flash('error_msg', 'You must be logged in to view this page.');
        req.session.returnTo = req.originalUrl;
        res.redirect('/auth/login');
    }
};

module.exports = { isAuthenticated };

middleware/errorMiddleware.js:
const notFound = (req, res, next) => {
  const error = new Error(`Not Found - ${req.originalUrl}`);
  res.status(404);
  next(error);
};

const errorHandler = (err, req, res, next) => {
  let statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  let message = err.message;

  if (err.name === 'CastError' && err.kind === 'ObjectId') {
    statusCode = 404;
    message = 'Resource not found';
  }
   if (err.name === 'ValidationError') {
       statusCode = 400;
       const errors = Object.values(err.errors).map(el => el.message);
       message = `Validation Error: ${errors.join(', ')}`;
   }
    if (err.code === 11000) {
       statusCode = 400;
       message = `Duplicate field value entered: ${Object.keys(err.keyValue)} already exists.`;
    }


  console.error("ERROR STACK: ", err.stack);

  if (req.accepts('html')) {
      res.status(statusCode).render('error', {
          title: 'Error',
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
          statusCode: statusCode
      });
  } else {
      res.status(statusCode).json({
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
      });
  }
};

module.exports = { notFound, errorHandler };

middleware/roleMiddleware.js:
// middleware/roleMiddleware.js

const isAdmin = (req, res, next) => {
  if (req.session.user && req.session.user.role === 'admin') {
    next();
  } else {
    req.flash('error_msg', 'Access Denied: Admin privileges required.');
    res.status(403).redirect('/');
  }
};

// --- REMOVED isDeliveryAdmin ---
// --- REMOVED isAdminOrDeliveryAdmin ---

module.exports = { isAdmin }; // Only export isAdmin now
models/Order.js:
// models/Order.js
const mongoose = require('mongoose');

const OrderProductSchema = new mongoose.Schema({
    productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
    name: { type: String, required: true },
    priceAtOrder: { type: Number, required: true },
    quantity: { type: Number, required: true, min: 1 },
    imageUrl: { type: String }
}, { _id: false });

const OrderAddressSchema = new mongoose.Schema({
    name: { type: String, trim: true, required: true },
    phone: { type: String, trim: true, required: true },
    pincode: { type: String, trim: true, required: true },
    cityVillage: { type: String, trim: true, required: true },
    landmarkNearby: { type: String, trim: true },
}, { _id: false });


const OrderSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
    },
    userEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    products: [OrderProductSchema],
    totalAmount: {
        type: Number,
        required: true,
        min: 0,
    },
    shippingAddress: {
        type: OrderAddressSchema,
        required: true
    },
    paymentMethod: {
        type: String,
        enum: ['COD'],
        required: true,
        default: 'COD',
    },
    status: {
        type: String,
        // --- REMOVED 'Out for Delivery' ---
        enum: ['Pending', 'Delivered', 'Cancelled'],
        // ---------------------------------
        default: 'Pending',
    },
    orderDate: {
        type: Date,
        default: Date.now,
    },
    receivedByDate: { // Renamed for clarity (date customer received it)
        type: Date,
    },
    // --- REMOVED assignedTo and assignedAdminEmail ---
    // assignedTo: { ... }
    // assignedAdminEmail: { ... }
    // ------------------------------------------------

    // --- OTP now only for Admin Direct Delivery ---
    orderOTP: String,
    orderOTPExpires: Date,
    // -------------------------------------------

    cancellationAllowedUntil: {
        type: Date,
    },
    cancellationReason: {
        type: String,
        trim: true,
    }
}, {
    timestamps: true
});

OrderSchema.pre('save', function(next) {
    // Set customer cancellation window only for new orders
    if (this.isNew && !this.cancellationAllowedUntil) {
        const now = this.orderDate || Date.now();
        // Allow customer cancellation for 1 hour after placement
        this.cancellationAllowedUntil = new Date(now.getTime() + 60 * 60 * 1000);
    }

    // Clear fields when order is cancelled (removed assignment fields)
    if (this.isModified('status') && this.status === 'Cancelled') {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
        this.receivedByDate = undefined; // Clear received date on cancellation
        this.cancellationAllowedUntil = undefined; // Prevent further user cancellation
    }

    // --- UPDATED: Clear OTP if status changes away from 'Pending' ---
    // OTP is only relevant in 'Pending' (for potential admin direct delivery)
    if (this.isModified('status') && this.status !== 'Pending') {
         this.orderOTP = undefined;
         this.orderOTPExpires = undefined;
    }
    // Clear OTP if status becomes Delivered or Cancelled (ensures OTP is gone after successful delivery/cancellation)
    if (this.status === 'Delivered' || this.status === 'Cancelled') {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
    }

    next();
});

const Order = mongoose.model('Order', OrderSchema);

module.exports = Order;
models/Product.js:
const mongoose = require('mongoose');

const RatingSchema = new mongoose.Schema({
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    rating: { type: Number, required: true, min: 1, max: 5 },
    comment: { type: String, trim: true },
}, { _id: false, timestamps: true });


const ProductSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide a product name'],
        trim: true,
    },
    category: {
        type: String,
        required: [true, 'Please provide a product category'],
        trim: true,
    },
    price: {
        type: Number,
        required: [true, 'Please provide a product price'],
        min: 0,
    },
    stock: {
        type: Number,
        required: [true, 'Please provide product stock quantity'],
        min: 0,
        default: 0,
    },
    imageUrl: {
        type: String,
        required: [true, 'Please provide a product image URL'],
        trim: true,
    },
    specifications: {
        type: String,
        trim: true,
    },
    sellerEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    ratings: [RatingSchema],
    averageRating: {
      type: Number,
      default: 0,
    },
    numReviews: {
        type: Number,
        default: 0,
    },
    orderCount: {
        type: Number,
        default: 0,
    }
}, {
    timestamps: true
});

ProductSchema.pre('save', function(next) {
    if (this.ratings && this.ratings.length > 0) {
        this.numReviews = this.ratings.length;
        this.averageRating = this.ratings.reduce((acc, item) => item.rating + acc, 0) / this.ratings.length;
    } else {
        this.numReviews = 0;
        this.averageRating = 0;
    }
    next();
});


const Product = mongoose.model('Product', ProductSchema);

module.exports = Product;

models/User.js:
// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const AddressSchema = new mongoose.Schema({
    name: { type: String, trim: true },
    phone: { type: String, trim: true },
    pincode: { type: String, trim: true },
    cityVillage: { type: String, trim: true },
    landmarkNearby: { type: String, trim: true },
}, { _id: false });

const CartItemSchema = new mongoose.Schema({
    productId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Product',
        required: true,
    },
    quantity: {
        type: Number,
        required: true,
        min: 1,
        default: 1,
    }
}, { _id: false });

const UserSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide your name'],
        trim: true,
    },
    email: {
        type: String,
        required: [true, 'Please provide your email'],
        unique: true,
        match: [
            /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            'Please provide a valid email address',
        ],
        lowercase: true,
        trim: true,
    },
    password: {
        type: String,
        required: [true, 'Please provide a password'],
        minlength: 6,
        select: false,
    },
    role: {
        type: String,
        // --- REMOVED 'delivery_admin' ---
        enum: ['user', 'admin'],
        // -------------------------------
        default: 'user',
    },
    isVerified: {
        type: Boolean,
        default: false,
    },
    otp: { type: String },
    otpExpires: { type: Date },
    address: AddressSchema,
    cart: [CartItemSchema],

    resetPasswordToken: String,
    resetPasswordExpires: Date,
}, {
    timestamps: true
});

UserSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();

    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
});

UserSchema.methods.matchPassword = async function(enteredPassword) {
    return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', UserSchema);

module.exports = User;
public/css/style.css:
/* public/css/style.css */

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --primary-color: #007bff;
  --primary-hover: #0056b3;
  --secondary-color: #6c757d;
  --secondary-hover: #5a6268;
  --success-color: #28a745;
  --success-hover: #218838;
  --danger-color: #dc3545;
  --danger-hover: #c82333;
  --warning-color: #ffc107;
  --warning-hover: #e0a800;
  --info-color: #17a2b8;
  --info-hover: #138496;
  --light-color: #f8f9fa;
  --dark-color: #343a40;
  --text-color: #333;
  --link-color: var(--primary-color);
  --bg-color: #fff;
  --border-color: #dee2e6;
  --card-bg: #ffffff;
  --card-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  --border-radius: 0.25rem;
  --spacing-unit: 1rem;
}

html {
  font-size: 16px;
  scroll-behavior: smooth;
}

body {
  font-family: 'Roboto', sans-serif;
  line-height: 1.6;
  color: var(--text-color);
  background-color: var(--bg-color);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

a {
  color: var(--link-color);
  text-decoration: none;
  transition: color 0.2s ease-in-out;
}

a:hover {
  color: var(--primary-hover);
  text-decoration: underline;
}

img {
  max-width: 100%;
  height: auto;
  display: block;
}

h1, h2, h3, h4, h5, h6 {
  margin-bottom: calc(var(--spacing-unit) * 0.75);
  line-height: 1.3;
  font-weight: 500;
}

p {
  margin-bottom: var(--spacing-unit);
}

ul, ol {
    margin-bottom: var(--spacing-unit);
    padding-left: calc(var(--spacing-unit) * 1.5);
}

/* Utility Classes */
.hidden { display: none !important; }
.text-center { text-align: center; }
.text-danger { color: var(--danger-color) !important; }
.text-success { color: var(--success-color) !important; }
.text-warning { color: var(--warning-color) !important; }
.text-info { color: var(--info-color) !important; }
.text-muted { color: var(--secondary-color) !important; }
.mb-1 { margin-bottom: calc(var(--spacing-unit) * 0.25) !important; }
.mb-2 { margin-bottom: calc(var(--spacing-unit) * 0.5) !important; }
.mb-3 { margin-bottom: var(--spacing-unit) !important; }
.mt-1 { margin-top: calc(var(--spacing-unit) * 0.25) !important; }
.mt-2 { margin-top: calc(var(--spacing-unit) * 0.5) !important; }
.mt-3 { margin-top: var(--spacing-unit) !important; }
.d-block { display: block !important; }
.small { font-size: 0.875em; }

/* Forms */
.inline-form {
    display: block;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.inline-form > * {
    margin-bottom: calc(var(--spacing-unit) * 0.25);
}

.form-group {
  margin-bottom: calc(var(--spacing-unit) * 0.8);
}

label {
  display: block;
  margin-bottom: calc(var(--spacing-unit) * 0.3);
  font-weight: 500;
}

input[type="text"],
input[type="email"],
input[type="password"],
input[type="tel"],
input[type="url"],
input[type="number"],
input[type="search"],
textarea,
select {
  width: 100%;
  padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.75);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  font-size: 1rem;
  line-height: 1.5;
  background-color: #fff;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

input[type="number"] {
    appearance: textfield;
    -moz-appearance: textfield;
}
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}


textarea {
  resize: vertical;
  min-height: 80px;
}

input:focus,
textarea:focus,
select:focus {
  border-color: var(--primary-color);
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

/* Buttons */
.btn {
  display: inline-block;
  font-weight: 400;
  color: #fff;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  user-select: none;
  background-color: var(--primary-color);
  border: 1px solid var(--primary-color);
  padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
  font-size: 1rem;
  line-height: 1.5;
  border-radius: var(--border-radius);
  transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
  text-transform: capitalize;
}

.btn:hover {
  color: #fff;
  text-decoration: none;
  background-color: var(--primary-hover);
  border-color: var(--primary-hover);
}

.btn:focus {
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.5);
}

.btn:disabled {
  opacity: 0.65;
  cursor: not-allowed;
}

.btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: #fff;}
.btn-primary:hover { background-color: var(--primary-hover); border-color: var(--primary-hover); }
.btn-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: #fff; }
.btn-secondary:hover { background-color: var(--secondary-hover); border-color: var(--secondary-hover); }
.btn-success { background-color: var(--success-color); border-color: var(--success-color); color: #fff;}
.btn-success:hover { background-color: var(--success-hover); border-color: var(--success-hover); }
.btn-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: #fff;}
.btn-danger:hover { background-color: var(--danger-hover); border-color: var(--danger-hover); }
.btn-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: #212529;}
.btn-warning:hover { background-color: var(--warning-hover); border-color: var(--warning-hover); }
.btn-info { background-color: var(--info-color); border-color: var(--info-color); color: #fff;}
.btn-info:hover { background-color: var(--info-hover); border-color: var(--info-hover); }
.btn-light { background-color: var(--light-color); border-color: var(--light-color); color: #212529;}
.btn-light:hover { background-color: #e2e6ea; border-color: #dae0e5; }
.btn-dark { background-color: var(--dark-color); border-color: var(--dark-color); color: #fff;}
.btn-dark:hover { background-color: #23272b; border-color: #1d2124; }

.btn-outline-secondary { color: var(--secondary-color); border-color: var(--secondary-color); background-color: transparent;}
.btn-outline-secondary:hover { color: #fff; background-color: var(--secondary-color); }

.btn-text {
    background-color: transparent;
    border-color: transparent;
    color: var(--link-color);
    padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.4);
}
.btn-text:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--primary-hover);
}
.btn-text.btn-danger { color: var(--danger-color); }
.btn-text.btn-danger:hover { color: var(--danger-hover); }


.btn-sm {
  padding: calc(var(--spacing-unit) * 0.25) calc(var(--spacing-unit) * 0.5);
  font-size: 0.875rem;
  line-height: 1.5;
  border-radius: calc(var(--border-radius) * 0.8);
}
.btn-lg {
    padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.25);
    font-size: 1.1rem;
}

.btn-block {
    display: block;
    width: 100%;
}

.btn .fa-spinner {
    margin-right: calc(var(--spacing-unit) * 0.25);
    animation: fa-spin 1s infinite linear;
}
@keyframes fa-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Alerts / Messages */
.alert {
  padding: calc(var(--spacing-unit) * 0.8) var(--spacing-unit);
  margin-bottom: var(--spacing-unit);
  border: 1px solid transparent;
  border-radius: var(--border-radius);
  position: relative;
  opacity: 0.95; /* Keep existing opacity slightly less than 1 if you like */
  margin-left: var(--spacing-unit);
  margin-right: var(--spacing-unit);
  margin-top: var(--spacing-unit);
  /* --- NEW: Add transition for smooth fade --- */
  transition: opacity 0.5s ease-out;
  /* --- END NEW --- */
}

.alert-success { color: #155724; background-color: #d4edda; border-color: #c3e6cb; }
.alert-danger { color: #721c24; background-color: #f8d7da; border-color: #f5c6cb; }
.alert-warning { color: #856404; background-color: #fff3cd; border-color: #ffeeba; }
.alert-info { color: #0c5460; background-color: #d1ecf1; border-color: #bee5eb; }

.close-alert {
  position: absolute;
  top: 5px;
  right: 10px;
  font-size: 1.2rem;
  background: none;
  border: none;
  color: inherit;
  opacity: 0.7;
  cursor: pointer;
}
.close-alert:hover {
  opacity: 1;
}

/* Header & Navigation */
.app-header {
  background-color: var( --primary-color);
  color: var(--light-color);
  padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
  position: sticky;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 1200px;
  margin: 0 auto;
}

.nav-left, .nav-right {
  display: flex;
  align-items: center;
}
.nav-right {
    gap: calc(var(--spacing-unit) * 0.5);
}

.app-logo {
  display: flex;
  align-items: center;
  color: var(--light-color);
  font-size: 1.2rem;
  font-weight: 500;
  margin-right: var(--spacing-unit);
}
.app-logo:hover {
  color: var(--warning-color);
  text-decoration: none;
}
.app-logo i {
  margin-right: calc(var(--spacing-unit) * 0.3);
}

.nav-link {
  color: var(--light-color);
  padding: calc(var(--spacing-unit) * 0.4) calc(var(--spacing-unit) * 0.6);
  border-radius: var(--border-radius);
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 0.75rem;
  text-decoration: none;
}
.nav-link span {
  display: none; /* Hide text labels on mobile */
}
.nav-link i {
    font-size: 1.1rem;
    margin-bottom: 2px;
}

.nav-link:hover,
.nav-link.active {
  background-color: rgba(255, 255, 255, 0.1);
  color: #fff;
  text-decoration: none;
}

.nav-link-cart {
    position: relative;
}
.cart-badge {
  position: absolute;
  top: -2px;
  right: -5px;
  background-color: var(--danger-color);
  color: white;
  border-radius: 50%;
  padding: 1px 5px;
  font-size: 0.7rem;
  font-weight: bold;
  line-height: 1;
}

.btn-login-register {
    font-size: 0.9rem;
    padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.8);
}

.profile-avatar-link {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 38px;
    height: 38px;
    border-radius: 50%;
    background-color: var(--light-color);
    color:black;
    font-weight: bold;
    font-size: 0.9rem;
    text-decoration: none;
    transition: background-color 0.2s ease;
    margin-left: calc(var(--spacing-unit) * 0.5);
    border: 1px solid transparent;
}

.profile-avatar-link:hover,
.profile-avatar-link.active {
    text-decoration: none;
    border-color: var(--light-color);
}

.profile-avatar-initials {
    line-height: 1;
}

/* Main Content & Footer */
.container {
  width: 100%;
  padding: var(--spacing-unit);
  margin: 0 auto;
  flex-grow: 1;
}

.app-footer {
  padding: var(--spacing-unit);
  text-align: center;
  font-size: 0.85rem;
  color: var(--secondary-color);
  background-color: var(--light-color);
  border-top: 1px solid var(--border-color);
  margin-top: auto;
  display: none; /* Hide footer on mobile by default */
}

/* Product Index Page */
.product-index-container h1 {
    font-size: 1.5rem;
}
.search-bar-container {
    margin-bottom: var(--spacing-unit);
}
.search-form {
    display: flex;
    align-items: center;
}
.search-form input[type="text"] {
    flex-grow: 1;
    border-radius: var(--border-radius) 0 0 var(--border-radius);
    border-right: none;
}
.search-form button {
    border-radius: 0 var(--border-radius) var(--border-radius) 0;
    padding: calc(var(--spacing-unit) * 0.6);
}
.btn-clear-search {
    margin-left: calc(var(--spacing-unit) * 0.5);
    font-size: 0.9rem;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: calc(var(--spacing-unit) * 0.75);
}

.product-card {
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: var(--card-shadow);
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.product-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.product-link {
  color: inherit;
  text-decoration: none;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}

.product-link:hover{
  color: inherit;
  text-decoration: none;
}

.product-image {
  width: 100%;
  aspect-ratio: 1 / 1; /* Ensures square aspect ratio */
  object-fit: cover;   /* Covers the area, might crop */
}

.product-info {
  padding: calc(var(--spacing-unit) * 0.6);
  flex-grow: 1;
}

.product-name {
  font-size: 0.95rem;
  font-weight: 500;
  margin-bottom: calc(var(--spacing-unit) * 0.25);
  line-height: 1.3;
  height: 2.6em; /* Limit height to 2 lines */
  overflow: hidden;
  text-overflow: ellipsis; /* Add ellipsis if text overflows */
}

.product-price {
  font-weight: 500;
  color: var(--success-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
  font-size: 1rem;
}

.product-stock,
.product-rating {
  font-size: 0.8rem;
  color: var(--secondary-color);
  margin-bottom: calc(var(--spacing-unit) * 0.2);
}
.product-rating .fa-star, .product-rating .fa-star-half-alt {
    color: #f8d347;
}

.add-to-cart-form {
    padding: 0 calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.6);
}
.btn-add-to-cart {
  width: 100%;
  padding: calc(var(--spacing-unit) * 0.5);
  font-size: 0.9rem;
}
.btn-add-to-cart i {
    margin-right: calc(var(--spacing-unit) * 0.25);
}

/* Product Detail Page */
.product-detail-container {
  background-color: var(--card-bg);
  padding: var(--spacing-unit);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
}
.product-detail-main {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-unit);
}
.product-detail-image {
    /* --- UPDATED for fixed aspect ratio --- */
    width: 100%;                  /* Take full width on mobile */
    max-width: 450px;             /* Limit size on mobile */
    margin: 0 auto var(--spacing-unit) auto; /* Center on mobile, add bottom margin */
    aspect-ratio: 1 / 1;          /* Force square shape */
    overflow: hidden;             /* Hide parts of image outside the aspect ratio */
    border-radius: 10px;
    background-color: #f8f9fa;    /* Light background for 'contain' or transparent images */
    position: relative;
}
.product-detail-image img {
    /* --- UPDATED for object-fit --- */
    display: block;
    width: 100%;                  /* Fill container width */
    height: 100%;                 /* Fill container height */
    object-fit: cover;            /* Cover container, crop if needed. Use 'contain' to fit all image inside. */
    object-position: center center; /* Center the image content */
    border-radius: inherit;       /* Inherit radius from container */
}
.product-detail-info h1 {
    font-size: 1.6rem;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.detail-price {
    font-size: 1.4rem;
    font-weight: bold;
    color: var(--success-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.detail-stock {
    font-size: 0.9rem;
    color: var(--secondary-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.detail-rating {
    margin-bottom: calc(var(--spacing-unit) * 0.75);
    color: var(--secondary-color);
}
.detail-rating i { color: #f8d347; }

.product-actions {
    margin: calc(var(--spacing-unit) * 1.2) 0;
    display: flex;
    flex-direction: column;
    gap: calc(var(--spacing-unit) * 0.5);
}
.quantity-selector {
    display: flex;
    align-items: center;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
    max-width: 150px;
}
.quantity-selector label {
    margin: 0 calc(var(--spacing-unit) * 0.4) 0 0;
    font-size: 0.9rem;
}
.quantity-selector input {
    text-align: center;
    font-size: 1rem;
    padding: calc(var(--spacing-unit) * 0.4);
}
.product-actions .btn {
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.6) var(--spacing-unit);
    font-size: 1rem;
}

.share-section { margin: calc(var(--spacing-unit) * 1.2) 0; }
.fallback-share-links { margin-top: 0.5rem; }
.fallback-share-links a { margin: 0 0.3rem; font-size: 1.5rem; }

.product-specifications { margin-top: calc(var(--spacing-unit) * 1.5); }
.product-specifications h3 { font-size: 1.1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3rem; margin-bottom: 0.5rem;}
.product-specifications pre {
    white-space: pre-wrap;
    font-size: 0.9rem;
    background-color: #f8f8f8;
    padding: calc(var(--spacing-unit) * 0.5);
    border-radius: var(--border-radius);
    max-height: 200px;
    overflow-y: auto;
}

/* Product Rating Section */
.product-rating-section {
    margin-top: var(--spacing-unit);
    border-top: 1px solid var(--border-color);
    padding-top: var(--spacing-unit);
}
.product-rating-section h3 {
    margin-bottom: calc(var(--spacing-unit) * 0.6);
    font-size: 1.2em;
}

.rating-stars {
  display: inline-flex;
  flex-direction: row-reverse;
  justify-content: flex-end;
  margin-bottom: calc(var(--spacing-unit) * 0.8);
}

.rating-stars input[type="radio"] {
  display: none;
}

.rating-stars label {
  display: inline-block;
  cursor: pointer;
  font-size: 1.8rem;
  color: lightgray;
  padding: 0 0.1em;
  margin: 0;
  transition: color 0.2s ease-in-out;
}

.rating-stars label:hover,
.rating-stars label:hover ~ label {
  color: #f8d347;
}

.rating-stars input[type="radio"]:checked ~ label {
  color: #f8d347;
}

/* Rating Statistics Section */
.rating-stats-container {
  margin-top: 30px;
  padding-top: 20px;
  border-top: 1px solid #eee;
}

.rating-stats-container h3 {
  margin-bottom: 15px;
  font-size: 1.4em;
  color: #333;
}

.rating-summary {
  display: flex;
  align-items: center;
  margin-bottom: 20px;
  gap: 15px;
}

.rating-average {
  display: flex;
  align-items: center;
}

.rating-average-value {
  font-size: 2.5em;
  font-weight: 500;
  margin-right: 5px;
  color: #222;
}

.rating-average .fa-star {
  font-size: 1.2em;
  color: #666;
  margin-bottom: 8px;
}

.rating-total {
  font-size: 0.95em;
  color: #555;
}

.rating-bars {
  max-width: 400px;
}

.rating-bar-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
  gap: 10px;
}

.rating-bar-label {
  width: 45px;
  font-size: 0.9em;
  color: #444;
  text-align: right;
  flex-shrink: 0;
}
.rating-bar-label .fa-star {
  color: #f8c107;
  font-size: 0.9em;
}

.rating-bar-progress {
  flex-grow: 1;
  height: 8px;
  background-color: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
}

.rating-bar-fill {
  height: 100%;
  background-color: #28a745; /* Default color */
  border-radius: 4px;
  transition: width 0.3s ease-in-out;
}
/* Color fills based on rating */
.rating-bar-row:nth-child(1) .rating-bar-fill { background-color: #28a745; } /* 5 stars */
.rating-bar-row:nth-child(2) .rating-bar-fill { background-color: #84c54c; } /* 4 stars */
.rating-bar-row:nth-child(3) .rating-bar-fill { background-color: #ffc107; } /* 3 stars */
.rating-bar-row:nth-child(4) .rating-bar-fill { background-color: #fd7e14; } /* 2 stars */
.rating-bar-row:nth-child(5) .rating-bar-fill { background-color: #dc3545; } /* 1 star */

.rating-bar-count {
  width: 40px;
  font-size: 0.9em;
  color: #555;
  text-align: right;
  flex-shrink: 0;
}

/* Auth Pages */
.auth-container {
  max-width: 450px;
  margin: var(--spacing-unit) auto;
  padding: var(--spacing-unit);
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  box-shadow: var(--card-shadow);
}
.auth-container h1 {
    font-size: 1.6rem;
    text-align: center;
    margin-bottom: var(--spacing-unit);
}
.auth-form .btn {
    width: 100%;
    margin-top: calc(var(--spacing-unit) * 0.5);
    padding: calc(var(--spacing-unit) * 0.7);
}
.auth-links {
    margin-top: var(--spacing-unit);
    font-size: 0.9rem;
    text-align: center;
}
.auth-links p {
    margin-bottom: calc(var(--spacing-unit) * 0.4);
}

.auth-container p { text-align: center; margin-bottom: var(--spacing-unit);}
.auth-container form ~ .auth-links { border-top: 1px solid var(--border-color); padding-top: var(--spacing-unit); }
#otp { text-align: center; font-size: 1.2rem; letter-spacing: 4px; }

/* Cart Page */
.cart-container h1 {
    font-size: 1.5rem;
    margin-bottom: var(--spacing-unit);
}

.cart-items {
  margin-bottom: var(--spacing-unit);
}

.cart-item {
  display: grid;
  grid-template-columns: 80px 1fr auto;
  grid-template-areas:
    "image details remove"
    "image quantity subtotal";
  gap: calc(var(--spacing-unit) * 0.75);
  background-color: var(--card-bg);
  padding: calc(var(--spacing-unit) * 0.75);
  border-bottom: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  margin-bottom: var(--spacing-unit);
  box-shadow: var(--card-shadow);
}

.cart-item-image { grid-area: image; align-self: center;}
.cart-item-image img {
    width: 80px;
    height: 80px;
    object-fit: cover;
    border-radius: calc(var(--border-radius) * 0.5);
}
.cart-item-details { grid-area: details; }
.cart-item-quantity {
    grid-area: quantity;
    display: flex;
    align-items: center;
    gap: 0.3rem;
}
.cart-item-subtotal {
    grid-area: subtotal;
    text-align: right;
    font-weight: 500;
    align-self: center;
}
.cart-item-remove { grid-area: remove; text-align: right; align-self: start;}

.cart-item-name {
    font-size: 1rem;
    font-weight: 500;
    margin-bottom: calc(var(--spacing-unit) * 0.2);
}
.cart-item-price {
    font-size: 0.9rem;
    color: var(--secondary-color);
    margin-bottom: calc(var(--spacing-unit) * 0.2);
}
.cart-item-stock {
    font-size: 0.8rem;
    color: #6c757d;
}

.cart-item-quantity label {
    font-size: 0.9rem;
    margin-bottom: 0;
    display: none; /* Hide label by default */
}
.cart-item-quantity input {
    width: 50px;
    padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.4);
    text-align: center;
    font-size: 0.9rem;
}
.cart-item-quantity .btn-update-qty {
    font-size: 0.8rem;
    padding: calc(var(--spacing-unit) * 0.3) calc(var(--spacing-unit) * 0.6);
}

.cart-item-subtotal {
    font-size: 0.9rem;
    white-space: nowrap;
}

.cart-item-remove .btn {
    padding: 0.1rem 0.4rem;
    font-size: 0.8rem;
    line-height: 1;
}

.cart-summary {
  margin-top: calc(var(--spacing-unit) * 1.5);
  padding: var(--spacing-unit);
  background-color: #f8f9fa;
  border-top: 2px solid var(--primary-color);
  border-radius: var(--border-radius);
  text-align: right;
}

.cart-summary h2 {
  font-size: 1.3rem;
  margin-bottom: calc(var(--spacing-unit) * 0.75);
}
.btn-checkout {
    width: 100%;
    padding: calc(var(--spacing-unit) * 0.7);
    font-size: 1.1rem;
}

/* Checkout Page */
.checkout-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit);}

.checkout-grid {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-unit);
}

.checkout-address, .checkout-summary {
    background-color: var(--card-bg);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}
.checkout-address h2, .checkout-summary h2 {
    font-size: 1.2rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: calc(var(--spacing-unit) * 0.4);
    margin-bottom: var(--spacing-unit);
}
.saved-address { font-size: 0.95rem; margin-bottom: var(--spacing-unit); }
.saved-address p { margin-bottom: calc(var(--spacing-unit) * 0.2); line-height: 1.4; }
#edit-address-btn { margin-top: calc(var(--spacing-unit) * 0.5); }

.address-form h3 { font-size: 1.1rem; }

.checkout-items {
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: var(--spacing-unit);
    padding-right: calc(var(--spacing-unit) * 0.5); /* space for scrollbar */
}
.checkout-item {
    display: flex;
    align-items: center;
    gap: calc(var(--spacing-unit) * 0.5);
    margin-bottom: calc(var(--spacing-unit) * 0.5);
    font-size: 0.9rem;
}
.checkout-item-image img {
    width: 40px;
    height: 40px;
    object-fit: cover;
    border-radius: 4px;
}
.checkout-item-info { flex-grow: 1; }
.checkout-item-price { font-weight: 500; white-space: nowrap;}

.checkout-totals { font-size: 0.95rem; }
.checkout-totals p {
    display: flex;
    justify-content: space-between;
    margin-bottom: calc(var(--spacing-unit) * 0.3);
}
.checkout-totals hr { margin: calc(var(--spacing-unit) * 0.5) 0; border-color: var(--border-color); opacity: 0.5;}
.checkout-totals strong { font-weight: bold; }

.checkout-payment h3 { font-size: 1.1rem; margin: calc(var(--spacing-unit) * 1) 0 calc(var(--spacing-unit) * 0.5) 0; }
.payment-option { padding: 0.5rem; border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: #f0f0f0; opacity: 0.8; margin-bottom: 0.5rem; cursor: pointer;}
.payment-option.selected { border-color: var(--primary-color); opacity: 1; background-color: #e7f3ff; }
.payment-option label { font-weight: normal; display: flex; align-items: center; cursor: pointer; margin-bottom: 0; }
.payment-option input[type="radio"] { margin-right: 0.5rem; }
.payment-option i { margin-right: 0.3rem; color: var(--success-color);}

.place-order-form { margin-top: var(--spacing-unit); }
.btn-place-order {
    width: 100%;
    font-size: 1.1rem;
    padding: calc(var(--spacing-unit) * 0.7);
}

/* My Orders Page */
.my-orders-container h1 { font-size: 1.5rem; margin-bottom: var(--spacing-unit); }
.order-list {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-unit);
}
.order-card {
  background-color: var(--card-bg);
  border-radius: var(--border-radius);
  border: 1px solid var(--border-color);
  box-shadow: var(--card-shadow);
  overflow: hidden;
}

.order-header {
  background-color: #f8f9fa;
  padding: calc(var(--spacing-unit) * 0.6);
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  font-size: 0.85rem;
  color: var(--secondary-color);
  border-bottom: 1px solid var(--border-color);
}
.order-header > div {
    margin-right: calc(var(--spacing-unit) * 0.8);
    margin-bottom: calc(var(--spacing-unit) * 0.2);
    white-space: nowrap;
}
.order-header strong { color: var(--text-color); }
.order-status {
    display: inline-block;
}

.order-body {
  padding: calc(var(--spacing-unit) * 0.75);
  display: flex;
  flex-direction: column;
  gap: calc(var(--spacing-unit) * 0.75);
}

.order-items-preview {
    display: flex;
    gap: calc(var(--spacing-unit) * 0.3);
    flex-wrap: wrap;
}
.order-items-preview img {
    width: 50px;
    height: 50px;
    object-fit: cover;
    border-radius: 4px;
    border: 1px solid var(--border-color);
}
.more-items {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 50px;
    height: 50px;
    border: 1px dashed var(--border-color);
    border-radius: 4px;
    font-size: 0.8rem;
    color: var(--secondary-color);
    text-align: center;
}

.order-details { font-size: 0.9rem; line-height: 1.5;}
.order-details p { margin-bottom: calc(var(--spacing-unit) * 0.3); }

.order-actions {
    padding: 0 calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 0.75);
    text-align: right;
}

.status-badge {
    font-weight: bold;
    padding: 0.2em 0.5em;
    border-radius: var(--border-radius);
    color: #333; /* Default text */
    background-color: var(--secondary-color); /* Default background */
    font-size: 0.85em;
    display: inline-block;
    vertical-align: middle;
    text-transform: capitalize;
}
.status-pending, .status-badge.status-pending { background-color: #fff3cd; color: #856404; }
.status-out-for-delivery, .status-badge.status-out-for-delivery { background-color: #d1ecf1; color: #0c5460; }
.status-delivered, .status-badge.status-delivered { background-color: #d4edda; color: #155724; }
.status-cancelled, .status-badge.status-cancelled { background-color: #f8d7da; color: #721c24; }

.order-card.status-cancelled, .data-table tr.status-cancelled { opacity: 0.9; }


/* Admin General & Tables */
.admin-manage-container, .admin-dashboard-container {
    padding: var(--spacing-unit);
}
.admin-manage-container h1, .admin-dashboard-container h1 {
    font-size: 1.5rem;
    margin-bottom: var(--spacing-unit);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: calc(var(--spacing-unit) * 0.5);
}

.table-container {
    overflow-x: auto; /* Allow horizontal scroll on small screens */
    margin-bottom: var(--spacing-unit);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    background-color: var(--card-bg);
    box-shadow: var(--card-shadow);
}
.data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9rem;
}

/* Mobile Table Styles (Stacking) */
.data-table thead {
  display: none; /* Hide headers on mobile */
}

.data-table tbody tr {
  display: block; /* Stack rows */
  margin-bottom: calc(var(--spacing-unit) * 1.5);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: calc(var(--spacing-unit) * 0.75);
  background-color: var(--card-bg);
  box-shadow: var(--card-shadow);
}
/* Remove extra styling when inside .table-container wrapper */
.table-container .data-table tbody tr {
    margin-bottom: 0;
    border: none;
    border-radius: 0;
    box-shadow: none;
    padding: calc(var(--spacing-unit) * 0.5);
    border-bottom: 1px solid var(--border-color);
}
.table-container .data-table tbody tr:last-child {
    border-bottom: none;
}


.data-table td {
  display: block; /* Stack cells */
  text-align: right; /* Align cell content to the right */
  padding: calc(var(--spacing-unit) * 0.5) 0;
  position: relative;
  border-bottom: 1px dashed #eee;
  transition: background-color 0.2s ease-in-out;
}
.data-table td:last-child {
    border-bottom: none;
}

/* Add data-label pseudo-element */
.data-table td::before {
  content: attr(data-label);
  position: absolute;
  left: 0;
  font-weight: bold;
  text-align: left;
  padding-right: 10px;
  color: #555;
  width: 40%; /* Adjust width as needed */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.table-img {
  max-width: 50px; /* Adjust size as needed */
  border-radius: 4px;
  display: inline-block; /* Allows margin-left to work */
  margin-left: 45%; /* Push image past the label */
  vertical-align: middle;
}

/* Adjustments for cells containing specific elements */
.data-table td:has(img) { text-align: right; padding: 5px 0; }
.data-table td:has(form), .actions-cell { padding: 10px 0;}
.data-table td:has(form) { margin-left: 45%; } /* Push form past the label */

/* Mobile Actions */
.actions-cell form, .actions-cell .btn {
    margin: calc(var(--spacing-unit) * 0.2) 0;
    display: block;
    width: 100%;
}
.actions-cell .inline-form { margin-bottom: calc(var(--spacing-unit) * 0.5); }
.action-group {
    border-top: 1px dashed #ccc;
    padding-top: calc(var(--spacing-unit) * 0.5);
    margin-top: calc(var(--spacing-unit) * 0.5);
    text-align: left; /* Align group content */
}
.action-group:first-child { border-top: none; margin-top: 0; padding-top: 0; }
.action-group-title {
    font-size: 0.8em;
    font-weight: bold;
    color: var(--secondary-color);
    margin-bottom: calc(var(--spacing-unit) * 0.3);
    display: block;
    text-align: left;
}

.actions-cell select.form-control-sm {
    margin-bottom: 5px;
    font-size: 0.9rem;
    padding: calc(var(--spacing-unit)*0.3) calc(var(--spacing-unit)*0.5);
    height: auto;
}
.data-table td:has(label) { text-align: left; }
.data-table td:has(label) > * { margin-left: 45%; }

/* Specific mobile forms */
.verify-otp-form { display: flex; align-items: center; gap: 5px; }
.verify-otp-form input[name="otp"] {
    flex-grow: 1;
    max-width: 120px;
    padding: calc(var(--spacing-unit)*0.3) calc(var(--spacing-unit)*0.5);
    font-size: 0.9rem;
    text-align: center;
}
.verify-otp-form button {
    flex-shrink: 0;
    width: auto;
    padding: calc(var(--spacing-unit)*0.3) calc(var(--spacing-unit)*0.5);
}
.cancel-delivery-form select { width: 100%; }

/* Admin Dashboard */
.admin-actions-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 2 columns on small screens */
    gap: var(--spacing-unit);
    margin-top: var(--spacing-unit);
}
.admin-action-card {
    background-color: var(--card-bg);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    text-align: center;
    box-shadow: var(--card-shadow);
    transition: transform 0.2s, box-shadow 0.2s;
    color: var(--text-color);
    text-decoration: none;
}
.admin-action-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    text-decoration: none;
}
.admin-action-card i {
    font-size: 2rem;
    color: var(--primary-color);
    margin-bottom: 0.5rem;
}
.admin-action-card h3 {
    font-size: 1.1rem;
    margin-bottom: 0.3rem;
    color: var(--text-color);
}
.admin-action-card p {
    font-size: 0.85rem;
    color: var(--secondary-color);
    margin-bottom: 0.5rem;
}

/* Error Page */
.error-container { text-align: center; padding-top: 2rem; }
.error-container h1 { color: var(--danger-color); margin-bottom: 0.5rem; }
.error-container .lead { font-size: 1.1rem; }
.error-container details { text-align: left; margin-top: 1rem; background: #f1f1f1; padding: 0.5rem; border-radius: 4px;}
.error-container details summary { cursor: pointer; font-weight: bold; }
.error-container details pre { white-space: pre-wrap; font-size: 0.8em; margin-top: 0.5rem; }


/* Profile Page */
.profile-container {
    max-width: 800px;
    margin: var(--spacing-unit) auto;
    padding: calc(var(--spacing-unit) * 1.5);
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    box-shadow: var(--card-shadow);
}

.profile-container h1 {
    font-size: 1.8rem;
    text-align: center;
    margin-bottom: calc(var(--spacing-unit) * 0.5);
}
.profile-container > p.text-muted {
    text-align: center;
    font-size: 1.1rem;
}


.profile-section {
    margin-top: calc(var(--spacing-unit) * 1.5);
    padding-top: calc(var(--spacing-unit) * 1);
    border-top: 1px solid var(--border-color);
}
.profile-section:first-of-type {
     border-top: none; /* No top border for the first section */
     padding-top: 0;
     margin-top: calc(var(--spacing-unit) * 0.8); /* Adjust top margin */
}

.profile-section h2 {
    font-size: 1.4rem;
    margin-bottom: calc(var(--spacing-unit) * 0.8);
    color: var(--primary-color);
}

#saved-address-display p {
    margin-bottom: calc(var(--spacing-unit) * 0.3);
    line-height: 1.5;
    font-size: 1rem;
}
#saved-address-display strong {
    font-weight: 500;
}
#edit-address-btn {
    margin-top: calc(var(--spacing-unit) * 0.5);
}

.address-form {
    max-width: 500px; /* Limit width of address form */
}
.address-form h3 {
    font-size: 1.2rem;
    margin-bottom: var(--spacing-unit);
    font-weight: 500;
}
#cancel-edit-btn {
    margin-left: calc(var(--spacing-unit) * 0.5);
}

.dashboards-section .btn {
    margin-right: 10px;
    margin-bottom: 10px;
}

.logout-section .btn {
    min-width: 120px;
}


/* =================================== */
/* ===== Medium Screens & Up (Tablet) ====== */
/* =================================== */
@media (min-width: 768px) {
  /* Layout Adjustments */
  .container {
    max-width: 960px;
  }

  /* Header/Nav Adjustments */
  .app-logo .app-name { display: inline; } /* Show app name */
  .nav-link { flex-direction: row; font-size: 0.9rem; align-items: center; } /* Row layout for links */
  .nav-link span { display: inline; } /* Show text labels */
  .nav-link i { margin-right: 0.4rem; margin-bottom: 0; font-size: 1rem; }
  .nav-right { gap: var(--spacing-unit); }

  /* Footer */
  .app-footer { display: block; } /* Show footer */

  /* Product Grid */
  .product-grid { grid-template-columns: repeat(3, 1fr); } /* 3 columns */
  .product-name { height: auto; white-space: normal; } /* Allow name to wrap */


  /* Product Detail Page Layout */
  .product-detail-main {
    flex-direction: row; /* Side-by-side layout */
    align-items: flex-start;
  }
  .product-detail-info {
    flex: 1 1 60%; /* Take 60% width */
  }
  .product-detail-image {
    /* --- UPDATED for responsive flex layout --- */
    flex: 1 1 40%;    /* Take 40% width */
    width: auto;      /* Override mobile width */
    max-width: none;  /* Override mobile max-width */
    margin: 0;        /* Reset mobile margin */
    /* aspect-ratio, overflow, border-radius, background-color are inherited */
  }
  /* No changes needed for .product-detail-image img */

  .product-actions { flex-direction: row; align-items: center; }
  .product-actions .btn { width: auto; }
  .quantity-selector { max-width: 120px; margin-bottom: 0; }

  /* Auth Container */
  .auth-container { margin: calc(var(--spacing-unit) * 2) auto; }

  /* Cart Layout Adjustments */
   .cart-item {
        grid-template-columns: 100px 1fr 100px 150px 80px; /* Adjusted columns for price */
        grid-template-areas: "image details price quantity remove";
        align-items: center;
        padding: var(--spacing-unit);
   }
   .cart-item-details { grid-area: details; }
   .cart-item-price {
       display: block; /* Show price column */
       grid-area: price;
       text-align: right;
       font-weight: 500;
       font-size: 1rem;
       color: var(--text-color);
       margin-bottom: 0;
   }
   .cart-item-quantity { grid-area: quantity; justify-content: center; }
   .cart-item-subtotal { display: none; } /* Hide mobile subtotal */
   .cart-item-remove { grid-area: remove; align-self: center; text-align: center; }


   /* Checkout Layout Adjustments */
    .checkout-grid {
        flex-direction: row; /* Side-by-side */
        gap: calc(var(--spacing-unit) * 1.5);
        align-items: flex-start;
    }
    .checkout-address { flex: 1 1 55%; } /* Address takes more space */
    .checkout-summary { flex: 1 1 45%; } /* Summary takes less space */

   /* Table Styles for Desktop */
   .table-container { border: none; border-radius: 0; background: none; box-shadow: none; }
   .data-table { border: 1px solid var(--border-color); border-radius: var(--border-radius); }
   .data-table thead {
       display: table-header-group; /* Show table headers */
       background-color: #f8f9fa;
       font-weight: 500;
    }
    .data-table th {
        padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 0.5);
        text-align: left;
        border-bottom: 2px solid var(--border-color);
    }

   .data-table tbody tr {
       display: table-row; /* Use standard table rows */
       margin-bottom: 0;
       border: none;
       padding: 0;
       box-shadow: none;
       background-color: transparent;
       border-bottom: 1px solid var(--border-color);
   }
   .data-table tbody tr:last-child { border-bottom: none; }
   .data-table tbody tr:hover { background-color: #f8f9fa; }

   .data-table td {
       display: table-cell; /* Use standard table cells */
       text-align: left; /* Default align */
       padding: calc(var(--spacing-unit) * 0.6) calc(var(--spacing-unit) * 0.5);
       vertical-align: middle;
       border-bottom: none; /* Remove mobile border */
       position: static;
       margin-left: 0 !important; /* Reset mobile margin */
   }
    .data-table td::before { content: none; } /* Hide mobile labels */
    .data-table td:has(form), .actions-cell {
       text-align: right; /* Align action cells right */
       white-space: nowrap; /* Prevent actions wrapping */
   }
   .inline-form { display: inline-block; margin: 0 5px 0 0;}
   .inline-form > * { margin-bottom: 0; }
   .action-group { border: none; padding: 0; margin: 0; display: inline-block; vertical-align: middle; margin-right: 10px;}
   .action-group-title { display: none; }
   .actions-cell > form, .actions-cell > div > form { display: inline-block; }
   .actions-cell > a { display: inline-block; margin-right: 5px; vertical-align: middle;}

   /* Specific Column Alignments */
   .data-table th[data-label*="Price"],
   .data-table td[data-label*="Price"],
   .data-table th[data-label*="Stock"],
   .data-table td[data-label*="Stock"],
   .data-table th[data-label*="Rating"],
   .data-table td[data-label*="Rating"],
   .data-table th[data-label*="Sold"], /* Added Sold */
   .data-table td[data-label*="Sold"] { /* Added Sold */
       text-align: center;
   }
   .data-table th[data-label="Status"],
   .data-table td[data-label="Status"] {
        text-align: center;
    }
   .data-table th[data-label*="Total"],
   .data-table td[data-label*="Total"] {
        text-align: right;
        font-weight: 500;
   }
   .data-table th.actions-cell,
   .data-table td.actions-cell { text-align: right !important; } /* Ensure actions are right aligned */

   /* Desktop Actions */
   .actions-cell form, .actions-cell .btn { display: inline-block; width: auto; margin: 0 0 0 5px;}
   .actions-cell .btn-block { display: inline-block; width: auto; }


   .table-img { max-width: 60px; margin-left: 0; }
   .data-table td:has(img) { text-align: left; }

   /* Admin Dashboard Layout */
    .admin-actions-grid { grid-template-columns: repeat(3, 1fr); } /* 3 columns */

    /* Rating Stats Layout */
    .rating-stats-container {
        display: flex;
        align-items: flex-start;
        gap: calc(var(--spacing-unit) * 2);
    }
    .rating-summary {
        flex-direction: column;
        align-items: center;
        margin-bottom: 0;
        flex-basis: 150px; /* Give summary fixed space */
        flex-shrink: 0;
    }
    .rating-average-value { font-size: 3em; }
    .rating-total { font-size: 1em; }
    .rating-bars {
        max-width: none; /* Let bars take remaining space */
        flex-grow: 1;
    }

    /* Profile Container Padding */
    .profile-container {
        padding: calc(var(--spacing-unit) * 2);
    }

} /* End @media 768px */


/* =================================== */
/* ===== Large Screens & Up (Desktop) ===== */
/* =================================== */
@media (min-width: 1024px) {
  /* Layout Adjustments */
  .container { max-width: 1140px; }

  /* Product Grid */
  .product-grid { grid-template-columns: repeat(4, 1fr); } /* 4 columns */

  /* Spacing */
  .product-grid, .admin-actions-grid { gap: calc(var(--spacing-unit) * 1); } /* Increase gap */

  /* Admin Dashboard */
  .admin-actions-grid { grid-template-columns: repeat(4, 1fr); } /* 4 columns */

} /* End @media 1024px */


public/js/main.js:
console.log("Main JS loaded.");

document.addEventListener('DOMContentLoaded', () => {

    // --- Cart Update AJAX Logic (Enhanced Spinner) ---
    const updateQtyButtons = document.querySelectorAll('.btn-update-qty');
    updateQtyButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const productId = button.dataset.productId;
            const quantityInput = document.getElementById(`quantity-${productId}`);
            const newQuantity = parseInt(quantityInput.value, 10);

            if (isNaN(newQuantity) || newQuantity < 0) {
                 alert('Invalid quantity');
                 // Revert input if possible? Or just return.
                 // quantityInput.value = button.dataset.previousValue || 1; // Needs previous value storage
                return;
             }
            const maxStock = parseInt(quantityInput.max, 10);
            if(newQuantity > maxStock){
                alert(`Only ${maxStock} items available in stock.`);
                quantityInput.value = maxStock; // Correct input to max stock
                 return;
             }

            updateCartItemQuantityAJAX(productId, newQuantity, button);
        });
        // Store initial value for potential revert on error (optional)
        // const quantityInput = document.getElementById(`quantity-${button.dataset.productId}`);
        // if(quantityInput) button.dataset.previousValue = quantityInput.value;
    });


    // --- Generic Form Submission Spinner ---
    document.querySelectorAll('form.form-submit-spinner').forEach(form => {
        form.addEventListener('submit', (event) => {
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton && !submitButton.disabled) {
                // Basic client-side validation check before showing spinner
                if (typeof form.checkValidity === 'function' && !form.checkValidity()) {
                    // Let browser handle HTML5 validation messages, don't show spinner
                    return;
                }

                const originalText = submitButton.innerHTML;
                // Store original text in case we need to revert *without* page load (e.g., advanced client-side errors)
                submitButton.dataset.originalText = originalText;
                submitButton.disabled = true;
                submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';

                // Spinner will generally be reset by page reload/redirect.
                // No explicit reset here simplifies things for standard forms.
            }
        });
    });


    // --- Responsive Table Logic ---
    function responsiveTables() {
        const tables = document.querySelectorAll('.data-table');
        tables.forEach(table => {
            const headerElements = table.querySelectorAll('thead th');
            if (!headerElements || headerElements.length === 0) return;

            const headers = Array.from(headerElements).map(th => th.textContent.trim());
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                cells.forEach((cell, index) => {
                    // Ensure we don't overwrite data-label if already set or if header is empty
                    if (!cell.hasAttribute('data-label') && headers[index] !== undefined && headers[index] !== '') {
                         cell.setAttribute('data-label', headers[index]);
                    }
                });
            });
        });
    }
     // Run on load and potentially on resize if needed
     if (document.querySelector('.data-table')) {
         responsiveTables();
         // Consider adding resize listener if layout changes dynamically often
         // window.addEventListener('resize', responsiveTables);
     }


    // --- Share Button Logic ---
    const shareButton = document.getElementById('share-product-btn');
    const fallbackLinks = document.getElementById('fallback-share-links');

    if (shareButton && fallbackLinks) {
        shareButton.addEventListener('click', async () => {
            const title = shareButton.dataset.title;
            const text = shareButton.dataset.text;
            const url = shareButton.dataset.url;

            if (navigator.share) {
                try {
                    await navigator.share({ title, text, url });
                    console.log('Product shared successfully!');
                } catch (error) {
                    console.error('Error sharing:', error);
                    if (error.name !== 'AbortError') {
                         fallbackLinks.classList.remove('hidden');
                    }
                }
            } else {
                console.log('Web Share API not supported, showing fallback links.');
                fallbackLinks.classList.remove('hidden');
            }
        });
    }

    // --- Checkout Address Form Toggle ---
    const editBtn = document.getElementById('edit-address-btn');
    const cancelBtn = document.getElementById('cancel-edit-btn');
    const addressForm = document.getElementById('address-form');
    const savedAddressDiv = document.querySelector('.saved-address'); // Should be #saved-address-display? Check profile.ejs if issues
    const profileSavedAddressDiv = document.getElementById('saved-address-display'); // Specific ID for profile page
    const placeOrderBtn = document.querySelector('.btn-place-order');
    const formTitle = addressForm?.querySelector('h3');
    const addressSourceInput = addressForm?.querySelector('input[name="source"]');
    let isProfilePage = addressSourceInput?.value === 'profile'; // Check if on profile page

    let initialAddressDiv = isProfilePage ? profileSavedAddressDiv : savedAddressDiv;
    const hasInitialAddress = initialAddressDiv && !initialAddressDiv.classList.contains('hidden');

    if (editBtn && addressForm && initialAddressDiv) {
        editBtn.addEventListener('click', () => {
            addressForm.classList.remove('hidden');
            initialAddressDiv.classList.add('hidden');
            if(placeOrderBtn) placeOrderBtn.disabled = true; // Disable place order while editing checkout address
            if(formTitle) formTitle.textContent = 'Edit Address';
        });
    }

    if (cancelBtn && addressForm && initialAddressDiv) {
        cancelBtn.addEventListener('click', () => {
            addressForm.classList.add('hidden');
            if (hasInitialAddress) {
                initialAddressDiv.classList.remove('hidden');
                 // Only re-enable place order button if NOT on profile page and address existed
                if(placeOrderBtn && !isProfilePage) placeOrderBtn.disabled = false;
            } else {
                 if(placeOrderBtn && !isProfilePage) placeOrderBtn.disabled = true; // Keep disabled if there was no initial address on checkout
            }
            // Reset form fields? Optional, but good practice
            // addressForm.reset();
        });
    }

     // Initial state check:
     // On Checkout: If no initial address, show form, ensure button is disabled
     if (!isProfilePage && !hasInitialAddress && addressForm && placeOrderBtn) {
         addressForm.classList.remove('hidden');
         placeOrderBtn.disabled = true;
         if (formTitle) formTitle.textContent = 'Add Address';
     } else if (!isProfilePage && hasInitialAddress && placeOrderBtn) {
         placeOrderBtn.disabled = false; // Ensure enabled if address exists initially on checkout
     }
     // On Profile: If no address, show form (cancel button might be hidden by EJS)
      if (isProfilePage && !hasInitialAddress && addressForm) {
         addressForm.classList.remove('hidden');
         if (formTitle) formTitle.textContent = 'Add Address';
     }

    // --- REMOVED Bulk Order Assignment Logic ---


}); // End DOMContentLoaded


// --- Cart AJAX Update Function (Revised Spinner/Button Handling) ---
async function updateCartItemQuantityAJAX(productId, quantity, buttonElement) {
     const originalButtonText = 'Update'; // Define original text
     const loadingButtonText = '<i class="fas fa-spinner fa-spin"></i>'; // Just spinner for small button
     const quantityInput = document.getElementById(`quantity-${productId}`); // Get input

     buttonElement.disabled = true;
     buttonElement.innerHTML = loadingButtonText;
     if(quantityInput) quantityInput.readOnly = true; // Make input readonly during update


    try {
        const response = await fetch('/user/cart/update', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                // Include CSRF token header if you implement CSRF protection
            },
            body: JSON.stringify({ productId, quantity })
         });

        if (!response.ok) {
             const errorData = await response.json().catch(() => ({ message: 'Failed to update cart. Server error.' }));
            throw new Error(errorData.message || `Update failed (Status: ${response.status})`);
        }

         const data = await response.json();

         if (data.success) {
            const cartItemDiv = buttonElement.closest('.cart-item'); // Find parent cart item

             if (quantity === 0) {
                if (cartItemDiv) {
                    cartItemDiv.style.transition = 'opacity 0.3s ease';
                    cartItemDiv.style.opacity = '0';
                    setTimeout(() => {
                        cartItemDiv.remove();
                         // Recalculate count and update UI after removing item
                        updateCartTotalAndBadge(data.cartTotal); // Pass the total from response
                        handleEmptyCartDisplay(); // Check if cart became empty
                    }, 300);
                     return; // Exit early as item is being removed
                }
             } else {
                 const subtotalSpan = cartItemDiv?.querySelector('.item-subtotal-value');
                 if (subtotalSpan) subtotalSpan.textContent = data.itemSubtotal.toFixed(2);
                if(quantityInput) {
                     quantityInput.value = data.newQuantity; // Update input with confirmed quantity
                 }

             }
             // Update total and badge for successful updates (non-zero quantity)
             updateCartTotalAndBadge(data.cartTotal);

         } else {
             // Server responded with success: false
             alert(`Update failed: ${data.message}`);
         }

    } catch (error) {
         // Network error or other exception during fetch/processing
         console.error('Error updating cart quantity:', error);
         alert(`Error: ${error.message}`);
    } finally {
         // Always re-enable button and input, restore original text
         buttonElement.disabled = false;
         buttonElement.innerHTML = originalButtonText;
         if(quantityInput) quantityInput.readOnly = false;
     }
}

// --- Helper Function: Update Cart Total Display and Header Badge ---
function updateCartTotalAndBadge(newCartTotal) {
    // Update Cart Total Display
     const cartTotalSpan = document.getElementById('cart-total-value');
     if (cartTotalSpan) cartTotalSpan.textContent = newCartTotal.toFixed(2);

    // Update Header Cart Count (Recalculate based on current DOM input values)
     const newCartItemCount = calculateNewCartCount();
     const cartBadge = document.querySelector('.cart-badge');
     if (cartBadge) {
         if (newCartItemCount > 0) {
             cartBadge.textContent = newCartItemCount;
             cartBadge.style.display = 'inline-block'; // Show badge
         } else {
            cartBadge.textContent = '0';
            cartBadge.style.display = 'none'; // Hide badge
         }
     } else {
         console.warn("Cart badge element not found in header.");
     }
}


// --- Helper function: Calculate cart count from input fields ---
function calculateNewCartCount() {
    const quantityInputs = document.querySelectorAll('.cart-item .quantity-input');
    let count = 0;
    quantityInputs.forEach(input => {
        const value = parseInt(input.value, 10);
        // Only count items with quantity >= 1
        if (!isNaN(value) && value > 0) {
          // Accumulate actual quantity (how many items total), not just number of rows
          count += value;
        }
    });
    return count;
}

// --- Helper function: Check and display empty cart message ---
function handleEmptyCartDisplay() {
    const cartItemsContainer = document.querySelector('.cart-items');
     const cartContainer = document.querySelector('.cart-container'); // Get the parent
     // Check count AFTER potential removal animation finishes
     if (calculateNewCartCount() === 0 && cartContainer && cartItemsContainer) {
         // Replace entire cart content if empty
         cartContainer.innerHTML = '<h1>Your Shopping Cart</h1><p>Your cart is empty. <a href="/">Continue Shopping</a></p>';
         // No need to hide summary as it's removed
     }
}
routes/adminRoutes.js:
// routes/adminRoutes.js
const express = require('express');
const adminController = require('../controllers/adminController');
const { isAuthenticated } = require('../middleware/authMiddleware');
const { isAdmin } = require('../middleware/roleMiddleware');

const router = express.Router();

// Apply authentication and admin role check to all routes in this file
router.use(isAuthenticated, isAdmin);

// Dashboard
router.get('/dashboard', adminController.getAdminDashboard);

// Products
router.get('/upload-product', adminController.getUploadProductPage);
router.post('/upload-product', adminController.uploadProduct);
router.get('/manage-products', adminController.getManageProductsPage);
router.get('/manage-products/edit/:id', adminController.getEditProductPage);
router.post('/manage-products/update/:id', adminController.updateProduct);
router.post('/manage-products/remove/:id', adminController.removeProduct);


// Orders
router.get('/manage-orders', adminController.getManageOrdersPage);
// Direct delivery by Admin actions
router.post('/orders/:orderId/send-direct-delivery-otp', adminController.sendDirectDeliveryOtpByAdmin);
router.post('/orders/:orderId/confirm-direct-delivery', adminController.confirmDirectDeliveryByAdmin);
// Cancel action
router.post('/orders/:orderId/cancel', adminController.cancelOrderByAdmin);
// --- REMOVED Assign/Unassign/Bulk Routes ---


// Users
router.get('/manage-users', adminController.getManageUsersPage);
router.post('/users/:id/update-role', adminController.updateUserRole);
router.post('/users/:id/remove', adminController.removeUser);


// --- REMOVED Assigned Orders Routes ---
// router.get('/manage-assigned-orders', adminController.getManageAssignedOrdersPage);
// router.get('/manage-assigned-orders/details/:deliveryAdminId/:type', adminController.getAssignedOrdersDetailForAdmin);
// router.post('/manage-assigned-orders/remove/:id', adminController.removeDeliveryAdminAssignment);


module.exports = router;
routes/authRoutes.js:
const express = require('express');
const authController = require('../controllers/authController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.get('/login', authController.getLoginPage);
router.get('/register', authController.getRegisterPage);
router.get('/verify-otp', authController.getVerifyOtpPage);
router.get('/forgot-password', authController.getForgotPasswordPage);
router.get('/reset-password/:token', authController.getResetPasswordPage);

router.post('/register', authController.registerUser);
router.post('/login', authController.loginUser);
 router.post('/logout', isAuthenticated, authController.logoutUser);
router.post('/verify-otp', authController.verifyOtp);
 router.post('/resend-otp', authController.resendOtp);

router.post('/forgot-password', authController.forgotPassword);
router.post('/reset-password/:token', authController.resetPassword);


module.exports = router;

routes/index.js:
// routes/index.js
const express = require('express');
const authRoutes = require('./authRoutes');
const productRoutes = require('./productRoutes');
const userRoutes = require('./userRoutes');
const orderRoutes = require('./orderRoutes');
const adminRoutes = require('./adminRoutes');
// --- REMOVED require('./deliveryRoutes') ---

const { getHomePage } = require('../controllers/authController'); // Assuming this is correct

const router = express.Router();

router.get('/', getHomePage);
router.use('/auth', authRoutes);
router.use('/products', productRoutes);

router.use('/user', userRoutes);
router.use('/orders', orderRoutes);

router.use('/admin', adminRoutes);

// --- REMOVED app.use('/delivery', deliveryRoutes); ---


module.exports = router;
routes/orderRoutes.js:
const express = require('express');
const orderController = require('../controllers/orderController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.use(isAuthenticated);

router.post('/place', orderController.placeOrder);

router.get('/my-orders', orderController.getMyOrders);

 router.post('/cancel/:id', orderController.cancelOrder);

module.exports = router;

routes/productRoutes.js:
const express = require('express');
const productController = require('../controllers/productController');
 const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.get('/', productController.getProducts);
router.get('/:id', productController.getProductDetails);

 router.post('/:id/rate', isAuthenticated, productController.rateProduct);

module.exports = router;

routes/userRoutes.js:
// routes/userRoutes.js
const express = require('express');
const userController = require('../controllers/userController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.use(isAuthenticated); // Apply to all user routes

// --- ADD NEW PROFILE ROUTE ---
router.get('/profile', userController.getUserProfilePage);
// --- END NEW ROUTE ---

router.get('/cart', userController.getCart);
router.post('/cart/add', userController.addToCart);
router.post('/cart/update', userController.updateCartQuantity);
router.post('/cart/remove/:productId', userController.removeFromCart);

router.post('/address/save', userController.saveAddress); // Keep existing save route

router.get('/checkout', userController.getCheckoutPage);

module.exports = router;
services/otpService.js:
const crypto = require('crypto');

const generateOTP = (length = 6) => {
  const buffer = crypto.randomBytes(Math.ceil(length / 2));
  let otp = buffer.toString('hex');
  otp = otp.replace(/[^0-9]/g, '');
  otp = otp.slice(0, length);
  while (otp.length < length) {
    otp = '0' + otp;
  }
  return otp;
};

const setOTPExpiration = (minutes = 10) => {
  return Date.now() + minutes * 60 * 1000;
};

module.exports = { generateOTP, setOTPExpiration };

views/admin/assigned-orders-detail.ejs:
<%# views/admin/assigned-orders-detail.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <%# Link might be invalid now if /admin/manage-assigned-orders was removed %>
    <p><a href="/admin/manage-assigned-orders">« Back to Delivery Admin Overview</a></p>

    <% if (orders.length > 0) { %>
        <div class="table-container card"> <%# Added wrapper %>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Image</th>
                        <th>Order ID</th>
                        <th>Placed Date</th>
                        <th>Customer Email</th>
                        <th>Address</th>
                        <th>Items</th>
                        <th>Total</th>
                        <th>Status</th>
                        <th>Delivered Date</th>
                    </tr>
                </thead>
                <tbody>
                    <% orders.forEach(order => { %>
                        <tr>
                            <td data-label="Image"> <%# Added data-label %>
                                <% if (order.products && order.products.length > 0 && order.products[0].imageUrl) { %>
                                    <%# Ensure productId exists before creating link %>
                                    <% if (order.products[0].productId) { %>
                                        <a href="/products/<%= order.products[0].productId %>">
                                            <img src="<%= order.products[0].imageUrl %>" alt="<%= order.products[0].name %>" class="table-img">
                                        </a>
                                    <% } else { %>
                                        <img src="<%= order.products[0].imageUrl %>" alt="<%= order.products[0].name %>" class="table-img">
                                    <% } %>
                                <% } else { %>
                                    <span class="text-muted">N/A</span>
                                <% } %>
                            </td>
                            <td data-label="Order ID"><%= order._id %></td>
                            <%# --- USE HELPER --- %>
                            <td data-label="Placed Date"><%= formatDateIST(order.orderDate) %></td>
                            <td data-label="Customer Email"><%= order.userEmail %></td>
                            <td data-label="Address">
                                <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %>
                                <br>Ph: <%= order.shippingAddress.phone %>
                            </td>
                            <td data-label="Items">
                                <% if (order.products && order.products.length > 0) { %>
                                    <%= order.products[0].name %> (x<%= order.products[0].quantity %>)
                                    <% if (order.products.length > 1) { %>
                                        <br><small>+ <%= order.products.length - 1 %> more item(s)</small>
                                    <% } %>
                                <% } else { %>
                                    No items found
                                <% } %>
                            </td>
                            <td data-label="Total">₹<%= order.totalAmount.toFixed(2) %></td>
                            <td data-label="Status"><span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span></td>
                            <%# --- USE HELPER --- %>
                            <td data-label="Delivered Date"><%= formatDateIST(order.receivedByDate) %></td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p>No orders found matching this criteria for <%= deliveryAdminEmail %>.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>
views/admin/dashboard.ejs:
<%- include('../partials/header', { title: 'Admin Dashboard' }) %>

<div class="admin-dashboard-container">
    <h1>Admin Dashboard</h1>
    <p class="text-muted mb-3">Welcome, <%= currentUser.name %>!</p>

    <div class="admin-actions-grid">
         <a href="/admin/upload-product" class="admin-action-card card"> <%# ADDED .card %>
            <i class="fas fa-upload"></i>
            <h3>Upload Products</h3>
            <p>Add new products to the store.</p>
        </a>
         <a href="/admin/manage-products" class="admin-action-card card"> <%# ADDED .card %>
            <i class="fas fa-edit"></i>
            <h3>Manage Products</h3>
            <p>Edit or remove existing products.</p>
         </a>
        <a href="/admin/manage-orders" class="admin-action-card card"> <%# ADDED .card %>
             <i class="fas fa-clipboard-list"></i>
             <h3>Manage Orders</h3>
             <p>View, verify, and assign orders.</p>
        </a>
        <a href="/admin/manage-users" class="admin-action-card card"> <%# ADDED .card %>
             <i class="fas fa-users-cog"></i>
             <h3>Manage Users</h3>
             <p>Update roles or remove users.</p>
        </a>
    </div>
</div>

 <%- include('../partials/footer') %>
views/admin/edit-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>

     <form action="/admin/manage-products/update/<%= product._id %>" method="POST">
        <div class="form-group">
             <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" value="<%= product.name %>" required>
         </div>
        <div class="form-group">
            <label for="category">Category:</label>
             <input type="text" id="category" name="category" value="<%= product.category %>" required>
         </div>
         <div class="form-group">
            <label for="price">Price:</label>
            <input type="number" id="price" name="price" step="0.01" min="0" value="<%= product.price %>" required>
         </div>
        <div class="form-group">
             <label for="stock">Stock Quantity:</label>
             <input type="number" id="stock" name="stock" min="0" value="<%= product.stock %>" required>
        </div>
         <div class="form-group">
             <label for="imageUrl">Image URL:</label>
             <input type="url" id="imageUrl" name="imageUrl" value="<%= product.imageUrl %>" required>
             <% if(product.imageUrl) { %> <img src="<%= product.imageUrl %>" alt="Current Image" style="max-width: 100px; margin-top: 5px;"> <% } %>
         </div>
         <div class="form-group">
             <label for="specifications">Specifications:</label>
             <textarea id="specifications" name="specifications" rows="5"><%= product.specifications %></textarea>
        </div>
         <button type="submit" class="btn btn-primary">Update Product</button>
         <a href="/admin/manage-products" class="btn btn-secondary">Cancel</a>
    </form>
 </div>

 <%- include('../partials/footer') %>
views/admin/manage-orders.ejs:
<%# views/admin/manage-orders.ejs %>
<%- include('../partials/header', { title: 'Manage Orders' }) %>

<div class="admin-manage-container">
    <h1>Manage Orders</h1>

    <% if (orders.length > 0) { %>
        <div class="table-container card">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Images</th>
                        <th>Order ID</th>
                        <th>Date</th>
                        <th>Customer</th>
                        <th>Address & Phone</th>
                        <th>Items & Prices</th>
                        <th>Total</th>
                        <th>Status</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% orders.forEach(order => { %>
                        <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %>" data-order-id="<%= order._id %>">
                            <td data-label="Images">
                                <% if (order.products && order.products.length > 0) { %>
                                    <% order.products.slice(0, 3).forEach(item => { %>
                                        <% if (item.productId && item.productId._id && item.imageUrl) { %>
                                            <a href="/products/<%= item.productId._id %>" title="View Product: <%= item.name %>">
                                                <img src="<%= item.imageUrl %>" alt="<%= item.name %>" class="table-img">
                                            </a>
                                        <% } else { %><span class="text-muted" style="font-size: 0.8em;">[?]</span><% } %>
                                    <% }) %>
                                    <% if (order.products.length > 3) { %><br><small class="text-muted" style="white-space: nowrap;">+ <%= order.products.length - 3 %> more</small><% } %>
                                <% } else { %><span class="text-muted">N/A</span><% } %>
                            </td>
                            <td data-label="Order ID"><%= order._id %></td>
                            <%# --- USE HELPER --- %>
                            <td data-label="Date"><%= formatDateIST(order.orderDate) %></td>
                            <td data-label="Customer"><%= order.userEmail %></td>
                            <td data-label="Address & Phone">
                                <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %>
                                <br><strong>Ph: <%= order.shippingAddress.phone %></strong>
                            </td>
                            <td data-label="Items & Prices">
                                <% if (order.products && order.products.length > 0) { %>
                                    <% order.products.forEach((item, index) => { %>
                                        <% if (item.productId) { %>
                                            <%= item.name %> (Qty: <%= item.quantity %>) : ₹<%= item.priceAtOrder.toFixed(2) %>
                                        <% } else { %>
                                            [Removed Product] (Qty: <%= item.quantity %>) : ₹<%= item.priceAtOrder.toFixed(2) %>
                                        <% } %>
                                        <% if (index < order.products.length - 1) { %><br><% } %>
                                    <% }) %>
                                <% } else { %>No items found<% } %>
                            </td>
                            <td data-label="Total"><strong>₹<%= order.totalAmount.toFixed(2) %></strong></td>
                            <td data-label="Status">
                                <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span>
                                <% if(order.status === 'Cancelled' && order.cancellationReason) { %><br><small class="text-danger">Reason: <%= order.cancellationReason %></small><% } %>
                                <%# --- USE HELPER --- %>
                                <% if(order.status === 'Delivered' && order.receivedByDate) { %><br><small class="text-success">Delivered: <%= formatDateIST(order.receivedByDate) %></small><% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Direct Delivery Confirmation by Admin (Pending orders) %>
                                <% if (order.canBeDirectlyDeliveredByAdmin) { %>
                                    <div class="action-group">
                                        <p class="action-group-title">Admin Direct Delivery:</p>
                                        <form action="/admin/orders/<%= order._id %>/send-direct-delivery-otp" method="POST" class="inline-form form-submit-spinner">
                                            <button type="submit" class="btn btn-warning btn-sm" title="Send delivery confirmation OTP to customer for direct delivery">
                                                <i class="fas fa-mobile-alt"></i> Send OTP
                                            </button>
                                        </form>
                                        <form action="/admin/orders/<%= order._id %>/confirm-direct-delivery" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                            <input type="text" name="otp" placeholder="6-Digit OTP" required size="8" pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter the 6-digit OTP from customer">
                                            <button type="submit" class="btn btn-success btn-sm" title="Confirm direct delivery">
                                                <i class="fas fa-check-double"></i> Confirm
                                            </button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Cancel Order (Admin: Pending only now) %>
                                <% if (order.canBeCancelledByAdmin) { %>
                                    <div class="action-group">
                                        <form action="/admin/orders/<%= order._id %>/cancel" method="POST" class="inline-form cancel-delivery-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to cancel this order? This cannot be undone.');">
                                            <label for="reason-<%= order._id %>" class="action-group-title">Cancel Order:</label>
                                            <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm">
                                                <option value="" disabled selected>Select Reason...</option>
                                                <% cancellationReasons.forEach(reason => { %>
                                                    <option value="<%= reason %>"><%= reason %></option>
                                                <% }) %>
                                            </select>
                                            <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-ban"></i> Cancel Order</button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Fallback %>
                                <% if (!order.canBeDirectlyDeliveredByAdmin && !order.canBeCancelledByAdmin) { %>
                                    <% if (order.status === 'Delivered') { %><small class="text-success">Completed.</small><% } else if (order.status === 'Cancelled') { %><small class="text-danger">Cancelled.</small><% } else { %><small class="text-muted">No actions available.</small><% } %>
                                <% } %>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p>No orders received yet.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>
views/admin/manage-products.ejs:
<%# Example: views/admin/manage-products.ejs %>
<%- include('../partials/header', { title: 'Manage Products' }) %>

<div class="admin-manage-container">
    <h1>Manage Products</h1>
    <a href="/admin/upload-product" class="btn btn-primary mb-3"><i class="fas fa-plus"></i> Upload New Product</a>

   <% if (products.length > 0) { %>
       <div class="table-container card"> <%# WRAP with .table-container and .card %>
           <table class="data-table">
               <thead>
                   <tr>
                       <th>Image</th>
                       <th>Name</th>
                       <th>Category</th>
                       <th>Price</th>
                       <th>Stock</th>
                       <th>Sold</th>
                       <th>Rating</th>
                       <th class="actions-cell" style="text-align: right;">Actions</th> <%# Align header right %>
                   </tr>
                </thead>
                <tbody>
                   <% products.forEach(product => { %>
                       <tr>
                           <td data-label="Image"><a href="/products/<%= product._id %>"><img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="table-img"></a></td>
                            <td data-label="Name"><%= product.name %></td>
                            <td data-label="Category"><%= product.category %></td>
                            <td data-label="Price">₹<%= product.price.toFixed(2) %></td>
                            <td data-label="Stock"><%= product.stock %></td>
                            <td data-label="Sold"><%= product.orderCount %></td>
                            <td data-label="Rating"><%= product.averageRating.toFixed(1) %> (<%= product.numReviews %>)</td>
                            <td data-label="Actions" class="actions-cell">
                               <a href="/admin/manage-products/edit/<%= product._id %>" class="btn btn-text btn-sm" title="Edit"><i class="fas fa-edit"></i></a> <%# Text button for icon %>
                               <form action="/admin/manage-products/remove/<%= product._id %>" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to remove this product: <%= product.name %>?');">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove"><i class="fas fa-trash"></i></button> <%# Text button for icon %>
                               </form>
                           </td>
                        </tr>
                    <% }) %>
               </tbody>
            </table>
       </div>
   <% } else { %>
        <p class="text-muted mt-3">No products found. <a href="/admin/upload-product">Upload the first product!</a></p>
   <% } %>
</div>

<%- include('../partials/footer') %>
views/admin/manage-users.ejs:
<%# views/admin/manage-users.ejs %>
<%- include('../partials/header', { title: 'Manage Users' }) %>

<div class="admin-manage-container">
    <h1>Manage Users</h1>

    <% if (users.length > 0) { %>
        <div class="table-container card"> <%# Added table wrapper %>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Email / Phone</th>
                        <th>Role</th>
                        <th>Registered On</th>
                        <th>Verified</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% users.forEach(user => { %>
                        <tr>
                            <td data-label="Name"><%= user.name %></td>
                            <td data-label="Email / Phone">
                                <%= user.email %>
                                <% if (user.address && user.address.phone) { %>
                                    <br><small>(<%= user.address.phone %>)</small>
                                <% } %>
                            </td>
                            <td data-label="Role">
                                <form action="/admin/users/<%= user._id %>/update-role" method="POST" class="inline-form form-submit-spinner"> <%# Added spinner class %>
                                    <select name="role" onchange="this.form.submit()">
                                        <option value="user" <%= user.role === 'user' ? 'selected' : '' %>>User</option>
                                        <option value="admin" <%= user.role === 'admin' ? 'selected' : '' %>>Admin</option>
                                        <%# Removed delivery_admin option %>
                                    </select>
                                    <noscript><button type="submit" class="btn btn-sm btn-primary">Update Role</button></noscript>
                                </form>
                            </td>
                            <%# --- USE HELPER --- %>
                            <td data-label="Registered On"><%= formatDateIST(user.createdAt) %></td>
                            <td data-label="Verified"><%= user.isVerified ? 'Yes' : 'No' %></td>
                            <td data-label="Actions" class="actions-cell">
                                <form action="/admin/users/<%= user._id %>/remove" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to remove user <%= user.email %>? This is irreversible.');"> <%# Added spinner class %>
                                    <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-user-times"></i> Remove</button>
                                </form>
                            </td>
                        </tr>
                    <% }) %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="text-muted mt-3">No other users registered.</p> <%# Added mt-3 for spacing %>
    <% } %>
</div>

<%- include('../partials/footer') %>
views/admin/upload-product.ejs:
<%- include('../partials/header', { title: 'Upload New Product' }) %>

<div class="admin-manage-container">
    <h1>Upload New Product</h1>

     <form action="/admin/upload-product" method="POST">
        <div class="form-group">
             <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" required>
         </div>
        <div class="form-group">
            <label for="category">Category:</label>
             <input type="text" id="category" name="category" required>
         </div>
         <div class="form-group">
            <label for="price">Price:</label>
            <input type="number" id="price" name="price" step="0.01" min="0" required>
         </div>
        <div class="form-group">
             <label for="stock">Stock Quantity:</label>
             <input type="number" id="stock" name="stock" min="0" required>
        </div>
         <div class="form-group">
             <label for="imageUrl">Image URL:</label>
             <input type="url" id="imageUrl" name="imageUrl" required>
         </div>
         <div class="form-group">
             <label for="specifications">Specifications:</label>
             <textarea id="specifications" name="specifications" rows="5"></textarea>
        </div>
         <button type="submit" class="btn btn-primary">Upload Product</button>
         <a href="/admin/dashboard" class="btn btn-secondary">Cancel</a>
    </form>
 </div>

 <%- include('../partials/footer') %>

views/auth/forgot-password.ejs:
<%- include('../partials/header', { title: 'Forgot Password' }) %>

<div class="auth-container">
    <h1>Forgot Password</h1>
    <p>Enter your email address below. If an account exists, we'll send an OTP to verify your request.</p>

    <form action="/auth/forgot-password" method="POST" class="auth-form">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required>
        </div>
        <button type="submit" class="btn btn-primary">Send Reset OTP</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/login.ejs:
<%- include('../partials/header', { title: 'Login' }) %>

<div class="auth-container">
    <h1>Login</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/login" method="POST" class="auth-form form-submit-spinner">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" required autocomplete="current-password">
        </div>
        <button type="submit" class="btn btn-primary">Login</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/forgot-password">Forgot Password?</a></p>
        <p>Don't have an account? <a href="/auth/register">Register here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>
views/auth/register.ejs:
<%- include('../partials/header', { title: 'Register' }) %>

<div class="auth-container">
    <h1>Register</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/register" method="POST" class="auth-form form-submit-spinner">
         <div class="form-group">
            <label for="name">Name:</label>
            <input type="text" id="name" name="name" required autocomplete="name">
        </div>
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" minlength="6" required autocomplete="new-password">
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required autocomplete="new-password">
        </div>
        <button type="submit" class="btn btn-primary">Register</button>
    </form>
    <div class="auth-links">
        <p>Already have an account? <a href="/auth/login">Login here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>
views/auth/reset-password.ejs:
<%- include('../partials/header', { title: 'Reset Password' }) %>

<div class="auth-container">
    <h1>Reset Password</h1>
    <p>Enter your new password below.</p>

    <form action="/auth/reset-password/<%= token %>" method="POST" class="auth-form">
        <div class="form-group">
            <label for="password">New Password:</label>
            <input type="password" id="password" name="password" minlength="6" required>
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm New Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required>
        </div>
        <button type="submit" class="btn btn-primary">Reset Password</button>
    </form>
     <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/verify-otp.ejs:
<%- include('../partials/header', { title: title || 'Verify OTP' }) %>

<div class="auth-container">
    <h1>Verify OTP</h1>
    <p>An OTP has been sent to <strong><%= email %></strong>. Please enter it below.</p>

    <%# --- Spinner Class Added & Input Attributes Updated --- %>
    <form action="/auth/verify-otp" method="POST" class="auth-form form-submit-spinner">
         <input type="hidden" name="email" value="<%= email %>">
        <div class="form-group">
            <label for="otp">OTP Code:</label>
            <input type="text" <%# Changed type to text for better compatibility %>
                   id="otp"
                   name="otp"
                   required
                   pattern="\d{6}" <%# Ensures exactly 6 digits %>
                   maxlength="6"  <%# Limits input length %>
                   inputmode="numeric" <%# Suggests numeric keyboard on mobile %>
                   autocomplete="one-time-code" <%# Helps password managers/browsers %>
                   title="Enter the 6-digit OTP code received"> <%# Clear hint %>
        </div>
        <button type="submit" class="btn btn-primary">Verify OTP</button>
    </form>
    <div class="auth-links">
        <p>Didn't receive the OTP?</p>
        <form action="/auth/resend-otp" method="POST" style="display:inline;" class="form-submit-spinner">
             <input type="hidden" name="email" value="<%= email %>">
             <button type="submit" class="btn btn-secondary btn-sm">Resend OTP</button>
         </form>
    </div>
</div>

<%- include('../partials/footer') %>
views/partials/footer.ejs:
    </main> <%# End Main Content Area %>

    <footer class="app-footer desktop-only">
        <p>© <%= new Date().getFullYear() %> ProShop. All rights reserved.</p>
    </footer>

    <script src="/js/main.js"></script>

</body>
</html>
views/partials/header.ejs:
<%# views/partials/header.ejs %>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <%# --- META TAGS FOR RICH LINK PREVIEWS --- %>
    <% const pageTitle = typeof title !== 'undefined' ? title + ' | miniapp' : 'miniapp'; %>
    <% const siteName = typeof defaultSiteName !== 'undefined' ? defaultSiteName : 'miniapp'; %>
    <% const currentMetaTitle = typeof metaTitle !== 'undefined' ? metaTitle : (typeof title !== 'undefined' ? title : 'miniapp'); %>
    <% const currentMetaDesc = typeof metaDescription !== 'undefined' ? metaDescription : 'Check out our products on ' + siteName; %>
    <%# Use a default logo/image if specific one isn't provided %>
    <% const currentMetaImage = typeof metaImageUrl !== 'undefined' ? metaImageUrl : '/images/default-logo.png'; /* Adjust path if needed */ %>
    <% const currentMetaUrl = typeof fullUrl !== 'undefined' ? fullUrl : ''; %>
    <% const currentMetaType = typeof metaType !== 'undefined' ? metaType : 'website'; %>

    <title><%= pageTitle %></title>

    <%# -- Standard Meta -- %>
    <meta name="description" content="<%= currentMetaDesc %>">

    <%# -- Open Graph Meta Tags (Facebook, WhatsApp, etc.) -- %>
    <meta property="og:title" content="<%= currentMetaTitle %>" />
    <meta property="og:description" content="<%= currentMetaDesc %>" />
    <meta property="og:image" content="<%= currentMetaImage %>" />
    <% if (currentMetaUrl) { %><meta property="og:url" content="<%= currentMetaUrl %>" /><% } %>
    <meta property="og:type" content="<%= currentMetaType %>" />
    <meta property="og:site_name" content="<%= siteName %>" />
    <%# Optional: Add image dimensions if known for better rendering %>
    <%# <meta property="og:image:width" content="1200" /> %>
    <%# <meta property="og:image:height" content="630" /> %>

    <%# -- Twitter Card Meta Tags -- %>
    <meta name="twitter:card" content="summary_large_image"> <%# Use summary_large_image for products %>
    <meta name="twitter:title" content="<%= currentMetaTitle %>">
    <meta name="twitter:description" content="<%= currentMetaDesc %>">
    <meta name="twitter:image" content="<%= currentMetaImage %>">
    <%# Optional: Add Twitter site/creator handle if you have one %>
    <%# <meta name="twitter:site" content="@YourTwitterHandle"> %>
    <%# <meta name="twitter:creator" content="@YourTwitterHandle"> %>
    <%# --- END META TAGS --- %>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <header class="app-header">
        <nav class="navbar">
            <div class="nav-left">
                <a href="/" class="app-logo">
                   <i class="fas fa-shopping-bag"></i>
                   <span class="app-name">miniapp</span>
                </a>
            </div>
            <div class="nav-right">
                <% if (currentUser) { %>
                    <a href="/" class="nav-link <%= currentUrl === '/' ? 'active' : '' %>" title="Home">
                        <i class="fas fa-home"></i> <span>Home</span>
                    </a>
                     <a href="/user/cart" class="nav-link nav-link-cart <%= currentUrl === '/user/cart' ? 'active' : '' %>" title="Cart">
                         <i class="fas fa-shopping-cart"></i>
                         <% if (cartItemCount > 0) { %>
                             <span class="cart-badge"><%= cartItemCount %></span>
                         <% } else { %>
                             <span class="cart-badge" style="display: none;">0</span>
                         <% } %>
                          <span>Cart</span>
                     </a>
                    <a href="/orders/my-orders" class="nav-link <%= currentUrl === '/orders/my-orders' ? 'active' : '' %>" title="My Orders">
                        <i class="fas fa-box"></i> <span>Orders</span>
                    </a>
                    <a href="/user/profile" class="profile-avatar-link <%= currentUrl === '/user/profile' ? 'active' : '' %>" title="My Profile">
                         <span class="profile-avatar-initials"><%= userInitials %></span>
                    </a>
                <% } else { %>
                    <a href="/auth/login" class="btn btn-login-register">
                        <i class="fas fa-sign-in-alt"></i> Login / Register
                    </a>
                <% } %>
            </div>
        </nav>
    </header>

     <%- include('messages') %>

    <main class="container">
views/partials/messages.ejs:
<% if (success_msg && success_msg.length > 0) { %>
  <div class="alert alert-success" role="alert">
    <%= success_msg %>
    <button type="button" class="close-alert" onclick="this.parentElement.style.display='none';">&times;</button>
  </div>
<% } %>

<% if (error_msg && error_msg.length > 0) { %>
  <div class="alert alert-danger" role="alert">
    <%= error_msg %>
     <button type="button" class="close-alert" onclick="this.parentElement.style.display='none';">&times;</button>
  </div>
<% } %>

<% if (error && typeof error !== 'undefined' && error.length > 0) { %>
  <div class="alert alert-danger" role="alert">
    <%= error %>
     <button type="button" class="close-alert" onclick="this.parentElement.style.display='none';">&times;</button>
  </div>
<% } %>


views/products/detail.ejs:
<%# views/products/detail.ejs %>

<%# --- UPDATED: Prepare meta description (exclude category/specs) --- %>
<% let metaDesc = `Check out ${product.name} on miniapp. Available now for ₹${product.price.toFixed(2)}.`; %>
<%# Ensure total length is reasonable (e.g., ~160 chars) %>
<% if (metaDesc.length > 160) {
     metaDesc = metaDesc.substring(0, 157) + '...';
   }
%>
<%# --- END UPDATED --- %>

<%- include('../partials/header', {
    title: product.name,
    metaTitle: product.name + ' - miniapp', /* Add site name to title */
    metaDescription: metaDesc,           /* Use the new, simpler description */
    metaImageUrl: product.imageUrl,      /* ASSUMES absolute URL */
    metaUrl: fullUrl,                    /* Already available via res.locals */
    metaType: 'product'                  /* Use 'product' type for product pages */
}) %>

<div class="product-detail-container">
   <div class="product-detail-main">
        <div class="product-detail-image">
           <img src="<%= product.imageUrl %>" alt="<%= product.name %>">
        </div>
       <div class="product-detail-info">
            <h1><%= product.name %></h1>
            <p class="detail-price">₹<%= product.price.toFixed(2) %></p>
            <p class="detail-stock">Available Stock: <%= product.stock %></p>

           <% if (product.numReviews > 0) { %>
                <p class="detail-rating">
                    Rating:
                   <% for(let i=1; i<=5; i++) { %>
                       <i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i>
                   <% } %>
                    (<%= product.numReviews %> reviews) | <%= product.orderCount %> Ordered
                </p>
            <% } else { %>
                <p class="detail-rating">No reviews yet | <%= product.orderCount %> Ordered</p>
            <% } %>

            <p>Seller: <%= product.sellerEmail %></p>

           <div class="product-actions">
                <form action="/user/cart/add" method="POST" style="display: inline-block; margin-right: 10px;" class="form-submit-spinner">
                   <input type="hidden" name="productId" value="<%= product._id %>">
                    <div class="quantity-selector">
                       <label for="quantity">Qty:</label>
                        <input type="number" id="quantity" name="quantity" value="1" min="1" max="<%= product.stock %>" required>
                    </div>
                    <button type="submit" class="btn btn-primary" <%= product.stock <= 0 ? 'disabled' : '' %>>
                        <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                    </button>
               </form>

                 <% if (product.stock > 0) { %>
                 <form action="/user/cart/add?redirectTo=checkout" method="POST" style="display: inline-block;" class="form-submit-spinner">
                       <input type="hidden" name="productId" value="<%= product._id %>">
                       <input type="hidden" name="quantity" value="1">
                      <button type="submit" class="btn btn-success">Buy Now</button>
                    </form>
                 <% } else {%>
                   <button class="btn btn-success" disabled>Buy Now</button>
                 <% } %>
           </div>

           <!-- Share Functionality -->
           <div class="share-section">
               <button id="share-product-btn" class="btn btn-secondary btn-sm"
                       data-title="<%= product.name %>"
                       data-text="Check out this product: <%= product.name %>"
                       data-url="<%= fullUrl %>">
                   <i class="fas fa-share-alt"></i> Share
               </button>
               <div id="fallback-share-links" class="fallback-share-links hidden">
                   <span>Share via:</span>
                   <a href="https://www.facebook.com/sharer/sharer.php?u=<%= encodeURIComponent(fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Facebook"><i class="fab fa-facebook-square"></i></a>
                   <a href="https://twitter.com/intent/tweet?url=<%= encodeURIComponent(fullUrl) %>&text=<%= encodeURIComponent('Check out this product: ' + product.name) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Twitter"><i class="fab fa-twitter-square"></i></a>
                   <a href="https://api.whatsapp.com/send?text=<%= encodeURIComponent('Check out this product: ' + product.name + ' ' + fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on WhatsApp"><i class="fab fa-whatsapp-square"></i></a>
                   <a href="mailto:?subject=<%= encodeURIComponent('Check out this product: ' + product.name) %>&body=<%= encodeURIComponent('I thought you might like this product:\n\n' + product.name + '\n' + fullUrl) %>" aria-label="Share via Email"><i class="fas fa-envelope-square"></i></a>
               </div>
           </div>
           <!-- End Share Functionality -->

           <%# Specifications are still displayed on the page itself %>
           <div class="product-specifications">
                <h3>Specifications</h3>
                <pre><%= product.specifications || 'No specifications provided.' %></pre>
            </div>
       </div>
    </div>

   <div class="product-rating-section">
        <h3>Rate This Product</h3>
        <% if (userCanRate) { %>
            <form action="/products/<%= product._id %>/rate" method="POST" class="form-submit-spinner">
                <div class="rating-stars">
                    <% for (let i = 5; i >= 1; i--) { %>
                       <input type="radio" id="star<%= i %>" name="rating" value="<%= i %>" <%= userRating === i ? 'checked' : '' %> required>
                       <label for="star<%= i %>" title="<%= i %> stars"><i class="fas fa-star"></i></label>
                    <% } %>
                </div>
                <button type="submit" class="btn btn-primary">Submit Rating</button>
            </form>
        <% } else { %>
           <p><a href="/auth/login?returnTo=<%= encodeURIComponent(currentUrl) %>">Login</a> to rate this product.</p>
        <% } %>
   </div>

    <div class="rating-stats-container">
        <h3>Ratings & Reviews</h3>
         <% if (totalRatings > 0) { %>
             <div class="rating-summary">
                 <div class="rating-average">
                     <span class="rating-average-value"><%= product.averageRating.toFixed(1) %></span> <i class="fas fa-star"></i>
                 </div>
                 <div class="rating-total">
                     <%= totalRatings %> Rating<%= totalRatings !== 1 ? 's' : '' %>
                 </div>
             </div>

            <div class="rating-bars">
                <% for (let i = 5; i >= 1; i--) { %>
                    <%
                        const count = ratingCounts[i] || 0;
                        const percentage = totalRatings > 0 ? (count / totalRatings) * 100 : 0;
                    %>
                     <div class="rating-bar-row">
                         <span class="rating-bar-label"><%= i %> <i class="fas fa-star"></i></span>
                         <div class="rating-bar-progress">
                             <div class="rating-bar-fill" data-width="<%= percentage.toFixed(1) %>"></div>
                         </div>
                         <span class="rating-bar-count"><%= count %></span>
                     </div>
                 <% } %>
            </div>
        <% } else { %>
            <p>No ratings yet for this product.</p>
         <% } %>
    </div>

</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.rating-bar-fill').forEach(function(el) {
        var width = el.getAttribute('data-width');
        if (width) {
            el.style.width = width + '%';
        }
    });
});
</script>

<%- include('../partials/footer') %>
views/products/index.ejs:
<%# views/products/index.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="product-index-container">
    <h1><%= title %></h1>

    <div class="search-bar-container">
        <form action="/products" method="GET" class="search-form">
            <input type="text" name="search" placeholder="Search products by name, category..." value="<%= searchTerm %>" aria-label="Search Products">
            <button type="submit" class="btn" aria-label="Submit Search"><i class="fas fa-search"></i></button>
             <% if (searchTerm) { %>
                 <a href="/" class="btn btn-clear-search">Clear</a>
             <% } %>
        </form>
    </div>

    <% if (products.length > 0) { %>
        <div class="product-grid">
            <% products.forEach(product => { %>
                <div class="product-card">
                    <a href="/products/<%= product._id %>" class="product-link">
                        <img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="product-image">
                        <div class="product-info">
                            <h3 class="product-name"><%= product.name %></h3>
                            <%# --- CURRENCY UPDATE --- %>
                            <%# Safely handle potentially missing price before formatting %>
                            <p class="product-price">₹<%= (typeof product.price === 'number' ? product.price : 0).toFixed(2) %></p>
                            <%# --- END CURRENCY UPDATE --- %>
                            <p class="product-stock">Stock: <%= product.stock %></p>
                            <% if (product.numReviews > 0) { %>
                                 <p class="product-rating">
                                    <% for(let i=1; i<=5; i++) { %>
                                        <i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i>
                                    <% } %>
                                    (<%= product.numReviews %>)
                                 </p>
                            <% } else { %>
                                <p class="product-rating"> </p> <%# Keep space for alignment %>
                            <% } %>
                        </div>
                    </a>
                     <%# --- Spinner Class Added --- %>
                     <form action="/user/cart/add" method="POST" class="add-to-cart-form form-submit-spinner">
                         <input type="hidden" name="productId" value="<%= product._id %>">
                         <input type="hidden" name="quantity" value="1">
                        <button type="submit" class="btn btn-primary btn-add-to-cart" <%= product.stock <= 0 ? 'disabled' : '' %>>
                            <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                         </button>
                    </form>
                </div>
            <% }) %>
        </div>
    <% } else { %>
        <p>No products found matching your criteria.</p>
    <% } %>

</div>

<%- include('../partials/footer') %>
views/user/cart.ejs:
<%# views/user/cart.ejs %>
<%- include('../partials/header', { title: 'Shopping Cart' }) %>

<div class="cart-container">
    <h1>Your Shopping Cart</h1>

    <% if (cart.length > 0) { %>
        <div class="cart-items">
            <% cart.forEach(item => { %>
                <div class="cart-item" data-product-id="<%= item.productId %>">
                    <div class="cart-item-image">
                        <a href="/products/<%= item.productId %>"><img src="<%= item.imageUrl %>" alt="<%= item.name %>"></a>
                    </div>
                    <div class="cart-item-details">
                        <h3 class="cart-item-name"><%= item.name %></h3>
                        <%# --- CURRENCY UPDATE --- %>
                        <%# Safely handle potentially missing item price %>
                        <p class="cart-item-price">₹<%= (typeof item.price === 'number' ? item.price : 0).toFixed(2) %></p>
                        <%# --- END CURRENCY UPDATE --- %>
                         <p class="cart-item-stock">Stock: <%= item.stock %></p>
                    </div>
                    <div class="cart-item-quantity">
                        <label for="quantity-<%= item.productId %>">Qty:</label>
                        <input type="number"
                               id="quantity-<%= item.productId %>"
                               class="quantity-input"
                               name="quantity"
                               value="<%= item.quantity %>"
                               min="0" <%# Allow 0 for removal via update %>
                               max="<%= item.stock %>"
                               data-product-id="<%= item.productId %>"
                               data-item-price="<%= item.price %>"
                               aria-label="Quantity for <%= item.name %>">
                        <button class="btn btn-secondary btn-sm btn-update-qty" data-product-id="<%= item.productId %>">Update</button> <%# Spinner handled by AJAX logic %>
                     </div>
                     <div class="cart-item-subtotal">
                         <%# --- CURRENCY UPDATE --- %>
                         <%# Safely handle potentially missing item subtotal %>
                         Subtotal: ₹<span class="item-subtotal-value"><%= (typeof item.subtotal === 'number' ? item.subtotal : 0).toFixed(2) %></span>
                         <%# --- END CURRENCY UPDATE --- %>
                    </div>
                    <div class="cart-item-remove">
                        <%# --- Spinner Class Added --- %>
                        <form action="/user/cart/remove/<%= item.productId %>" method="POST" class="form-submit-spinner">
                            <button type="submit" class="btn btn-danger btn-sm">× Remove</button>
                         </form>
                     </div>
                </div>
            <% }) %>
        </div>

         <div class="cart-summary">
             <%# --- CURRENCY UPDATE --- %>
             <%# Safely handle potentially missing cart total %>
             <h2>Cart Total: ₹<span id="cart-total-value"><%= (typeof cartTotal === 'number' ? cartTotal : 0).toFixed(2) %></span></h2>
             <%# --- END CURRENCY UPDATE --- %>
             <a href="/user/checkout" class="btn btn-success btn-checkout">Proceed to Checkout</a>
        </div>

    <% } else { %>
        <p>Your cart is empty. <a href="/">Continue Shopping</a></p>
    <% } %>
</div>

 <%- include('../partials/footer') %>
views/user/checkout.ejs:
<%# views/user/checkout.ejs %>
<%- include('../partials/header', { title: 'Checkout' }) %>

<div class="checkout-container">
    <h1>Checkout</h1>

    <div class="checkout-grid">
        <div class="checkout-address">
            <h2>Shipping Address</h2>
            <% if (userAddress && userAddress.name) { %>
                <div class="saved-address">
                    <p><strong><%= userAddress.name %></strong></p>
                    <p><%= userAddress.phone %></p>
                    <p><%= userAddress.landmarkNearby ? userAddress.landmarkNearby + ', ' : '' %><%= userAddress.cityVillage %></p>
                    <p>Pincode: <%= userAddress.pincode %></p>
                    <button type="button" id="edit-address-btn" class="btn btn-secondary btn-sm">Edit Address</button>
                </div>
             <% } %>

            <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (userAddress && userAddress.name) ? 'hidden' : '' %> form-submit-spinner">
                <h3><%= (userAddress && userAddress.name) ? 'Edit Address' : 'Add Address' %></h3>
                <div class="form-group">
                    <label for="name">Full Name:</label>
                    <input type="text" id="name" name="name" value="<%= userAddress?.name || '' %>" required autocomplete="name">
                </div>
                <div class="form-group">
                    <label for="phone">Phone Number:</label>
                    <input type="tel" <%# Correct semantic type %>
                           id="phone"
                           name="phone"
                           value="<%= userAddress?.phone || '' %>"
                           required
                           pattern="\d{10,15}" <%# Expect 10-15 digits %>
                           minlength="10"  <%# Minimum 10 digits %>
                           maxlength="15" <%# Maximum 15 digits %>
                           title="Enter 10 to 15 digit phone number (numbers only)" <%# Clear hint %>
                           autocomplete="tel"> <%# Standard autocomplete %>
                </div>
                 <div class="form-group">
                    <label for="pincode">Pincode:</label>
                     <input type="text" <%# Use text type, pattern handles format %>
                            id="pincode"
                            name="pincode"
                            value="<%= userAddress?.pincode || '' %>"
                            required
                            pattern="\d{6}" <%# Assuming 6 digit Indian pincode %>
                            maxlength="6"
                            inputmode="numeric"
                            title="Enter 6-digit Pincode"
                            autocomplete="postal-code">
                </div>
                 <div class="form-group">
                    <label for="cityVillage">City / Village:</label>
                     <input type="text" id="cityVillage" name="cityVillage" value="<%= userAddress?.cityVillage || '' %>" required autocomplete="address-level2">
                </div>
                <div class="form-group">
                    <label for="landmarkNearby">Landmark / Nearby (Optional):</label>
                     <input type="text" id="landmarkNearby" name="landmarkNearby" value="<%= userAddress?.landmarkNearby || '' %>">
                </div>
                <button type="submit" class="btn btn-primary">Save Address</button>
                <% if (userAddress && userAddress.name) { %>
                    <button type="button" id="cancel-edit-btn" class="btn btn-secondary">Cancel Edit</button>
                <% } %>
             </form>
        </div>

         <div class="checkout-summary">
             <h2>Order Summary</h2>
             <div class="checkout-items">
                 <% items.forEach(item => { %>
                    <div class="checkout-item">
                         <a href="/products/<%= item.productId %>" class="checkout-item-image">
                            <img src="<%= item.imageUrl %>" alt="<%= item.name %>">
                        </a>
                        <div class="checkout-item-info">
                             <%= item.name %> (Qty: <%= item.quantity %>)
                        </div>
                        <div class="checkout-item-price">₹<%= item.itemTotal.toFixed(2) %></div>
                     </div>
                <% }) %>
            </div>
            <hr>
            <div class="checkout-totals">
                <p>Subtotal: <span>₹<%= subTotal.toFixed(2) %></span></p>
                 <p>Shipping: <span>FREE</span></p>
                <hr>
                 <p><strong>Total: <span>₹<%= totalAmount.toFixed(2) %></span></strong></p>
            </div>

            <div class="checkout-payment">
                <h3>Payment Method</h3>
                 <div class="payment-option selected">
                     <input type="radio" id="cod" name="paymentMethodValue" value="COD" checked disabled>
                     <label for="cod"><i class="fas fa-money-bill-wave"></i> Cash on Delivery (COD)</label>
                 </div>
            </div>

            <form action="/orders/place" method="POST" class="place-order-form form-submit-spinner">
                 <input type="hidden" name="paymentMethod" value="COD">
                 <button type="submit" class="btn btn-success btn-block btn-place-order" <%= (!userAddress || !userAddress.name) ? 'disabled' : '' %>>
                    Place Order
                 </button>
                 <% if (!userAddress || !userAddress.name) { %>
                    <p class="text-danger small">Please add/save your shipping address first.</p>
                 <% } %>
             </form>
         </div>
    </div>
</div>

<%- include('../partials/footer') %>

<%# Checkout specific JS logic was moved to public/js/main.js %>
views/user/my-orders.ejs:
<%# views/user/my-orders.ejs %>
<%- include('../partials/header', { title: 'My Orders' }) %>

<div class="my-orders-container">
    <h1>My Orders</h1>

    <% if (orders.length > 0) { %>
        <div class="order-list">
            <% orders.forEach(order => { %>
                <div class="order-card status-<%= order.status.toLowerCase().replace(/ /g, '-') %>">
                     <div class="order-header">
                         <div><strong>Order ID:</strong> <%= order._id %></div>
                         <%# --- USE HELPER --- %>
                        <div><strong>Placed on:</strong> <%= formatDateIST(order.orderDate) %></div>
                         <div><strong>Total:</strong> ₹<%= order.totalAmount.toFixed(2) %></div>
                         <div><strong>Status:</strong> <span class="order-status"><%= order.status %></span></div>
                     </div>
                    <div class="order-body">
                         <div class="order-items-preview">
                             <% order.products.slice(0, 3).forEach(item => { %>
                                <% if (item.productId && item.imageUrl) { %>
                                    <a href="/products/<%= item.productId %>" title="<%= item.name %> (Qty: <%= item.quantity %>)">
                                        <img src="<%= item.imageUrl %>" alt="<%= item.name %>">
                                    </a>
                                <% } %>
                             <% }) %>
                             <% if(order.products.length > 3) { %><span class="more-items">+ <%= order.products.length - 3 %> more</span><% } %>
                        </div>
                        <div class="order-details">
                             <p><strong>Shipping To:</strong> <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, Pin: <%= order.shippingAddress.pincode %></p>
                             <%# --- USE HELPER --- %>
                             <p><strong>Delivered On:</strong> <%= formatDateIST(order.receivedByDate) %></p>
                              <% if (order.status === 'Cancelled' && order.cancellationReason) { %>
                                <p class="text-danger"><small><strong>Reason:</strong> <%= order.cancellationReason %></small></p>
                              <% } %>
                         </div>
                    </div>
                     <div class="order-actions">
                        <% if (order.isCancellable) { %>
                            <form action="/orders/cancel/<%= order._id %>" method="POST" onsubmit="return confirm('Are you sure you want to cancel this order?');" class="form-submit-spinner">
                                <button type="submit" class="btn btn-danger btn-sm">Cancel Order</button>
                             </form>
                         <% } else if (order.status === 'Pending') { %>
                             <small class="text-muted">Cancellation window closed or processing.</small>
                         <% } else if (order.status === 'Delivered') { %>
                              <small class="text-success">Order delivered.</small>
                         <% } else if (order.status === 'Cancelled') { %>
                              <small class="text-danger">Order was cancelled.</small>
                         <% } %>
                     </div>
                </div>
            <% }) %>
        </div>
    <% } else { %>
        <p>You haven't placed any orders yet. <a href="/">Start Shopping!</a></p>
    <% } %>
</div>

<%- include('../partials/footer') %>
views/user/profile.ejs:
<%# views/user/profile.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="profile-container">
    <h1>My Profile</h1>
    <p class="text-muted mb-3">Welcome, <%= user.name %> (<%= user.email %>)</p>

    <%# --- Conditional Dashboards --- %>
    <div class="profile-section dashboards-section">
        <h2>Dashboards</h2>
        <% if (user.role === 'admin') { %>
            <p><a href="/admin/dashboard" class="btn btn-info"><i class="fas fa-user-shield"></i> Go to Admin Dashboard</a></p>
        <% } %>
        <%# --- REMOVED delivery_admin check --- %>
        <% if (user.role === 'user') { %>
            <p>You have standard user access.</p>
        <% } %>
    </div>

    <%# --- Address Management (remains the same) --- %>
    <div class="profile-section address-section">
        <h2>My Address</h2>
        <div id="saved-address-display" class="<%= (!user.address || !user.address.name) ? 'hidden' : '' %>">
            <% if (user.address && user.address.name) { %>
                <p><strong><%= user.address.name %></strong></p>
                <p><%= user.address.phone %></p>
                <p><%= user.address.landmarkNearby ? user.address.landmarkNearby + ', ' : '' %><%= user.address.cityVillage %></p>
                <p>Pincode: <%= user.address.pincode %></p>
                <button type="button" id="edit-address-btn" class="btn btn-secondary btn-sm">Edit Address</button>
            <% } %>
        </div>
        <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (user.address && user.address.name) ? 'hidden' : '' %> form-submit-spinner">
             <h3><%= (user.address && user.address.name) ? 'Edit Address' : 'Add Address' %></h3>
             <input type="hidden" name="source" value="profile">
             <div class="form-group">
                 <label for="name">Full Name:</label>
                 <input type="text" id="name" name="name" value="<%= user.address?.name || '' %>" required autocomplete="name">
             </div>
             <div class="form-group">
                 <label for="phone">Phone Number:</label>
                 <input type="tel" id="phone" name="phone" value="<%= user.address?.phone || '' %>" required pattern="\d{10,15}" minlength="10" maxlength="15" title="Enter 10 to 15 digit phone number (numbers only)" autocomplete="tel">
             </div>
             <div class="form-group">
                 <label for="pincode">Pincode:</label>
                 <input type="text" id="pincode" name="pincode" value="<%= user.address?.pincode || '' %>" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit Pincode" autocomplete="postal-code">
             </div>
             <div class="form-group">
                 <label for="cityVillage">City / Village:</label>
                 <input type="text" id="cityVillage" name="cityVillage" value="<%= user.address?.cityVillage || '' %>" required autocomplete="address-level2">
             </div>
             <div class="form-group">
                 <label for="landmarkNearby">Landmark / Nearby (Optional):</label>
                 <input type="text" id="landmarkNearby" name="landmarkNearby" value="<%= user.address?.landmarkNearby || '' %>">
             </div>
             <button type="submit" class="btn btn-primary">Save Address</button>
             <button type="button" id="cancel-edit-btn" class="btn btn-secondary <%= (!user.address || !user.address.name) ? 'hidden' : '' %>">Cancel</button>
        </form>
    </div>

    <%# --- Logout Section --- %>
    <div class="profile-section logout-section">
        <h2>Account Actions</h2>
        <form action="/auth/logout" method="POST" class="form-submit-spinner">
            <button type="submit" class="btn btn-danger"><i class="fas fa-sign-out-alt"></i> Logout</button>
        </form>
    </div>

</div>

<%- include('../partials/footer') %>
views/error.ejs:
<%- include('./partials/header', { title: 'Error' }) %>

<div class="error-container container">
    <h1>Error <%= typeof statusCode !== 'undefined' ? statusCode : '' %></h1>
    <p class="lead text-danger"><%= message %></p>

    <%# Use NODE_ENV from res.locals now %>
    <% if (NODE_ENV === 'development' && typeof stack !== 'undefined' && stack) { %>
        <details style="white-space: pre-wrap; margin-top: 20px; background: #f1f1f1; padding: 10px; border-radius: 5px; font-size: 0.8em;">
            <summary>Stack Trace (Development Mode)</summary>
            <code><%= stack %></code>
        </details>
    <% } %>

    <p style="margin-top: 20px;"><a href="/" class="btn btn-primary">Go back to Home</a></p>
</div>

<%- include('./partials/footer') %>
.env:
NODE_ENV=development
PORT=3000
MONGO_URI=mongodb+srv://ecommerce:ecommerce@cluster0.jcfuk.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
SESSION_SECRET=e6142a6d230d0445c9b050af41bfd1e53ece6270797e546fbdaa97af20f3b77e
SESSION_MAX_AGE=86400000

MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USER=ayyappanallamothu4@gmail.com
MAIL_PASS=yxor nmot lxmq skyc
MAIL_FROM='"Surya Ecom" ayyappanallamothu4@gmail.com'
server.js:
// server.js
require('dotenv').config();
const express = require('express');
const path = require('path');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const flash = require('connect-flash');
const methodOverride = require('method-override');

const connectDB = require('./config/database');
const mainRouter = require('./routes/index'); // Main router including all sub-routes
const { notFound, errorHandler } = require('./middleware/errorMiddleware');

// Connect to Database
connectDB();

const app = express();

// View Engine Setup
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Middleware Setup
app.use(express.json()); // Parse JSON bodies
app.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies
app.use(express.static(path.join(__dirname, 'public'))); // Serve static files (CSS, JS, images)
app.use(methodOverride('_method')); // Support PUT/DELETE via POST with _method query param

// Session Middleware
app.use(
  session({
    secret: process.env.SESSION_SECRET, // Secret used to sign the session ID cookie
    resave: false, // Don't save session if unmodified
    saveUninitialized: false, // Don't create session until something stored
    store: MongoStore.create({ // Store session data in MongoDB
        mongoUrl: process.env.MONGO_URI,
        collectionName: 'sessions' // Optional: specify collection name
    }),
    cookie: {
        maxAge: parseInt(process.env.SESSION_MAX_AGE || '86400000', 10), // Session duration (default 1 day)
        httpOnly: true // Prevent client-side JS from accessing cookie
        // secure: process.env.NODE_ENV === 'production', // Use secure cookies in production (HTTPS) - Uncomment if using HTTPS
        // sameSite: 'lax' // Mitigate CSRF attacks
    }
  })
);

// Flash Message Middleware
app.use(flash()); // Requires session middleware

// Middleware to set local variables for views (accessible in EJS templates)
app.use((req, res, next) => {
  // Flash messages
  res.locals.success_msg = req.flash('success_msg');
  res.locals.error_msg = req.flash('error_msg');
  res.locals.error = req.flash('error'); // General error flash

  // User information
  res.locals.currentUser = req.session.user || null; // Logged-in user object or null

  // URL information
  res.locals.currentUrl = req.originalUrl; // Current path (e.g., /products/123)
  res.locals.fullUrl = `${req.protocol}://${req.get('host')}${req.originalUrl}`; // Full URL including domain

  // Cart count (calculated safely)
  res.locals.cartItemCount = req.session.user?.cart?.reduce((count, item) => count + (item.quantity || 0), 0) || 0;

  // Calculate User Initials for Avatar
  let userInitials = '??'; // Default fallback
  if (req.session.user && req.session.user.name) { // Check for name first
    try {
      const nameParts = req.session.user.name.trim().split(' ');
      if (nameParts.length > 1 && nameParts[0] && nameParts[1]) {
          // Use first letter of first and last name parts
          userInitials = (nameParts[0][0] + nameParts[nameParts.length - 1][0]).toUpperCase();
      } else if (nameParts.length === 1 && nameParts[0].length >= 2) {
          // Use first two letters of single name
          userInitials = nameParts[0].substring(0, 2).toUpperCase();
      } else if (nameParts.length === 1 && nameParts[0].length === 1) {
           // Use single letter twice if only one letter name
           userInitials = (nameParts[0][0] + nameParts[0][0]).toUpperCase();
      }
       // Fallback to email if name processing failed or name is empty
       else if (req.session.user.email) {
            const emailPrefix = req.session.user.email.split('@')[0];
            if (emailPrefix.length >= 2) {
                userInitials = emailPrefix.substring(0, 2).toUpperCase();
            } else if (emailPrefix.length === 1) {
                userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
            }
       }
    } catch (e) {
      console.error("Error generating initials:", e);
      // Fallback to email if error during name processing
       if (req.session.user.email) {
            const emailPrefix = req.session.user.email.split('@')[0];
            if (emailPrefix.length >= 2) {
                userInitials = emailPrefix.substring(0, 2).toUpperCase();
            } else if (emailPrefix.length === 1) {
                userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
            }
       }
    }
  } else if (req.session.user && req.session.user.email) { // If no name, use email
        const emailPrefix = req.session.user.email.split('@')[0];
        if (emailPrefix.length >= 2) {
            userInitials = emailPrefix.substring(0, 2).toUpperCase();
        } else if (emailPrefix.length === 1) {
            userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase();
        }
  }
  res.locals.userInitials = userInitials;

  // Date Formatting Helper for IST timezone
  res.locals.formatDateIST = (dateInput) => {
      if (!dateInput) return 'N/A'; // Handle null or undefined dates
      try {
          const date = new Date(dateInput);
          // Check if the date object is valid
          if (isNaN(date.getTime())) {
              console.warn(`formatDateIST received invalid dateInput: ${dateInput}`);
              return 'Invalid Date';
          }

          const options = {
              timeZone: 'Asia/Kolkata', // Target timezone IST
              year: 'numeric',
              month: 'short', // e.g., 'Jan', 'Feb'
              day: 'numeric',
              hour: 'numeric', // e.g., '1', '2'... '12'
              minute: '2-digit', // e.g., '05', '15'
              // second: '2-digit', // Optional: include seconds if needed
              hour12: true // Use AM/PM
          };
          // Use 'en-IN' locale for formatting conventions common in India (can use 'en-US' too)
          return date.toLocaleString('en-IN', options);
      } catch (error) {
          console.error("Error formatting date to IST:", error, "Input:", dateInput);
          return 'Date Error'; // Fallback error message
      }
  };

  // Default Site Name for Meta Tags
  res.locals.defaultSiteName = 'miniapp'; // Change this to your actual application name

  // Pass NODE_ENV to views for conditional rendering (e.g., error stack)
  res.locals.NODE_ENV = process.env.NODE_ENV;

  next(); // Proceed to the next middleware or route handler
});

// Main Application Routes
app.use('/', mainRouter); // Mount the main router at the root path

// Error Handling Middleware (Should be LAST after routes)
app.use(notFound); // Handle 404 Not Found errors
app.use(errorHandler); // Handle all other errors

// Start Server
const PORT = process.env.PORT || 3000; // Use port from .env or default to 3000

app.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});