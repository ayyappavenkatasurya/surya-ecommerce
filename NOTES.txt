config/database.js:
// config/categories.js

// ** IMPORTANT: Replace these placeholder URLs with your actual external image URLs **
const categories = [
    { name: "Electronics", iconUrl: "https://cdn.iconscout.com/icon/premium/png-512-thumb/electronics-industry-4494765-3725864.png?f=webp&w=512" },
    { name: "Food", iconUrl: "https://cdn-icons-png.flaticon.com/128/737/737967.png" },
    { name: "Home & Kitchen", iconUrl: "https://cdn.iconscout.com/icon/free/png-512/free-kitchen-icon-download-in-svg-png-gif-file-formats--appliances-stove-digital-electric-cooking-online-store-pack-miscellaneous-icons-288069.png?f=webp&w=512" },
    { name: "Books", iconUrl: "https://cdn.iconscout.com/icon/premium/png-512-thumb/books-3166435-2641511.png?f=webp&w=512" },
    { name: "Sports & Outdoors", iconUrl: "https://cdn.iconscout.com/icon/premium/png-512-thumb/sports-3552379-2971891.png?f=webp&w=512" },
    { name: "Toys & Games", iconUrl: "https://cdn.iconscout.com/icon/premium/png-512-thumb/games-3407099-2833026.png?f=webp&w=512" },
    { name: "Grocery", iconUrl: "https://cdn.iconscout.com/icon/premium/png-512-thumb/grocery-9471761-7699268.png?f=webp&w=512" },
    { name: "Health & Beauty", iconUrl: "https://cdn.iconscout.com/icon/free/png-512/free-beauty-icon-download-in-svg-png-gif-file-formats--care-cosmetics-makeup-and-pack-icons-804.png?f=webp&w=512" },
    // Add or modify categories as needed
  ];
  
  // Also export just the names for validation purposes
  const categoryNames = categories.map(cat => cat.name);
  
  module.exports = categories;
  module.exports.categoryNames = categoryNames; // Export names separately

config/database.js:
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error connecting to MongoDB: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;


config/gemini.js:
// config/gemini.js
const { GoogleGenerativeAI } = require("@google/generative-ai");

// Access your API key as an environment variable
if (!process.env.GEMINI_API_KEY) {
    console.warn("GEMINI_API_KEY is not set in .env file. Gemini features will be disabled.");
}

const genAI = process.env.GEMINI_API_KEY ? new GoogleGenerativeAI(process.env.GEMINI_API_KEY) : null;

const textModel = genAI ? genAI.getGenerativeModel({ model: "gemini-2.0-flash"}) : null; // Use appropriate model

if (genAI && textModel) {
    console.log("Gemini AI SDK Initialized successfully.");
} else {
     console.log("Gemini AI SDK could not be initialized (API Key missing?).");
}

module.exports = { textModel }; // Export the model instance

config/mailer.js:
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
  host: process.env.MAIL_HOST,
  port: parseInt(process.env.MAIL_PORT, 10),
  secure: parseInt(process.env.MAIL_PORT, 10) === 465,
  auth: {
    user: process.env.MAIL_USER,
    pass: process.env.MAIL_PASS,
  },
});

transporter.verify((error, success) => {
  if (error) {
    console.error('Error with Nodemailer transporter configuration:', error);
  } else {
    console.log('Nodemailer transporter is ready to send emails');
  }
});

const sendEmail = async (to, subject, text, html) => {
  try {
    await transporter.sendMail({
      from: process.env.MAIL_FROM,
      to: to,
      subject: subject,
      text: text,
      html: html,
    });
    console.log(`Email sent successfully to ${to}`);
    return true;
  } catch (error) {
    console.error(`Error sending email to ${to}:`, error);
    return false;
  }
};

module.exports = { sendEmail };


controllers/adminController.js:
// controllers/adminController.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const BannerConfig = require('../models/BannerConfig');
const { sendEmail } = require('../config/mailer');
const { reviewProductWithGemini } = require('../services/geminiService');
const {
    generateAndSendDirectDeliveryOTPByAdmin,
    confirmDirectDeliveryByAdmin,
} = require('./orderController');
const mongoose = require('mongoose');
// *** Import categories and names ***
const categories = require('../config/categories');
const { categoryNames } = require('../config/categories');

const cancellationReasons = [
    "📞 Unable to contact the customer",
    "❗ Out of stock/unavailable item",
    "🗺️ Address incorrect/incomplete",
    "🚫 Customer requested cancellation",
    "❓ Other (Admin)",
];

// --- Admin Dashboard ---
exports.getAdminDashboard = (req, res) => {
    res.render('admin/dashboard', { title: 'Admin Dashboard' });
};

// --- Admin Product Upload Page ---
exports.getUploadProductPage = (req, res) => {
    // *** Pass categories to the view ***
    res.render('admin/upload-product', {
        title: 'Admin: Upload New Product',
        product: {},
        categories: categories // Pass the full list
    });
};

// --- Admin Product Upload Action ---
exports.uploadProduct = async (req, res, next) => {
    // --- UPDATED: Destructure imageUrl2 ---
    const { name, category, price, stock, imageUrl, imageUrl2, specifications, shortDescription } = req.body;
    // --- END UPDATED ---
    const adminUserId = req.session.user._id;
    const adminUserEmail = req.session.user.email;

    // Basic Validation
    if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields (Name, Category, Price, Stock, Primary Image URL).');
        // *** Pass categories back on error ***
        return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
    }
    if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
        req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
        // *** Pass categories back on error ***
        return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
    }
    // *** Add Category Validation ***
    if (!categoryNames.includes(category)) {
        req.flash('error_msg', 'Invalid category selected.');
        return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
    }
    // Optional: Add validation for imageUrl2 if needed (e.g., check URL format if provided)

    try {
        const newProduct = new Product({
            name: name.trim(),
            category: category.trim(), // Category is now validated
            shortDescription: shortDescription ? shortDescription.trim() : undefined,
            price: Number(price),
            stock: Number(stock),
            imageUrl: imageUrl.trim(),
            // --- UPDATED: Assign imageUrl2 ---
            imageUrl2: imageUrl2 ? imageUrl2.trim() : undefined,
            // --- END UPDATED ---
            specifications: specifications ? specifications.trim() : '',
            sellerId: adminUserId,
            sellerEmail: adminUserEmail,
            reviewStatus: 'pending'
        });

        await newProduct.save(); // This will trigger enum validation
        console.log(`Product ${newProduct._id} saved initially by ADMIN ${adminUserEmail}.`);

        // Send for Gemini Review (Asynchronous - keep existing)
        reviewProductWithGemini(newProduct).then(async reviewResult => {
            try {
                const productToUpdate = await Product.findById(newProduct._id);
                if (productToUpdate) {
                    productToUpdate.reviewStatus = reviewResult.status;
                    productToUpdate.rejectionReason = reviewResult.reason;
                    await productToUpdate.save();
                    console.log(`Product ${newProduct._id} (Admin Upload) review status updated to ${reviewResult.status}.`);
                }
            } catch (updateError) {
                console.error(`Error updating product ${newProduct._id} (Admin Upload) after Gemini review:`, updateError);
            }
        }).catch(reviewError => {
            console.error(`Error in Gemini review promise chain for product ${newProduct._id} (Admin Upload):`, reviewError);
            Product.findByIdAndUpdate(newProduct._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed.' }).catch(err => console.error("Failed to mark admin-uploaded product as pending after review error:", err));
        });

        req.flash('success_msg', `Product "${newProduct.name}" uploaded and submitted for review.`);
        res.redirect('/admin/manage-products');

    } catch (error) {
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
           // *** Pass categories back on error ***
           return res.render('admin/upload-product', { title: 'Admin: Upload New Product', product: req.body, categories: categories });
       }
        console.error("Error uploading product by Admin:", error);
        next(error);
    }
};

// --- Manage Products (Admin sees ALL) ---
exports.getManageProductsPage = async (req, res, next) => {
    try {
        const products = await Product.find({})
                                    .populate('sellerId', 'name email')
                                    .sort({ createdAt: -1 })
                                    .lean();
        res.render('admin/manage-products', {
            title: 'Manage All Products',
            products: products
        });
    } catch (error) {
        next(error);
    }
};

// --- Edit Product (Admin edits ANY) ---
exports.getEditProductPage = async (req, res, next) => {
    try {
        const product = await Product.findById(req.params.id)
                                     .populate('sellerId', 'name email')
                                     .lean();
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.redirect('/admin/manage-products');
        }
        // *** Pass categories to the view ***
        res.render('admin/edit-product', {
            title: `Admin Edit: ${product.name}`,
            product: product,
            isAdminView: true,
            categories: categories // Pass the full list
        });
    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.redirect('/admin/manage-products');
        }
        next(error);
    }
};

// --- Update Product (Admin updates ANY) ---
exports.updateProduct = async (req, res, next) => {
    const productId = req.params.id;
    // --- UPDATED: Destructure imageUrl2 ---
    const { name, category, price, stock, imageUrl, imageUrl2, specifications, shortDescription, reviewStatus, rejectionReason } = req.body;
    // --- END UPDATED ---
    const renderOptions = { title: `Admin Edit Error`, product: { _id: productId, ...req.body }, isAdminView: true, categories: categories }; // For re-rendering on error

    // Validation
    if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields.');
        return res.render('admin/edit-product', renderOptions);
    }
    if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
        req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
         return res.render('admin/edit-product', renderOptions);
    }
    // *** Add Category Validation ***
    if (!categoryNames.includes(category)) {
        req.flash('error_msg', 'Invalid category selected.');
         return res.render('admin/edit-product', renderOptions);
    }
    const allowedStatus = ['pending', 'approved', 'rejected'];
    if (reviewStatus && !allowedStatus.includes(reviewStatus)) {
        req.flash('error_msg', 'Invalid review status selected.');
         return res.render('admin/edit-product', renderOptions);
    }
    if (reviewStatus === 'rejected' && !rejectionReason?.trim()) {
        req.flash('error_msg', 'Rejection reason is required when setting status to Rejected.');
        return res.render('admin/edit-product', renderOptions);
    }
    // Optional: Validate imageUrl2 format if present

    try {
        const product = await Product.findById(productId); // Fetch non-lean for saving
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('/admin/manage-products');
        }

        product.name = name.trim();
        product.category = category.trim(); // Category validated
        product.shortDescription = shortDescription ? shortDescription.trim() : undefined;
        product.price = Number(price);
        product.stock = Number(stock);
        product.imageUrl = imageUrl.trim();
        // --- UPDATED: Update imageUrl2 ---
        product.imageUrl2 = imageUrl2 ? imageUrl2.trim() : undefined;
        // --- END UPDATED ---
        product.specifications = specifications ? specifications.trim() : '';

        if (reviewStatus && allowedStatus.includes(reviewStatus)) {
            product.reviewStatus = reviewStatus;
            product.rejectionReason = (reviewStatus === 'rejected') ? rejectionReason.trim() : undefined;
        }

        await product.save(); // Will trigger enum validation
        req.flash('success_msg', `Product "${product.name}" updated successfully by admin.`);
        res.redirect('/admin/manage-products');

    } catch (error) {
        if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
             try {
                 const originalProduct = await Product.findById(productId).lean();
                 renderOptions.product = { ...originalProduct, ...req.body }; // Merge original with invalid data
             } catch (fetchErr) {
                 console.error("Error refetching product on update validation fail:", fetchErr);
                 // Use req.body as fallback
             }
             return res.render('admin/edit-product', renderOptions);
        }
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.status(400).redirect('/admin/manage-products');
        }
        console.error("Error updating product by Admin:", error);
        next(error);
    }
};


// --- Remove Product (Admin removes ANY - keep existing) ---
exports.removeProduct = async (req, res, next) => {
    const productId = req.params.id;
    try {
        const product = await Product.findByIdAndDelete(productId);
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('/admin/manage-products');
        }
        req.flash('success_msg', `Product "${product.name}" removed successfully by admin.`);
        res.redirect('/admin/manage-products');
    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
            return res.status(400).redirect('/admin/manage-products');
        }
        console.error("Error removing product by Admin:", error);
        next(error);
    }
};


// --- Manage Orders (Admin sees ALL - keep existing) ---
exports.getManageOrdersPage = async (req, res, next) => {
    try {
        const orders = await Order.find({})
                                   .sort({ orderDate: -1 })
                                   .select('-__v -products.__v -shippingAddress._id')
                                   .populate('products.productId', 'name imageUrl _id price sellerId')
                                   .populate('userId', 'name email')
                                   .lean();

        const now = Date.now();

        orders.forEach(order => {
            order.canBeCancelledByAdmin = order.status === 'Pending';
            order.canBeDirectlyDeliveredByAdmin = order.status === 'Pending';
            order.showDeliveryOtp = order.status === 'Pending' && !!order.orderOTP && !!order.orderOTPExpires && new Date(order.orderOTPExpires).getTime() > now;

            if (order.products && order.products.length > 0) {
                order.itemsSummary = order.products.map(p => {
                    const productName = p.productId?.name || p.name || '[Product Missing]';
                    const price = p.priceAtOrder ?? 0;
                    return `${productName} (Qty: ${p.quantity}) @ ₹${price.toFixed(2)}`;
                }).join('<br>');
            } else {
                order.itemsSummary = 'No items found';
            }
        });

        res.render('admin/manage-orders', {
            title: 'Manage All Orders',
            orders: orders,
            cancellationReasons: cancellationReasons
        });
    } catch (error) {
        next(error);
    }
};


// --- Admin Order Actions (keep existing) ---
exports.sendDirectDeliveryOtpByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    try {
        const result = await generateAndSendDirectDeliveryOTPByAdmin(orderId);
        req.flash('success_msg', result.message + ' Ask customer for OTP.');
    } catch (error) {
        req.flash('error_msg', `Admin OTP Send Failed: ${error.message}`);
    }
    res.redirect('/admin/manage-orders');
};

exports.confirmDirectDeliveryByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { otp } = req.body;
    const adminUserId = req.session.user._id;

    if (!otp || !/^\d{6}$/.test(otp.trim())) {
        req.flash('error_msg', 'Please enter the 6-digit OTP.');
        return res.redirect('/admin/manage-orders');
    }

    try {
        const { order } = await confirmDirectDeliveryByAdmin(orderId, adminUserId, otp.trim(), res);
        req.flash('success_msg', `Order ${orderId} confirmed delivered by Admin.`);
    } catch (error) {
        req.flash('error_msg', `Admin Delivery Confirm Failed: ${error.message}`);
    }
    res.redirect('/admin/manage-orders');
};

exports.cancelOrderByAdmin = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const adminUserId = req.session.user._id;

    if (!reason || !cancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid admin reason for cancellation.');
        return res.redirect('/admin/manage-orders');
    }

    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction();
    try {
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'name _id')
                                .populate('userId', 'email')
                                .session(sessionDB);

        if (!order) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/admin/manage-orders');
        }
        if (order.status !== 'Pending') {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', `Order status is '${order.status}'. Only 'Pending' orders can be cancelled.`);
            return res.redirect('/admin/manage-orders');
        }

        // Restore Stock
        const productStockRestorePromises = order.products.map(item => {
            const quantityToRestore = Number(item.quantity);
            if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                console.warn(`Admin Cancel: Invalid item P.ID ${item.productId?._id} or Qty ${item.quantity} in O.ID ${orderId}. Skipping restore.`);
                return Promise.resolve();
            }
            return Product.updateOne(
                { _id: item.productId._id },
                { $inc: { stock: quantityToRestore, orderCount: -1 } },
                { session: sessionDB }
            ).catch(err => {
               console.error(`Admin Cancel: Failed stock/count restore P.ID ${item.productId._id} O.ID ${orderId}: ${err.message}`);
            });
        });
        await Promise.allSettled(productStockRestorePromises);

        order.status = 'Cancelled';
        order.cancellationReason = reason;
        await order.save({ session: sessionDB });

        await sessionDB.commitTransaction();

        // Send Email Notification
        try {
            const customerEmail = order.userEmail || order.userId?.email;
            if(customerEmail) {
                const subjectCust = `Your Order (${order._id}) Has Been Cancelled`;
                const htmlCust = `<p>Your order (${order._id}) has been cancelled by administration.</p><p><strong>Reason:</strong> ${order.cancellationReason}</p><p>Contact support for questions.</p>`;
                await sendEmail(customerEmail, subjectCust, `Order ${order._id} cancelled. Reason: ${order.cancellationReason}`, htmlCust);
            }
        } catch (emailError) {
            console.error(`Failed sending cancellation email for order ${order._id}:`, emailError);
        }

        req.flash('success_msg', `Order ${orderId} cancelled by admin. Reason: ${reason}.`);
        res.redirect('/admin/manage-orders');

    } catch (error) {
        await sessionDB.abortTransaction();
        console.error(`Error cancelling order ${orderId} by admin ${adminUserId}:`, error);
        req.flash('error_msg', 'Failed to cancel order due to an internal error.');
        res.redirect('/admin/manage-orders');
    } finally {
        sessionDB.endSession();
    }
};


// --- Manage Users (Admin - keep existing) ---
exports.getManageUsersPage = async (req, res, next) => {
    try {
        const users = await User.find({ _id: { $ne: req.session.user._id } })
                                  .select('name email role createdAt isVerified address.phone')
                                  .sort({ createdAt: -1 })
                                  .lean();
        res.render('admin/manage-users', {
            title: 'Manage Registered Users',
            users: users
        });
    } catch (error) {
        next(error);
    }
};

exports.updateUserRole = async (req, res, next) => {
    const userId = req.params.id;
    const { role } = req.body;
    const allowedRoles = ['user', 'admin', 'seller'];

    if (!role || !allowedRoles.includes(role)) {
        req.flash('error_msg', 'Invalid role selected.');
        return res.status(400).redirect('/admin/manage-users');
    }
    if (userId === req.session.user._id.toString()) {
         req.flash('error_msg', 'You cannot change your own role.');
         return res.redirect('/admin/manage-users');
    }

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return res.status(404).redirect('/admin/manage-users');
        }
        user.role = role;
        await user.save();
        req.flash('success_msg', `User ${user.email}'s role updated to ${role}.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid user ID format.');
            return res.status(400).redirect('/admin/manage-users');
        }
        console.error(`Error updating role for user ${userId}:`, error);
        req.flash('error_msg', 'Error updating user role.');
        res.redirect('/admin/manage-users');
    }
};

exports.removeUser = async (req, res, next) => {
    const userId = req.params.id;

    if (userId === req.session.user._id.toString()) {
        req.flash('error_msg', 'You cannot remove yourself.');
        return res.redirect('/admin/manage-users');
    }

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            return res.status(404).redirect('/admin/manage-users');
        }

        if (user.role === 'admin') {
            const adminCount = await User.countDocuments({ role: 'admin' });
            if (adminCount <= 1) {
                req.flash('error_msg', 'Cannot remove the last admin account.');
                return res.redirect('/admin/manage-users');
            }
        }

        await User.deleteOne({ _id: userId });
        req.flash('success_msg', `User ${user.email} removed successfully.`);
        res.redirect('/admin/manage-users');

    } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid user ID format.');
            return res.status(400).redirect('/admin/manage-users');
        }
        console.error(`Error removing user ${userId}:`, error);
        req.flash('error_msg', 'Error removing user.');
        res.redirect('/admin/manage-users');
    }
};


// --- Banner Management Controllers ---
exports.getManageBannersPage = async (req, res, next) => {
    try {
        let bannerConfig = await BannerConfig.findOne({ configKey: 'mainBanners' }).lean();
        if (!bannerConfig) {
            bannerConfig = { configKey: 'mainBanners', banners: [] };
        }
        const displayBanners = Array.from({ length: 4 }).map((_, index) => {
             return bannerConfig.banners[index] || { imageUrl: '', linkUrl: '', title: '' };
         });
        res.render('admin/manage-banners', {
            title: 'Manage Homepage Banners',
            bannerConfig: { ...bannerConfig, banners: displayBanners }
        });
    } catch (error) {
        console.error("Error fetching banner configuration:", error);
        next(error);
    }
};

exports.updateBanners = async (req, res, next) => {
    const { imageUrl1, linkUrl1, title1, imageUrl2, linkUrl2, title2, imageUrl3, linkUrl3, title3, imageUrl4, linkUrl4, title4 } = req.body;
    const adminUserId = req.session.user._id;

    const urlPattern = /^https?:\/\/.+/;
    const bannerInputs = [
        { imageUrl: imageUrl1, linkUrl: linkUrl1, title: title1 },
        { imageUrl: imageUrl2, linkUrl: linkUrl2, title: title2 },
        { imageUrl: imageUrl3, linkUrl: linkUrl3, title: title3 },
        { imageUrl: imageUrl4, linkUrl: linkUrl4, title: title4 }
    ];

    const newBanners = [];
    let validationError = false;
    for (let i = 0; i < bannerInputs.length; i++) {
        const input = bannerInputs[i];
        const trimmedImageUrl = input.imageUrl?.trim();
        const trimmedLinkUrl = input.linkUrl?.trim();
        const trimmedTitle = input.title?.trim();

        if (trimmedImageUrl) {
            if (!urlPattern.test(trimmedImageUrl)) {
                req.flash('error_msg', `Banner ${i + 1}: Image URL format is invalid.`);
                validationError = true;
            }
            if (trimmedLinkUrl && !urlPattern.test(trimmedLinkUrl)) {
                 req.flash('error_msg', `Banner ${i + 1}: Link URL format is invalid.`);
                 validationError = true;
             }
             if (!validationError) {
                newBanners.push({
                     imageUrl: trimmedImageUrl,
                     linkUrl: trimmedLinkUrl || undefined,
                     title: trimmedTitle || undefined
                 });
             }
        }
    }

    if (validationError) {
         const displayBannersForError = Array.from({ length: 4 }).map((_, index) => bannerInputs[index]);
         return res.render('admin/manage-banners', {
             title: 'Manage Homepage Banners',
             bannerConfig: { banners: displayBannersForError }
         });
    }

    try {
        await BannerConfig.findOneAndUpdate(
            { configKey: 'mainBanners' },
            { banners: newBanners, lastUpdatedBy: adminUserId },
            { new: true, upsert: true, runValidators: true }
        );
        req.flash('success_msg', 'Homepage banners updated successfully.');
        res.redirect('/admin/manage-banners');
    } catch (error) {
        if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
             req.flash('error_msg', `Validation Error: ${errors.join(', ')}`);
             const displayBannersForError = Array.from({ length: 4 }).map((_, index) => bannerInputs[index]);
             return res.render('admin/manage-banners', {
                  title: 'Manage Homepage Banners',
                 bannerConfig: { banners: displayBannersForError }
             });
         }
        console.error("Error updating banners:", error);
        req.flash('error_msg', 'Failed to update banners due to a server error.');
        res.redirect('/admin/manage-banners');
    }
};

controllers/authController.js:
// controllers/authController.js
const User = require('../models/User');
const Product = require('../models/Product');
const BannerConfig = require('../models/BannerConfig');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { generateOTP, setOTPExpiration } = require('../services/otpService');
const { sendEmail } = require('../config/mailer');
// *** Import categories and names ***
const categories = require('../config/categories');
const { categoryNames } = require('../config/categories');


// --- getLoginPage, getRegisterPage, getVerifyOtpPage, etc. (No changes needed) ---
exports.getLoginPage = (req, res) => {
    if (req.session.user) {
         return res.redirect('/'); // Redirect if already logged in
    }
    res.render('auth/login', { title: 'Login' });
};

exports.getRegisterPage = (req, res) => {
    if (req.session.user) {
        return res.redirect('/'); // Redirect if already logged in
   }
    res.render('auth/register', { title: 'Register' });
};

exports.getVerifyOtpPage = (req, res) => {
    const email = req.query.email;
    if (!email) {
        req.flash('error_msg', 'Email required for OTP verification.');
        return res.redirect('/auth/register');
    }
     if (req.session.user) { // Redirect if already logged in
        return res.redirect('/');
   }
    res.render('auth/verify-otp', { title: 'Verify Email', email });
};

exports.getForgotPasswordPage = (req, res) => {
     if (req.session.user) {
         return res.redirect('/'); // Redirect if already logged in
    }
    res.render('auth/forgot-password', { title: 'Forgot Password' });
};

exports.getResetPasswordPage = async (req, res, next) => {
     if (req.session.user) {
         req.flash('info_msg', 'You are already logged in.');
         return res.redirect('/');
    }
    try {
        const user = await User.findOne({
            resetPasswordToken: req.params.token,
            resetPasswordExpires: { $gt: Date.now() },
        });

        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired.');
            return res.redirect('/auth/forgot-password');
        }
        res.render('auth/reset-password', { title: 'Reset Password', token: req.params.token });
    } catch (error) {
        next(error);
    }
};

// --- registerUser, verifyOtp, resendOtp, loginUser (No changes needed) ---
exports.registerUser = async (req, res, next) => {
     if (req.session.user) {
        return res.redirect('/');
    }
    const { name, email, password, confirmPassword } = req.body;

    let errors = [];
    if (!name || !email || !password || !confirmPassword) { errors.push('Please fill in all fields.'); }
    if (password !== confirmPassword) { errors.push('Passwords do not match.'); }
    if (password && password.length < 6) { errors.push('Password must be at least 6 characters.'); }
    if (email && !/^\S+@\S+\.\S+$/.test(email)) { errors.push('Please enter a valid email address.'); }

    if (errors.length > 0) {
        req.flash('error_msg', errors.join(' '));
        return res.render('auth/register', { title: 'Register', name: name, email: email, error_msg: req.flash('error_msg') });
    }

    try {
        const lowerCaseEmail = email.toLowerCase();
        let user = await User.findOne({ email: lowerCaseEmail });

        if (user && user.isVerified) {
            req.flash('error_msg', 'Email is already registered and verified. Please login.');
            return res.redirect('/auth/login');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10);

        if (user && !user.isVerified) {
            user.name = name;
            if (password) { user.password = password; }
            user.otp = otp;
            user.otpExpires = otpExpires;
            user.isVerified = false;
            await user.save({ validateBeforeSave: false });
            console.log(`Updating existing unverified user: ${user.email}`);
        } else {
            user = new User({ name, email: lowerCaseEmail, password, otp, otpExpires, isVerified: false });
            await user.save();
            console.log(`New user created: ${user.email}`);
        }

        const subject = 'Verify Your Email Address';
        const text = `Your verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
        const html = `<p>Welcome to our store!</p><p>Your verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;
        const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
            req.flash('success_msg', `An OTP has been sent to ${user.email}. Please check your inbox and verify.`);
            res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
        } else {
             if(!user.createdAt || (Date.now() - user.createdAt.getTime()) < 5000) {
                try {
                    await User.deleteOne({ _id: user._id, isVerified: false });
                    console.log(`Cleaned up unverified user ${user.email} due to failed email send.`);
                } catch (deleteError) { console.error(`Error cleaning up unverified user ${user.email}:`, deleteError); }
             }
            req.flash('error_msg', 'Could not send OTP email. Please try registering again or contact support.');
            res.redirect('/auth/register');
        }
    } catch (error) {
        if (error.code === 11000) {
            req.flash('error_msg', 'Email already exists. Please login or use a different email.');
            return res.render('auth/register', { title: 'Register', name: name, email: email });
        }
        if (error.name === 'ValidationError') {
           let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', validationErrors.join(' '));
            return res.render('auth/register', { title: 'Register', name: name, email: email });
       }
        next(error);
    }
};

exports.verifyOtp = async (req, res, next) => {
    const { email, otp } = req.body;
     if (req.session.user) { return res.redirect('/'); }
    if (!email || !otp) {
        req.flash('error_msg', 'Email and OTP are required.');
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email || '')}`);
    }
    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail, otp: otp.trim(), otpExpires: { $gt: Date.now() }, }).select('+password');

        if (!user) {
            const existingUser = await User.findOne({ email: lowerCaseEmail });
            let errorMessage = 'Invalid or expired OTP. Please try again or resend.';
            if (existingUser && existingUser.isVerified) {
                 errorMessage = 'This account is already verified. Please login.';
                 req.flash('error_msg', errorMessage);
                 return res.redirect('/auth/login');
            } else if (!existingUser) {
                 errorMessage = 'Verification failed. Account not found. Please register again.';
                 req.flash('error_msg', errorMessage);
                 return res.redirect('/auth/register');
            }
             req.flash('error_msg', errorMessage);
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email)}`);
        }

         const isPasswordReset = user.resetPasswordToken && user.resetPasswordExpires && user.resetPasswordExpires > Date.now();
         user.isVerified = true;
         user.otp = undefined;
         user.otpExpires = undefined;

         if (isPasswordReset) {
             await user.save({ validateBeforeSave: false });
             req.flash('success_msg', 'OTP Verified. Please set your new password.');
             return res.redirect(`/auth/reset-password/${user.resetPasswordToken}`);
         }
         else {
            await user.save({ validateBeforeSave: false });
             req.session.regenerate(err => {
                if (err) {
                     console.error("Session regeneration error after OTP verify:", err);
                     req.flash('error_msg', 'Verification successful, but auto-login failed. Please login manually.');
                     return res.redirect('/auth/login');
                 }
                req.session.user = { _id: user._id, name: user.name, email: user.email, role: user.role, address: user.address, cart: user.cart || [] };
                req.session.save(err => {
                   if (err) {
                        console.error("Session save error after OTP verify login:", err);
                         req.flash('error_msg', 'Verification successful, but auto-login failed. Please login manually.');
                        return res.redirect('/auth/login');
                    }
                    req.flash('success_msg', 'Email verified successfully! You are now logged in.');
                    const returnTo = req.session.returnTo || '/';
                    delete req.session.returnTo;
                    res.redirect(returnTo);
                 });
             });
         }
    } catch (error) {
        next(error);
    }
};

exports.resendOtp = async (req, res, next) => {
    const { email } = req.body;
     if (req.session.user) { return res.redirect('/'); }
    if (!email) {
        req.flash('error_msg', 'Email is required to resend OTP.');
         return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(req.query.email || '')}`);
    }
    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail });

        if (!user) {
            console.log(`Resend OTP attempt for non-existent email: ${lowerCaseEmail}`);
            req.flash('info_msg', 'If your email is registered, a new OTP will be sent. Please check your inbox.');
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(email)}`);
        }

        const isForReset = user.resetPasswordToken && user.resetPasswordExpires && user.resetPasswordExpires > Date.now();

        if(user.isVerified && !isForReset) {
             req.flash('error_msg', 'This account is already verified. Please login.');
            return res.redirect('/auth/login');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(10);
        user.otp = otp;
        user.otpExpires = otpExpires;
        await user.save({ validateBeforeSave: false });

        let subject, text, html;
        if (isForReset) {
            subject = 'Your New Password Reset OTP';
            text = `Your new password reset OTP is: ${otp}\nIt will expire in 10 minutes.\nIf you did not request this, please ignore this email.`;
            html = `<p>Your new password reset OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;
        } else {
             subject = 'Your New Verification OTP';
             text = `Your new verification OTP is: ${otp}\nIt will expire in 10 minutes.`;
            html = `<p>Your new verification OTP is: <strong>${otp}</strong></p><p>It will expire in 10 minutes.</p>`;
        }

        const emailSent = await sendEmail(user.email, subject, text, html);
        const redirectUrl = `/auth/verify-otp?email=${encodeURIComponent(user.email)}${isForReset ? '&reason=reset' : ''}`;

        if (emailSent) {
            req.flash('success_msg', `A new OTP has been sent to ${user.email}. Please check your inbox.`);
        } else {
            console.error(`Failed to resend OTP email to ${user.email}`);
            req.flash('error_msg', 'Could not resend OTP email. Please try again later or contact support.');
        }
        res.redirect(redirectUrl);
    } catch (error) {
        next(error);
    }
};

exports.loginUser = async (req, res, next) => {
     if (req.session.user) { return res.redirect('/'); }
    const { email, password } = req.body;
    if (!email || !password) {
        req.flash('error_msg', 'Please provide both email and password.');
        return res.render('auth/login', { title: 'Login', email: email });
    }
    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail }).select('+password').populate('cart.productId', 'name price imageUrl');

        if (!user) {
            req.flash('error_msg', 'Invalid credentials. Please check your email and password.');
            return res.render('auth/login', { title: 'Login', email: email });
        }
         if (!user.isVerified) {
            req.flash('error_msg', 'Your email is not verified. Please check your inbox for the verification OTP or request a new one.');
            return res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}`);
         }
        const isMatch = await user.matchPassword(password);
        if (!isMatch) {
            req.flash('error_msg', 'Invalid credentials. Please check your email and password.');
            return res.render('auth/login', { title: 'Login', email: email });
        }

         req.session.regenerate(err => {
            if (err) {
                 console.error("Session regeneration error during login:", err);
                 req.flash('error_msg', 'Login failed due to a session error. Please try again.');
                 return res.render('auth/login', { title: 'Login', email: email });
             }
            req.session.user = {
                _id: user._id, name: user.name, email: user.email, role: user.role,
                address: user.address ? user.address.toObject() : undefined,
                cart: user.cart ? user.cart.map(item => ({ productId: item.productId?._id, quantity: item.quantity })) : []
             };
             req.session.save(err => {
                 if (err) {
                     console.error("Session save error after login:", err);
                     req.flash('error_msg', 'Login successful, but session could not be saved. Please try again.');
                      return res.render('auth/login', { title: 'Login', email: email });
                 }
                 req.flash('success_msg', 'You are now logged in successfully.');
                 const returnTo = req.session.returnTo || '/';
                 delete req.session.returnTo;
                 res.redirect(returnTo);
            });
        });
    } catch (error) {
        next(error);
    }
};

// --- UPDATED logoutUser ---
exports.logoutUser = (req, res, next) => {
    req.flash('success_msg', 'You have been logged out successfully.');
    req.session.destroy(err => {
        if (err) {
            console.error('Session destruction error:', err);
             return res.redirect('/auth/login');
        }
        res.clearCookie(req.app.get('session cookie name') || 'connect.sid');
        res.redirect('/auth/login');
    });
};


// --- forgotPassword, resetPassword (No changes needed) ---
exports.forgotPassword = async (req, res, next) => {
    const { email } = req.body;
    if (!email) {
        req.flash('error_msg', 'Please provide an email address.');
        return res.redirect('/auth/forgot-password');
    }
    try {
        const lowerCaseEmail = email.toLowerCase();
        const user = await User.findOne({ email: lowerCaseEmail });
        const genericMessage = 'If an account with that email exists and is verified, a password reset OTP will be sent. Please check your inbox.';
        req.flash('info_msg', genericMessage);

        if (!user || !user.isVerified) {
            console.log(`Password reset request for ${lowerCaseEmail}: User ${!user ? 'not found' : 'found but not verified'}. Sending generic response.`);
            return res.redirect('/auth/forgot-password');
        }

         const otp = generateOTP();
         const resetToken = crypto.randomBytes(20).toString('hex');
        const otpExpires = setOTPExpiration(10);
        const resetExpires = setOTPExpiration(60);

        user.otp = otp;
        user.otpExpires = otpExpires;
        user.resetPasswordToken = resetToken;
        user.resetPasswordExpires = resetExpires;
        await user.save({ validateBeforeSave: false });

        const subject = 'Password Reset Request - Verify OTP';
        const text = `You requested a password reset.\n\nPlease use the following OTP to verify your request: ${otp}\n\nThis OTP will expire in 10 minutes.\n\nIf you did not request this, please ignore this email.`;
        const html = `<p>You requested a password reset.</p><p>Please use the following OTP to verify your request: <strong>${otp}</strong></p><p>This OTP will expire in 10 minutes.</p><p>If you did not request this, please ignore this email.</p>`;
         const emailSent = await sendEmail(user.email, subject, text, html);

        if (emailSent) {
             console.log(`Password reset OTP sent to verified user: ${user.email}`);
             res.redirect(`/auth/verify-otp?email=${encodeURIComponent(user.email)}&reason=reset`);
        } else {
            console.error(`Failed to send password reset OTP email to ${user.email}`);
            res.redirect('/auth/forgot-password');
        }
    } catch (error) {
        console.error("Error in forgotPassword:", error);
        req.flash('error_msg', 'An error occurred while processing your request. Please try again later.');
        res.redirect('/auth/forgot-password');
    }
};

exports.resetPassword = async (req, res, next) => {
    const { password, confirmPassword } = req.body;
    const token = req.params.token;

    let errors = [];
    if (!password || !confirmPassword) { errors.push('Please enter and confirm your new password.'); }
    if (password !== confirmPassword) { errors.push('Passwords do not match.'); }
     if (password && password.length < 6) { errors.push('Password must be at least 6 characters.'); }
    if (errors.length > 0) {
         req.flash('error_msg', errors.join(' '));
         return res.redirect(`/auth/reset-password/${token}`);
    }

    try {
        const user = await User.findOne({ resetPasswordToken: token, resetPasswordExpires: { $gt: Date.now() }, }).select('+password');
        if (!user) {
            req.flash('error_msg', 'Password reset token is invalid or has expired. Please request a new reset link.');
            return res.redirect('/auth/forgot-password');
        }

        user.password = password;
        user.resetPasswordToken = undefined;
        user.resetPasswordExpires = undefined;
        user.otp = undefined;
        user.otpExpires = undefined;
        user.isVerified = true;
        await user.save();

        req.session.regenerate(err => {
             if (err) {
                console.error("Session regeneration error after password reset:", err);
                req.flash('success_msg', 'Password reset successful. Please log in with your new password.');
                return res.redirect('/auth/login');
             }
              req.session.user = {
                  _id: user._id, name: user.name, email: user.email, role: user.role,
                  address: user.address ? user.address.toObject() : undefined,
                  cart: user.cart ? user.cart.map(item => ({ productId: item.productId, quantity: item.quantity })) : []
              };
            req.session.save(err => {
                if(err) {
                    console.error("Session save error after password reset login:", err);
                     req.flash('success_msg', 'Password reset successful. Please log in with your new password.');
                    return res.redirect('/auth/login');
                 }
                 req.flash('success_msg', 'Password has been reset successfully. You are now logged in.');
                res.redirect('/');
             });
         });
    } catch (error) {
        if (error.name === 'ValidationError') {
           let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', validationErrors.join(' '));
            return res.redirect(`/auth/reset-password/${token}`);
       }
        next(error);
    }
};


// --- Modified getHomePage ---
exports.getHomePage = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || '';
    // *** Get category from query ***
    const categoryFilter = req.query.category || '';

    let query = {
        reviewStatus: 'approved',
        stock: { $gt: 0 }
    };

    if (searchTerm) {
         query.$text = { $search: searchTerm };
    }
    // *** Add category to query if valid ***
    if (categoryFilter && categoryNames.includes(categoryFilter)) {
        query.category = categoryFilter;
    } else if (categoryFilter) {
        console.warn(`Invalid category filter attempted: ${categoryFilter}`);
    }

     const projection = searchTerm ? { score: { $meta: "textScore" } } : {};
     const sort = searchTerm ? { score: { $meta: "textScore" } } : { createdAt: -1 };

    // Fetch Products, Banners concurrently
    const [products, bannerConfig] = await Promise.all([
        Product.find(query, projection).sort(sort).lean(),
        BannerConfig.findOne({ configKey: 'mainBanners' }).lean()
    ]);

    // Extract banner URLs
    const banners = bannerConfig?.banners || [];
    const validBanners = banners.filter(banner => banner.imageUrl);

    // Determine page title based on filters
    let pageTitle = 'Home';
    if (searchTerm) {
        pageTitle = `Search Results for "${searchTerm}"`;
    } else if (categoryFilter && categoryNames.includes(categoryFilter)) {
        pageTitle = `Category: ${categoryFilter}`;
    }

    res.render('products/index', {
      title: pageTitle,
      products: products,
      searchTerm: searchTerm,
      selectedCategory: categoryFilter && categoryNames.includes(categoryFilter) ? categoryFilter : null, // Pass selected category
      homepageBanners: validBanners,
      // *** Pass display categories to the view ***
      displayCategories: categories
    });
  } catch (error) {
    console.error("Error fetching products/banners/categories for home page:", error);
    next(error);
  }
};

controllers/orderController.js:
// controllers/orderController.js
const Order = require('../models/Order');
const User = require('../models/User');
const Product = require('../models/Product');
const { sendEmail } = require('../config/mailer');
const mongoose = require('mongoose');
const { generateOTP, setOTPExpiration } = require('../services/otpService');

// --- UPDATE placeOrder to include sellerId and check approval/stock within transaction ---
exports.placeOrder = async (req, res, next) => {
    const userId = req.session.user._id;
    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction({ readConcern: { level: 'snapshot' }, writeConcern: { w: 'majority' } }); // Use snapshot isolation if possible

    try {
        const user = await User.findById(userId)
                              // Populate necessary cart product fields including status and seller
                              .populate('cart.productId', 'name price imageUrl stock reviewStatus sellerId')
                              .session(sessionDB); // Use session

        if (!user) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'User session not found. Please log in again.');
            return res.redirect('/auth/login');
        }
        if (!user.cart || user.cart.length === 0) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Your cart is empty.');
            return res.redirect('/user/cart');
        }
        // Ensure address exists
        if (!user.address || !user.address.name || !user.address.phone || !user.address.pincode || !user.address.cityVillage) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Please complete your shipping address before placing the order.');
            return res.redirect('/user/checkout');
        }

        let orderProducts = [];
        let totalAmount = 0;
        const productStockUpdates = [];
        let validationFailed = false;
        let validationErrorMessage = 'An issue occurred with your cart. Please review and try again.';
        const itemsToRemoveFromCart = []; // Track items to remove due to issues

        // --- Validate Cart Items Within Transaction ---
        for (const item of user.cart) {
            // Basic checks
            const itemQuantity = Number(item.quantity);
            if (isNaN(itemQuantity) || !Number.isInteger(itemQuantity) || itemQuantity <= 0) {
                validationErrorMessage = `Invalid quantity found for an item. It has been removed.`;
                itemsToRemoveFromCart.push(item._id);
                validationFailed = true; continue; // Continue checking other items
            }
            if (!item.productId || !item.productId._id) {
                 validationErrorMessage = `An invalid product reference was found and removed.`;
                 itemsToRemoveFromCart.push(item._id);
                 validationFailed = true; continue;
            }

            const currentProduct = item.productId; // Already populated

            // *** Check Approval Status ***
             if (currentProduct.reviewStatus !== 'approved') {
                validationErrorMessage = `Product "${currentProduct.name}" is not available and has been removed from your cart.`;
                itemsToRemoveFromCart.push(item._id);
                validationFailed = true; continue;
            }
            // *** Check Stock Availability ***
            if (currentProduct.stock < itemQuantity) {
                // If stock issue, fail the whole order immediately, don't just remove item
                validationErrorMessage = `Insufficient stock for "${currentProduct.name}". Available: ${currentProduct.stock}. Please update your cart quantity.`;
                validationFailed = true;
                break; // Stop processing on critical stock issue
            }

            // If valid, add to order and prepare update
            orderProducts.push({
                productId: currentProduct._id,
                name: currentProduct.name,
                priceAtOrder: currentProduct.price, // Price at the time of order
                quantity: itemQuantity,
                imageUrl: currentProduct.imageUrl,
                sellerId: currentProduct.sellerId // *** Include Seller ID ***
            });
            totalAmount += currentProduct.price * itemQuantity;
            productStockUpdates.push({
                 productId: currentProduct._id,
                 quantityToDecrement: itemQuantity
             });
        } // End cart loop

        // --- Handle Validation Failures ---
        if (validationFailed) {
             // If items needed removal, perform the removal update
             if (itemsToRemoveFromCart.length > 0) {
                 await User.updateOne(
                    { _id: userId },
                    { $pull: { cart: { _id: { $in: itemsToRemoveFromCart } } } }
                 ).session(sessionDB); // Perform removal within session
                 console.log(`Removed ${itemsToRemoveFromCart.length} invalid items from cart for user ${userId}`);
             }
            await sessionDB.abortTransaction(); sessionDB.endSession(); // Abort the transaction

             // Refresh session cart AFTER DB update
             const updatedUser = await User.findById(userId).select('cart').populate('cart.productId').lean();
             req.session.user.cart = updatedUser ? updatedUser.cart.filter(i => i.productId) : [];
             await req.session.save();

             req.flash('error_msg', validationErrorMessage);
             return res.redirect('/user/cart');
         }

        // --- Proceed with DB Updates if Validation Passed ---

        // Decrement Stock and Increment Order Count
        for (const update of productStockUpdates) {
            const updateResult = await Product.updateOne(
                { _id: update.productId, stock: { $gte: update.quantityToDecrement } }, // Check stock again
                { $inc: { stock: -update.quantityToDecrement, orderCount: 1 } },
                { session: sessionDB }
            );
            if (updateResult.modifiedCount === 0) { // Handle concurrent update failure
                 await sessionDB.abortTransaction(); sessionDB.endSession();
                 req.flash('error_msg', `Checkout failed: Stock changed for a product during checkout. Please try again.`);
                 // Don't remove items here, let user review cart again
                 return res.redirect('/user/cart');
             }
        }

        // Create the Order document
        const order = new Order({
            userId: userId,
            userEmail: user.email,
            products: orderProducts, // Includes sellerId
            totalAmount: totalAmount,
            shippingAddress: user.address,
            paymentMethod: 'COD', // Or from request body if multiple methods allowed
            status: 'Pending',
            // cancellationAllowedUntil is set by pre-save hook
        });
        await order.save({ session: sessionDB });

        // Clear User's Cart
        user.cart = [];
        await user.save({ session: sessionDB });

        // --- Commit Transaction ---
        await sessionDB.commitTransaction();

        // Update session cart AFTER successful commit
        req.session.user.cart = [];
        await req.session.save();

        // --- Send Confirmation Email (Outside Transaction) ---
        try {
            const subject = 'Your Order Has Been Placed!';
            let productListHTML = order.products.map(p => `<li>${p.name} (Qty: ${p.quantity}) - ₹${p.priceAtOrder.toFixed(2)}</li>`).join('');
            const formattedOrderDate = res.locals.formatDateIST(order.orderDate);
            const html = `<h2>Thank you for your order!</h2><p>Your Order ID: ${order._id}</p><p>Order Placed: ${formattedOrderDate}</p><p>Total Amount: ₹${order.totalAmount.toFixed(2)}</p><p>Shipping To: ${order.shippingAddress.name}, ${order.shippingAddress.cityVillage}</p><h3>Items:</h3><ul>${productListHTML}</ul><p>You can track your order status in the 'My Orders' section.</p>`;
            await sendEmail(user.email, subject, `Your order ${order._id} has been placed. Total: ₹${totalAmount.toFixed(2)}`, html);
        } catch (emailError) {
            console.error(`Failed sending order confirmation email for order ${order._id}:`, emailError);
            // Don't fail the request if email fails
        }

        req.flash('success_msg', 'Order placed successfully!');
        res.redirect('/orders/my-orders'); // Redirect to user's order history

    } catch (error) {
        // Ensure transaction is aborted on any unexpected error
        if (sessionDB.inTransaction()) {
             await sessionDB.abortTransaction();
        }
        console.error("Order Placement Transaction Error:", error);
        req.flash('error_msg', `Order placement failed due to a server error. Please review your cart and try again.`);
        res.redirect('/user/cart'); // Redirect to cart
    } finally {
        // Always end the session
        if (sessionDB.id) { // Check if session exists before ending
             await sessionDB.endSession();
        }
    }
};

// --- UPDATE cancelOrder (Uses Transaction) ---
exports.cancelOrder = async (req, res, next) => {
    const orderId = req.params.id;
    const userId = req.session.user._id;
    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction({ writeConcern: { w: 'majority' }}); // Ensure durability

    try {
        // Find the order: Must belong to the user, be 'Pending', and within cancellation window
        const order = await Order.findOne({
             _id: orderId,
             userId: userId, // Belongs to logged-in user
             status: 'Pending', // Only pending orders
             cancellationAllowedUntil: { $gt: Date.now() } // Within allowed time
        })
        .populate('products.productId', '_id name') // Need _id for update
        .session(sessionDB); // Use the transaction session

        if (!order) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
             req.flash('error_msg', 'Order not found, already processed/cancelled, or cancellation period expired.');
            return res.redirect('/orders/my-orders');
        }

        console.log(`User Cancellation: Restoring stock/orderCount for order ${orderId}.`);
        // Restore stock and decrement orderCount for each valid product item
        const productUpdatePromises = order.products.map(item => {
            const quantityToRestore = Number(item.quantity);
            if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                 console.warn(`User Cancel: Invalid item P.ID ${item.productId?._id} or Qty ${item.quantity} in O.ID ${orderId}. Skipping stock restore.`);
                return Promise.resolve(); // Skip invalid items gracefully
             }
            // Update the Product: Increment stock, decrement orderCount
             return Product.updateOne(
                 { _id: item.productId._id },
                 { $inc: { stock: quantityToRestore, orderCount: -1 } },
                 { session: sessionDB } // Use transaction session
             ).catch(err => {
                // Log error, but allow cancellation to continue for the order itself
                console.error(`User Cancel: Failed stock/orderCount restore for P.ID ${item.productId._id} on O.ID ${orderId}: ${err.message}`);
             });
        });
        // Wait for all stock updates to attempt (use allSettled)
        const results = await Promise.allSettled(productUpdatePromises);
        results.forEach((result, index) => {
            if (result.status === 'rejected') {
                console.error(`Failed promise during stock restore for item index ${index} in order ${orderId}: ${result.reason}`);
            }
        });
        console.log(`User Cancel: Stock/OrderCount restoration process completed for order ${orderId}.`);


        // Update the Order status
        order.status = 'Cancelled';
        order.cancellationReason = "Cancelled by customer";
        // OTP fields etc., should be cleared by the pre-save hook in Order model
        await order.save({ session: sessionDB });

        // --- Commit Transaction ---
        await sessionDB.commitTransaction();

        // Send email confirmation (outside transaction)
         try{
             const subject = 'Your Order Has Been Cancelled';
             const html = `<p>Your order (${order._id}) has been successfully cancelled as requested.</p>`;
            await sendEmail(order.userEmail, subject, `Order ${order._id} cancelled.`, html);
         } catch (emailError){
             console.error(`Failed sending cancellation confirmation email for order ${order._id}:`, emailError);
         }

        req.flash('success_msg', 'Order cancelled successfully.');
        res.redirect('/orders/my-orders');

    } catch (error) {
         // Abort transaction on error
         if (sessionDB.inTransaction()) {
             await sessionDB.abortTransaction();
         }
         console.error("Order Cancellation Error:", error);
         req.flash('error_msg', 'Failed to cancel the order due to an internal error.');
         res.redirect('/orders/my-orders');
    } finally {
        // Always end the session
        if (sessionDB.id) { await sessionDB.endSession(); }
    }
};

// --- Get My Orders (Includes OTP display logic) ---
exports.getMyOrders = async (req, res, next) => {
    try {
        const orders = await Order.find({ userId: req.session.user._id })
                                   .select('-__v') // Exclude version key for cleaner output
                                   .sort({ orderDate: -1 })
                                   // Populate products for display
                                   .populate('products.productId', 'name imageUrl _id price')
                                   .lean(); // Use lean for read-only access

        const now = Date.now();
        orders.forEach(order => {
            // Determine if customer can cancel
            order.isCancellable = order.status === 'Pending' && order.cancellationAllowedUntil && now < new Date(order.cancellationAllowedUntil).getTime();

            // Determine if Delivery OTP should be shown
            order.showDeliveryOtp = order.status === 'Pending' &&
                                    !!order.orderOTP &&          // OTP must exist
                                    !!order.orderOTPExpires &&   // Expiry must exist
                                    new Date(order.orderOTPExpires).getTime() > now; // Must not be expired

            // Dates will be formatted in EJS using the formatDateIST helper
        });

        res.render('user/my-orders', {
            title: 'My Orders',
            orders: orders // Pass orders to the view
            // formatDateIST helper is available via res.locals
        });
    } catch (error) {
        console.error("Error fetching user orders:", error);
        next(error); // Pass error to central handler
    }
};

// --- Admin OTP Generation Logic (Remains Largely the Same) ---
exports.generateAndSendDirectDeliveryOTPByAdmin = async (orderId) => {
    try {
        const order = await Order.findById(orderId);
        if (!order) throw new Error('Order not found.');
        if (order.status !== 'Pending') throw new Error(`Cannot generate OTP for order status '${order.status}'. Must be 'Pending'.`);

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(5); // 5 minutes validity
        order.orderOTP = otp;
        order.orderOTPExpires = otpExpires;
        await order.save();

        const user = await User.findById(order.userId).select('email'); // Get user email for logging/potential notification
        const userEmail = user ? user.email : '[User Account Missing]';

        console.log(`ADMIN generated Direct Delivery OTP for O.ID ${orderId}. OTP: ${otp}. (User: ${userEmail})`);
        // Optional: Send email/SMS to user.email here if needed

        return { success: true, message: `OTP generated for order ${orderId}. It is visible on the customer's 'My Orders' page.` };
    } catch (error) {
        console.error(`Error in generateAndSendDirectDeliveryOTPByAdmin for O.ID ${orderId}:`, error);
        throw error; // Re-throw for the calling controller
    }
};

// --- Seller OTP Generation Logic (NEW) ---
exports.generateAndSendDirectDeliveryOTPBySeller = async (orderId, sellerId) => {
    try {
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'sellerId'); // Populate sellerId for verification

        if (!order) throw new Error('Order not found.');
        if (order.status !== 'Pending') throw new Error(`Cannot generate OTP for order status '${order.status}'. Must be 'Pending'.`);

        // Security Check: Ensure the order contains at least one product from this seller
        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
            console.warn(`Seller ${sellerId} attempted OTP generation for unrelated order ${orderId}.`);
            throw new Error('Permission Denied: Order does not contain your products.');
        }

        const otp = generateOTP();
        const otpExpires = setOTPExpiration(5); // 5 minutes validity
        order.orderOTP = otp;
        order.orderOTPExpires = otpExpires;
        await order.save();

        const user = await User.findById(order.userId).select('email');
        const userEmail = user ? user.email : '[User Account Missing]';

        console.log(`SELLER (${sellerId}) generated OTP for O.ID ${orderId}. OTP: ${otp}. (User: ${userEmail})`);
        // Optional: Send email/SMS notification

        return { success: true, message: `OTP generated for order ${orderId}. It is visible on the customer's 'My Orders' page.` };
    } catch (error) {
        console.error(`Error in generateAndSendDirectDeliveryOTPBySeller for O.ID ${orderId} by Seller ${sellerId}:`, error);
        throw error; // Re-throw for the calling controller
    }
};

// --- Admin Confirm Delivery Logic (Remains Largely the Same) ---
exports.confirmDirectDeliveryByAdmin = async (orderId, adminUserId, providedOtp, resForHelper = null) => {
    try {
        const order = await Order.findOne({
           _id: orderId,
           status: 'Pending',
           orderOTP: providedOtp,
           orderOTPExpires: { $gt: Date.now() }
        });

        if (!order) {
           // Check specific failure reason
           const checkOrder = await Order.findById(orderId).select('status orderOTP orderOTPExpires');
           if (!checkOrder) throw new Error('Order not found.');
           if (checkOrder.status !== 'Pending') throw new Error(`Order status is '${checkOrder.status}', cannot confirm delivery.`);
           if (checkOrder.orderOTP !== providedOtp) throw new Error('Invalid OTP.');
           if (!checkOrder.orderOTPExpires || checkOrder.orderOTPExpires <= Date.now()) throw new Error('Expired OTP.');
           throw new Error('OTP verification failed.'); // Generic fallback
        }

        // Update Order
        order.status = 'Delivered';
        order.receivedByDate = new Date();
        // Clear OTP fields - Pre-save hook in Order model should handle this, but explicit clear is safe
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined; // Disable cancellation
        await order.save();

        console.log(`Order ${orderId} confirmed delivered by ADMIN ${adminUserId}`);

        // Send Confirmation Email
        try {
            const subject = `Your Order Has Been Delivered!`;
            const formattedDeliveryDate = resForHelper?.locals?.formatDateIST(order.receivedByDate) || new Date(order.receivedByDate).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
            const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed by administration.</p><p>Received Date: ${formattedDeliveryDate}</p><p>Thank you for shopping with us!</p>`;
           await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
        } catch (emailError){
            console.error(`Admin Confirm: Failed sending delivery confirmation email for O.ID ${order._id}:`, emailError);
        }

        return { success: true, order: order };
    } catch (error) {
        console.error(`Error verifying ADMIN Direct Delivery OTP for O.ID ${orderId} by Admin ${adminUserId}:`, error);
        throw error; // Re-throw
   }
};

// --- Seller Confirm Delivery Logic (NEW) ---
exports.confirmDirectDeliveryBySeller = async (orderId, sellerId, providedOtp, resForHelper = null) => {
    try {
        const order = await Order.findOne({
            _id: orderId,
            status: 'Pending',
            orderOTP: providedOtp,
            orderOTPExpires: { $gt: Date.now() }
        }).populate('products.productId', 'sellerId'); // Need sellerId for verification

        if (!order) {
           // Check specific failure reason
           const checkOrder = await Order.findById(orderId).select('status orderOTP orderOTPExpires');
           if (!checkOrder) throw new Error('Order not found.');
           if (checkOrder.status !== 'Pending') throw new Error(`Order status is '${checkOrder.status}'.`);
           if (checkOrder.orderOTP !== providedOtp) throw new Error('Invalid OTP.');
           if (!checkOrder.orderOTPExpires || checkOrder.orderOTPExpires <= Date.now()) throw new Error('Expired OTP.');
           throw new Error('OTP verification failed.');
        }

        // Security Check: Verify order relevance to this seller
        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
           console.warn(`Seller ${sellerId} attempted to confirm unrelated order ${orderId}.`);
           throw new Error('Permission Denied: Order does not contain your products.');
        }

        // Update Order
        order.status = 'Delivered';
        order.receivedByDate = new Date();
        // Clear OTP fields
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined;
        await order.save();

        console.log(`Order ${orderId} confirmed delivered by SELLER ${sellerId}`);

        // Send Confirmation Email
        try {
           const subject = `Your Order Has Been Delivered!`;
           const formattedDeliveryDate = resForHelper?.locals?.formatDateIST(order.receivedByDate) || new Date(order.receivedByDate).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
           const html = `<p>Great news! Your order (${order._id}) has been successfully delivered and confirmed by the seller.</p><p>Received Date: ${formattedDeliveryDate}</p><p>Thank you for shopping with us!</p>`;
           await sendEmail(order.userEmail, subject, `Your order ${order._id} has been delivered.`, html);
        } catch (emailError){
            console.error(`Seller Confirm: Failed sending delivery confirmation email for O.ID ${order._id}:`, emailError);
        }

        return { success: true, order: order };
    } catch (error) {
        console.error(`Error verifying SELLER Direct Delivery OTP for O.ID ${orderId} by Seller ${sellerId}:`, error);
        throw error; // Re-throw
   }
};

controllers/productController.js:
// controllers/productController.js
const Product = require('../models/Product');
const User = require('../models/User');
// *** Import category names ***
const { categoryNames } = require('../config/categories');


function escapeRegex(string) {
  // Simple regex escape. Consider a more robust library if needed.
  return string.replace(/[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

// --- Get Products (Handles listing, search, AND category filter) ---
exports.getProducts = async (req, res, next) => {
  try {
    const searchTerm = req.query.search || '';
    // *** Get category filter ***
    const categoryFilter = req.query.category || '';

    let query = {
        reviewStatus: 'approved', // Always filter by approved
        stock: { $gt: 0 }         // Always filter by in-stock
    };
    let sort = { createdAt: -1 }; // Default sort
    const projection = {};

    // Use Regex for sequential matching if searchTerm exists
    if (searchTerm) {
      const escapedSearchTerm = escapeRegex(searchTerm);
      const regex = new RegExp(escapedSearchTerm, 'i');
      query.$or = [
        { name: regex },
        { category: regex }
      ];
      console.log(`Regex Search Query: ${JSON.stringify(query)}`);
    }
    // Apply category filter ONLY if no search term is present
    else if (categoryFilter && categoryNames.includes(categoryFilter)) {
         query.category = categoryFilter;
    } else if (categoryFilter) {
         console.warn(`Invalid category filter attempted on /products route: ${categoryFilter}`);
    }
    // --- End Filter Logic ---

    const products = await Product.find(query, projection)
                                    .sort(sort)
                                    .lean();

    // Determine page title based on filters
    let pageTitle = 'Products';
    if (searchTerm) {
        pageTitle = `Search Results for "${searchTerm}"`;
    } else if (categoryFilter && categoryNames.includes(categoryFilter)) {
        pageTitle = `Category: ${categoryFilter}`;
    }

    // Render the same index page, passing search term and category for display
    res.render('products/index', {
      title: pageTitle,
      products: products,
      searchTerm: searchTerm,
      selectedCategory: categoryFilter && categoryNames.includes(categoryFilter) ? categoryFilter : null, // Pass selected category
      // Note: displayCategories are typically passed by getHomePage, not needed here unless specifically rendering categories on this route
      // displayCategories: require('../config/categories') // Uncomment if needed here
    });
  } catch (error) {
    console.error("Error fetching products:", error);
    next(error); // Pass error to central handler
  }
};


// --- Get Product Details (No changes needed) ---
exports.getProductDetails = async (req, res, next) => {
  try {
    const product = await Product.findById(req.params.id)
                                    .populate('sellerId', 'name email')
                                    .lean();

    if (!product) {
       const error = new Error('Product not found');
       error.status = 404;
       return next(error);
    }

    const isApproved = product.reviewStatus === 'approved';
    const user = req.session.user;
    const isAdmin = user?.role === 'admin';
    const isOwner = user && product.sellerId?._id && user._id.toString() === product.sellerId._id.toString();

    if (!isApproved && !isAdmin && !isOwner) {
         const error = new Error('Product not available');
         error.status = 404;
         return next(error);
    }

    let userRating = null;
    if (user) {
       const ratingData = product.ratings?.find(r => r.userId?.toString() === user._id.toString());
       userRating = ratingData ? ratingData.rating : null;
    }

    const ratingCounts = { 5: 0, 4: 0, 3: 0, 2: 0, 1: 0 };
    let totalRatings = 0;
    if (product.ratings && product.ratings.length > 0) {
        totalRatings = product.ratings.length;
        product.ratings.forEach(r => {
            if (r.rating && ratingCounts.hasOwnProperty(r.rating)) {
                ratingCounts[r.rating]++;
            }
        });
    }
    const displayTotalRatings = product.numReviews || totalRatings;

    res.render('products/detail', {
      title: product.name,
      product: product,
      isApproved: isApproved,
      isAdminView: isAdmin,
      isOwnerView: isOwner,
      userRating: userRating,
      userCanRate: user ? true : false,
      ratingCounts: ratingCounts,
      totalRatings: displayTotalRatings
    });
  } catch (error) {
       if (error.name === 'CastError') {
           const notFoundError = new Error('Product not found (Invalid ID)');
           notFoundError.status = 404;
           return next(notFoundError);
       }
    next(error);
  }
};


// --- Rate Product (No changes needed) ---
 exports.rateProduct = async (req, res, next) => {
     const { rating } = req.body;
    const productId = req.params.id;
    const userId = req.session.user._id;

     if (!rating || isNaN(Number(rating)) || rating < 1 || rating > 5) {
         req.flash('error_msg', 'Please provide a valid rating between 1 and 5.');
        return res.redirect('back');
     }

    try {
        const product = await Product.findById(productId);

         if (!product) {
             req.flash('error_msg', 'Product not found.');
             return res.status(404).redirect('/');
         }

         const existingRatingIndex = product.ratings.findIndex(r => r.userId?.toString() === userId.toString());

         if (existingRatingIndex > -1) {
            product.ratings[existingRatingIndex].rating = Number(rating);
         } else {
            product.ratings.push({ userId, rating: Number(rating) });
         }

        await product.save();

         req.flash('success_msg', 'Thank you for your rating!');
         res.redirect(`/products/${productId}`);

     } catch (error) {
        if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID.');
            return res.status(400).redirect('/');
        }
        console.error("Error rating product:", error);
        next(error);
     }
 };

 // --- Get Product Suggestions (Updated for sequential matching - no category changes needed here) ---
 exports.getProductSuggestions = async (req, res, next) => {
    const searchTerm = req.query.q;
    const limit = 8;

    if (!searchTerm || searchTerm.trim().length < 2) {
        return res.json([]);
    }

    try {
        const escapedSearchTerm = escapeRegex(searchTerm);
        const regex = new RegExp(escapedSearchTerm, 'i');

        const query = {
            $or: [ { name: regex }, { category: regex } ],
            reviewStatus: 'approved',
            stock: { $gt: 0 }
        };

        const suggestions = await Product.find(query)
            .select('_id name imageUrl')
            .limit(limit)
            .sort({ name: 1 })
            .lean();

        res.json(suggestions);

    } catch (error) {
        console.error("Error fetching product suggestions:", error);
        res.status(500).json({ error: 'Failed to fetch suggestions' });
    }
 };

controllers/userController.js:
// controllers/userController.js
const User = require('../models/User');
const Product = require('../models/Product');
const mongoose = require('mongoose');
const axios = require('axios');

// ===================================================
// Existing functions (getUserProfilePage, updateUserName - NO CHANGES needed)
// ===================================================
exports.getUserProfilePage = async (req, res, next) => {
    try {
        const userId = req.session.user._id;
        const user = await User.findById(userId)
                            .select('name email role address createdAt')
                            .lean();

        if (!user) {
            console.warn(`User not found in DB despite active session: ${userId}`);
            req.flash('error_msg', 'User session invalid. Please log in again.');
            return req.session.destroy(err => {
                if (err) return next(err);
                res.redirect('/auth/login');
            });
        }

        res.render('user/profile', {
            title: 'My Profile',
            user: user
        });

    } catch (error) {
        next(error);
    }
};

exports.updateUserName = async (req, res, next) => {
    const { name } = req.body;
    const userId = req.session.user._id;

    if (!name || typeof name !== 'string' || name.trim().length < 2) {
        req.flash('error_msg', 'Please enter a valid name (at least 2 characters).');
        return res.redirect('/user/profile');
    }

    const trimmedName = name.trim();

    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found. Please log in again.');
            return res.redirect('/auth/login');
        }

        user.name = trimmedName;
        await user.save();

        req.session.user.name = user.name;
        await req.session.save();

        req.flash('success_msg', 'Name updated successfully.');
        res.redirect('/user/profile');

    } catch (error) {
        if (error.name === 'ValidationError') {
            let validationErrors = Object.values(error.errors).map(el => el.message);
            req.flash('error_msg', `Validation Error: ${validationErrors.join(' ')}`);
            return res.redirect('/user/profile');
        }
        console.error("Error updating user name:", error);
        next(error);
    }
};

// ===================================================
// UPDATED saveAddress function
// ===================================================
exports.saveAddress = async (req, res, next) => {
    // Destructure locality along with other fields
    const { name, phone, pincode, locality, cityVillage, landmarkNearby, source, state, district, mandal } = req.body;
    const userId = req.session.user._id;
    const redirectPath = (source === 'profile') ? '/user/profile' : '/user/checkout';

    // --- Input Validation ---
    let errors = [];
    // Add locality check
    if (!name || !phone || !pincode || !locality || !cityVillage) {
        errors.push('Please provide Name, Phone, Pincode, select a Locality, and enter House No/Building/Area.');
    }
    if (phone && !/^\d{10,15}$/.test(phone.trim())) { errors.push('Please enter a valid phone number (10-15 digits, numbers only).'); }
    if (pincode && !/^\d{6}$/.test(pincode.trim())) { errors.push('Please enter a valid 6-digit pincode.'); }
    if (!state || !district || !mandal) { errors.push('State, District, and Mandal/Taluk could not be determined. Please verify the Pincode and try saving again.'); }
    // Check if locality is empty if state/district/mandal were determined
    if (state && (!locality || locality.trim() === '')) {
        errors.push('Please select a Locality/Post Office from the dropdown after entering the Pincode.');
    }

    if (errors.length > 0) {
         req.flash('error_msg', errors.join(' '));
        // Pass back data to repopulate form
        req.session.addressFormData = req.body; // Store temporarily
        return res.redirect(redirectPath);
    }

    // --- Save Address Logic ---
    try {
        const user = await User.findById(userId);
        if (!user) {
            req.flash('error_msg', 'User not found.');
            delete req.session.addressFormData; // Clean up session data
            return res.redirect('/auth/login');
        }

        user.address = {
            name: name.trim(),
            phone: phone.trim(),
            pincode: pincode.trim(),
            locality: locality.trim(), // Save locality
            cityVillage: cityVillage.trim(), // Save House No/Building/Area
            landmarkNearby: landmarkNearby ? landmarkNearby.trim() : undefined, // Save Landmark
            mandal: mandal?.trim() || undefined,
            district: district?.trim() || undefined,
            state: state?.trim() || undefined
        };

        await user.save();

        // --- Update Session ---
        req.session.user.address = user.address.toObject();
        await req.session.save();
        delete req.session.addressFormData; // Clean up temporary form data

        req.flash('success_msg', 'Address saved successfully.');
        res.redirect(redirectPath);

    } catch (error) {
        delete req.session.addressFormData; // Clean up session data
        if (error.name === 'ValidationError') {
            let validationErrors = Object.values(error.errors).map(el => el.message);
             if (!state || !district || !mandal || !locality) {
                validationErrors.unshift('Pincode or Locality data might be missing.');
             }
            req.flash('error_msg', `Validation Error: ${validationErrors.join(' ')}`);
            req.session.addressFormData = req.body; // Store temporarily for repopulation
            return res.redirect(redirectPath);
        }
        next(error);
    }
};

// ===================================================
// Existing Cart/Checkout functions (NO CHANGES needed)
// ===================================================
exports.getCart = async (req, res, next) => {
    try {
        const userId = req.session.user._id;
        const user = await User.findById(userId)
                                    .populate('cart.productId', 'name price imageUrl stock _id reviewStatus')
                                    .lean();

        if (!user) {
           console.warn(`User not found in getCart despite session: ${userId}`);
           req.flash('error_msg', 'User not found.');
           return req.session.destroy(err => {
                if(err) return next(err);
                res.redirect('/auth/login');
           });
         }

        let cartTotal = 0;
        let populatedCart = [];
        let cartUpdated = false;

        if (user.cart && user.cart.length > 0) {
             populatedCart = user.cart.map(item => {
                 if (!item.productId || !item.productId._id) {
                     console.warn(`Cart item refers to a non-existent product ID for user: ${user.email}. Will filter.`);
                     cartUpdated = true;
                     return null;
                 }
                 if (item.productId.reviewStatus !== 'approved') {
                      console.warn(`Product ${item.productId.name} (${item.productId._id}) in cart is not approved. Will filter.`);
                      cartUpdated = true;
                      return null;
                 }
                const itemSubtotal = item.productId.price * item.quantity;
                cartTotal += itemSubtotal;
                return {
                    productId: item.productId._id,
                    name: item.productId.name,
                    price: item.productId.price,
                    imageUrl: item.productId.imageUrl,
                    stock: item.productId.stock,
                    quantity: item.quantity,
                    subtotal: itemSubtotal
                };
             }).filter(item => item !== null);

             if (cartUpdated) {
                 const validCartItems = populatedCart.map(item => ({ productId: item.productId, quantity: item.quantity }));
                 req.session.user.cart = validCartItems;
                 await req.session.save(); // Save updated session cart
                  console.log(`Session cart updated for user ${user.email} due to invalid/unapproved items found.`);
             }
         }

        res.render('user/cart', {
          title: 'Your Shopping Cart',
          cart: populatedCart,
          cartTotal: cartTotal
        });
      } catch (error) {
        next(error);
      }
};

exports.addToCart = async (req, res, next) => {
    const { productId, quantity = 1 } = req.body;
    const userId = req.session.user._id;
    const numQuantity = parseInt(quantity, 10);

     if (!productId || !mongoose.Types.ObjectId.isValid(productId) || isNaN(numQuantity) || numQuantity < 1) {
         req.flash('error_msg', 'Invalid product or quantity.');
         return res.redirect(req.headers.referer || '/');
     }

    try {
        const [user, product] = await Promise.all([
            User.findById(userId),
            Product.findById(productId).select('name stock reviewStatus')
        ]);

        if (!user) {
            req.flash('error_msg', 'User session error. Please log in again.');
            return res.redirect('/auth/login');
        }
        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.redirect(req.headers.referer || '/');
        }

        if (product.reviewStatus !== 'approved') {
             req.flash('error_msg', `Sorry, "${product.name}" is currently unavailable.`);
             return res.redirect(req.headers.referer || '/');
        }

       if (product.stock <= 0) {
            req.flash('error_msg', `${product.name} is currently out of stock.`);
            return res.redirect(req.headers.referer || '/');
        }

       const existingCartItemIndex = user.cart.findIndex(item => item.productId.toString() === productId.toString());

       if (existingCartItemIndex > -1) {
           const existingQuantity = user.cart[existingCartItemIndex].quantity;
           const newQuantity = existingQuantity + numQuantity;
            if (product.stock < newQuantity) {
               req.flash('error_msg', `Cannot add ${numQuantity} more ${product.name}. Only ${product.stock} available in total (you have ${existingQuantity} in cart).`);
                return res.redirect(req.headers.referer?.includes(`/products/${productId}`) ? `/products/${productId}` : '/');
           }
            user.cart[existingCartItemIndex].quantity = newQuantity;
       } else {
           if (product.stock < numQuantity) {
               req.flash('error_msg', `Insufficient stock for ${product.name}. Only ${product.stock} available.`);
                return res.redirect(req.headers.referer?.includes(`/products/${productId}`) ? `/products/${productId}` : '/');
           }
           user.cart.push({ productId, quantity: numQuantity });
       }

        await user.save();

       req.session.user.cart = user.cart.map(item => ({ productId: item.productId, quantity: item.quantity }));
       await req.session.save();

        req.flash('success_msg', `${product.name} added to cart!`);

        if(req.query.redirectTo === 'checkout') {
           return res.redirect('/user/checkout');
       }
        res.redirect('/user/cart');

    } catch (error) {
         if (error.name === 'CastError') {
            req.flash('error_msg', 'Invalid product ID format.');
             return res.redirect('/');
         }
         console.error("Add to Cart Error:", error);
        next(error);
    }
};

exports.updateCartQuantity = async (req, res, next) => {
         const { productId, quantity } = req.body;
         const userId = req.session.user._id;
         const numQuantity = parseInt(quantity, 10);

         if (!productId || !mongoose.Types.ObjectId.isValid(productId) || isNaN(numQuantity) || numQuantity < 0) {
              return res.status(400).json({ success: false, message: 'Invalid product ID or quantity.' });
         }

        try {
            const [user, product] = await Promise.all([
                 User.findById(userId),
                 Product.findById(productId).select('stock price reviewStatus name')
            ]);

            if (!user) {
               return res.status(404).json({ success: false, message: 'User not found.' });
            }
            if (!product) {
               return res.status(404).json({ success: false, message: 'Product not found.' });
            }

            if (product.reviewStatus !== 'approved') {
                const itemIndexToRemove = user.cart.findIndex(item => item.productId.toString() === productId.toString());
                if (itemIndexToRemove > -1) {
                    user.cart.splice(itemIndexToRemove, 1);
                    await user.save();
                    req.session.user.cart = user.cart.map(i => ({ productId: i.productId, quantity: i.quantity }));
                    await req.session.save();
                }
                return res.status(400).json({ success: false, message: `Product "${product.name}" is unavailable and has been removed.`, removal: true });
            }

            const cartItemIndex = user.cart.findIndex(item => item.productId.toString() === productId.toString());

            if (numQuantity === 0) {
                if (cartItemIndex > -1) {
                    user.cart.splice(cartItemIndex, 1);
                }
            }
            else {
               if (product.stock < numQuantity) {
                  return res.status(400).json({ success: false, message: `Insufficient stock for ${product.name}. Only ${product.stock} available.` });
                 }
                if (cartItemIndex > -1) {
                    user.cart[cartItemIndex].quantity = numQuantity;
                } else {
                     // Avoid adding if quantity > stock during direct update
                    if (product.stock >= numQuantity) {
                       user.cart.push({ productId, quantity: numQuantity });
                    } else {
                         return res.status(400).json({ success: false, message: `Insufficient stock for ${product.name}. Only ${product.stock} available.` });
                    }
                 }
            }

            await user.save();
            // Refresh session data after save
            req.session.user.cart = user.cart.map(item => ({ productId: item.productId, quantity: item.quantity }));

            let cartTotal = 0;
            let itemSubtotal = 0;
             // Repopulate with prices after save
            const updatedUser = await User.findById(userId).populate('cart.productId', 'price').lean();

             for (const item of updatedUser.cart) {
                 if (item.productId && typeof item.productId.price === 'number') {
                    const currentItemSubtotal = item.productId.price * item.quantity;
                    cartTotal += currentItemSubtotal;
                    if (item.productId._id.toString() === productId.toString()) {
                         itemSubtotal = currentItemSubtotal;
                     }
                 }
            }
             await req.session.save(); // Save the potentially updated cart count/total info

            res.json({
                 success: true,
                 message: 'Cart updated successfully.',
                 newQuantity: user.cart.find(item => item.productId.toString() === productId.toString())?.quantity ?? 0,
                 itemSubtotal: itemSubtotal,
                 cartTotal: cartTotal,
                 itemId: productId
             });

        } catch (error) {
            console.error("Cart Update Error:", error);
            res.status(500).json({ success: false, message: 'Error updating cart quantity.' });
        }
};

exports.removeFromCart = async (req, res, next) => {
    const { productId } = req.params;
    const userId = req.session.user._id;

    if (!productId || !mongoose.Types.ObjectId.isValid(productId)) {
       req.flash('error_msg', 'Invalid Product ID.');
       return res.redirect('/user/cart');
     }

    try {
        // Fetch user to get the current cart before update
        const userBeforeUpdate = await User.findById(userId).lean();
        const initialCartLength = userBeforeUpdate ? userBeforeUpdate.cart.length : 0;

        const user = await User.findOneAndUpdate(
            { _id: userId },
            { $pull: { cart: { productId: productId } } },
            { new: true } // Return updated document
        );

         if (!user) {
             req.flash('error_msg', 'User not found.');
            return res.redirect('/auth/login');
         }

         // Update session cart
         req.session.user.cart = user.cart.map(item => ({ productId: item.productId, quantity: item.quantity }));
         await req.session.save();

         // Check if an item was actually removed
         if (user.cart.length < initialCartLength) {
             req.flash('success_msg', 'Item removed from cart.');
         } else {
              req.flash('info_msg', 'Item not found in cart.'); // Or no message
         }
         res.redirect('/user/cart');

    } catch (error) {
       console.error("Remove From Cart Error:", error);
       next(error);
    }
};

exports.getCheckoutPage = async (req, res, next) => {
    try {
       const userId = req.session.user._id;
       const user = await User.findById(userId)
                              .populate('cart.productId', 'name price imageUrl stock reviewStatus sellerId _id')
                              .lean();

       if (!user) {
           req.flash('error_msg', 'User session expired. Please login.');
           return res.redirect('/auth/login');
       }
       if (!user.cart || user.cart.length === 0) {
           req.flash('error_msg', 'Your cart is empty.');
           return res.redirect('/user/cart');
       }

       let subTotal = 0;
        let checkoutItems = [];
        let issuesFound = false;
        let issueMessages = [];
        let itemsToRemoveFromCartOnRedirect = []; // Track items to remove

       for (const item of user.cart) {
           const productName = item.productId?.name || '[Unknown Product]';
           const productStock = item.productId?.stock ?? 0;
           const productStatus = item.productId?.reviewStatus ?? 'unavailable';

           if (!item.productId || !item.productId._id) {
               issueMessages.push(`An invalid item was detected in your cart.`);
               issuesFound = true;
               itemsToRemoveFromCartOnRedirect.push(item._id);
               continue;
           }
            if(productStatus !== 'approved'){
                issueMessages.push(`"${productName}" is currently unavailable.`);
                issuesFound = true;
                itemsToRemoveFromCartOnRedirect.push(item._id);
                continue;
            }
            if(productStock < item.quantity){
                issueMessages.push(`Insufficient stock for "${productName}" (Only ${productStock} left).`);
                issuesFound = true;
                 continue;
            }
            const itemPrice = typeof item.productId.price === 'number' ? item.productId.price : 0;
            const itemTotal = itemPrice * item.quantity;
            subTotal += itemTotal;
           checkoutItems.push({
               productId: item.productId._id,
               name: productName,
               price: itemPrice,
               imageUrl: item.productId.imageUrl || '/images/placeholder.png',
               quantity: item.quantity,
               stock: productStock,
               itemTotal: itemTotal
            });
       }

        if (issuesFound) {
             if (itemsToRemoveFromCartOnRedirect.length > 0) {
                 await User.updateOne(
                     { _id: userId },
                     { $pull: { cart: { _id: { $in: itemsToRemoveFromCartOnRedirect } } } }
                 );
                 const updatedUser = await User.findById(userId).select('cart').lean();
                 req.session.user.cart = updatedUser ? updatedUser.cart.map(i => ({ productId: i.productId, quantity: i.quantity })) : [];
                 await req.session.save();
                 issueMessages.push('Problematic items have been removed.');
             }
             req.flash('error_msg', "Please resolve the following issues in your cart: " + issueMessages.join(' '));
             return res.redirect('/user/cart');
        }

        const totalAmount = subTotal;

       res.render('user/checkout', {
           title: 'Checkout',
           userAddress: user.address,
           items: checkoutItems,
           subTotal: subTotal,
           totalAmount: totalAmount,
           paymentMethod: 'COD'
       });

   } catch (error) {
       next(error);
   }
};

// ============================================================
// *** UPDATED Pincode Lookup using api.postalpincode.in ***
// ============================================================
exports.lookupPincode = async (req, res) => {
    const pincode = req.params.pincode;
    const API_URL = `https://api.postalpincode.in/pincode/${pincode}`;

    if (!pincode || !/^\d{6}$/.test(pincode)) {
        return res.status(400).json({ success: false, message: 'Invalid Pincode format (must be 6 digits).' });
    }

    try {
        console.log(`[Pincode Lookup] Requesting data for Pincode: ${pincode}`);
        const response = await axios.get(API_URL, { timeout: 7000 });

        if (response.status !== 200) {
            console.error(`[Pincode Lookup] API request failed for ${pincode}. Status: ${response.status}`);
            return res.status(502).json({ success: false, message: `Pincode API unavailable (${response.statusText})` });
        }

        const data = response.data;

        if (!Array.isArray(data) || data.length === 0 || !data[0]) {
            console.error(`[Pincode Lookup] Unexpected API response format for ${pincode}. Data:`, JSON.stringify(data));
            return res.status(500).json({ success: false, message: 'Unexpected API response format.' });
        }

        const result = data[0];

        if (result.Status !== 'Success') {
            console.log(`[Pincode Lookup] Pincode ${pincode} not found by API. Message: ${result.Message}`);
            return res.status(404).json({ success: false, message: `Pincode not found (${result.Message || 'No records'})` });
        }

        // Check if PostOffice data exists
        if (!result.PostOffice || !Array.isArray(result.PostOffice) || result.PostOffice.length === 0) {
            console.warn(`[Pincode Lookup] Pincode ${pincode} found (Status: Success) but no PostOffice data returned.`);
            return res.json({
                success: true,
                location: {
                    pinCode: pincode,
                    mandalName: '',
                    districtName: '',
                    stateName: '',
                    localities: [] // Return empty array
                }
            });
            // OR: return res.status(404).json({ success: false, message: 'Pincode found, but no location details available.' });
        }

        // --- Extract and Map Data ---
        const postOffices = result.PostOffice;
        const firstPO = postOffices[0];

        // --- Extract list of localities ---
        const localitiesList = postOffices
            .map(po => po.Name)
            .filter(name => name && name.trim() !== '' && name.toUpperCase() !== 'NA')
            .sort(); // Optional: sort

        const uniqueLocalities = [...new Set(localitiesList)];

        const transformedLocation = {
            pinCode: firstPO.Pincode || pincode,
            mandalName: firstPO.Block && firstPO.Block !== 'NA'
                            ? firstPO.Block
                            : (firstPO.Taluk && firstPO.Taluk !== 'NA'
                                ? firstPO.Taluk
                                : firstPO.Division || ''),
            districtName: firstPO.District || '',
            stateName: firstPO.State || '',
            // --- Add localities array ---
            localities: uniqueLocalities
        };

        console.log(`[Pincode Lookup] Success for ${pincode}. Location:`, transformedLocation);
        res.json({ success: true, location: transformedLocation });

    } catch (error) {
        console.error(`[Pincode Lookup] Network/Request Error for pincode ${pincode}:`, error.message);
        let statusCode = 500;
        let message = 'Error looking up pincode information.';
        if (axios.isAxiosError(error)) {
            if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
                message = 'Pincode lookup timed out. Please try again.';
                statusCode = 504;
            } else if (error.response) {
                 message = `Pincode API error (${error.response.status}).`;
                 statusCode = 502;
            } else if (error.request) {
                message = 'Network error during pincode lookup.';
                statusCode = 502;
            }
        }
        res.status(statusCode).json({ success: false, message: message });
    }
};
// ============================================================
// End Updated Pincode Lookup
// ============================================================

controllers/sellerController.js:
// controllers/sellerController.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const { sendEmail } = require('../config/mailer');
const { reviewProductWithGemini } = require('../services/geminiService');
const {
    generateAndSendDirectDeliveryOTPBySeller,
    confirmDirectDeliveryBySeller
} = require('./orderController');
const mongoose = require('mongoose');
// *** Import categories and names ***
const categories = require('../config/categories');
const { categoryNames } = require('../config/categories');

const sellerCancellationReasons = [
    "❗ Item Out of Stock",
    "🚚 Unable to Fulfill/Ship",
    "👤 Technical Issue",
    "❓ Other Reason",
];

// Seller Dashboard
exports.getSellerDashboard = (req, res) => {
    res.render('seller/dashboard', { title: 'Seller Dashboard' });
};

// Product Management Pages
exports.getUploadProductPage = (req, res) => {
    // *** Pass categories to the view ***
    res.render('seller/upload-product', {
        title: 'Upload New Product',
        product: {},
        categories: categories // Pass the full list
    });
};

// --- Product Management Actions ---
exports.uploadProduct = async (req, res, next) => {
    // --- UPDATED: Destructure imageUrl2 ---
    const { name, category, price, stock, imageUrl, imageUrl2, specifications, shortDescription } = req.body;
    // --- END UPDATED ---
    const sellerId = req.session.user._id;
    const sellerEmail = req.session.user.email;

     // Validation
     if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields (Name, Category, Price, Stock, Primary Image URL).');
        // *** Pass categories back on error ***
        return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories });
    }
     if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
        req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
         // *** Pass categories back on error ***
         return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories });
     }
     // *** Add Category Validation ***
     if (!categoryNames.includes(category)) {
        req.flash('error_msg', 'Invalid category selected.');
        return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories });
    }
    // Optional: Validate imageUrl2 format if present

    try {
        const newProduct = new Product({
            name: name.trim(),
            category: category.trim(), // Category validated
            shortDescription: shortDescription ? shortDescription.trim() : undefined,
            price: Number(price),
            stock: Number(stock),
            imageUrl: imageUrl.trim(),
            // --- UPDATED: Assign imageUrl2 ---
            imageUrl2: imageUrl2 ? imageUrl2.trim() : undefined,
            // --- END UPDATED ---
            specifications: specifications ? specifications.trim() : '',
            sellerId: sellerId,
            sellerEmail: sellerEmail,
            reviewStatus: 'pending'
        });

        await newProduct.save(); // Trigger enum validation
        console.log(`Product ${newProduct._id} saved initially by seller ${sellerEmail}.`);

        // Trigger Gemini review asynchronously
        reviewProductWithGemini(newProduct).then(async reviewResult => {
             try {
                 const productToUpdate = await Product.findById(newProduct._id);
                 if (productToUpdate) {
                    productToUpdate.reviewStatus = reviewResult.status;
                    productToUpdate.rejectionReason = reviewResult.reason;
                    await productToUpdate.save();
                    console.log(`Product ${newProduct._id} review status updated to ${reviewResult.status}.`);
                 } else {
                     console.warn(`Product ${newProduct._id} not found for status update after Gemini review.`);
                 }
             } catch (updateError) {
                console.error(`Error updating product ${newProduct._id} after Gemini review:`, updateError);
             }
        }).catch(reviewError => {
             console.error(`Error in Gemini review promise chain for product ${newProduct._id}:`, reviewError);
              Product.findByIdAndUpdate(newProduct._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed.' }).catch(err => console.error("Failed to mark product as pending after review error:", err));
        });

        req.flash('success_msg', `Product "${newProduct.name}" submitted for review.`);
        res.redirect('/seller/products');

    } catch (error) {
        if (error.name === 'ValidationError') {
           let errors = Object.values(error.errors).map(el => el.message);
           req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
            // *** Pass categories back on error ***
           return res.render('seller/upload-product', { title: 'Upload New Product', product: req.body, categories: categories });
       }
        console.error("Error uploading product:", error);
        next(error);
    }
};


// --- Manage Products Page (Seller) ---
exports.getManageProductsPage = async (req, res, next) => {
    try {
        const sellerId = req.session.user._id;
        const products = await Product.find({ sellerId: sellerId })
                                    .sort({ createdAt: -1 })
                                    .lean();

        res.render('seller/manage-products', {
            title: 'Manage Your Products',
            products: products
        });
    } catch (error) {
        next(error);
    }
};

// --- Edit Product Page (Seller) ---
exports.getEditProductPage = async (req, res, next) => {
     try {
        const product = await Product.findById(req.params.id)
                                     .lean();
        if (!product) {
           req.flash('error_msg', 'Product not found or access denied.');
           return res.redirect('/seller/products');
       }
       // *** Pass categories to the view ***
       res.render('seller/edit-product', {
           title: `Edit Product: ${product.name}`,
           product: product,
           categories: categories // Pass the full list
       });
   } catch (error) {
        if (error.name === 'CastError') {
          req.flash('error_msg', 'Invalid product ID format.');
           return res.redirect('/seller/products');
      }
       next(error);
    }
};

// --- Update Product Action (Seller) ---
exports.updateProduct = async (req, res, next) => {
    const productId = req.params.id;
    const sellerId = req.session.user._id;
    // --- UPDATED: Destructure imageUrl2 ---
    const { name, category, price, stock, imageUrl, imageUrl2, specifications, shortDescription } = req.body;
    // --- END UPDATED ---
    const renderOptions = { title: `Edit Product Error`, product: { _id: productId, ...req.body }, categories: categories }; // For re-rendering on error


     // Validation
     if (!name || !category || price === undefined || stock === undefined || !imageUrl) {
        req.flash('error_msg', 'Please fill in all required fields.');
        try { const originalProduct = await Product.findOne({ _id: productId, sellerId: sellerId }).lean(); renderOptions.product = { ...originalProduct, ...req.body }; } catch (fetchErr) { console.error("Error refetching product on update validation fail:", fetchErr); }
        return res.render('seller/edit-product', renderOptions);
    }
     if (isNaN(Number(price)) || Number(price) < 0 || isNaN(Number(stock)) || Number(stock) < 0) {
         req.flash('error_msg', 'Price and Stock must be valid non-negative numbers.');
         try { const originalProduct = await Product.findOne({ _id: productId, sellerId: sellerId }).lean(); renderOptions.product = { ...originalProduct, ...req.body }; } catch (fetchErr) { console.error("Error refetching product on update validation fail:", fetchErr); }
         return res.render('seller/edit-product', renderOptions);
     }
      // *** Add Category Validation ***
     if (!categoryNames.includes(category)) {
        req.flash('error_msg', 'Invalid category selected.');
         try { const originalProduct = await Product.findOne({ _id: productId, sellerId: sellerId }).lean(); renderOptions.product = { ...originalProduct, ...req.body }; } catch (fetchErr) { console.error("Error refetching product on update validation fail:", fetchErr); }
        return res.render('seller/edit-product', renderOptions);
    }
    // Optional: Validate imageUrl2 format if present

    try {
        const product = await Product.findOne({ _id: productId, sellerId: sellerId }); // Fetch non-lean

        if (!product) {
            req.flash('error_msg', 'Product not found or access denied.');
            return res.status(404).redirect('/seller/products');
         }

         product.name = name.trim();
         product.category = category.trim(); // Category validated
         product.shortDescription = shortDescription ? shortDescription.trim() : undefined;
         product.price = Number(price);
         product.stock = Number(stock);
         product.imageUrl = imageUrl.trim();
         // --- UPDATED: Update imageUrl2 ---
         product.imageUrl2 = imageUrl2 ? imageUrl2.trim() : undefined;
         // --- END UPDATED ---
         product.specifications = specifications ? specifications.trim() : '';
         product.reviewStatus = 'pending'; // Reset status on update
         product.rejectionReason = undefined;

         await product.save(); // Trigger enum validation
         console.log(`Product ${productId} updated by seller, set to pending review.`);

        // Trigger Gemini review asynchronously
        reviewProductWithGemini(product).then(async reviewResult => {
             try {
                 const productToUpdate = await Product.findById(product._id);
                 if (productToUpdate) {
                    productToUpdate.reviewStatus = reviewResult.status;
                    productToUpdate.rejectionReason = reviewResult.reason;
                    await productToUpdate.save();
                    console.log(`Product ${product._id} review status updated to ${reviewResult.status} after edit.`);
                 }
             } catch (updateError) {
                console.error(`Error updating product ${product._id} after Gemini review (post-edit):`, updateError);
             }
        }).catch(reviewError => {
             console.error(`Error in Gemini review promise chain for edited product ${product._id}:`, reviewError);
              Product.findByIdAndUpdate(product._id, { reviewStatus: 'pending', rejectionReason: 'AI review process failed after edit.' }).catch(err => console.error("Failed to mark edited product as pending after review error:", err));
         });

         req.flash('success_msg', `Product "${product.name}" updated and resubmitted for review.`);
         res.redirect('/seller/products');

    } catch (error) {
         if (error.name === 'ValidationError') {
            let errors = Object.values(error.errors).map(el => el.message);
             req.flash('error_msg', `Validation Error: ${errors.join(' ')}`);
              try { const originalProduct = await Product.findOne({ _id: productId, sellerId: sellerId }).lean(); renderOptions.product = { ...originalProduct, ...req.body }; } catch (fetchErr) { console.error("Error refetching product on update validation fail:", fetchErr); }
             return res.render('seller/edit-product', renderOptions);
         }
         console.error("Error updating product:", error);
         next(error);
     }
 };

// --- Remove Product (Seller) ---
exports.removeProduct = async (req, res, next) => {
    const productId = req.params.id;
    const sellerId = req.session.user._id;

    try {
         const product = await Product.findOneAndDelete({ _id: productId, sellerId: sellerId });

        if (!product) {
             req.flash('error_msg', 'Product not found or already removed.');
             return res.status(404).redirect('/seller/products');
         }
         req.flash('success_msg', `Product "${product.name}" removed successfully.`);
         res.redirect('/seller/products');
    } catch (error) {
        if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid product ID format.');
            return res.status(400).redirect('/seller/products');
        }
        console.error("Error removing product:", error);
        req.flash('error_msg', 'Error removing product.');
        res.redirect('/seller/products');
    }
};

// --- Manage Orders (Seller) ---
exports.getManageOrdersPage = async (req, res, next) => {
    try {
        const sellerId = req.session.user._id;

        const sellerProductRefs = await Product.find({ sellerId: sellerId }).select('_id').lean();
        const sellerProductIds = sellerProductRefs.map(p => p._id);

        if (sellerProductIds.length === 0) {
             return res.render('seller/manage-orders', {
                 title: 'Manage Your Orders',
                 orders: [],
                 message: 'You have no products listed, so no orders to manage yet.',
                 sellerCancellationReasons: sellerCancellationReasons
             });
        }

        const orders = await Order.find({ 'products.productId': { $in: sellerProductIds } })
                                   .sort({ orderDate: -1 })
                                   .populate('products.productId', 'name imageUrl _id price sellerId') // Ensure imageUrl is populated
                                   .populate('userId', 'name email')
                                   .lean();

        const now = Date.now();
        orders.forEach(order => {
             order.isRelevantToSeller = true;
             order.canBeDirectlyDeliveredBySeller = order.status === 'Pending';
             order.canBeCancelledBySeller = order.status === 'Pending';

             order.showDeliveryOtp = order.status === 'Pending' &&
                                     !!order.orderOTP &&
                                     !!order.orderOTPExpires &&
                                     new Date(order.orderOTPExpires).getTime() > now;

            if (order.products && order.products.length > 0) {
                order.itemsSummary = order.products.map(p => {
                    const isSellerItem = p.productId?.sellerId?.toString() === sellerId.toString();
                    const price = (p.priceAtOrder !== undefined && p.priceAtOrder !== null) ? p.priceAtOrder : (p.productId?.price ?? 0);
                    const productName = p.productId?.name || p.name || '[Product Name Missing]';
                    return `${isSellerItem ? '<strong class="text-success">' : ''}${productName} (Qty: ${p.quantity}) @ ₹${price.toFixed(2)}${isSellerItem ? ' (Your Item)</strong>' : ''}`;
                }).join('<br>');
            } else {
                 order.itemsSummary = 'No items found';
            }
        });
        res.render('seller/manage-orders', {
            title: 'Manage Your Orders',
            orders: orders,
            message: null,
            sellerCancellationReasons: sellerCancellationReasons
        });
    } catch (error) {
        next(error);
    }
};


// --- Seller Order Actions ---
exports.sendDirectDeliveryOtpBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const sellerId = req.session.user._id;

    try {
        const order = await Order.findById(orderId);
        if (!order) throw new Error("Order not found.");
        if (order.status !== 'Pending') throw new Error(`Cannot send OTP for order status ${order.status}.`);

        const result = await generateAndSendDirectDeliveryOTPBySeller(orderId, sellerId);
        req.flash('success_msg', result.message + ' Ask customer for OTP.');
    } catch (error) {
        req.flash('error_msg', `Failed to send delivery OTP: ${error.message}`);
    }
    res.redirect('/seller/orders');
};

exports.confirmDirectDeliveryBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const { otp } = req.body;
    const sellerId = req.session.user._id;

    if (!otp || !/^\d{6}$/.test(otp.trim())) {
        req.flash('error_msg', 'Please enter the 6-digit OTP.');
        return res.redirect('/seller/orders');
    }

    try {
         const { order } = await confirmDirectDeliveryBySeller(orderId, sellerId, otp.trim(), res);
        req.flash('success_msg', `Order ${orderId} confirmed delivered by you.`);
    } catch (error) {
        req.flash('error_msg', `Delivery confirmation failed: ${error.message}`);
    }
    res.redirect('/seller/orders');
};

exports.cancelOrderBySeller = async (req, res, next) => {
    const { orderId } = req.params;
    const { reason } = req.body;
    const sellerId = req.session.user._id;
    const sellerEmail = req.session.user.email;

    if (!reason || !sellerCancellationReasons.includes(reason)) {
        req.flash('error_msg', 'Please select a valid seller reason for cancellation.');
        return res.redirect('/seller/orders');
    }

    const sessionDB = await mongoose.startSession();
    sessionDB.startTransaction();
    try {
        const order = await Order.findById(orderId)
                                .populate('products.productId', 'sellerId name _id')
                                .populate('userId', 'email')
                                .session(sessionDB);

        if (!order) {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', 'Order not found.');
            return res.status(404).redirect('/seller/orders');
        }

        if (order.status !== 'Pending') {
            await sessionDB.abortTransaction(); sessionDB.endSession();
            req.flash('error_msg', `Order status is '${order.status}'. Only 'Pending' orders can be cancelled by seller.`);
            return res.redirect('/seller/orders');
        }

        const isRelevant = order.products.some(p => p.productId?.sellerId?.toString() === sellerId.toString());
        if (!isRelevant) {
             await sessionDB.abortTransaction(); sessionDB.endSession();
             console.warn(`Seller ${sellerEmail} (${sellerId}) attempted cancellation for non-relevant order ${orderId}.`);
             req.flash('error_msg', 'Permission Denied: Order does not contain your products.');
             return res.status(403).redirect('/seller/orders');
        }


        console.log(`Seller Cancel: Restoring stock for seller ${sellerId}'s items in order ${orderId}.`);
        const productStockRestorePromises = order.products
            .filter(item => item.productId?.sellerId?.toString() === sellerId.toString())
            .map(item => {
                const quantityToRestore = Number(item.quantity);
                 if (!item.productId?._id || isNaN(quantityToRestore) || quantityToRestore <= 0) {
                    console.warn(`Seller Cancel: Invalid P.ID ${item.productId?._id} or Qty ${item.quantity} for seller's item in O.ID ${orderId}. Skipping restore.`);
                    return Promise.resolve();
                }
                console.log(`Seller Cancel: Restoring ${quantityToRestore} stock for P.ID ${item.productId._id}`);
                 return Product.updateOne(
                     { _id: item.productId._id },
                     { $inc: { stock: quantityToRestore, orderCount: -1 } },
                     { session: sessionDB }
                 ).catch(err => {
                    console.error(`Seller Cancel: Failed stock/count restore P.ID ${item.productId._id} O.ID ${orderId}: ${err.message}`);
                 });
            });

        await Promise.allSettled(productStockRestorePromises);
        console.log(`Seller Cancel: Stock restoration attempts completed for seller ${sellerId} in order ${orderId}.`);

        order.status = 'Cancelled';
        order.cancellationReason = `Cancelled by Seller: ${reason}`;
        order.orderOTP = undefined;
        order.orderOTPExpires = undefined;
        order.cancellationAllowedUntil = undefined;

        await order.save({ session: sessionDB });

        await sessionDB.commitTransaction();

        try {
            const customerEmail = order.userEmail || order.userId?.email;
            if(customerEmail) {
                const subjectCust = `Update on Your Order (${order._id})`;
                const htmlCust = `<p>Unfortunately, your order (${order._id}) has been cancelled by the seller.</p><p><strong>Reason:</strong> ${reason}</p><p>Any payment made (if applicable) will be refunded according to policy.</p><p>We apologize for any inconvenience. Please contact support if you have questions.</p>`;
                const textCust = `Your order ${order._id} was cancelled by the seller. Reason: ${reason}. Contact support for questions.`;
                await sendEmail(customerEmail, subjectCust, textCust, htmlCust);
            } else {
                console.warn(`Seller Cancel: Could not find customer email for order ${orderId} notification.`);
            }
        } catch (emailError) {
            console.error(`Seller Cancel: Failed sending cancellation email for order ${order._id}:`, emailError);
        }

        req.flash('success_msg', `Order ${orderId} cancelled successfully. Reason: ${reason}. Customer notified.`);
        res.redirect('/seller/orders');

    } catch (error) {
        await sessionDB.abortTransaction();
        console.error(`Error cancelling order ${orderId} by seller ${sellerEmail} (${sellerId}):`, error);
        req.flash('error_msg', 'Failed to cancel order due to an internal error.');
        res.redirect('/seller/orders');
    } finally {
        sessionDB.endSession();
    }
};

middleware/authMiddleware.js:
const User = require('../models/User');

const isAuthenticated = (req, res, next) => {
    if (req.session && req.session.user) {
        User.findById(req.session.user._id).then(user => {
            if (!user) {
                req.session.destroy(err => {
                    if (err) {
                        console.error('Session destruction error:', err);
                        return next(err);
                    }
                    req.flash('error_msg', 'Session expired or user not found. Please login again.');
                    res.redirect('/auth/login');
                });
            } else {
                req.user = user;
                res.locals.currentUser = user;
                next();
            }
        }).catch(err => {
            console.error("Error checking user authentication:", err);
            req.flash('error_msg', 'An error occurred during authentication.');
            res.redirect('/auth/login');
        });
    } else {
        req.flash('error_msg', 'You must be logged in to view this page.');
        req.session.returnTo = req.originalUrl;
        res.redirect('/auth/login');
    }
};

module.exports = { isAuthenticated };


middleware/errorMiddleware.js:
const notFound = (req, res, next) => {
  const error = new Error(`Not Found - ${req.originalUrl}`);
  res.status(404);
  next(error);
};

const errorHandler = (err, req, res, next) => {
  let statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  let message = err.message;

  if (err.name === 'CastError' && err.kind === 'ObjectId') {
    statusCode = 404;
    message = 'Resource not found';
  }
   if (err.name === 'ValidationError') {
       statusCode = 400;
       const errors = Object.values(err.errors).map(el => el.message);
       message = `Validation Error: ${errors.join(', ')}`;
   }
    if (err.code === 11000) {
       statusCode = 400;
       message = `Duplicate field value entered: ${Object.keys(err.keyValue)} already exists.`;
    }


  console.error("ERROR STACK: ", err.stack);

  if (req.accepts('html')) {
      res.status(statusCode).render('error', {
          title: 'Error',
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
          statusCode: statusCode
      });
  } else {
      res.status(statusCode).json({
          message: message,
          stack: process.env.NODE_ENV === 'development' ? err.stack : null,
      });
  }
};

module.exports = { notFound, errorHandler };


middleware/roleMiddleware.js:
// middleware/roleMiddleware.js
const Product = require('../models/Product');
const Order = require('../models/Order');
const mongoose = require('mongoose');

const isAdmin = (req, res, next) => {
  // Ensure user exists and has the 'admin' role
  if (req.session.user && req.session.user.role === 'admin') {
    return next(); // Use return to avoid executing further code
  } else {
    req.flash('error_msg', 'Access Denied: Admin privileges required.');
    return res.status(403).redirect('/'); // Use return
  }
};

// *** NEW: Middleware to check if user is a seller ***
const isSeller = (req, res, next) => {
  if (req.session.user && req.session.user.role === 'seller') {
    return next();
  } else {
    req.flash('error_msg', 'Access Denied: Seller privileges required.');
    return res.status(403).redirect('/');
  }
};

// *** NEW: Middleware to check if user is admin OR seller ***
const isAdminOrSeller = (req, res, next) => {
   if (req.session.user && (req.session.user.role === 'admin' || req.session.user.role === 'seller')) {
     return next();
   } else {
     req.flash('error_msg', 'Access Denied: Admin or Seller privileges required.');
     return res.status(403).redirect('/');
   }
};


// *** NEW: Middleware to check if the product belongs to the logged-in seller ***
// Apply this AFTER isAuthenticated and isSeller
const isProductOwner = async (req, res, next) => {
    const productId = req.params.id || req.params.productId; // Check common param names
    const sellerId = req.session.user._id;

    if (!mongoose.Types.ObjectId.isValid(productId)) {
         req.flash('error_msg', 'Invalid Product ID format.');
         return res.status(400).redirect('back'); // Redirect back if possible
    }

    try {
        const product = await Product.findById(productId).select('sellerId').lean(); // Only fetch sellerId

        if (!product) {
            req.flash('error_msg', 'Product not found.');
            return res.status(404).redirect('back');
        }

        if (product.sellerId.toString() !== sellerId.toString()) {
            req.flash('error_msg', 'Access Denied: You do not own this product.');
            return res.status(403).redirect('/seller/products'); // Redirect to their products page
        }

        // Attach product briefly for potential use later? Maybe not necessary.
        // req.product = product;
        next();
    } catch (error) {
         console.error("Error in isProductOwner middleware:", error);
         // Handle CastError specifically if lean() is removed or select changes
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid Product ID format.');
             return res.status(400).redirect('back');
         }
         req.flash('error_msg', 'An error occurred while verifying product ownership.');
         return res.status(500).redirect('back');
    }
};


// *** NEW: Middleware to check if an order contains products relevant to the logged-in seller ***
// Apply this AFTER isAuthenticated and isSeller
const isOrderRelevantToSeller = async (req, res, next) => {
    const orderId = req.params.orderId || req.params.id;
    const sellerId = req.session.user._id;

     if (!mongoose.Types.ObjectId.isValid(orderId)) {
         req.flash('error_msg', 'Invalid Order ID format.');
         return res.status(400).redirect('back');
    }

    try {
        // 1. Find products sold by this seller
        const sellerProductIds = await Product.find({ sellerId: sellerId }, '_id').lean();
        const sellerProductIdStrings = sellerProductIds.map(p => p._id.toString());

        if (sellerProductIdStrings.length === 0) {
             req.flash('error_msg', 'Access Denied: You have no products listed.');
             return res.status(403).redirect('/seller/orders');
        }

        // 2. Find the order and check if any product matches the seller's products
        // We only need to know IF there's a match, not the full order details yet
        const order = await Order.findOne({
            _id: orderId,
            'products.productId': { $in: sellerProductIdStrings.map(id => new mongoose.Types.ObjectId(id)) } // Convert back to ObjectId for query
        }).select('_id').lean(); // Select minimal field

        if (!order) {
            req.flash('error_msg', 'Order not found or does not contain your products.');
            return res.status(404).redirect('/seller/orders');
        }

        // Order is relevant
        next();

    } catch (error) {
        console.error("Error in isOrderRelevantToSeller middleware:", error);
         if (error.name === 'CastError') {
             req.flash('error_msg', 'Invalid ID format encountered.');
             return res.status(400).redirect('back');
         }
        req.flash('error_msg', 'An error occurred while verifying order relevance.');
        return res.status(500).redirect('back');
    }
};

module.exports = {
    isAdmin,
    isSeller,         // Export new middleware
    isAdminOrSeller,  // Export new middleware
    isProductOwner,   // Export new middleware
    isOrderRelevantToSeller // Export new middleware
};

models/BannerConfig.js:
// models/BannerConfig.js
const mongoose = require('mongoose');

const BannerSchema = new mongoose.Schema({
  imageUrl: { type: String, trim: true, required: true },
  linkUrl: { type: String, trim: true }, // Optional: URL to navigate to when banner is clicked
  title: { type: String, trim: true }, // Optional: Title/Alt text for the banner
}, { _id: false }); // Don't need separate IDs for each banner item in the array

const BannerConfigSchema = new mongoose.Schema({
  // Using a known key to ensure we only have one document (singleton pattern)
  configKey: {
    type: String,
    default: 'mainBanners',
    unique: true, // Enforces only one banner config document
    required: true,
  },
  banners: {
    type: [BannerSchema],
    validate: [arrayLimit, '{PATH} exceeds the limit of 4 banners'] // Custom validator
  },
  lastUpdatedBy: { // Track who last updated it
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true // Adds createdAt and updatedAt
});

// Custom validator function for array limit
function arrayLimit(val) {
  return val.length <= 4;
}

const BannerConfig = mongoose.model('BannerConfig', BannerConfigSchema);

module.exports = BannerConfig;

models/Order.js:
// models/Order.js
const mongoose = require('mongoose');

const OrderProductSchema = new mongoose.Schema({
    productId: { type: mongoose.Schema.Types.ObjectId, ref: 'Product', required: true },
    name: { type: String, required: true },
    priceAtOrder: { type: Number, required: true },
    quantity: { type: Number, required: true, min: 1 },
    imageUrl: { type: String },
    sellerId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
}, { _id: false });

const OrderAddressSchema = new mongoose.Schema({
    name: { type: String, trim: true, required: true },
    phone: { type: String, trim: true, required: true },
    pincode: { type: String, trim: true, required: true },
    // **** ADD LOCALITY ****
    locality: { type: String, trim: true, required: true }, // Selected from dropdown
    // **** END LOCALITY ****
    cityVillage: { type: String, trim: true, required: true }, // For House No / Building / Area
    landmarkNearby: { type: String, trim: true }, // Optional Landmark
    mandal: { type: String, trim: true },     // Derived from pincode lookup
    district: { type: String, trim: true },   // Derived from pincode lookup
    state: { type: String, trim: true },      // Derived from pincode lookup
}, { _id: false });


const OrderSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
    },
    userEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    products: [OrderProductSchema],
    totalAmount: {
        type: Number,
        required: true,
        min: 0,
    },
    shippingAddress: {
        type: OrderAddressSchema, // Now includes the locality field
        required: true
    },
    paymentMethod: {
        type: String,
        enum: ['COD'],
        required: true,
        default: 'COD',
    },
    status: {
        type: String,
        enum: ['Pending', 'Delivered', 'Cancelled'],
        default: 'Pending',
    },
    orderDate: {
        type: Date,
        default: Date.now,
    },
    receivedByDate: {
        type: Date,
    },
    orderOTP: String,
    orderOTPExpires: Date,
    cancellationAllowedUntil: {
        type: Date,
    },
    cancellationReason: {
        type: String,
        trim: true,
    }
}, {
    timestamps: true
});

OrderSchema.pre('save', function(next) {
    if (this.isNew && !this.cancellationAllowedUntil) {
        const now = this.orderDate || Date.now();
        this.cancellationAllowedUntil = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour
    }

    // Clear OTP and related fields on cancellation or delivery
    if (this.isModified('status') && (this.status === 'Cancelled' || this.status === 'Delivered')) {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
        this.cancellationAllowedUntil = undefined; // Disable cancellation
        if (this.status === 'Cancelled') {
            this.receivedByDate = undefined; // Clear received date if cancelled
        }
    }
     // Also clear OTP if status changes FROM Pending to something else (but might be redundant with above)
     if (this.isModified('status') && this.status !== 'Pending') {
        this.orderOTP = undefined;
        this.orderOTPExpires = undefined;
    }

    next();
});

const Order = mongoose.model('Order', OrderSchema);

module.exports = Order;

models/Product.js:
// models/Product.js
const mongoose = require('mongoose');
const { categoryNames } = require('../config/categories');

const RatingSchema = new mongoose.Schema({
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    rating: { type: Number, required: true, min: 1, max: 5 },
    comment: { type: String, trim: true },
}, { _id: false, timestamps: true });


const ProductSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide a product name'],
        trim: true,
        index: true
    },
    shortDescription: {
        type: String,
        trim: true,
        maxlength: 200
    },
    category: {
        type: String,
        required: [true, 'Please select a product category'],
        trim: true,
        index: true,
        enum: {
            values: categoryNames,
            message: '{VALUE} is not a supported category.'
        }
    },
    price: {
        type: Number,
        required: [true, 'Please provide a product price'],
        min: 0,
    },
    stock: {
        type: Number,
        required: [true, 'Please provide product stock quantity'],
        min: 0,
        default: 0,
    },
    imageUrl: { // First (required) image
        type: String,
        required: [true, 'Please provide a product image URL'],
        trim: true,
    },
    // --- UPDATED: Added imageUrl2 ---
    imageUrl2: { // Second (optional) image
        type: String,
        trim: true,
    },
    // --- END UPDATED ---
    specifications: {
        type: String,
        trim: true,
    },
    sellerId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true
    },
    sellerEmail: {
        type: String,
        required: true,
        lowercase: true,
        trim: true,
    },
    ratings: [RatingSchema],
    averageRating: {
      type: Number,
      default: 0,
    },
    numReviews: {
        type: Number,
        default: 0,
    },
    orderCount: {
        type: Number,
        default: 0,
    },
    reviewStatus: {
        type: String,
        enum: ['pending', 'approved', 'rejected'],
        default: 'pending',
        index: true
    },
    rejectionReason: {
        type: String,
        trim: true
    }
}, {
    timestamps: true
});

// Pre-save hook remains the same
ProductSchema.pre('save', function(next) {
    if (this.isModified('ratings')) {
        if (this.ratings && this.ratings.length > 0) {
            this.numReviews = this.ratings.length;
            this.averageRating = this.ratings.reduce((acc, item) => item.rating + acc, 0) / this.ratings.length;
        } else {
            this.numReviews = 0;
            this.averageRating = 0;
        }
    }

    if (this.isModified('reviewStatus') && this.reviewStatus !== 'rejected') {
        this.rejectionReason = undefined;
    }
    next();
});

ProductSchema.index({ name: 'text', category: 'text', specifications: 'text' });


const Product = mongoose.model('Product', ProductSchema);

module.exports = Product;

models/User.js:
// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const AddressSchema = new mongoose.Schema({
    name: { type: String, trim: true },
    phone: { type: String, trim: true },
    pincode: { type: String, trim: true },
    // **** ADD LOCALITY ****
    locality: { type: String, trim: true }, // Selected from dropdown
    // **** END LOCALITY ****
    cityVillage: { type: String, trim: true }, // For House No / Building / Area
    landmarkNearby: { type: String, trim: true }, // Optional Landmark
    mandal: { type: String, trim: true },     // Derived from pincode lookup
    district: { type: String, trim: true },   // Derived from pincode lookup
    state: { type: String, trim: true },      // Derived from pincode lookup
}, { _id: false });

const CartItemSchema = new mongoose.Schema({
    productId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Product',
        required: true,
    },
    quantity: {
        type: Number,
        required: true,
        min: 1,
        default: 1,
    }
}, { _id: false });

const UserSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [true, 'Please provide your name'],
        trim: true,
    },
    email: {
        type: String,
        required: [true, 'Please provide your email'],
        unique: true,
        match: [
            /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            'Please provide a valid email address',
        ],
        lowercase: true,
        trim: true,
    },
    password: {
        type: String,
        required: [true, 'Please provide a password'],
        minlength: 6,
        select: false, // Keep password hidden by default
    },
    role: {
        type: String,
        enum: ['user', 'admin', 'seller'],
        default: 'user',
    },
    isVerified: {
        type: Boolean,
        default: false,
    },
    otp: { type: String },
    otpExpires: { type: Date },
    address: AddressSchema, // Contains the new fields now
    cart: [CartItemSchema],

    resetPasswordToken: String,
    resetPasswordExpires: Date,
}, {
    timestamps: true
});

// Hash password before saving
UserSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();
    try {
        const salt = await bcrypt.genSalt(10);
        this.password = await bcrypt.hash(this.password, salt);
        next();
    } catch (error) {
        next(error); // Pass error to mongoose error handling
    }
});

// Method to compare entered password with hashed password
UserSchema.methods.matchPassword = async function(enteredPassword) {
    if (!this.password) {
        const userWithPassword = await mongoose.model('User').findById(this._id).select('+password').exec();
        if (!userWithPassword) return false;
        return await bcrypt.compare(enteredPassword, userWithPassword.password);
    }
    return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', UserSchema);

module.exports = User;

public/css/style.css:
/* public/css/style.css */
/* Microsoft Fluent-Inspired E-commerce Theme */

*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* Microsoft-Inspired Color Palette */
  --primary-blue: #0078D4; /* Standard Microsoft Blue */
  --primary-blue-hover: #005A9E;
  --primary-blue-active: #004578;
  --primary-blue-light: #EFF6FC; /* Light background tint */

  --neutral-primary: #323130; /* Dark Grey for primary text */
  --neutral-secondary: #605E5C; /* Medium Grey for secondary text */
  --neutral-tertiary: #A19F9D; /* Lighter Grey for hints, disabled */
  --neutral-quaternary: #C8C6C4;
  --neutral-light: #EDEBE9; /* Very light grey for backgrounds/borders */
  --neutral-lighter: #F3F2F1; /* Lighter background */
  --neutral-white: #FFFFFF;

  --status-success: #107C10; /* Green */
  --status-success-bg: #DFF6DD;
  --status-danger: #D83B01; /* Red/Orange */
  --status-danger-bg: #FDE7E9;
  --status-warning: #FFB900; /* Yellow */
  --status-warning-bg: #FFF4CE;
  --status-info: #0078D4; /* Blue */
  --status-info-bg: #EFF6FC;
  --status-pending-bg: #FFF4CE; /* Reuse warning bg for pending */
  --status-pending-text: #8C6D0F; /* Dark yellow text */

  /* Typography */
  --font-family-base: "Segoe UI", "Roboto", "Helvetica Neue", Arial, sans-serif;
  --font-size-base: 1rem; /* 16px */
  --font-size-sm: 0.875rem; /* 14px */
  --font-size-lg: 1.125rem; /* 18px */
  --font-weight-light: 300;
  --font-weight-normal: 400;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  --line-height-base: 1.5;

  /* Borders & Shadows */
  --border-radius: 4px;
  --border-color: var(--neutral-light);
  --box-shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.06);
  --box-shadow-md: 0 4px 8px rgba(0, 0, 0, 0.1);

  /* Spacing */
  --space-unit: 8px; /* Base spacing unit */
  --space-xs: calc(var(--space-unit) * 0.5);  /* 4px */
  --space-sm: var(--space-unit);            /* 8px */
  --space-md: calc(var(--space-unit) * 1.5); /* 12px */
  --space-lg: calc(var(--space-unit) * 2);   /* 16px */
  --space-xl: calc(var(--space-unit) * 3);   /* 24px */
  --space-xxl: calc(var(--space-unit) * 4);  /* 32px */
}

html {
  font-size: var(--font-size-base);
  scroll-behavior: smooth;
}

body {
  font-family: var(--font-family-base);
  line-height: var(--line-height-base);
  color: var(--neutral-primary);
  background-color: var(--neutral-lighter); /* Use light grey background */
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  color: var(--primary-blue);
  text-decoration: none;
  transition: color 0.15s ease-in-out;
}
a:hover {
  color: var(--primary-blue-hover);
  text-decoration: underline;
}

img {
  max-width: 100%;
  height: auto;
  display: block;
}

h1, h2, h3, h4, h5, h6 {
  margin-bottom: var(--space-lg);
  line-height: 1.3;
  font-weight: var(--font-weight-semibold);
}
h1 { font-size: 1.75rem; } /* ~28px */
h2 { font-size: 1.5rem; }  /* ~24px */
h3 { font-size: 1.25rem; } /* ~20px */
h4 { font-size: 1.125rem; }/* ~18px */

p { margin-bottom: var(--space-lg); }
ul, ol { padding-left: var(--space-xl); margin-bottom: var(--space-lg); }

/* --- Utility Classes --- */
.hidden, .hide { display: none !important; }
.text-center { text-align: center; }
.text-danger { color: var(--status-danger) !important; }
.text-success { color: var(--status-success) !important; }
.text-warning { color: var(--status-warning) !important; }
.text-info { color: var(--status-info) !important; }
.text-muted { color: var(--neutral-secondary) !important; }
.mb-1 { margin-bottom: var(--space-xs) !important; }
.mb-2 { margin-bottom: var(--space-sm) !important; }
.mb-3 { margin-bottom: var(--space-lg) !important; }
.mb-4 { margin-bottom: var(--space-xl) !important; }
.mt-1 { margin-top: var(--space-xs) !important; }
.mt-2 { margin-top: var(--space-sm) !important; }
.mt-3 { margin-top: var(--space-lg) !important; }
.mt-4 { margin-top: var(--space-xl) !important; }
.ms-1 { margin-left: var(--space-xs) !important; }
.ms-2 { margin-left: var(--space-sm) !important; }
.me-1 { margin-right: var(--space-xs) !important; }
.me-2 { margin-right: var(--space-sm) !important; }
.me-3 { margin-right: var(--space-lg) !important; }
.p-1 { padding: var(--space-xs) !important; }
.p-2 { padding: var(--space-sm) !important; }
.p-3 { padding: var(--space-lg) !important; }
.pt-1 { padding-top: var(--space-xs) !important; }
.pt-2 { padding-top: var(--space-sm) !important; }
.pt-3 { padding-top: var(--space-lg) !important; }
.pb-1 { padding-bottom: var(--space-xs) !important; }
.pb-2 { padding-bottom: var(--space-sm) !important; }
.pb-3 { padding-bottom: var(--space-lg) !important; }
.d-flex { display: flex !important; }
.d-inline-flex { display: inline-flex !important; }
.d-block { display: block !important; }
.d-inline-block { display: inline-block !important; }
.align-items-center { align-items: center !important; }
.justify-content-between { justify-content: space-between !important; }
.justify-content-center { justify-content: center !important; }
.flex-wrap { flex-wrap: wrap !important; }
.flex-grow-1 { flex-grow: 1 !important; }
.gap-1 { gap: var(--space-xs) !important; }
.gap-2 { gap: var(--space-sm) !important; }
.gap-3 { gap: var(--space-lg) !important; }
.small { font-size: var(--font-size-sm); }
.fs-5 { font-size: 1.25rem !important; }
.w-100 { width: 100% !important; }
.visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
.fw-bold { font-weight: var(--font-weight-bold) !important; }
.fw-normal { font-weight: var(--font-weight-normal) !important; }
.fw-semibold { font-weight: var(--font-weight-semibold) !important; }
.text-capitalize { text-transform: capitalize !important; }
.border { border: 1px solid var(--border-color) !important; }
.border-top { border-top: 1px solid var(--border-color) !important; }
.border-bottom { border-bottom: 1px solid var(--border-color) !important; }
.rounded { border-radius: var(--border-radius) !important; }

/* --- Forms --- */
.form-group { margin-bottom: var(--space-lg); }
label:not(.form-label-inline) { display: block; margin-bottom: var(--space-sm); font-weight: var(--font-weight-semibold); font-size: var(--font-size-sm); }
label.form-label-inline { margin-bottom: 0; margin-right: var(--space-sm); font-weight: normal; }

input[type="text"], input[type="email"], input[type="password"], input[type="tel"], input[type="url"], input[type="number"], input[type="search"], textarea, select {
  width: 100%;
  padding: var(--space-sm) var(--space-md);
  border: 1px solid var(--neutral-secondary); /* Slightly darker default border */
  border-radius: var(--border-radius);
  font-size: var(--font-size-sm);
  line-height: var(--line-height-base);
  background-color: var(--neutral-white);
  color: var(--neutral-primary);
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}
.form-control { /* Ensure .form-control matches base input styles */
    display: block;
    width: 100%;
    padding: var(--space-sm) var(--space-md);
    font-size: var(--font-size-sm);
    font-weight: var(--font-weight-normal);
    line-height: var(--line-height-base);
    color: var(--neutral-primary);
    background-color: var(--neutral-white);
    background-clip: padding-box;
    border: 1px solid var(--neutral-secondary);
    appearance: none;
    border-radius: var(--border-radius);
    transition: border-color .15s ease-in-out,box-shadow .15s ease-in-out;
}
textarea { resize: vertical; min-height: 80px; }
input[type="number"] { appearance: textfield; -moz-appearance: textfield; }
input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

input:focus, textarea:focus, select:focus, .form-control:focus {
  border-color: var(--primary-blue);
  outline: 0;
  box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3); /* Subtle blue focus ring */
}
input[readonly], .form-control[readonly] {
  background-color: var(--neutral-light);
  opacity: 1;
  cursor: default;
}

.form-control-sm {
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--font-size-sm);
  border-radius: var(--border-radius);
}
select.form-control-sm { height: auto; }

.inline-form { display: inline-flex; gap: var(--space-sm); align-items: center; vertical-align: middle; margin-bottom: 0; }
.inline-form > * { margin-bottom: 0; }

/* --- Buttons --- */
.btn {
  display: inline-block;
  font-weight: var(--font-weight-semibold);
  color: var(--neutral-white);
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
  user-select: none;
  background-color: var(--primary-blue);
  border: 1px solid var(--primary-blue);
  padding: var(--space-sm) var(--space-lg);
  font-size: var(--font-size-sm);
  line-height: var(--line-height-base);
  border-radius: var(--border-radius);
  transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
  text-transform: none; /* No capitalize */
}
.btn:hover {
  color: var(--neutral-white);
  text-decoration: none;
  background-color: var(--primary-blue-hover);
  border-color: var(--primary-blue-hover);
}
.btn:active {
  background-color: var(--primary-blue-active);
  border-color: var(--primary-blue-active);
}
.btn:focus {
  outline: 0;
  box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.5);
}
.btn:disabled, .btn.loading {
  background-color: var(--neutral-light);
  border-color: var(--neutral-light);
  color: var(--neutral-tertiary);
  cursor: not-allowed;
  pointer-events: none;
  opacity: 1;
}

.btn-primary { background-color: var(--primary-blue); border-color: var(--primary-blue); color: var(--neutral-white); }
.btn-primary:hover { background-color: var(--primary-blue-hover); border-color: var(--primary-blue-hover); }
.btn-secondary { background-color: var(--neutral-secondary); border-color: var(--neutral-secondary); color: var(--neutral-white); }
.btn-secondary:hover { background-color: var(--neutral-primary); border-color: var(--neutral-primary); }
.btn-success { background-color: var(--status-success); border-color: var(--status-success); color: var(--neutral-white); }
.btn-success:hover { background-color: #0b6a0b; border-color: #0b6a0b; }
.btn-danger { background-color: var(--status-danger); border-color: var(--status-danger); color: var(--neutral-white); }
.btn-danger:hover { background-color: #a82c00; border-color: #a82c00; }
.btn-warning { background-color: var(--status-warning); border-color: var(--status-warning); color: var(--neutral-primary); }
.btn-warning:hover { background-color: #f0ac00; border-color: #f0ac00; }
.btn-info { background-color: var(--status-info); border-color: var(--status-info); color: var(--neutral-white); }
.btn-info:hover { background-color: var(--primary-blue-hover); border-color: var(--primary-blue-hover); }

.btn-outline-secondary { color: var(--neutral-secondary); border-color: var(--neutral-secondary); background-color: transparent; }
.btn-outline-secondary:hover { color: var(--neutral-white); background-color: var(--neutral-secondary); }
.btn-outline-primary { color: var(--primary-blue); border-color: var(--primary-blue); background-color: transparent; }
.btn-outline-primary:hover { color: var(--neutral-white); background-color: var(--primary-blue); }

.btn-text {
    background-color: transparent; border-color: transparent; color: var(--primary-blue);
    padding: var(--space-xs) var(--space-sm); font-weight: var(--font-weight-normal);
}
.btn-text:hover, .btn-text:focus { background-color: var(--neutral-light); color: var(--primary-blue-hover); text-decoration: none; outline: none; box-shadow: none; }
.btn-text.btn-danger { color: var(--status-danger); }
.btn-text.btn-danger:hover, .btn-text.btn-danger:focus { color: #a82c00; background-color: var(--status-danger-bg); }

.btn-sm { padding: var(--space-xs) var(--space-md); font-size: var(--font-size-sm); }
.btn-lg { padding: var(--space-md) var(--space-xl); font-size: var(--font-size-lg); }
.btn-block { display: block; width: 100%; }

.btn .fa-spinner { margin-right: var(--space-sm); animation: fa-spin 1s infinite linear; }
@keyframes fa-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

/* --- Alerts & Toasts --- */
.alert {
  padding: var(--space-md) var(--space-lg); margin-bottom: var(--space-lg);
  border: 1px solid transparent; border-radius: var(--border-radius);
  position: relative; font-size: var(--font-size-sm);
}
.alert-success { color: #0b6a0b; background-color: var(--status-success-bg); border-color: #a7d7a7; }
.alert-danger { color: #a82c00; background-color: var(--status-danger-bg); border-color: #f7c9c9; }
.alert-warning { color: #8C6D0F; background-color: var(--status-warning-bg); border-color: #ffe9a6; }
.alert-info { color: #005A9E; background-color: var(--status-info-bg); border-color: #a9d6f5; }
.alert-link { font-weight: var(--font-weight-semibold); color: inherit; text-decoration: underline; }
.close-alert { /* Positioned absolutely via JS if needed */ }

/* Toast Notifications (Positioning from JS, styling here) */
.toast-container {
    position: fixed;
    top: var(--space-lg);
    right: var(--space-lg);
    z-index: 1055;
    width: auto;
    max-width: 350px;
}
.toast {
  background-color: var(--neutral-white); border: 1px solid var(--border-color);
  border-radius: var(--border-radius); box-shadow: var(--box-shadow-md);
  margin-bottom: var(--space-lg); padding: var(--space-md);
  position: relative; opacity: 0; transform: translateX(110%);
  transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
  width: 100%; pointer-events: auto; min-height: 50px;
  display: flex; align-items: center; overflow: hidden;
}
.toast.show { opacity: 1; transform: translateX(0); }
.toast.hide { opacity: 0; transition: opacity 0.3s ease-in, transform 0.3s ease-in; }
.toast-body { flex-grow: 1; font-size: var(--font-size-sm); line-height: 1.4; padding-right: var(--space-xl); }
.toast-close-btn {
  position: absolute; top: 50%; right: var(--space-md); transform: translateY(-50%);
  background: transparent; border: none; font-size: 1.4rem; line-height: 1;
  font-weight: bold; color: inherit; opacity: 0.6; cursor: pointer; padding: 0.1rem 0.4rem;
}
.toast-close-btn:hover { opacity: 1; text-decoration: none; }
.toast-success { background-color: var(--status-success-bg); color: #0b6a0b; border-left: 4px solid var(--status-success); }
.toast-danger { background-color: var(--status-danger-bg); color: #a82c00; border-left: 4px solid var(--status-danger); }
.toast-warning { background-color: var(--status-warning-bg); color: #8C6D0F; border-left: 4px solid var(--status-warning); }
.toast-info { background-color: var(--status-info-bg); color: #005A9E; border-left: 4px solid var(--status-info); }
.toast-success .toast-close-btn, .toast-danger .toast-close-btn, .toast-warning .toast-close-btn, .toast-info .toast-close-btn { color: inherit; }


/* --- Header / Navbar --- */
.app-header {
  background-color: var(--primary-blue);
  color: var(--neutral-white);
  padding: var(--space-sm) var(--space-lg);
  position: sticky; top: 0; left: 0; width: 100%; z-index: 1000;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
.navbar {
  display: flex; justify-content: space-between; align-items: center;
  max-width: 1200px; margin: 0 auto; gap: var(--space-md); min-height: 40px;
}
.nav-left { display: flex; align-items: center; flex-shrink: 0; margin-right: auto; }
.app-logo {
  display: flex; align-items: center; color: var(--neutral-white);
  font-size: 1.1rem; font-weight: var(--font-weight-semibold); text-decoration: none; margin-right: var(--space-lg);
}
.app-logo:hover, .app-logo:focus { color: var(--neutral-white); text-decoration: none; opacity: 0.9; }
.app-logo i { margin-right: var(--space-sm); font-size: 1.2em; }

/* Search Bar */
.search-container-dynamic { flex-grow: 0; max-width: none; order: 1; margin: 0; position: static; }
.search-form-dynamic {
  display: flex; align-items: center; width: 100%; height: 36px; /* Smaller height */
  background-color: var(--neutral-white); border: 1px solid transparent; /* No border initially */
  border-radius: var(--border-radius); transition: border-color 0.2s ease, box-shadow 0.2s ease;
  overflow: hidden; color: var(--neutral-primary);
}
#search-input-dynamic {
  flex-grow: 1; padding: 0 var(--space-md); border: none; background-color: transparent;
  color: var(--neutral-primary); font-size: var(--font-size-sm); height: 100%; outline: none;
}
#search-input-dynamic::placeholder { color: var(--neutral-tertiary); opacity: 1; }
.search-submit-btn-dynamic {
  background: transparent; border: none; color: var(--neutral-secondary); padding: 0 var(--space-md);
  cursor: pointer; font-size: 1rem; height: 100%; display: flex; align-items: center;
  flex-shrink: 0; transition: color 0.15s ease-in-out;
}
.search-submit-btn-dynamic:hover { color: var(--primary-blue); }
/* Focus state for the entire search form */
.search-form-dynamic:focus-within { border-color: var(--primary-blue); box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3); }

/* Search Suggestions */
.suggestions-dropdown {
  display: none; position: absolute; left: 0; right: 0;
  background-color: var(--neutral-white); border: 1px solid var(--border-color); border-top: none;
  border-radius: 0 0 var(--border-radius) var(--border-radius);
  box-shadow: var(--box-shadow-md); max-height: 400px; overflow-y: auto; z-index: 1010;
}
.suggestions-dropdown.active { display: block; }
.suggestion-item {
  display: flex; align-items: center; padding: var(--space-sm) var(--space-md);
  cursor: pointer; color: var(--neutral-primary); text-decoration: none;
  border-bottom: 1px solid var(--neutral-lighter); gap: var(--space-md);
}
.suggestion-item:last-child { border-bottom: none; }
.suggestion-item:hover, .suggestion-item:focus { background-color: var(--neutral-lighter); text-decoration: none; color: var(--neutral-primary); }
.suggestion-item img { width: 32px; height: 32px; object-fit: cover; border-radius: var(--border-radius); flex-shrink: 0; }
.suggestion-item span { font-size: var(--font-size-sm); line-height: 1.3; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.suggestion-item i { font-style: normal; color: var(--neutral-secondary); }

/* Nav Right Items */
.nav-right { display: flex; align-items: center; flex-shrink: 0; gap: var(--space-xs); }
.nav-link { /* Mobile first: Icon only */
  color: var(--neutral-white); padding: var(--space-sm); border-radius: var(--border-radius);
  display: flex; flex-direction: column; align-items: center;
  font-size: 0.65rem; /* Smaller text for mobile icon label */
  text-decoration: none; background: none; border: none; cursor: pointer;
  transition: background-color 0.2s ease; line-height: 1.1; width: 50px; /* Fixed width for alignment */
}
.nav-link span { display: block; margin-top: 2px; } /* Show text below icon on mobile */
.nav-link i { font-size: 1.1rem; margin-bottom: 2px; }
.nav-link:hover, .nav-link.active, .nav-link:focus {
  background-color: rgba(255, 255, 255, 0.1); color: var(--neutral-white); text-decoration: none; outline: none;
}

/* Cart Badge */
.nav-link-cart { position: relative; }
.cart-badge {
  position: absolute; top: 2px; right: 2px; background-color: var(--status-danger);
  color: white; border-radius: 50%; padding: 1px 5px; font-size: 0.7rem;
  font-weight: var(--font-weight-bold); line-height: 1; pointer-events: none; border: 1px solid white;
}
.cart-badge.hide { display: none; }

/* Login/Register Button */
.btn-login-register {
    font-size: var(--font-size-sm); padding: var(--space-sm) var(--space-md);
    background-color: var(--neutral-white); color: var(--primary-blue);
    border: 1px solid var(--primary-blue); font-weight: var(--font-weight-semibold);
}
.btn-login-register:hover, .btn-login-register:focus { background-color: #f0f0f0; color: var(--primary-blue-hover); border-color: var(--primary-blue-hover);}
.btn-login-register i { margin-right: var(--space-sm); }

/* Profile Avatar */
.profile-avatar-link {
    display: inline-flex; align-items: center; justify-content: center;
    width: 32px; height: 32px; border-radius: 50%;
    background-color: var(--neutral-lighter); color: var(--primary-blue);
    font-weight: var(--font-weight-semibold); font-size: var(--font-size-sm);
    text-decoration: none; transition: transform 0.2s ease, box-shadow 0.2s ease;
    border: 1px solid transparent; margin-left: var(--space-sm);
}
.profile-avatar-link:hover, .profile-avatar-link:focus, .profile-avatar-link.active {
    text-decoration: none; box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.4); outline: none;
}
.profile-avatar-initials { line-height: 1; }

/* Mobile Search Toggle */
.search-toggle-btn { display: flex; order: 0; }

/* --- Main Container & Footer --- */
.container { width: 100%; padding: var(--space-lg); margin: 0 auto; flex-grow: 1; max-width: 1200px; }
.app-footer {
  display: none; /* Hidden by default, shown on desktop */
  padding: var(--space-lg); text-align: center; font-size: var(--font-size-sm);
  color: var(--neutral-secondary); background-color: var(--neutral-lighter);
  border-top: 1px solid var(--border-color); margin-top: auto;
}

/* --- Product Grid --- */
.product-index-container h1 { font-size: 1.5rem; }
.product-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: var(--space-lg); }
.product-card {
  background-color: var(--neutral-white); border: 1px solid var(--border-color);
  border-radius: var(--border-radius); overflow: hidden; display: flex; flex-direction: column;
  box-shadow: var(--box-shadow-sm); transition: transform 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}
.product-card:hover { transform: translateY(-2px); box-shadow: var(--box-shadow-md); }
.product-link { color: inherit; text-decoration: none; flex-grow: 1; display: flex; flex-direction: column; }
.product-link:hover { color: inherit; text-decoration: none; }
.product-image { width: 100%; aspect-ratio: 1 / 1; object-fit: cover; }
.product-info { padding: var(--space-md); flex-grow: 1; }
.product-name {
  font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-xs);
  line-height: 1.3; height: 2.6em; overflow: hidden; text-overflow: ellipsis;
  display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
}
.product-price { font-weight: var(--font-weight-semibold); color: var(--neutral-primary); margin-bottom: var(--space-xs); font-size: 1rem; }
.product-stock, .product-rating { font-size: 0.8rem; color: var(--neutral-secondary); margin-bottom: var(--space-xs); }
.product-rating .fa-star, .product-rating .fa-star-half-alt { color: #f8d347; }
.product-rating .fa-star-regular { color: var(--neutral-quaternary); }
.add-to-cart-form { padding: 0 var(--space-md) var(--space-md); }
.btn-add-to-cart { width: 100%; padding: var(--space-sm); font-size: var(--font-size-sm); }
.btn-add-to-cart i { margin-right: var(--space-sm); }

/* --- Product Detail --- */
.product-detail-container { background-color: var(--neutral-white); padding: var(--space-xl); border-radius: var(--border-radius); box-shadow: var(--box-shadow-sm); }
.product-detail-main { display: flex; flex-direction: column; gap: var(--space-xl); }

.product-detail-info h1 { font-size: 1.75rem; margin-bottom: var(--space-sm); }
.product-short-description { font-size: var(--font-size-sm); color: var(--neutral-secondary); }
.detail-price { font-size: 1.5rem; font-weight: var(--font-weight-semibold); color: var(--neutral-primary); margin-bottom: var(--space-xs); }
.detail-stock { font-size: var(--font-size-sm); color: var(--neutral-secondary); margin-bottom: var(--space-sm); }
.detail-stock .text-danger { color: var(--status-danger) !important; }
.share-section { margin: var(--space-md) 0; }
.share-section .btn { font-weight: var(--font-weight-normal); }
.fallback-share-links { margin-top: var(--space-sm); }
.fallback-share-links small { font-size: 0.8rem; margin-right: var(--space-sm); }
.fallback-share-links a { margin: 0 var(--space-xs); font-size: 1.5rem; color: var(--neutral-secondary); }
.fallback-share-links a:hover { color: var(--primary-blue); }
.detail-rating { margin-bottom: var(--space-lg); font-size: var(--font-size-sm); color: var(--neutral-secondary); }
.detail-rating i { color: #f8d347; } .detail-rating .fa-star-regular { color: var(--neutral-quaternary); }
.product-actions { margin: var(--space-xl) 0; display: flex; flex-direction: column; gap: var(--space-md); }
.quantity-selector { display: flex; align-items: center; margin-bottom: var(--space-md); max-width: 150px; }
.quantity-selector label { font-size: var(--font-size-sm); margin: 0 var(--space-sm) 0 0; }
.quantity-selector input { text-align: center; font-size: 1rem; padding: var(--space-xs); width: 60px; }
.product-actions .btn { width: 100%; padding: var(--space-md); font-size: 1rem; }
.product-specifications { margin-top: var(--space-xl); }
.product-specifications h3 { font-size: 1.25rem; border-bottom: 1px solid var(--border-color); padding-bottom: var(--space-sm); margin-bottom: var(--space-md); }
.product-specifications pre { white-space: pre-wrap; font-size: var(--font-size-sm); background-color: var(--neutral-lighter); padding: var(--space-md); border-radius: var(--border-radius); max-height: 250px; overflow-y: auto; font-family: Consolas, monospace; }

/* Rating Section */
.product-rating-section { margin-top: var(--space-xl); border-top: 1px solid var(--border-color); padding-top: var(--space-xl); }
.product-rating-section h3 { font-size: 1.25rem; margin-bottom: var(--space-md); }
.rating-stars { display: inline-flex; flex-direction: row-reverse; justify-content: flex-end; margin-bottom: var(--space-lg); }
.rating-stars input[type="radio"] { display: none; }
.rating-stars label { display: inline-block; cursor: pointer; font-size: 1.8rem; color: var(--neutral-light); padding: 0 0.1em; margin: 0; transition: color 0.2s ease-in-out; }
.rating-stars label:hover, .rating-stars label:hover ~ label { color: #f8d347; }
.rating-stars input[type="radio"]:checked ~ label { color: #f8d347; }
.rating-stats-container { margin-top: var(--space-xxl); padding-top: var(--space-xl); border-top: 1px solid var(--border-color); }
.rating-stats-container h3 { margin-bottom: var(--space-lg); font-size: 1.25rem; color: var(--neutral-primary); }
.rating-summary { display: flex; align-items: center; margin-bottom: var(--space-xl); gap: var(--space-lg); }
.rating-average { display: flex; align-items: center; }
.rating-average-value { font-size: 2.5em; font-weight: var(--font-weight-semibold); margin-right: var(--space-xs); color: var(--neutral-primary); }
.rating-average .fa-star { font-size: 1.2em; color: var(--neutral-secondary); margin-bottom: 8px; }
.rating-total { font-size: 1rem; color: var(--neutral-secondary); }
.rating-bars { max-width: 400px; margin: 0 auto; }
.rating-bar-row { display: flex; align-items: center; margin-bottom: var(--space-sm); gap: var(--space-md); }
.rating-bar-label { width: 45px; font-size: var(--font-size-sm); color: var(--neutral-primary); text-align: right; flex-shrink: 0; }
.rating-bar-label .fa-star { color: #f8d347; font-size: 0.9em; }
.rating-bar-progress { flex-grow: 1; height: 8px; background-color: var(--neutral-light); border-radius: 4px; overflow: hidden; }
.progress-bar { background-color: var(--primary-blue); color: #fff; display: flex; flex-direction: column; justify-content: center; overflow: hidden; text-align: center; white-space: nowrap; transition: width .6s ease; }
.rating-bar-fill { height: 100%; background-color: var(--status-success); border-radius: 4px; transition: width 0.3s ease-in-out; }
/* Adjust bar colors if needed */
.rating-bar-row:nth-child(1) .rating-bar-fill { background-color: var(--status-success); } /* 5 stars */
.rating-bar-row:nth-child(2) .rating-bar-fill { background-color: #54a854; } /* 4 stars */
.rating-bar-row:nth-child(3) .rating-bar-fill { background-color: var(--status-warning); } /* 3 stars */
.rating-bar-row:nth-child(4) .rating-bar-fill { background-color: #ff8c00; } /* 2 stars */
.rating-bar-row:nth-child(5) .rating-bar-fill { background-color: var(--status-danger); } /* 1 star */
.rating-bar-count { width: 40px; font-size: var(--font-size-sm); color: var(--neutral-secondary); text-align: right; flex-shrink: 0; }

/* --- Auth Pages --- */
.auth-container {
  max-width: 400px; margin: var(--space-xxl) auto; padding: var(--space-xl);
  background-color: var(--neutral-white); border: 1px solid var(--border-color);
  border-radius: var(--border-radius); box-shadow: var(--box-shadow-sm);
}
.auth-container h1 { font-size: 1.5rem; text-align: center; margin-bottom: var(--space-xl); }
.auth-form .btn { width: 100%; margin-top: var(--space-lg); padding: var(--space-md); font-size: 1rem; }
.auth-links { margin-top: var(--space-xl); font-size: var(--font-size-sm); text-align: center; }
.auth-links p { margin-bottom: var(--space-sm); }
.auth-container p:not(.auth-links p) { text-align: center; margin-bottom: var(--space-lg); font-size: var(--font-size-sm); color: var(--neutral-secondary); }
.auth-container form ~ .auth-links { border-top: 1px solid var(--border-color); padding-top: var(--space-lg); }
#otp { text-align: center; font-size: 1.2rem; letter-spacing: 4px; font-family: Consolas, monospace; }

/* --- Cart --- */
.cart-container h1 { font-size: 1.5rem; margin-bottom: var(--space-lg); }
.cart-items { margin-bottom: var(--space-xl); }
.cart-item {
  display: grid; grid-template-columns: 80px 1fr auto;
  grid-template-areas: "image details remove" "image quantity subtotal";
  gap: var(--space-md); background-color: var(--neutral-white);
  padding: var(--space-lg); border-bottom: 1px solid var(--border-color);
  border-radius: var(--border-radius); margin-bottom: var(--space-lg); box-shadow: var(--box-shadow-sm);
}
.cart-item-image { grid-area: image; align-self: center;}
.cart-item-image img { width: 80px; height: 80px; object-fit: cover; border-radius: var(--border-radius); }
.cart-item-details { grid-area: details; }
.cart-item-quantity { grid-area: quantity; display: flex; align-items: center; gap: var(--space-sm); }
.cart-item-subtotal { grid-area: subtotal; text-align: right; font-weight: var(--font-weight-semibold); align-self: center; }
.cart-item-remove { grid-area: remove; text-align: right; align-self: start;}
.cart-item-name { font-size: 1rem; font-weight: var(--font-weight-semibold); margin-bottom: var(--space-xs); }
.cart-item-price { font-size: var(--font-size-sm); color: var(--neutral-secondary); margin-bottom: var(--space-xs); }
.cart-item-stock { font-size: 0.8rem; color: var(--neutral-tertiary); }
.cart-item-quantity label { display: none; }
.cart-item-quantity input { width: 55px; padding: var(--space-xs) var(--space-sm); text-align: center; font-size: var(--font-size-sm); }
.cart-item-quantity .btn-update-qty { font-size: var(--font-size-sm); padding: var(--space-xs) var(--space-md); }
.cart-item-subtotal { font-size: 1rem; white-space: nowrap; }
.cart-item-remove .btn { padding: var(--space-xs) var(--space-sm); font-size: var(--font-size-sm); }

.cart-summary {
  margin-top: var(--space-xl); padding: var(--space-lg); background-color: var(--neutral-lighter);
  border-top: 2px solid var(--primary-blue); border-radius: var(--border-radius); text-align: right;
}
.cart-summary h2 { font-size: 1.3rem; margin-bottom: var(--space-lg); }
#cart-total-value { font-weight: var(--font-weight-semibold); }
.btn-checkout { width: 100%; padding: var(--space-md); font-size: 1.1rem; }

/* --- Checkout --- */
.checkout-container h1 { font-size: 1.5rem; margin-bottom: var(--space-lg);}
.checkout-grid { display: flex; flex-direction: column; gap: var(--space-xl); }
.checkout-address, .checkout-summary { background-color: var(--neutral-white); padding: var(--space-lg); border-radius: var(--border-radius); border: 1px solid var(--border-color); box-shadow: var(--box-shadow-sm); }
.checkout-address h2, .checkout-summary h2 { font-size: 1.2rem; border-bottom: 1px solid var(--border-color); padding-bottom: var(--space-md); margin-bottom: var(--space-lg); }
.saved-address { font-size: var(--font-size-sm); margin-bottom: var(--space-lg); }
.saved-address p { margin-bottom: var(--space-xs); line-height: 1.4; }
.saved-address strong { font-weight: var(--font-weight-semibold); }
#edit-address-btn { margin-top: var(--space-md); }
.address-form h3 { font-size: 1.1rem; }
.checkout-items { max-height: 200px; overflow-y: auto; margin-bottom: var(--space-lg); padding-right: var(--space-sm); }
.checkout-item { display: flex; align-items: center; gap: var(--space-md); margin-bottom: var(--space-md); font-size: var(--font-size-sm); }
.checkout-item-image img { width: 40px; height: 40px; object-fit: cover; border-radius: var(--border-radius); }
.checkout-item-info { flex-grow: 1; }
.checkout-item-price { font-weight: var(--font-weight-semibold); white-space: nowrap;}
.checkout-totals { font-size: var(--font-size-sm); }
.checkout-totals p { display: flex; justify-content: space-between; margin-bottom: var(--space-xs); }
.checkout-totals hr { margin: var(--space-md) 0; border-color: var(--border-color); opacity: 0.5;}
.checkout-totals strong { font-weight: var(--font-weight-bold); }
.checkout-payment h3 { font-size: 1.1rem; margin: var(--space-lg) 0 var(--space-md) 0; }
.payment-option { padding: var(--space-md); border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: var(--neutral-lighter); opacity: 0.8; margin-bottom: var(--space-sm); cursor: not-allowed; }
.payment-option.selected { border-color: var(--primary-blue); opacity: 1; background-color: var(--primary-blue-light); }
.payment-option label { font-weight: normal; display: flex; align-items: center; cursor: inherit; margin-bottom: 0; }
.payment-option input[type="radio"] { margin-right: var(--space-sm); }
.payment-option i { margin-right: var(--space-xs); color: var(--status-success);}
.place-order-form { margin-top: var(--space-lg); }
.btn-place-order { width: 100%; font-size: 1.1rem; padding: var(--space-md); }

/* --- My Orders --- */
.my-orders-container h1 { font-size: 1.5rem; margin-bottom: var(--space-lg); }
.order-list { display: flex; flex-direction: column; gap: var(--space-lg); }
.order-card { background-color: var(--neutral-white); border-radius: var(--border-radius); border: 1px solid var(--border-color); box-shadow: var(--box-shadow-sm); overflow: hidden; }
.order-header {
  background-color: var(--neutral-lighter); padding: var(--space-md);
  display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
  font-size: var(--font-size-sm); color: var(--neutral-secondary); border-bottom: 1px solid var(--border-color);
}
.order-header > div { margin-right: var(--space-lg); margin-bottom: var(--space-xs); white-space: nowrap; }
.order-header strong { color: var(--neutral-primary); }
.order-body { padding: var(--space-lg); display: flex; flex-direction: column; gap: var(--space-md); }
.order-items-images { display: flex; flex-wrap: wrap; gap: var(--space-sm); padding-left: 0; list-style: none; }
.order-item-thumbnail { width: 40px; height: 40px; object-fit: cover; border-radius: var(--border-radius); border: 1px solid var(--border-color); vertical-align: middle; background-color: var(--neutral-lighter); }
.order-item-thumbnail:hover { opacity: 0.85; }
.order-item-thumbnail-placeholder { display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: var(--border-radius); border: 1px dashed var(--neutral-secondary); background-color: var(--neutral-light); color: var(--neutral-secondary); font-size: 0.6rem; font-weight: bold; text-align: center; text-decoration: none; vertical-align: middle; line-height: 1; padding: 2px; }
.order-items-list small { display: block; margin-bottom: var(--space-xs); }
.order-details { font-size: var(--font-size-sm); line-height: 1.5;}
.order-details p { margin-bottom: var(--space-xs); }
.order-actions { padding: var(--space-md); text-align: right; border-top: 1px solid var(--border-color); background-color: var(--neutral-lighter); }

/* Status Badge */
.status-badge {
    font-weight: var(--font-weight-semibold); padding: var(--space-xs) var(--space-sm); border-radius: var(--border-radius);
    color: var(--neutral-primary); background-color: var(--neutral-light); font-size: 0.8rem;
    display: inline-block; vertical-align: middle; text-transform: capitalize;
}
.status-pending, .status-badge.status-pending { background-color: var(--status-pending-bg); color: var(--status-pending-text); }
.status-delivered, .status-badge.status-delivered { background-color: var(--status-success-bg); color: var(--status-success); }
.status-cancelled, .status-badge.status-cancelled { background-color: var(--status-danger-bg); color: var(--status-danger); }
.status-approved, .status-badge.status-approved { background-color: var(--status-success-bg); color: var(--status-success); }
.status-rejected, .status-badge.status-rejected { background-color: var(--status-danger-bg); color: var(--status-danger); }
.order-card.status-cancelled, .data-table tr.status-cancelled { opacity: 0.9; }
.data-table tr.status-rejected { opacity: 0.85; }

/* --- Admin/Seller Pages --- */
.admin-manage-container, .admin-dashboard-container { padding: var(--space-xl); }
.admin-manage-container h1, .admin-dashboard-container h1 { font-size: 1.5rem; margin-bottom: var(--space-lg); border-bottom: 1px solid var(--border-color); padding-bottom: var(--space-md); }

/* Responsive Tables */
.table-container { overflow-x: auto; margin-bottom: var(--space-lg); }
.data-table {
  width: 100%; border-collapse: separate; border-spacing: 0; font-size: var(--font-size-sm);
  background-color: var(--neutral-white); border: 1px solid var(--border-color);
  border-radius: var(--border-radius); box-shadow: var(--box-shadow-sm); overflow: hidden;
}
.data-table thead { display: none; background-color: var(--neutral-lighter); font-weight: var(--font-weight-semibold); color: var(--neutral-primary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; }
.data-table th { padding: var(--space-md); text-align: left; border-bottom: 1px solid var(--border-color); }
/* Mobile Table Rows */
.data-table tbody tr:not([id^="no-"]) { /* Exclude 'no results' row */
  display: block; margin-bottom: var(--space-lg); border: 1px solid var(--border-color);
  border-radius: var(--border-radius); padding: var(--space-md); background-color: var(--neutral-white);
  box-shadow: var(--box-shadow-sm);
}
.data-table tbody tr:last-child { margin-bottom: 0; }
.data-table td { display: block; text-align: right; padding: var(--space-sm) 0; position: relative; border-bottom: 1px dashed var(--neutral-light); }
.data-table td:last-child { border-bottom: none; }
.data-table td::before { content: attr(data-label); position: absolute; left: 0; font-weight: var(--font-weight-semibold); text-align: left; padding-right: var(--space-md); color: var(--neutral-secondary); width: 45%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.85em; }
.table-img { max-width: 40px; border-radius: var(--border-radius); display: inline-block; margin-left: 50%; vertical-align: middle; }
.data-table td:has(img) { text-align: right; padding: var(--space-xs) 0; }
.data-table td.actions-cell { padding-top: var(--space-md); }
.data-table td.actions-cell::before { display: none; }
.actions-cell .action-group { border-top: 1px solid var(--neutral-light); padding-top: var(--space-md); margin-top: var(--space-md); text-align: left; }
.actions-cell .action-group:first-child { border-top: none; margin-top: 0; padding-top: 0; }
.actions-cell .action-group-title { font-size: 0.8em; font-weight: bold; color: var(--neutral-secondary); margin-bottom: var(--space-sm); display: block; text-align: left; }
.actions-cell form, .actions-cell .btn { margin: var(--space-xs) 0; display: block; width: 100%; }
.actions-cell .inline-form { display: flex; flex-wrap: wrap; gap: var(--space-sm); align-items: center; }
.actions-cell .inline-form input, .actions-cell .inline-form button { width: auto; flex-grow: 1; }
.actions-cell .inline-form button { flex-grow: 0; flex-shrink: 0; }
.actions-cell select.form-control-sm { margin-bottom: var(--space-xs); font-size: var(--font-size-sm); padding: var(--space-xs) var(--space-sm); height: auto; width: 100%; }
.actions-cell .no-actions-text { display: block; text-align: left; margin-top: var(--space-sm); color: var(--neutral-tertiary); font-style: italic; font-size: 0.85em; }
/* Mobile Order Table Specifics */
.order-table td[data-label="Items"] .order-items-summary { font-size: 0.85em; line-height: 1.5; margin-bottom: var(--space-sm); text-align: left; margin-left: 50%; }
.order-table td[data-label="Items"] .order-items-summary strong { color: var(--neutral-primary); }
.order-table .order-items-images { margin-top: var(--space-xs); justify-content: flex-end; margin-left: 50%; }
.order-table td[data-label="Total"].order-total strong { font-size: 1.1em; color: var(--neutral-primary); }
.order-table td[data-label="Status"] .status-badge { float: right; margin-bottom: var(--space-xs); }
.order-table td[data-label="Status"] small { clear: both; display: block; text-align: right; margin-top: var(--space-xs); font-size: 0.8em; }
/* Mobile Delivery OTP */
.delivery-otp-display { margin-top: var(--space-sm); padding: var(--space-sm); background-color: var(--status-info-bg); border: 1px solid #a9d6f5; border-radius: var(--border-radius); font-size: 0.85rem; text-align: left; clear: both; margin-left: 50%; }
.delivery-otp-display p { margin-bottom: var(--space-xs) !important; }
.delivery-otp-code { font-weight: var(--font-weight-bold); color: var(--primary-blue); font-size: 1.1em; margin: 0 var(--space-xs); letter-spacing: 1px; background-color: var(--neutral-white); padding: 1px 4px; border-radius: var(--border-radius); border: 1px solid var(--primary-blue); }
.delivery-otp-display small { display: block; margin-top: var(--space-xs); color: var(--neutral-secondary); }
.verify-otp-form { display: flex; align-items: center; gap: var(--space-xs); width: 100%; }
.verify-otp-form input[name="otp"] { flex-grow: 1; max-width: 150px; padding: var(--space-xs) var(--space-sm); font-size: var(--font-size-sm); text-align: center; border-radius: var(--border-radius); }
.verify-otp-form button { flex-shrink: 0; width: auto; padding: var(--space-xs) var(--space-sm); font-size: var(--font-size-sm); line-height: 1.4; }

/* Admin Actions Grid */
.admin-actions-grid { display: grid; grid-template-columns: repeat(1, 1fr); gap: var(--space-lg); margin-top: var(--space-lg); }
.admin-action-card { background-color: var(--neutral-white); padding: var(--space-lg); border-radius: var(--border-radius); border: 1px solid var(--border-color); text-align: center; box-shadow: var(--box-shadow-sm); transition: transform 0.15s ease, box-shadow 0.15s ease; color: var(--neutral-primary); text-decoration: none; }
.admin-action-card:hover { transform: translateY(-2px); box-shadow: var(--box-shadow-md); text-decoration: none; }
.admin-action-card i { font-size: 2rem; color: var(--primary-blue); margin-bottom: var(--space-md); }
.admin-action-card h3 { font-size: 1.1rem; margin-bottom: var(--space-xs); color: var(--neutral-primary); }
.admin-action-card p { font-size: var(--font-size-sm); color: var(--neutral-secondary); margin-bottom: var(--space-sm); }

/* --- Error Page --- */
.error-container { text-align: center; padding-top: var(--space-xxl); }
.error-container h1 { color: var(--status-danger); margin-bottom: var(--space-sm); }
.error-container .lead { font-size: 1.1rem; color: var(--neutral-secondary); }
.error-container details { text-align: left; margin-top: var(--space-xl); background: var(--neutral-lighter); padding: var(--space-md); border-radius: var(--border-radius); border: 1px solid var(--border-color); }
.error-container details summary { cursor: pointer; font-weight: var(--font-weight-semibold); }
.error-container details pre { white-space: pre-wrap; font-size: 0.8em; margin-top: var(--space-sm); color: var(--neutral-secondary); font-family: Consolas, monospace; }

/* --- Profile Page --- */
.profile-container { max-width: 800px; margin: var(--space-xl) auto; padding: var(--space-xl); background-color: var(--neutral-white); border: 1px solid var(--border-color); border-radius: var(--border-radius); box-shadow: var(--box-shadow-sm); }
.profile-header { display: flex; flex-direction: column; align-items: center; text-align: center; }
.profile-header h1 { font-size: 1.75rem; margin-bottom: var(--space-xs); }
.profile-header .d-flex { /* Container for name + edit */ flex-wrap: wrap; justify-content: center; }
.profile-header #saved-name-display { font-size: 1.1rem; }
.profile-container > p.text-muted { text-align: center; font-size: var(--font-size-sm); margin-bottom: var(--space-xl); }
.profile-section { margin-top: var(--space-xl); padding-top: var(--space-xl); border-top: 1px solid var(--border-color); }
.profile-section:first-of-type { border-top: none; padding-top: 0; margin-top: var(--space-lg); }
.profile-section h2 { font-size: 1.25rem; margin-bottom: var(--space-lg); color: var(--neutral-primary); font-weight: var(--font-weight-semibold); }
#saved-address-display p { margin-bottom: var(--space-xs); line-height: 1.5; font-size: var(--font-size-sm); }
#saved-address-display strong { font-weight: var(--font-weight-semibold); }
#edit-address-btn, #add-address-btn { margin-top: var(--space-md); font-weight: var(--font-weight-normal); }
.address-form { max-width: 500px; }
.address-form h3 { font-size: 1.1rem; margin-bottom: var(--space-lg); font-weight: var(--font-weight-semibold); }
#cancel-edit-btn { margin-left: var(--space-sm); font-weight: var(--font-weight-normal); }
.dashboards-section .btn, .orders-section .btn { margin-right: var(--space-sm); margin-bottom: var(--space-sm); font-weight: var(--font-weight-normal); }
.logout-section .btn { min-width: 120px; }

/* --- Category Icons --- */
.category-icons-section h2 { font-size: 1.25rem; font-weight: var(--font-weight-semibold); color: var(--neutral-primary); text-align: center; margin-bottom: var(--space-lg); }
.category-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--space-md); }
.category-item { display: flex; flex-direction: column; align-items: center; text-align: center; padding: var(--space-sm); border-radius: var(--border-radius); transition: background-color 0.2s ease-in-out; color: var(--neutral-primary); text-decoration: none; cursor: pointer; }
.category-item:hover { background-color: var(--neutral-light); text-decoration: none; }
.category-item.active { background-color: var(--primary-blue-light); }
.category-item.active .category-name { color: var(--primary-blue); font-weight: var(--font-weight-semibold); }
.category-icon-wrapper { width: 50px; height: 50px; margin-bottom: var(--space-sm); background-color: var(--neutral-white); border-radius: var(--border-radius); display: flex; align-items: center; justify-content: center; overflow: hidden; border: 1px solid var(--border-color); box-shadow: var(--box-shadow-sm); }
.category-icon { max-width: 60%; max-height: 60%; object-fit: contain; display: block; }
.category-name { font-size: 0.75rem; font-weight: var(--font-weight-normal); line-height: 1.3; color: var(--neutral-secondary); }

/* --- Pincode Lookup Styles --- */
.auto-filled-fields-container { background-color: var(--neutral-lighter); border-left: 3px solid var(--primary-blue); padding: var(--space-sm) var(--space-md); border-radius: 0 var(--border-radius) var(--border-radius) 0; margin-top: calc(var(--space-unit) * -0.5); margin-bottom: var(--space-lg); }
.auto-filled-fields-container .form-group { margin-bottom: var(--space-sm); }
.auto-filled-fields-container .form-group:last-child { margin-bottom: 0; }
.auto-filled-field[readonly] { background-color: var(--neutral-light); opacity: 1; cursor: default; border: 1px solid var(--neutral-quaternary); font-weight: var(--font-weight-semibold); color: var(--neutral-secondary); }
.pincode-status { display: block; margin-top: var(--space-xs); font-size: 0.8em; min-height: 1.2em; transition: color 0.2s ease-in-out; }

/* --- Table Filtering / No Results --- */
.admin-manage-container .form-group.mb-3 { margin-bottom: var(--space-lg) !important; }
#no-admin-orders-found td, #no-seller-orders-found td, #no-admin-products-found td, #no-seller-products-found td, #no-admin-users-found td { text-align: center; padding: var(--space-lg); color: var(--neutral-secondary); font-style: italic; }
tr.hidden { display: none !important; }

/* ============================ */
/* Slider Styles (NEW/UPDATED) */
/* ============================ */

/* --- Banner Slider --- */
.banner-slider-container {
    position: relative;
    width: 100%;
    aspect-ratio: 2.5 / 1; /* Adjust as needed */
    overflow: hidden; /* Hide slides outside the container */
    border-radius: var(--border-radius);
    background-color: var(--neutral-light);
    touch-action: pan-y; /* Allow vertical scroll, handle horizontal in JS */
    -webkit-tap-highlight-color: transparent;
    margin-bottom: var(--space-lg); /* Ensure margin exists */
}

.banner-slides-wrapper {
    display: flex; /* Arrange slides horizontally */
    height: 100%;
    position: relative;
    /* Transition applied via JS for initial load and jumps */
}

.banner-slide {
    width: 100%; /* Each slide takes full container width */
    flex-shrink: 0; /* Prevent slides from shrinking */
    height: 100%;
    position: relative; /* Needed if content needs positioning inside */
    background-color: var(--neutral-lighter);
    /* Removed old opacity/visibility styles */
}

.banner-link { display: block; width: 100%; height: 100%; }
.banner-image { display: block; width: 100%; height: 100%; object-fit: cover; }

/* Keep Nav and Dots positioning relative to the main container */
.banner-nav {
    position: absolute; top: 50%; transform: translateY(-50%);
    background-color: rgba(0, 0, 0, 0.4); color: white; border: none;
    border-radius: 50%; width: 35px; height: 35px; font-size: 0.9rem;
    cursor: pointer; z-index: 2; display: none; /* Hide initially, show via JS */ align-items: center;
    justify-content: center; transition: background-color 0.2s ease; opacity: 0.8;
}
.banner-nav:hover { background-color: rgba(0, 0, 0, 0.6); opacity: 1; }
.banner-prev { left: var(--space-md); }
.banner-next { right: var(--space-md); }

.banner-dots {
    position: absolute; bottom: var(--space-md); left: 50%; transform: translateX(-50%);
    display: none; /* Hide initially, show via JS */ gap: var(--space-sm); z-index: 2;
}
.banner-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.5); border: 1px solid rgba(0, 0, 0, 0.2);
    cursor: pointer; padding: 0; transition: background-color 0.3s ease;
}
.banner-dot.active { background-color: white; }


/* --- Product Detail Image Slider --- */
.product-detail-image-section {
    position: relative; /* Keep for positioning nav/dots */
    width: 100%;
    max-width: 450px; /* Or remove if full width on mobile */
    margin: 0 auto var(--space-lg) auto;
    aspect-ratio: 1 / 1;
    overflow: hidden; /* Crucial for sliding */
    border-radius: var(--border-radius);
    background-color: var(--neutral-lighter);
    border: 1px solid var(--border-color);
    touch-action: pan-y; /* Allow vertical scroll */
    -webkit-tap-highlight-color: transparent;
}

/* Container that actually moves */
.product-image-slides-wrapper {
    display: flex;
    height: 100%;
    position: relative;
    /* Transition applied via JS */
}

/* Individual Slide Styling */
.product-image-slide {
    width: 100%;
    flex-shrink: 0;
    height: 100%;
    position: relative; /* For potential content inside */
    /* Removed old absolute positioning, opacity, visibility */
}

.product-detail-image { display: block; width: 100%; height: 100%; object-fit: cover; border-radius: inherit; }

/* Keep Nav and Dots positioning */
.product-image-nav {
    position: absolute; top: 50%; transform: translateY(-50%);
    background-color: rgba(0, 0, 0, 0.4); color: white; border: none;
    border-radius: 50%; width: 30px; height: 30px; font-size: 1rem; font-weight: bold;
    line-height: 1; cursor: pointer; z-index: 2; display: none; /* Hide initially, show via JS */ align-items: center;
    justify-content: center; transition: background-color 0.2s ease; opacity: 0.8;
}
.product-image-nav:hover, .product-image-nav:focus { background-color: rgba(0, 0, 0, 0.6); opacity: 1; outline: none; }
.product-image-prev { left: var(--space-sm); }
.product-image-next { right: var(--space-sm); }

.product-image-dots {
    position: absolute; bottom: var(--space-sm); left: 50%; transform: translateX(-50%);
    display: none; /* Hide initially, show via JS */ gap: var(--space-sm); z-index: 2;
}
.product-image-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.6); border: 1px solid rgba(0, 0, 0, 0.3);
    cursor: pointer; padding: 0; transition: background-color 0.3s ease;
}
.product-image-dot.active { background-color: white; }
.product-image-dot:focus { outline: 1px dotted white; outline-offset: 1px; }

/* ============================ */
/* Media Queries                */
/* ============================ */

/* Small devices (landscape phones, 576px and up) */
@media (min-width: 576px) {
    .category-grid { grid-template-columns: repeat(5, 1fr); gap: var(--space-lg); }
    .category-icon-wrapper { width: 55px; height: 55px; }
    .category-name { font-size: 0.8rem; }
    .admin-actions-grid { grid-template-columns: repeat(2, 1fr); }
}

/* Medium devices (tablets, 768px and up) */
@media (min-width: 768px) {
    .container { /* Max width set via variable */ }
    .app-footer { display: block; }
    .product-grid { grid-template-columns: repeat(3, 1fr); }
    .product-name { height: auto; white-space: normal; display: block; -webkit-line-clamp: unset; -webkit-box-orient: unset; }
    .product-detail-main { flex-direction: row; align-items: flex-start; }
    .product-detail-info { flex: 1 1 60%; }
    .product-detail-image-section { flex: 1 1 40%; width: auto; max-width: none; margin: 0; }
    .product-actions { flex-direction: row; align-items: center; }
    .product-actions .btn { width: auto; }
    .quantity-selector { max-width: 120px; margin-bottom: 0; }
    .auth-container { margin: var(--space-xxl) auto; }
    .cart-item { grid-template-columns: 100px 1fr 100px 150px 80px; grid-template-areas: "image details price quantity remove"; align-items: center; padding: var(--space-lg); }
    .cart-item-details { grid-area: details; }
    .cart-item-price { display: block; grid-area: price; text-align: right; font-weight: var(--font-weight-semibold); font-size: 1rem; color: var(--neutral-primary); margin-bottom: 0; }
    .cart-item-quantity { grid-area: quantity; justify-content: center; }
    .cart-item-subtotal { display: none; }
    .cart-item-remove { grid-area: remove; align-self: center; text-align: center; }
    .checkout-grid { flex-direction: row; gap: var(--space-xl); align-items: flex-start; }
    .checkout-address { flex: 1 1 55%; }
    .checkout-summary { flex: 1 1 45%; }

    /* Restore Table Layout */
    .data-table thead { display: table-header-group; }
    .data-table tbody tr:not([id^="no-"]) { display: table-row; margin-bottom: 0; border: none; padding: 0; box-shadow: none; background-color: transparent; border-bottom: 1px solid var(--border-color); border-radius: 0; }
    .data-table tbody tr:last-child { border-bottom: none; }
    .data-table tbody tr:hover { background-color: var(--neutral-lighter); }
    .data-table td { display: table-cell; text-align: left; padding: var(--space-md); vertical-align: middle; border-bottom: none; position: static; margin-left: 0 !important; }
    .data-table td::before { content: none; }
    .table-img { max-width: 50px; margin-left: 0; }
    .data-table td:has(img) { text-align: left; width: 70px; }
    .data-table th[data-label*="Price"], .data-table td[data-label*="Price"], .data-table th[data-label*="Stock"], .data-table td[data-label*="Stock"], .data-table th[data-label*="Total"], .data-table td[data-label*="Total"], .data-table td.order-total { text-align: right; width: 100px; }
    .data-table th[data-label="Status"], .data-table td[data-label="Status"], .data-table td.order-status-cell { text-align: center; width: 130px; }
    .data-table td[data-label="Status"] .status-badge, .order-status-cell .status-badge { float: none; display: inline-block; }
    .order-status-cell small { text-align: center; }
    .data-table th.actions-cell, .data-table td.actions-cell { text-align: right !important; width: 220px; white-space: normal; }
    .actions-cell .action-group { border: none; padding: 0; margin: 0 0 var(--space-sm) 0; display: block; text-align: right; }
    .actions-cell .action-group:last-child { margin-bottom: 0; }
    .actions-cell .action-group-title { display: none; }
    .actions-cell form, .actions-cell .btn { display: inline-block; width: auto; margin: 0 0 0 var(--space-sm); vertical-align: middle; }
    .actions-cell .inline-form { display: inline-flex; width: auto; margin-left: 0; }
    .actions-cell .inline-form + .inline-form { margin-left: var(--space-sm); }
    .actions-cell .verify-otp-form input { max-width: 100px; }
    .actions-cell select.form-control-sm { width: auto; display: inline-block; margin-right: var(--space-xs);}
    .actions-cell .no-actions-text { display: inline-block; text-align: right; width: 100%;}
    .w-md-auto { width: auto !important; }
    .order-table td[data-label="Items"] .order-items-summary { margin-left: 0; text-align: left; }
    .order-table .order-items-images { justify-content: flex-start; margin-left: 0; }
    .delivery-otp-display { margin-left: 0; margin-top: var(--space-xs); padding: var(--space-xs) var(--space-sm); font-size: 0.8rem; display: inline-block; width: auto; text-align: center; }
    .delivery-otp-display p { margin-bottom: 0 !important; }
    .delivery-otp-display small { display: none; }

    /* Header/Navbar Tablet+ */
    .app-header { padding: var(--space-sm) var(--space-lg); }
    .navbar { gap: var(--space-lg); }
    .app-logo .app-name { display: inline; }
    .app-logo { font-size: 1.25rem; }
    .search-toggle-btn { display: none; }
    .search-container-dynamic { display: flex; flex-grow: 1; justify-content: center; order: 0; margin: 0 var(--space-lg); max-width: 500px; position: relative; }
    .nav-left { margin-right: 0; }
    .search-form-dynamic { position: relative; top: auto; left: auto; right: auto; width: 100%; box-shadow: none; opacity: 1; visibility: visible; transform: none; height: 36px; }
    .suggestions-dropdown { position: absolute; top: 100%; left: 0; right: 0; width: 100%; }

    /* Nav links Tablet+ */
    .nav-link { flex-direction: row; font-size: var(--font-size-sm); align-items: center; padding: var(--space-sm) var(--space-md); width: auto; }
    .nav-link span { display: inline; margin-left: var(--space-sm); }
    .nav-link i { font-size: 1rem; margin-bottom: 0; margin-right: 0; }
    .nav-right { gap: var(--space-md); }
    .profile-avatar-link { width: 36px; height: 36px; }
    .btn-login-register { font-size: var(--font-size-sm); }

    /* Category Grid Tablet */
    .category-grid { grid-template-columns: repeat(6, 1fr); gap: var(--space-lg); }
    .category-icon-wrapper { width: 60px; height: 60px; }
    .category-name { font-size: var(--font-size-sm); }
    .category-icons-section { padding: var(--space-lg) 0; }
    .category-icons-section h2 { font-size: 1.4rem; }

    /* Banner Slider Tablet */
    .banner-slider-container { aspect-ratio: 24 / 7; }
    .banner-nav { width: 40px; height: 40px; font-size: 1rem; }
    .banner-dots { bottom: var(--space-lg); }
    .banner-dot { width: 10px; height: 10px; }

    /* Rating Stats Layout */
    .rating-stats-container { display: flex; align-items: flex-start; gap: var(--space-xl); }
    .rating-summary { flex-direction: column; align-items: center; margin-bottom: 0; flex-basis: 150px; flex-shrink: 0; }
    .rating-average-value { font-size: 3em; }
    .rating-total { font-size: 1em; }
    .rating-bars { max-width: none; flex-grow: 1; margin: 0; }

    .profile-container { padding: var(--space-xl); }
}

/* Large devices (desktops, 992px and up) */
@media (min-width: 992px) {
    .container { max-width: 960px; }
    .product-grid { grid-template-columns: repeat(4, 1fr); gap: var(--space-xl); }
    .admin-actions-grid { grid-template-columns: repeat(3, 1fr); gap: var(--space-xl); }
    .navbar { /* Max width inherited */ }
    .category-grid { grid-template-columns: repeat(8, 1fr); gap: var(--space-lg); }
    .category-icon-wrapper { width: 65px; height: 65px; }
    .category-icons-section { padding: var(--space-xl) 0; }
    .banner-slider-container { aspect-ratio: 24 / 6; }
}

/* Extra large devices (large desktops, 1200px and up) */
@media (min-width: 1200px) {
    .container { max-width: 1140px; }
    .admin-actions-grid { grid-template-columns: repeat(4, 1fr); }
    /* .product-grid { grid-template-columns: repeat(5, 1fr); } */
    /* .category-grid { grid-template-columns: repeat(10, 1fr); } */
    .category-icon-wrapper { width: 70px; height: 70px; }
}

/* Mobile Search Bar Specific Overlay/Positioning */
@media (max-width: 767px) {
  .search-container-dynamic { position: static; order: 1; } /* Keep in flow */
  .search-form-dynamic {
      position: absolute; top: calc(100% + var(--space-sm)); /* Below header */
      left: var(--space-lg); right: var(--space-lg);
      width: calc(100% - (2 * var(--space-lg)));
      background-color: var(--neutral-white); border: 1px solid var(--border-color);
      box-shadow: var(--box-shadow-md);
      opacity: 0; visibility: hidden;
      transform: translateY(-10px) scaleY(0.95); transform-origin: top center;
      transition: opacity 0.25s ease, transform 0.25s ease, visibility 0s linear 0.25s;
      z-index: 1005; border-radius: var(--border-radius); height: 40px;
  }
  .search-container-dynamic.active .search-form-dynamic {
      opacity: 1; visibility: visible; transform: translateY(0) scaleY(1);
      transition: opacity 0.25s ease, transform 0.25s ease, visibility 0s linear 0s;
  }
  .suggestions-dropdown {
      top: calc(100% + var(--space-sm) + 40px + var(--space-xs)); /* Below search form */
      left: var(--space-lg); right: var(--space-lg);
      width: calc(100% - (2 * var(--space-lg)));
      z-index: 1010; border-top: 1px solid var(--border-color);
  }
   .search-container-dynamic.active .suggestions-dropdown.active { display: block; }
   .nav-link span { display: block; } /* Ensure text is visible below icon */
}

public/js/main.js:
// public/js/main.js
console.log("Main JS loaded.");

document.addEventListener('DOMContentLoaded', () => {

    // --- Button Spinner Logic ---
    document.querySelectorAll('form.form-submit-spinner').forEach(form => {
        form.addEventListener('submit', (event) => {
            const submitButton = form.querySelector('button[type="submit"]');
            if (submitButton && !submitButton.disabled) {
                // Basic HTML5 validation check
                if (typeof form.checkValidity === 'function' && !form.checkValidity()) {
                    // If form is invalid, don't disable button or show spinner
                    return;
                }
                const originalText = submitButton.innerHTML;
                submitButton.dataset.originalText = originalText; // Store original HTML
                submitButton.disabled = true;
                submitButton.classList.add('loading'); // Optional: Add class for specific styling
                submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';

                // Reset button if user navigates back without form submitting (browser specific)
                window.addEventListener('pageshow', function(pageEvent) { // Renamed event variable
                    if (pageEvent.persisted && submitButton.disabled) {
                        // Restore button only if it still has the loading state
                        if (submitButton.dataset.originalText) {
                            submitButton.innerHTML = submitButton.dataset.originalText;
                        }
                        submitButton.disabled = false;
                        submitButton.classList.remove('loading');
                    }
                });
            }
        });
    });

    // --- Responsive Table Logic ---
    function responsiveTables() {
        const tables = document.querySelectorAll('.data-table');
        tables.forEach(table => {
            const headerElements = table.querySelectorAll('thead th');
            if (!headerElements || headerElements.length === 0) return;

            const headers = Array.from(headerElements).map(th => th.textContent.trim());
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                // Skip 'no results' row if it exists in tbody
                if(row.id && row.id.startsWith('no-')) return;

                const cells = row.querySelectorAll('td');
                cells.forEach((cell, index) => {
                    // Add data-label only if it doesn't exist and header exists
                    if (!cell.hasAttribute('data-label') && headers[index] !== undefined && headers[index] !== '') {
                         cell.setAttribute('data-label', headers[index]);
                    }
                });
            });
        });
    }
     if (document.querySelector('.data-table')) {
         responsiveTables();
         // Re-run if content is dynamically added (e.g., via AJAX, though not currently used for tables)
         // const observer = new MutationObserver(responsiveTables);
         // observer.observe(document.body, { childList: true, subtree: true });
     }

    // --- Share Button Logic ---
    const shareButton = document.getElementById('share-product-btn');
    const fallbackLinks = document.getElementById('fallback-share-links');
    if (shareButton && fallbackLinks) {
        shareButton.addEventListener('click', async () => {
            const title = shareButton.dataset.title || document.title; // Fallback to page title
            const text = shareButton.dataset.text || `Check out ${title}`; // Fallback text
            const url = shareButton.dataset.url || window.location.href; // Fallback url

            if (navigator.share) {
                try {
                    await navigator.share({ title, text, url });
                    console.log('Product shared successfully!');
                    showToast('Link shared!', 'success'); // Optional feedback
                } catch (error) {
                    console.error('Error sharing:', error);
                    // Don't show fallback if user explicitly cancelled (AbortError)
                    if (error.name !== 'AbortError') {
                         fallbackLinks.classList.remove('hidden');
                         showToast('Sharing failed, use fallback links.', 'warning');
                    }
                }
            } else {
                console.log('Web Share API not supported, showing fallback links.');
                fallbackLinks.classList.remove('hidden');
                showToast('Web Share not supported, use link options.', 'info');
            }
        });
    }

    // --- Profile Page Specific Logic ---
    const profilePage = document.querySelector('.profile-container'); // Check if we are on profile page
    if (profilePage) {
        // --- Address Edit/Add Logic ---
        const editAddressBtn = document.getElementById('edit-address-btn');
        const addAddressBtn = document.getElementById('add-address-btn'); // Get the Add button
        const cancelAddressBtn = document.getElementById('cancel-edit-btn');
        const addressForm = document.getElementById('address-form');
        const savedAddressDiv = document.getElementById('saved-address-display');

        const showAddressForm = () => {
            if (!addressForm || !savedAddressDiv) return;
            addressForm.classList.remove('hidden');
            const isEditing = savedAddressDiv.querySelector('strong') !== null;
            addressForm.querySelector('h3').textContent = isEditing ? 'Edit Address' : 'Add Address';
            savedAddressDiv.classList.add('hidden');
            if (addAddressBtn) addAddressBtn.classList.add('hidden'); // Hide Add button when form is visible
            if (cancelAddressBtn) cancelAddressBtn.classList.remove('hidden'); // Always show Cancel when form is open

            // Trigger pincode check for edit if pincode exists
            const pincodeInput = addressForm.querySelector('#profile-pincode');
            const localitySelect = addressForm.querySelector('#profile-locality');
            // Get the potentially pre-filled value from the EJS render
            const savedLocality = localitySelect ? localitySelect.dataset.savedValue : null;

            if (pincodeInput && pincodeInput.value.length === 6 && /^\d{6}$/.test(pincodeInput.value)) {
                fetchPincodeData(pincodeInput.value, 'profile', savedLocality); // Pass saved locality
            } else if (localitySelect) {
                // Ensure locality is reset if pincode isn't valid when opening form
                clearAutoFilledFields('profile'); // Use helper to clear derived fields
            }
        };

        const hideAddressForm = () => {
            if (!addressForm || !savedAddressDiv) return;
            addressForm.classList.add('hidden');
            savedAddressDiv.classList.remove('hidden'); // Show the container (has address or "No address" text)
            if (cancelAddressBtn) cancelAddressBtn.classList.add('hidden');
            // Show Add button only if there's no saved address content
            if (!savedAddressDiv.querySelector('strong') && addAddressBtn) {
                 addAddressBtn.classList.remove('hidden');
            }
            // Clear status messages and derived fields when hiding
            clearAutoFilledFields('profile');
            const pincodeInput = addressForm.querySelector('#profile-pincode');
            const statusElement = pincodeInput?.nextElementSibling;
            if (statusElement) statusElement.textContent = '';
        };

        if (editAddressBtn) {
            editAddressBtn.addEventListener('click', showAddressForm);
        }
        if (addAddressBtn) {
             addAddressBtn.addEventListener('click', () => {
                 if(addressForm) {
                     addressForm.reset(); // Clear form fields when adding new
                     clearAutoFilledFields('profile'); // Clear auto-filled fields too
                     // Manually clear pincode status as reset() doesn't trigger input event
                     const statusElement = addressForm.querySelector('.pincode-status');
                     if (statusElement) statusElement.textContent = '';
                 }
                 showAddressForm();
             });
        }
        if (cancelAddressBtn) {
            cancelAddressBtn.addEventListener('click', hideAddressForm);
        }

        // Initial state check: Show Add button only if no address exists and form is hidden
        if (savedAddressDiv && addressForm && addAddressBtn) {
            if (!savedAddressDiv.querySelector('strong') && addressForm.classList.contains('hidden')) {
                addAddressBtn.classList.remove('hidden');
            } else {
                 addAddressBtn.classList.add('hidden');
            }
        }


        // --- Name Edit Logic ---
        const editNameBtn = document.getElementById('edit-name-btn');
        const cancelNameBtn = document.getElementById('cancel-edit-name-btn');
        const nameForm = document.getElementById('name-form');
        const savedNameDisplaySpan = document.getElementById('saved-name-display');
        const nameInput = document.getElementById('name-input');
        const displayUserNameStrong = document.getElementById('display-user-name');

        const showNameForm = () => {
            if (!nameForm || !savedNameDisplaySpan || !editNameBtn || !displayUserNameStrong) return;
            nameForm.classList.remove('hidden');
            savedNameDisplaySpan.classList.add('hidden');
            editNameBtn.classList.add('hidden');
            nameInput.value = displayUserNameStrong.textContent.trim(); // Use trim
            nameInput.focus();
        };

        const hideNameForm = () => {
            if (!nameForm || !savedNameDisplaySpan || !editNameBtn || !displayUserNameStrong) return;
            nameForm.classList.add('hidden');
            savedNameDisplaySpan.classList.remove('hidden');
            editNameBtn.classList.remove('hidden');
            // No need to reset input value here, keep original name display
        };

        if (editNameBtn) {
            editNameBtn.addEventListener('click', showNameForm);
        }

        if (cancelNameBtn) {
            cancelNameBtn.addEventListener('click', hideNameForm);
        }
    } // End if (profilePage)

    // --- Checkout Address Toggle Logic ---
    const checkoutPage = document.querySelector('.checkout-container'); // Check if on checkout page
    if (checkoutPage) {
        const checkoutEditBtn = checkoutPage.querySelector('.checkout-address #edit-address-btn');
        const checkoutCancelBtn = checkoutPage.querySelector('.checkout-address #cancel-edit-btn');
        const checkoutAddressForm = checkoutPage.querySelector('.checkout-address #address-form');
        const checkoutSavedAddressDiv = checkoutPage.querySelector('.checkout-address .saved-address');
        const placeOrderBtn = checkoutPage.querySelector('.btn-place-order');
        const hasInitialAddress = checkoutSavedAddressDiv && !checkoutSavedAddressDiv.classList.contains('hidden');

        if (checkoutEditBtn) {
            checkoutEditBtn.addEventListener('click', () => {
                if (!checkoutAddressForm || !checkoutSavedAddressDiv) return;
                checkoutAddressForm.classList.remove('hidden');
                checkoutSavedAddressDiv.classList.add('hidden');
                if(placeOrderBtn) placeOrderBtn.disabled = true;
                checkoutAddressForm.querySelector('h3').textContent = 'Edit Shipping Address'; // Update title
                if (checkoutCancelBtn) checkoutCancelBtn.classList.remove('hidden');

                // Trigger pincode check for edit if pincode exists
                const pincodeInput = checkoutAddressForm.querySelector('#checkout-pincode');
                const localitySelect = checkoutAddressForm.querySelector('#checkout-locality');
                const savedLocality = localitySelect ? localitySelect.dataset.savedValue : null;

                if (pincodeInput && pincodeInput.value.length === 6 && /^\d{6}$/.test(pincodeInput.value)) {
                    fetchPincodeData(pincodeInput.value, 'checkout', savedLocality); // Pass saved locality
                } else if (localitySelect){
                    clearAutoFilledFields('checkout'); // Clear derived fields
                }
            });
        }

        if (checkoutCancelBtn) {
            checkoutCancelBtn.addEventListener('click', () => {
                if (!checkoutAddressForm || !checkoutSavedAddressDiv) return;
                checkoutAddressForm.classList.add('hidden');
                if (hasInitialAddress) {
                    checkoutSavedAddressDiv.classList.remove('hidden');
                    if(placeOrderBtn) placeOrderBtn.disabled = false;
                } else {
                    // If there was no initial address, hiding the form means they can't checkout
                    if(placeOrderBtn) placeOrderBtn.disabled = true;
                }
                checkoutCancelBtn.classList.add('hidden');
                // Clear status messages and derived fields when hiding
                clearAutoFilledFields('checkout');
                const pincodeInput = checkoutAddressForm.querySelector('#checkout-pincode');
                const statusElement = pincodeInput?.nextElementSibling;
                if (statusElement) statusElement.textContent = '';
            });
        }

        // Initialize form state on page load
        if (!hasInitialAddress && checkoutAddressForm) {
            checkoutAddressForm.classList.remove('hidden');
            if (placeOrderBtn) placeOrderBtn.disabled = true;
            checkoutAddressForm.querySelector('h3').textContent = 'Add Shipping Address';
            if (checkoutCancelBtn) checkoutCancelBtn.classList.add('hidden');
        } else if (hasInitialAddress && checkoutAddressForm) {
            checkoutAddressForm.classList.add('hidden');
            if (placeOrderBtn) placeOrderBtn.disabled = false;
            if (checkoutCancelBtn) checkoutCancelBtn.classList.add('hidden');
        }
    } // End if(checkoutPage)


    // --- Cart Update AJAX Logic ---
    const cartItemsContainer = document.querySelector('.cart-items');
    if (cartItemsContainer) {
        cartItemsContainer.addEventListener('click', (e) => {
            // Delegate event for update buttons
            if (e.target.classList.contains('btn-update-qty')) {
                e.preventDefault();
                const button = e.target;
                const quantityInput = button.previousElementSibling; // Find the input just before the button
                if (!quantityInput || !quantityInput.matches('.quantity-input')) return; // Ensure it's the correct input

                const productId = quantityInput.dataset.productId;
                const newQuantity = parseInt(quantityInput.value, 10);

                if (!quantityInput.dataset.originalValue) {
                    quantityInput.dataset.originalValue = quantityInput.value;
                }

                if (isNaN(newQuantity) || newQuantity < 0) {
                    showToast('Invalid quantity entered.', 'danger');
                    quantityInput.value = quantityInput.dataset.originalValue || '1'; // Fallback to 1 if original is missing
                    return;
                }
                const maxStock = parseInt(quantityInput.max, 10);
                if (!isNaN(maxStock) && newQuantity > maxStock) {
                    showToast(`Only ${maxStock} items available in stock.`, 'warning');
                    quantityInput.value = maxStock;
                    return;
                }
                updateCartItemQuantityAJAX(productId, newQuantity, button, quantityInput);
            }
        });
    }


    // ========================================
    // Dynamic Search Bar Logic
    // ========================================
    const searchContainer = document.getElementById('dynamic-search-container');
    const searchToggleBtn = document.getElementById('search-toggle-btn');
    const searchForm = document.getElementById('dynamic-search-form');
    const searchInput = document.getElementById('search-input-dynamic');
    const suggestionsDropdown = document.getElementById('suggestions-dropdown');
    let suggestionFetchTimeout;

    if (searchToggleBtn && searchContainer) {
        searchToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent body click listener from closing it immediately
            searchContainer.classList.toggle('active');
            if (searchContainer.classList.contains('active')) {
                // Use requestAnimationFrame for smoother focus transition after style changes
                requestAnimationFrame(() => { if(searchInput) searchInput.focus(); });
            } else {
                if(suggestionsDropdown) suggestionsDropdown.classList.remove('active');
            }
        });
    }

    if (searchInput && suggestionsDropdown && searchForm) {
        searchInput.addEventListener('input', () => {
            const query = searchInput.value.trim();
            clearTimeout(suggestionFetchTimeout);

            if (query.length >= 2) {
                suggestionsDropdown.innerHTML = '<div class="suggestion-item text-muted"><i>Loading...</i></div>';
                suggestionsDropdown.classList.add('active');
                suggestionFetchTimeout = setTimeout(() => {
                    fetchSuggestions(query);
                }, 300); // Debounce API calls
            } else {
                suggestionsDropdown.innerHTML = '';
                suggestionsDropdown.classList.remove('active');
            }
        });

        searchInput.addEventListener('focus', () => {
             const query = searchInput.value.trim();
              // Show suggestions on focus only if there's a query and suggestions are already rendered
              const hasActualSuggestions = suggestionsDropdown.querySelector('a.suggestion-item');
              if (query.length >= 2 && hasActualSuggestions) {
                 suggestionsDropdown.classList.add('active');
             }
        });

         // Optional: Prevent form submission if user clicks a suggestion link quickly
         searchForm.addEventListener('submit', (e) => {
             // If suggestions are visible, maybe delay submit slightly or check click target
             if (suggestionsDropdown.classList.contains('active')) {
                // Potentially add logic here if needed, but default browser behavior usually handles it
             }
         });
    }

     async function fetchSuggestions(query) {
         if (!suggestionsDropdown) return;
         try {
             const response = await fetch(`/products/suggestions?q=${encodeURIComponent(query)}`);
             if (!response.ok) {
                 let errorMsg = `HTTP error! status: ${response.status}`;
                 try { const errorData = await response.json(); errorMsg = errorData.error || errorMsg; } catch (parseError) {}
                 throw new Error(errorMsg);
             }
             const suggestions = await response.json();
             displaySuggestions(suggestions);
         } catch (error) {
             console.error('Error fetching suggestions:', error);
             suggestionsDropdown.innerHTML = `<div class="suggestion-item text-danger"><i>Error: ${error.message || 'Failed to fetch'}</i></div>`;
             if (!suggestionsDropdown.classList.contains('active')) {
                 suggestionsDropdown.classList.add('active'); // Ensure dropdown is visible for error
             }
         }
     }

     function displaySuggestions(suggestions) {
          if (!suggestionsDropdown) return;
         suggestionsDropdown.innerHTML = ''; // Clear previous results/loading
         if (suggestions.length > 0) {
             suggestions.forEach(product => {
                 const item = document.createElement('a');
                 item.classList.add('suggestion-item');
                 item.href = `/products/${product._id}`;
                 // Basic sanitization for display (more robust needed for complex HTML injection)
                 const safeName = product.name ? product.name.replace(/</g, "<").replace(/>/g, ">") : '[No Name]';
                 const safeImageUrl = product.imageUrl ? product.imageUrl.replace(/</g, "<").replace(/>/g, ">") : '/images/placeholder.png';
                 item.innerHTML = `
                    <img src="${safeImageUrl}" alt="" loading="lazy">
                    <span>${safeName}</span>
                 `;
                 suggestionsDropdown.appendChild(item);
             });
             if (!suggestionsDropdown.classList.contains('active')) {
                suggestionsDropdown.classList.add('active'); // Ensure dropdown visible
             }
         } else {
              suggestionsDropdown.innerHTML = '<div class="suggestion-item text-muted"><i>No matching products found.</i></div>';
              if (!suggestionsDropdown.classList.contains('active')) {
                suggestionsDropdown.classList.add('active'); // Ensure dropdown visible
             }
         }
     }

     // Global click listener to close search/suggestions
     document.addEventListener('click', (e) => {
         // Close if click is outside the search container AND outside the toggle button
         if (searchContainer && suggestionsDropdown && searchToggleBtn && !searchContainer.contains(e.target) && !searchToggleBtn.contains(e.target)) {
             searchContainer.classList.remove('active');
             suggestionsDropdown.classList.remove('active');
         }
     });

     // Handle clicks within the suggestions dropdown
     if(suggestionsDropdown) {
         suggestionsDropdown.addEventListener('click', (e) => {
             const link = e.target.closest('a.suggestion-item');
             if (!link) {
                 // Prevent closing if clicking inside the dropdown but not on a link
                 e.stopPropagation();
             }
             // Browser default action will navigate if 'link' is clicked
         });
     }
    // ========================================
    // End Dynamic Search Bar Logic
    // ========================================


    // ========================================
    // Toast Notification Logic (Initial Setup)
    // ========================================
    const toastContainer = document.querySelector('.toast-container');
    if (toastContainer) {
        const toastElements = toastContainer.querySelectorAll('.toast');

        toastElements.forEach((toastElement) => {
            const closeButton = toastElement.querySelector('.toast-close-btn');
            const autoHideDelay = 5000; // 5 seconds
            let hideTimeoutId;

            const dismissToast = () => {
                clearTimeout(hideTimeoutId);
                if (toastElement.classList.contains('hide') || !toastElement.parentNode) return;
                toastElement.classList.remove('show');
                toastElement.classList.add('hide');
                // Use transitionend event for reliable removal after animation
                toastElement.addEventListener('transitionend', (event) => {
                    // Check event target and property to avoid multiple removals if transitions apply to child elements
                    if (event.target === toastElement && (event.propertyName === 'opacity' || event.propertyName === 'transform')) {
                        if (toastElement.classList.contains('hide') && toastElement.parentNode) {
                           try { toastElement.remove(); } catch(e) { console.warn("Error removing toast:", e); }
                        }
                    }
                }, { once: true });
            };

            // Show toast initially with a slight delay for animation
            setTimeout(() => {
                if (toastElement.parentNode) { // Check if still in DOM
                   toastElement.classList.add('show');
                }
            }, 10); // Short delay

             // Auto hide
             hideTimeoutId = setTimeout(dismissToast, autoHideDelay);

            // Manual close
            if (closeButton) {
                closeButton.addEventListener('click', dismissToast);
            }

             // Pause on hover, resume on leave
             toastElement.addEventListener('mouseenter', () => clearTimeout(hideTimeoutId));
             toastElement.addEventListener('mouseleave', () => {
                 clearTimeout(hideTimeoutId); // Clear any previous timeout
                 hideTimeoutId = setTimeout(dismissToast, autoHideDelay / 2); // Resume timeout (can adjust duration)
            });

        });
    }
    // ========================================
    // End Toast Notification Logic (Initial Setup)
    // ========================================

    // --- Rating Stats Bar Animation ---
    document.querySelectorAll('.rating-bar-fill').forEach(function(el) {
        const width = el.getAttribute('data-width');
        if (width) {
            // Use requestAnimationFrame for smoother animation start
            requestAnimationFrame(() => {
                 if(el.parentNode) { // Check if element is still in DOM
                    el.style.width = width + '%';
                 }
            });
        }
    });

    // ========================================
    // Loading State for Non-Form Actions (e.g., Proceed to Checkout)
    // ========================================
    const proceedCheckoutBtn = document.getElementById('btn-proceed-checkout');
    if (proceedCheckoutBtn) {
        const originalCheckoutText = proceedCheckoutBtn.innerHTML;
        const loadingCheckoutText = proceedCheckoutBtn.dataset.loadingText || '<i class="fas fa-spinner fa-spin"></i> Loading...';

        proceedCheckoutBtn.addEventListener('click', function(event) {
            // Prevent multiple clicks while loading
            if (proceedCheckoutBtn.classList.contains('loading')) {
                event.preventDefault();
                return;
            }
            // Add loading state
            proceedCheckoutBtn.classList.add('loading');
            proceedCheckoutBtn.innerHTML = loadingCheckoutText;
            proceedCheckoutBtn.style.pointerEvents = 'none'; // Disable clicks via CSS
            proceedCheckoutBtn.setAttribute('aria-disabled', 'true'); // Accessibility
        });

        // Handle browser back button potentially showing stale loading state
        window.addEventListener('pageshow', function(pageEvent) {
            if (pageEvent.persisted && proceedCheckoutBtn.classList.contains('loading')) {
                // Restore button if the page was loaded from bfcache and button is still loading
                proceedCheckoutBtn.classList.remove('loading');
                proceedCheckoutBtn.innerHTML = originalCheckoutText;
                proceedCheckoutBtn.style.pointerEvents = 'auto';
                proceedCheckoutBtn.removeAttribute('aria-disabled');
            }
        });
    }
    // ========================================
    // End Loading State for Non-Form Actions
    // ========================================


    // ========================================
    // Pincode Lookup Logic (UPDATED for Locality)
    // ========================================
    const pincodeInputs = document.querySelectorAll('.pincode-input');
    let pincodeTimeout;

    pincodeInputs.forEach(input => {
        const targetPrefix = input.dataset.targetPrefix;
        if (!targetPrefix) {
            console.warn("Pincode input missing data-target-prefix:", input);
            return;
        }

        // Get Locality Select Element and status element
        const localitySelect = document.getElementById(`${targetPrefix}-locality`);
        const pincodeStatusElement = input.nextElementSibling?.classList.contains('pincode-status') ? input.nextElementSibling : null; // Safer check

        if (!localitySelect) {
            console.warn(`Locality select not found for prefix ${targetPrefix}`);
            return; // Skip this input if locality select is missing
        }

        input.addEventListener('input', () => {
            clearTimeout(pincodeTimeout);
            const pincode = input.value.trim();

            // Basic validation and clearing/resetting fields
            clearAutoFilledFields(targetPrefix); // Always clear derived fields on input change
            if (pincodeStatusElement) { // Reset status on input
                pincodeStatusElement.textContent = '';
                pincodeStatusElement.className = 'pincode-status text-muted';
            }

            if (pincode.length === 0) {
                 return; // Do nothing more if empty
            }

            if (!/^\d*$/.test(pincode)) { // Check for non-digits
                 if (pincodeStatusElement) {
                    pincodeStatusElement.textContent = 'Digits only';
                    pincodeStatusElement.className = 'pincode-status text-danger';
                 }
                 return;
            }

            if (pincode.length === 6) { // Only trigger lookup when exactly 6 digits
                if (pincodeStatusElement) {
                    pincodeStatusElement.textContent = 'Looking up...';
                    pincodeStatusElement.className = 'pincode-status text-muted';
                }
                localitySelect.disabled = true;
                localitySelect.innerHTML = '<option value="" selected disabled>Looking up Pincode...</option>';

                pincodeTimeout = setTimeout(() => {
                    fetchPincodeData(pincode, targetPrefix, null); // Pass null for savedLocalityValue on input trigger
                }, 500); // Debounce API call
            } else if (pincode.length > 6) {
                 if (pincodeStatusElement) {
                     pincodeStatusElement.textContent = 'Max 6 digits';
                     pincodeStatusElement.className = 'pincode-status text-danger';
                 }
            }
            // No status message needed if < 6 digits and valid
        });

        // Optional: Re-validate or fetch on blur if needed, but input event is usually sufficient
        // input.addEventListener('blur', () => { ... });

        // Initial check on page load for pre-filled pincodes
        const initialPincode = input.value.trim();
        // Get saved locality value from data attribute set in EJS
        const savedLocality = localitySelect.dataset.savedValue || null;

        if (initialPincode.length === 6 && /^\d{6}$/.test(initialPincode)) {
            if (pincodeStatusElement) {
                pincodeStatusElement.textContent = 'Verifying...';
                 pincodeStatusElement.className = 'pincode-status text-muted';
            }
            localitySelect.disabled = true;
            localitySelect.innerHTML = '<option value="" selected disabled>Verifying Pincode...</option>';
            // Fetch data on load for pre-filled valid pincode
            fetchPincodeData(initialPincode, targetPrefix, savedLocality); // Pass saved locality
        } else {
             // Ensure dropdown is disabled if pincode is initially invalid/empty
             localitySelect.disabled = true;
             localitySelect.innerHTML = '<option value="" selected disabled>Enter Pincode First</option>';
        }

    }); // end pincodeInputs.forEach

    async function fetchPincodeData(pincode, prefix, savedLocalityValue = null) {
        // Find all related elements using the prefix
        const stateInput = document.getElementById(`${prefix}-state`);
        const districtInput = document.getElementById(`${prefix}-district`);
        const mandalInput = document.getElementById(`${prefix}-mandal`);
        const stateHiddenInput = document.getElementById(`${prefix}-state-hidden`);
        const districtHiddenInput = document.getElementById(`${prefix}-district-hidden`);
        const mandalHiddenInput = document.getElementById(`${prefix}-mandal-hidden`);
        const containerDiv = document.getElementById(`${prefix}-auto-filled-fields`);
        const pincodeInput = document.getElementById(`${prefix}-pincode`);
        const pincodeStatusElement = pincodeInput?.nextElementSibling?.classList.contains('pincode-status') ? pincodeInput.nextElementSibling : null;
        const localitySelect = document.getElementById(`${prefix}-locality`);

        // Basic check if all necessary elements exist
        if (!stateInput || !districtInput || !mandalInput || !containerDiv || !pincodeStatusElement || !localitySelect || !stateHiddenInput || !districtHiddenInput || !mandalHiddenInput) {
            console.error("Pincode related elements not found for prefix:", prefix);
            if (pincodeStatusElement) { pincodeStatusElement.textContent = 'Page Setup Error'; pincodeStatusElement.className = 'pincode-status text-danger'; }
            if (localitySelect) { localitySelect.innerHTML = '<option value="" selected disabled>Page Setup Error</option>'; localitySelect.disabled = true; }
            return;
        }

        // Update status only if not already success (prevents flicker on load)
        if (!pincodeStatusElement.classList.contains('text-success')) {
            pincodeStatusElement.textContent = 'Fetching...';
            pincodeStatusElement.className = 'pincode-status text-muted';
        }

        try {
            const response = await fetch(`/user/pincode-lookup/${pincode}`);
            const data = await response.json();

            if (!response.ok || !data.success) {
                 throw new Error(data.message || `Pincode ${response.statusText}`);
             }

            const location = data.location;

            // Update visible readonly fields
            stateInput.value = location.stateName || '';
            districtInput.value = location.districtName || '';
            mandalInput.value = location.mandalName || '';

             // Update hidden fields for form submission
            stateHiddenInput.value = location.stateName || '';
            districtHiddenInput.value = location.districtName || '';
            mandalHiddenInput.value = location.mandalName || '';

            // Populate Locality Dropdown using the helper
            populateLocalityDropdown(localitySelect, location.localities, savedLocalityValue);

            containerDiv.style.display = 'block'; // Show the container
            const firstLocality = location.localities && location.localities.length > 0 ? location.localities[0] : 'Area';
            pincodeStatusElement.textContent = `✓ Location Found`; // Simpler success message
            pincodeStatusElement.className = 'pincode-status text-success';

        } catch (error) {
             console.error('Pincode lookup error:', error);
             clearAutoFilledFields(prefix); // Clear derived fields on error
             pincodeStatusElement.textContent = `Error: ${error.message}`;
             pincodeStatusElement.className = 'pincode-status text-danger';
             localitySelect.innerHTML = '<option value="" selected disabled>Pincode Error</option>';
             localitySelect.disabled = true;
        }
    }

    function populateLocalityDropdown(selectElement, localities, valueToSelect = null) {
        if (!selectElement) return;
        selectElement.innerHTML = ''; // Clear existing options

        if (localities && localities.length > 0) {
            // Add the default "Select..." option
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "Select Locality / Post Office...";
            defaultOption.disabled = true;
            // Select default option initially only if no specific value needs selecting
            defaultOption.selected = !valueToSelect;
            selectElement.appendChild(defaultOption);

            let valueMatched = false;
            localities.forEach(locality => {
                const option = document.createElement('option');
                option.value = locality; // Use locality name as value
                option.textContent = locality; // Display locality name
                if (valueToSelect && locality === valueToSelect) {
                    option.selected = true; // Pre-select if value matches
                    valueMatched = true;
                }
                selectElement.appendChild(option);
            });

            // If a specific value was provided and matched, unselect the default option
             if (valueMatched) {
                 defaultOption.selected = false;
             }

            selectElement.disabled = false; // Enable the dropdown
        } else {
            // Handle case where API returns success but no localities
            selectElement.innerHTML = '<option value="" selected disabled>No Localities Found</option>';
            selectElement.disabled = true;
        }
    }

    function clearAutoFilledFields(prefix) {
        const stateInput = document.getElementById(`${prefix}-state`);
        const districtInput = document.getElementById(`${prefix}-district`);
        const mandalInput = document.getElementById(`${prefix}-mandal`);
        const stateHiddenInput = document.getElementById(`${prefix}-state-hidden`);
        const districtHiddenInput = document.getElementById(`${prefix}-district-hidden`);
        const mandalHiddenInput = document.getElementById(`${prefix}-mandal-hidden`);
        const containerDiv = document.getElementById(`${prefix}-auto-filled-fields`);
        const localitySelect = document.getElementById(`${prefix}-locality`);

        if (stateInput) stateInput.value = '';
        if (districtInput) districtInput.value = '';
        if (mandalInput) mandalInput.value = '';
        if (stateHiddenInput) stateHiddenInput.value = '';
        if (districtHiddenInput) districtHiddenInput.value = '';
        if (mandalHiddenInput) mandalHiddenInput.value = '';
        if (containerDiv) containerDiv.style.display = 'none'; // Hide the container

        // Reset the locality dropdown
        if (localitySelect) {
            localitySelect.innerHTML = '<option value="" selected disabled>Enter Pincode First</option>';
            localitySelect.disabled = true;
            localitySelect.value = ''; // Ensure value is cleared
            localitySelect.dataset.savedValue = ''; // Clear saved value tracker
        }
        // Pincode status is usually cleared by the input event handler itself
    }
    // ========================================
    // End Pincode Lookup Logic
    // ========================================

    // ========================================
    // Generic Live Table Filtering Logic
    // ========================================
    /**
     * Sets up live filtering for a table based on text input.
     * @param {string} inputId ID of the filter input element.
     * @param {string} tableId ID of the table element.
     * @param {string} noResultsId ID of the 'no results' <tr> element.
     * @param {string} rowSelectorClass CSS class used to identify data rows in the tbody.
     */
    function setupGenericTableFilter(inputId, tableId, noResultsId, rowSelectorClass) {
        const filterInput = document.getElementById(inputId);
        const table = document.getElementById(tableId);
        const noResultsRow = document.getElementById(noResultsId);

        if (!filterInput || !table || !noResultsRow) {
            // console.warn(`Filter setup skipped for ${inputId}. Missing elements.`); // Optional warning
            return; // Exit if any required element is missing
        }

        const tableBody = table.querySelector('tbody');
        if (!tableBody) {
            // console.warn(`Filter setup skipped for ${tableId}. Missing tbody.`); // Optional warning
            return; // Exit if table structure is unexpected
        }

        filterInput.addEventListener('input', () => {
            const filterValue = filterInput.value.trim().toLowerCase();
            const rows = tableBody.querySelectorAll(`tr.${rowSelectorClass}`); // Select only data rows
            let matchFound = false;

            rows.forEach(row => {
                const rowText = row.textContent.toLowerCase();
                if (filterValue === '' || rowText.includes(filterValue)) {
                    row.style.display = ''; // Show row (reverts to default display)
                    matchFound = true;
                } else {
                    row.style.display = 'none'; // Hide row
                }
            });

            // Toggle the 'no results' row visibility
            if (!matchFound && rows.length > 0) { // Only show 'no results' if there were rows to filter
                noResultsRow.classList.remove('hidden');
                noResultsRow.style.display = ''; // Use default display (usually table-row)
            } else {
                noResultsRow.classList.add('hidden');
                noResultsRow.style.display = 'none'; // Hide 'no results' row
            }
        });
    }

    // --- Call the setup function for ALL tables that need filtering ---
    setupGenericTableFilter('order-filter-input', 'admin-order-table', 'no-admin-orders-found', 'order-row');
    setupGenericTableFilter('order-filter-input', 'seller-order-table', 'no-seller-orders-found', 'order-row'); // Assumes same input ID pattern
    setupGenericTableFilter('admin-product-filter-input', 'admin-product-table', 'no-admin-products-found', 'product-row');
    setupGenericTableFilter('seller-product-filter-input', 'seller-product-table', 'no-seller-products-found', 'product-row');
    setupGenericTableFilter('user-filter-input', 'admin-user-table', 'no-admin-users-found', 'user-row'); // User filter

    // ========================================
    // End Live Table Filtering Logic
    // ========================================


    // ========================================
    // Generic Infinite Sliding Logic (Handles Banner & Product Images)
    // ========================================
    /**
     * Initializes an infinite sliding carousel.
     * @param {string} containerSelector - CSS selector for the main slider container element.
     * @param {object} options - Configuration options.
     * @param {number} [options.slideIntervalTime=5000] - Autoplay interval in ms (0 to disable).
     * @param {string} [options.slideClass='[data-slide]'] - CSS selector for individual slide elements.
     * @param {string} [options.wrapperClass='[data-slides-wrapper]'] - CSS selector for the wrapper holding the slides.
     * @param {string} [options.prevBtnClass='[data-slider-prev]'] - CSS selector for the previous button.
     * @param {string} [options.nextBtnClass='[data-slider-next]'] - CSS selector for the next button.
     * @param {string} [options.dotsContainerClass='[data-slider-dots]'] - CSS selector for the dots container.
     * @param {string} [options.dotClass='[data-slide-to]'] - CSS selector for individual dot elements.
     * @param {string} [options.dotDataAttribute='data-slide-to'] - Data attribute on dots containing the target index.
     */
    function initializeInfiniteSlider(containerSelector, options = {}) {
        const sliderContainer = document.querySelector(containerSelector);
        if (!sliderContainer) {
            // console.log(`Slider container "${containerSelector}" not found.`);
            return;
        }

        const config = {
            slideIntervalTime: 5000,
            slideClass: '[data-slide]', // Default to data-slide used in banner
            wrapperClass: '[data-slides-wrapper]',
            prevBtnClass: '[data-slider-prev]',
            nextBtnClass: '[data-slider-next]',
            dotsContainerClass: '[data-slider-dots]',
            dotClass: '[data-slide-to]', // Use the data attribute itself as selector part
            dotDataAttribute: 'data-slide-to',
            ...options // Override defaults with provided options
        };

        const slidesWrapper = sliderContainer.querySelector(config.wrapperClass);
        const originalSlides = Array.from(sliderContainer.querySelectorAll(`${config.wrapperClass} > ${config.slideClass}`)); // Select direct children matching slideClass

        const prevBtn = sliderContainer.querySelector(config.prevBtnClass);
        const nextBtn = sliderContainer.querySelector(config.nextBtnClass);
        const dotsContainer = sliderContainer.querySelector(config.dotsContainerClass);
        let dots = dotsContainer ? Array.from(dotsContainer.querySelectorAll(config.dotClass)) : [];

        if (!slidesWrapper || originalSlides.length === 0) {
            // console.log(`Slider "${containerSelector}" missing wrapper or slides.`);
            // Optionally hide controls if no slides
            if (prevBtn) prevBtn.style.display = 'none';
            if (nextBtn) nextBtn.style.display = 'none';
            if (dotsContainer) dotsContainer.style.display = 'none';
            return;
        }

        let totalOriginalSlides = originalSlides.length;
        let currentIndex = 1; // Start at the first *original* slide (index 1 after cloning)
        let totalSlidesIncludingClones = totalOriginalSlides;
        let isTransitioning = false;
        let autoSlideInterval = null;
        let isDragging = false;
        let startX = 0;
        let currentX = 0;
        let diffX = 0;
        const swipeThreshold = 50; // Min pixels to swipe

        // --- Setup Clones for Infinite Loop (only if more than 1 slide) ---
        if (totalOriginalSlides > 1) {
            const firstClone = originalSlides[0].cloneNode(true);
            const lastClone = originalSlides[totalOriginalSlides - 1].cloneNode(true);

            // Remove data attributes from clones if they cause issues (e.g., duplicate IDs)
            firstClone.removeAttribute(config.slideClass.replace(/[\[\]]/g, '')); // Remove data-slide attribute if that's the selector
            lastClone.removeAttribute(config.slideClass.replace(/[\[\]]/g, ''));
            // Ensure specific dot data attributes are removed if they exist
             const dotAttr = config.dotDataAttribute;
             if (dotAttr) {
                 firstClone.removeAttribute(dotAttr);
                 lastClone.removeAttribute(dotAttr);
                 // Also check children if necessary, although unlikely for slides
             }

            slidesWrapper.appendChild(firstClone);
            slidesWrapper.insertBefore(lastClone, originalSlides[0]);
            totalSlidesIncludingClones = totalOriginalSlides + 2;
        } else {
            // Only one slide, disable controls and interval
            currentIndex = 0; // Only one slide at index 0
            if (prevBtn) prevBtn.style.display = 'none';
            if (nextBtn) nextBtn.style.display = 'none';
            if (dotsContainer) dotsContainer.style.display = 'none';
            config.slideIntervalTime = 0; // Disable autoslide
        }

        // --- Initial Positioning ---
        function setInitialPosition() {
            slidesWrapper.style.transition = 'none'; // No transition for initial set
            slidesWrapper.style.transform = `translateX(-${currentIndex * 100}%)`;
            // Force reflow/repaint before re-enabling transitions
            void slidesWrapper.offsetWidth;
            // Set transition after initial position is set
            slidesWrapper.style.transition = 'transform 0.5s ease-in-out';
        }

        // --- Update Dots ---
        function updateDots(targetOriginalIndex) {
            if (dots.length !== totalOriginalSlides) return; // Ensure dots match original slides
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === targetOriginalIndex);
            });
        }

        // --- Go To Slide Function ---
        function goToSlide(index, withTransition = true) {
            if (isTransitioning || totalSlidesIncludingClones <= 1) return; // Prevent multiple transitions / no slides
            isTransitioning = true;

            slidesWrapper.style.transition = withTransition ? 'transform 0.5s ease-in-out' : 'none';
            slidesWrapper.style.transform = `translateX(-${index * 100}%)`;
            currentIndex = index;

            // Calculate the corresponding dot index (0-based for original slides)
            let targetOriginalIndex = (currentIndex - 1 + totalOriginalSlides) % totalOriginalSlides;
            updateDots(targetOriginalIndex);

            // If not using transition (jump), reset isTransitioning immediately
             if (!withTransition) {
                setTimeout(() => { isTransitioning = false; }, 50); // Small delay to ensure styles apply
             }
        }

        // --- Handle Transition End for Infinite Loop Jump ---
        slidesWrapper.addEventListener('transitionend', () => {
            isTransitioning = false; // Transition finished

             if (totalOriginalSlides <= 1) return; // No jump needed for single slide

            // Jump from last clone to original first slide
            if (currentIndex === totalSlidesIncludingClones - 1) {
                 goToSlide(1, false); // Jump to index 1 (first original) without transition
            }
            // Jump from first clone to original last slide
            else if (currentIndex === 0) {
                 goToSlide(totalOriginalSlides, false); // Jump to index totalOriginalSlides (last original) without transition
            }
        });

        // --- Navigation Button Listeners ---
        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                if (isTransitioning || totalSlidesIncludingClones <= 1) return;
                goToSlide(currentIndex + 1);
                resetAutoSlide(); // Reset timer on manual interaction
            });
        }
        if (prevBtn) {
            prevBtn.addEventListener('click', () => {
                if (isTransitioning || totalSlidesIncludingClones <= 1) return;
                goToSlide(currentIndex - 1);
                resetAutoSlide();
            });
        }

        // --- Dot Navigation Listeners ---
        if (dotsContainer && dots.length > 0) {
            dots.forEach((dot) => {
                dot.addEventListener('click', (e) => {
                    if (isTransitioning || totalSlidesIncludingClones <= 1) return;
                     // Use closest to ensure we get the button even if user clicks inner element like <i>
                    const targetDotButton = e.target.closest(`[${config.dotDataAttribute}]`);
                    if (targetDotButton) {
                        const targetOriginalIndex = parseInt(targetDotButton.getAttribute(config.dotDataAttribute), 10);
                        if (!isNaN(targetOriginalIndex)) {
                            goToSlide(targetOriginalIndex + 1); // Go to actual index (+1 for clone)
                            resetAutoSlide();
                        }
                    }
                });
            });
        }


        // --- Auto Sliding ---
        function startAutoSlide() {
            if (config.slideIntervalTime <= 0 || totalSlidesIncludingClones <= 1) return; // Only if interval > 0 and more than one slide
            clearInterval(autoSlideInterval); // Clear previous interval
            autoSlideInterval = setInterval(() => {
                goToSlide(currentIndex + 1);
            }, config.slideIntervalTime);
        }

        function resetAutoSlide() {
            clearInterval(autoSlideInterval);
            startAutoSlide();
        }

        // Pause on hover
        sliderContainer.addEventListener('mouseenter', () => clearInterval(autoSlideInterval));
        sliderContainer.addEventListener('mouseleave', startAutoSlide);
        // Also pause on focus within slider elements (accessibility)
        sliderContainer.addEventListener('focusin', () => clearInterval(autoSlideInterval));
        sliderContainer.addEventListener('focusout', startAutoSlide);


        // --- Touch/Swipe Listeners ---
        function handleTouchStart(event) {
            if (totalSlidesIncludingClones <= 1) return;
            isDragging = true;
            startX = event.touches[0].pageX;
            currentX = startX;
            diffX = 0;
            clearInterval(autoSlideInterval); // Pause auto slide
            slidesWrapper.style.transition = 'none'; // Disable transition during drag
        }

        function handleTouchMove(event) {
             if (!isDragging || totalSlidesIncludingClones <= 1) return;
             currentX = event.touches[0].pageX;
             diffX = startX - currentX;
             // Apply drag effect directly to transform
             const currentTranslate = -currentIndex * slidesWrapper.offsetWidth; // Base position
             slidesWrapper.style.transform = `translateX(${currentTranslate - diffX}px)`;
             // Simple check to prevent vertical scroll during horizontal swipe
             if (Math.abs(diffX) > 10) {
                // Note: preventDefault() here can block vertical scrolling, use carefully
                // event.preventDefault();
             }
        }

        function handleTouchEnd() {
             if (!isDragging || totalSlidesIncludingClones <= 1) return;
             isDragging = false;
             slidesWrapper.style.transition = 'transform 0.5s ease-in-out'; // Re-enable transition

             if (Math.abs(diffX) > swipeThreshold) {
                 if (diffX > 0) { goToSlide(currentIndex + 1); } // Swipe Left -> Next
                 else { goToSlide(currentIndex - 1); } // Swipe Right -> Prev
             } else {
                 // Didn't swipe enough, snap back to current slide
                 goToSlide(currentIndex);
             }
             // Reset variables and restart auto-slide
             startX = 0; currentX = 0; diffX = 0;
             resetAutoSlide();
         }

        if (totalSlidesIncludingClones > 1) {
            sliderContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
            sliderContainer.addEventListener('touchmove', handleTouchMove, { passive: true }); // Use passive: true if not preventing default
            sliderContainer.addEventListener('touchend', handleTouchEnd);
            sliderContainer.addEventListener('touchcancel', handleTouchEnd); // Handle cancelled touches
        }

        // --- Initialize ---
        setInitialPosition(); // Set initial position without transition
        updateDots(0); // Update dots for the first original slide
        startAutoSlide(); // Start auto-slide if applicable

         // --- Make Controls Visible After Setup (if applicable) ---
         if (totalOriginalSlides > 1) {
            if (prevBtn) prevBtn.style.display = 'flex'; // Or 'block'/'inline-flex' as needed
            if (nextBtn) nextBtn.style.display = 'flex';
            if (dotsContainer) dotsContainer.style.display = 'flex';
        }

    } // --- End initializeInfiniteSlider ---


    // --- Call the function for the Banner Slider ---
    initializeInfiniteSlider('[data-slider-container]', {
        // Options specific to banner slider if needed, otherwise defaults are used
        // Example: slideIntervalTime: 6000
    });

    // --- Call the function for the Product Detail Slider ---
    initializeInfiniteSlider('[data-product-image-slider]', {
        slideClass: '[data-product-slide]', // Specify the slide selector used here
        wrapperClass: '[data-product-slides-wrapper]',
        prevBtnClass: '[data-product-image-nav="prev"]',
        nextBtnClass: '[data-product-image-nav="next"]',
        dotsContainerClass: '.product-image-dots', // Class selector for dots container
        dotClass: '[data-product-image-dot]', // Selector for dots
        dotDataAttribute: 'data-product-image-dot', // Attribute containing index
        slideIntervalTime: 0 // Disable auto-slide for product images
    });

    // ========================================
    // End Generic Infinite Sliding Logic
    // ========================================


}); // End DOMContentLoaded


// ===================================================
// Helper Functions (Defined outside DOMContentLoaded)
// ===================================================

// --- Cart Update AJAX Function ---
async function updateCartItemQuantityAJAX(productId, quantity, buttonElement, quantityInputElement) {
     // Use the button's text or a default
     const originalButtonText = quantityInputElement?.dataset.originalButtonText || 'Update';
     const loadingButtonText = '<i class="fas fa-spinner fa-spin"></i>';
     const cartItemDiv = buttonElement.closest('.cart-item');

     if (!quantityInputElement?.dataset.originalButtonText) {
         quantityInputElement.dataset.originalButtonText = buttonElement.textContent.trim() || 'Update';
     }

     buttonElement.disabled = true;
     buttonElement.innerHTML = loadingButtonText;
     if(quantityInputElement) quantityInputElement.readOnly = true;

    try {
        const response = await fetch('/user/cart/update', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json' // Indicate expected response type
            },
            body: JSON.stringify({ productId, quantity })
         });

        const data = await response.json(); // Assume server always sends JSON

        if (!response.ok) {
             // Handle specific case where item becomes unavailable during update
             if (data.removal === true && cartItemDiv) {
                 showToast(data.message || 'Item unavailable and removed.', 'warning');
                 // Animate removal
                 cartItemDiv.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease, border 0.3s ease';
                 cartItemDiv.style.opacity = '0';
                 cartItemDiv.style.height = '0';
                 cartItemDiv.style.marginTop = '0';
                 cartItemDiv.style.marginBottom = '0';
                 cartItemDiv.style.paddingTop = '0';
                 cartItemDiv.style.paddingBottom = '0';
                 cartItemDiv.style.borderWidth = '0';
                 setTimeout(() => {
                     if (cartItemDiv.parentNode) cartItemDiv.remove();
                     updateCartTotalAndBadge(data.cartTotal); // Update total from response
                     handleEmptyCartDisplay(); // Check if cart is now empty
                 }, 300); // Match transition duration
                 return; // Exit function after initiating removal
             } else {
                 // General error handling
                 throw new Error(data.message || `Update failed (Status: ${response.status})`);
             }
        }

         // --- Handle successful update ---
         if (data.success) {
             if(quantityInputElement) {
                 quantityInputElement.dataset.originalValue = data.newQuantity; // Update original value tracker
             }

             if (quantity === 0 && cartItemDiv) { // Handle removal via quantity 0
                 // Animate removal (same as above)
                 cartItemDiv.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease, border 0.3s ease';
                 cartItemDiv.style.opacity = '0';
                 cartItemDiv.style.height = '0';
                 cartItemDiv.style.marginTop = '0';
                 cartItemDiv.style.marginBottom = '0';
                 cartItemDiv.style.paddingTop = '0';
                 cartItemDiv.style.paddingBottom = '0';
                 cartItemDiv.style.borderWidth = '0';
                 setTimeout(() => {
                     if (cartItemDiv.parentNode) cartItemDiv.remove();
                     updateCartTotalAndBadge(data.cartTotal);
                     handleEmptyCartDisplay();
                     showToast('Item removed from cart.', 'success');
                 }, 300);
                 return; // Exit after starting removal animation
             } else if (cartItemDiv) {
                 // Update UI for non-zero quantity
                 const subtotalSpan = cartItemDiv.querySelector('.item-subtotal-value');
                 if (subtotalSpan) subtotalSpan.textContent = (data.itemSubtotal !== undefined ? data.itemSubtotal : 0).toFixed(2);
                 if(quantityInputElement) quantityInputElement.value = data.newQuantity;
                 updateCartTotalAndBadge(data.cartTotal); // Update total from response
                 // showToast('Cart quantity updated.', 'success'); // Optional success message
             }
         } else {
              // Handle cases where data.success might be false but response was 200 OK (less common)
              showToast(`Update failed: ${data.message || 'Unknown error'}`, 'danger');
              if(quantityInputElement && quantityInputElement.dataset.originalValue) {
                  quantityInputElement.value = quantityInputElement.dataset.originalValue;
              }
         }

    } catch (error) {
         console.error('Error updating cart quantity:', error);
          showToast(`Error: ${error.message}`, 'danger');
          // Restore input value on error
          if(quantityInputElement && quantityInputElement.dataset.originalValue) {
            quantityInputElement.value = quantityInputElement.dataset.originalValue;
          }

    } finally {
         // Re-enable button only if the item wasn't removed
         if (cartItemDiv && (!cartItemDiv.style.opacity || parseFloat(cartItemDiv.style.opacity) !== 0)) {
             buttonElement.disabled = false;
             buttonElement.innerHTML = quantityInputElement?.dataset.originalButtonText || 'Update'; // Restore original text
             if(quantityInputElement) quantityInputElement.readOnly = false;
         }
     }
}

// --- Helper Function to Show Toasts Dynamically ---
function showToast(message, type = 'info') {
    const toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
        console.error("Toast container not found! Falling back to alert.");
        alert(`${type.toUpperCase()}: ${message}`); // Fallback alert
        return;
    }

    const toastElement = document.createElement('div');
    toastElement.className = `toast toast-${type}`; // e.g., toast-success, toast-danger
    toastElement.setAttribute('role', 'alert');
    toastElement.setAttribute('aria-live', 'assertive');
    toastElement.setAttribute('aria-atomic', 'true');

    // Basic sanitization to prevent HTML injection from the message
    const sanitizedMessage = typeof message === 'string'
        ? message.replace(/</g, "<").replace(/>/g, ">")
        : 'An unexpected error occurred.';

    toastElement.innerHTML = `
        <div class="toast-body">
            ${sanitizedMessage}
            <button type="button" class="toast-close-btn" aria-label="Close">×</button>
        </div>
    `;

    const closeButton = toastElement.querySelector('.toast-close-btn');
    toastContainer.appendChild(toastElement);

    const autoHideDelay = 5000; // 5 seconds
    let hideTimeoutId;

    const dismissToast = () => {
        clearTimeout(hideTimeoutId);
        if (toastElement.classList.contains('hide') || !toastElement.parentNode) return;
        toastElement.classList.remove('show');
        toastElement.classList.add('hide');
        toastElement.addEventListener('transitionend', (event) => {
             // Ensure removal only happens once and for the correct transition
            if (event.target === toastElement && (event.propertyName === 'opacity' || event.propertyName === 'transform')) {
                if (toastElement.classList.contains('hide') && toastElement.parentNode) {
                   try { toastElement.remove(); } catch(e) { console.warn("Error removing toast:", e); }
                }
            }
        }, { once: true });
    };

    // Trigger the show animation shortly after appending
    setTimeout(() => {
        if (toastElement.parentNode) { // Check if still in DOM
           toastElement.classList.add('show');
        }
    }, 10); // Short delay

    // Set auto-hide timer
    hideTimeoutId = setTimeout(dismissToast, autoHideDelay);

    // Add close button functionality
    if (closeButton) { closeButton.addEventListener('click', dismissToast); }

    // Pause timer on hover, resume on leave
    toastElement.addEventListener('mouseenter', () => clearTimeout(hideTimeoutId));
    toastElement.addEventListener('mouseleave', () => {
        clearTimeout(hideTimeoutId); // Clear existing timeout
        hideTimeoutId = setTimeout(dismissToast, autoHideDelay / 2); // Resume with potentially shorter delay
    });
}


// --- Helper Functions for Cart Badge and Empty Display ---
function updateCartTotalAndBadge(newCartTotal) {
     const cartTotalSpan = document.getElementById('cart-total-value');
     // Update Cart Total Display if element exists
     if (cartTotalSpan) {
         cartTotalSpan.textContent = (newCartTotal !== undefined && typeof newCartTotal === 'number' ? newCartTotal : 0).toFixed(2);
     }

     const newCartItemCount = calculateNewCartCount();
     const cartBadge = document.querySelector('.cart-badge');
     // Update Header Cart Badge
     if (cartBadge) {
         if (newCartItemCount > 0) {
             cartBadge.textContent = newCartItemCount;
             cartBadge.classList.remove('hide');
         } else {
            cartBadge.textContent = '0'; // Keep badge structure but hide content visually or via class
            cartBadge.classList.add('hide');
         }
     }
}

function calculateNewCartCount() {
    // Calculate count based on *visible* cart items in the DOM
    // This is simpler than trying to sync perfectly with server/session state
    const cartItems = document.querySelectorAll('.cart-item');
    let count = 0;
    cartItems.forEach(item => {
        // Check if the item is currently displayed and not marked for removal (e.g., opacity 0)
        const style = window.getComputedStyle(item);
        if (style.display !== 'none' && (!item.style.opacity || parseFloat(item.style.opacity) > 0)) {
            count++;
        }
    });
    return count;
}

function handleEmptyCartDisplay() {
    const cartItemsContainer = document.querySelector('.cart-items');
    const cartContainer = document.querySelector('.cart-container');
    const cartSummary = document.querySelector('.cart-summary');

    // Check if the main containers exist
    if (cartItemsContainer && cartContainer) {
        // Check if there are any visible items left
        const visibleItems = Array.from(cartItemsContainer.querySelectorAll('.cart-item')).filter(item => {
            const style = window.getComputedStyle(item);
            return style.display !== 'none' && (!item.style.opacity || parseFloat(item.style.opacity) > 0);
        });

        if (visibleItems.length === 0) {
            // Only add the "empty" message if it's not already there
            if (!cartContainer.querySelector('.alert-info')) {
                // Clear the items container specifically
                cartItemsContainer.innerHTML = '';
                // Remove the summary section if it exists
                if (cartSummary) cartSummary.remove();

                // Create and insert the "empty cart" message
                const emptyCartHTML = `
                    <p class="alert alert-info mt-3">
                        Your cart is empty. <a href="/" class="alert-link">Continue Shopping</a>
                    </p>`;
                 // Insert after the H1 title
                 const h1 = cartContainer.querySelector('h1');
                 if (h1) {
                     h1.insertAdjacentHTML('afterend', emptyCartHTML);
                 } else {
                     // Fallback if H1 isn't found (less likely)
                     cartContainer.insertAdjacentHTML('beforeend', emptyCartHTML);
                 }
            }
        }
    }
}

routes/adminRoutes.js:
// routes/adminRoutes.js
const express = require('express');
const adminController = require('../controllers/adminController');
const { isAuthenticated } = require('../middleware/authMiddleware');
const { isAdmin } = require('../middleware/roleMiddleware'); // Use specific admin check

const router = express.Router();

// Apply authentication and admin check to ALL routes in this file
router.use(isAuthenticated, isAdmin);

// Dashboard
router.get('/dashboard', adminController.getAdminDashboard);

// --- Product Management (Admin) ---
router.get('/upload-product', adminController.getUploadProductPage);
router.post('/upload-product', adminController.uploadProduct);
router.get('/manage-products', adminController.getManageProductsPage);
router.get('/manage-products/edit/:id', adminController.getEditProductPage);
router.post('/manage-products/update/:id', adminController.updateProduct);
router.post('/manage-products/remove/:id', adminController.removeProduct);

// Order Management (Admin View/Manage ALL - Existing Routes)
router.get('/manage-orders', adminController.getManageOrdersPage);
router.post('/orders/:orderId/send-direct-delivery-otp', adminController.sendDirectDeliveryOtpByAdmin);
router.post('/orders/:orderId/confirm-direct-delivery', adminController.confirmDirectDeliveryByAdmin);
router.post('/orders/:orderId/cancel', adminController.cancelOrderByAdmin);

// User Management (Existing Routes)
router.get('/manage-users', adminController.getManageUsersPage);
router.post('/users/:id/update-role', adminController.updateUserRole);
router.post('/users/:id/remove', adminController.removeUser);

// --- NEW: Banner Management ---
router.get('/manage-banners', adminController.getManageBannersPage); // Page to manage banners
router.post('/manage-banners', adminController.updateBanners);       // Action to save banners

module.exports = router;

routes/authRoutes.js:
const express = require('express');
const authController = require('../controllers/authController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.get('/login', authController.getLoginPage);
router.get('/register', authController.getRegisterPage);
router.get('/verify-otp', authController.getVerifyOtpPage);
router.get('/forgot-password', authController.getForgotPasswordPage);
router.get('/reset-password/:token', authController.getResetPasswordPage);

router.post('/register', authController.registerUser);
router.post('/login', authController.loginUser);
 router.post('/logout', isAuthenticated, authController.logoutUser);
router.post('/verify-otp', authController.verifyOtp);
 router.post('/resend-otp', authController.resendOtp);

router.post('/forgot-password', authController.forgotPassword);
router.post('/reset-password/:token', authController.resetPassword);


module.exports = router;


routes/index.js:
// routes/index.js
const express = require('express');
const authRoutes = require('./authRoutes');
const productRoutes = require('./productRoutes');
const userRoutes = require('./userRoutes');
const orderRoutes = require('./orderRoutes');
const adminRoutes = require('./adminRoutes');
const sellerRoutes = require('./sellerRoutes'); // *** IMPORT Seller Routes ***
const { getHomePage } = require('../controllers/authController'); // Home page controller

const router = express.Router();

// --- Public Routes ---
router.get('/', getHomePage);           // Home page (shows approved products)
router.use('/auth', authRoutes);        // Login, Register, Forgot Pwd, OTP Verify, etc.
router.use('/products', productRoutes); // Public product list (approved) & details (permission checked)

// --- Authenticated User Routes ---
// Middleware inside these route files ensure user is logged in
router.use('/user', userRoutes);        // Profile, Cart, Checkout, Address
router.use('/orders', orderRoutes);     // Place Order, My Orders

// --- Role-Specific Routes ---
// Middleware inside these files ensures correct role (and authentication)
router.use('/admin', adminRoutes);      // Admin actions
router.use('/seller', sellerRoutes);    // *** USE Seller Routes ***

module.exports = router;

routes/orderRoutes.js:
const express = require('express');
const orderController = require('../controllers/orderController');
const { isAuthenticated } = require('../middleware/authMiddleware');

const router = express.Router();

router.use(isAuthenticated);

router.post('/place', orderController.placeOrder);

router.get('/my-orders', orderController.getMyOrders);

 router.post('/cancel/:id', orderController.cancelOrder);

module.exports = router;


routes/productRoutes.js:
// routes/productRoutes.js
const express = require('express');
const productController = require('../controllers/productController');
 const { isAuthenticated } = require('../middleware/authMiddleware'); // Needed only for rating

const router = express.Router();

// --- NEW: Route for product suggestions ---
// Needs to be defined BEFORE the '/:id' route
router.get('/suggestions', productController.getProductSuggestions);

// Public routes - controllers ensure visibility rules (e.g., only 'approved')
router.get('/', productController.getProducts);         // List/Search approved, in-stock products
router.get('/:id', productController.getProductDetails); // Show product details (controller checks status/permissions)

// Rating requires user to be logged in
router.post('/:id/rate', isAuthenticated, productController.rateProduct);

module.exports = router;

routes/userRoutes.js:
// routes/userRoutes.js
const express = require('express');
const userController = require('../controllers/userController');
const { isAuthenticated } = require('../middleware/authMiddleware'); // Protect user-specific routes

const router = express.Router();

// --- Pincode Lookup Route (No changes needed here) ---
router.get('/pincode-lookup/:pincode', userController.lookupPincode);
// --- End Pincode Lookup Route ---

// Apply isAuthenticated middleware to the remaining routes in this file
router.use(isAuthenticated);

// User Profile
router.get('/profile', userController.getUserProfilePage);
router.post('/profile/update-name', userController.updateUserName);

// User Cart Management
router.get('/cart', userController.getCart);                // View cart (controller filters unapproved)
router.post('/cart/add', userController.addToCart);         // Add to cart (controller checks approval)
router.post('/cart/update', userController.updateCartQuantity); // Update quantity (controller checks approval/stock)
router.post('/cart/remove/:productId', userController.removeFromCart); // Remove from cart

// Address Management
router.post('/address/save', userController.saveAddress); // Save shipping address

// Checkout Process
router.get('/checkout', userController.getCheckoutPage);  // View checkout page (controller validates cart)

module.exports = router;

routes/sellerRoutes.js:
// routes/sellerRoutes.js
const express = require('express');
const sellerController = require('../controllers/sellerController');
const { isAuthenticated } = require('../middleware/authMiddleware');
// Import relevant role/ownership middleware
const { isSeller, isProductOwner, isOrderRelevantToSeller } = require('../middleware/roleMiddleware');

const router = express.Router();

// Apply authentication and seller check to ALL routes in this file
router.use(isAuthenticated, isSeller);

// Seller Dashboard
router.get('/dashboard', sellerController.getSellerDashboard);

// Seller Product Management
router.get('/products/upload', sellerController.getUploadProductPage); // Page to show upload form
router.post('/products/upload', sellerController.uploadProduct); // Handle product submission (triggers review)
router.get('/products', sellerController.getManageProductsPage); // List *only* this seller's products (incl. status)

// Actions requiring ownership of the specific product ID
// isProductOwner middleware runs AFTER isAuthenticated and isSeller
router.get('/products/edit/:id', isProductOwner, sellerController.getEditProductPage); // Get edit form for OWN product
router.post('/products/update/:id', isProductOwner, sellerController.updateProduct); // Handle update of OWN product (triggers re-review)
router.post('/products/remove/:id', isProductOwner, sellerController.removeProduct); // Handle removal of OWN product

// Seller Order Management
router.get('/orders', sellerController.getManageOrdersPage); // List orders containing *any* of this seller's products

// Actions requiring relevance to the specific order ID
// isOrderRelevantToSeller middleware runs AFTER isAuthenticated and isSeller
router.post('/orders/:orderId/send-otp', isOrderRelevantToSeller, sellerController.sendDirectDeliveryOtpBySeller); // Seller sends OTP for relevant orders
router.post('/orders/:orderId/confirm-delivery', isOrderRelevantToSeller, sellerController.confirmDirectDeliveryBySeller); // Seller confirms delivery for relevant orders

// --- NEW: Seller Cancel Order Route ---
router.post('/orders/:orderId/cancel', isOrderRelevantToSeller, sellerController.cancelOrderBySeller);

module.exports = router;

services/otpService.js:
// services/otpService.js
const crypto = require('crypto');

/**
 * Generates a random numeric OTP code of a specified length.
 * @param {number} [length=6] - The desired length of the OTP.
 * @returns {string} The generated OTP code.
 */
const generateOTP = (length = 6) => {
  // More robust generation ensuring target length even with non-numeric hex chars
  if (length <= 0) throw new Error('OTP length must be positive');
  const chars = '0123456789';
  let otp = '';
  const randomBytes = crypto.randomBytes(length); // Generate sufficient random bytes
  for (let i = 0; i < length; i++) {
    const randomIndex = randomBytes[i] % chars.length;
    otp += chars[randomIndex];
  }
  return otp;
};

/**
 * Calculates the expiration timestamp for an OTP.
 * @param {number} [minutes=10] - The duration in minutes until the OTP expires.
 * @returns {Date} The expiration date object.
 */
const setOTPExpiration = (minutes = 10) => {
  // Returns a Date object representing the expiration time
  return new Date(Date.now() + minutes * 60 * 1000);
};

module.exports = { generateOTP, setOTPExpiration };

services/geminiService.js:
// services/geminiService.js
const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = require("@google/generative-ai");
const axios = require('axios');

const API_KEY = process.env.GEMINI_API_KEY;
if (!API_KEY) {
    console.warn("GEMINI_API_KEY is not set in .env file. Gemini features will be disabled.");
}
const genAI = API_KEY ? new GoogleGenerativeAI(API_KEY) : null;
// --- UPDATED: Use a vision-capable model like gemini-1.5-flash ---
const visionModel = genAI ? genAI.getGenerativeModel({ model: "gemini-1.5-flash" }) : null;
// --- END UPDATED ---

const safetySettings = [
  { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
  { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
];

if (genAI && visionModel) {
    console.log("Gemini AI SDK Initialized successfully with Vision model.");
} else {
     console.log("Gemini AI SDK Vision model could not be initialized (API Key missing or configuration error?).");
}

// --- Helper function to fetch image and get Base64 data + MIME type ---
async function urlToGenerativePart(url) {
    console.log(`Fetching image from: ${url}`);
    try {
        const response = await axios.get(url, {
            responseType: 'arraybuffer', // Fetch as binary data
            timeout: 10000 // Add a timeout (10 seconds)
        });

        if (response.status !== 200) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const contentType = response.headers['content-type'];
        // Relaxed content type check to allow more flexibility, but keep warning
        if (!contentType || !contentType.toLowerCase().startsWith('image/')) {
             console.warn(`Potentially unsupported image Content-Type: ${contentType} from URL: ${url}. Proceeding but Gemini might reject.`);
             // Allow common image types even if not strictly in the list
             if (!['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/heic', 'image/heif'].includes(contentType.toLowerCase())) {
                 console.warn(`Content-Type ${contentType} is less common for Gemini Vision.`);
             }
        } else if (!['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/heic', 'image/heif'].includes(contentType.toLowerCase())) {
             console.warn(`Content-Type ${contentType} is less common for Gemini Vision.`);
        }


        const base64Data = Buffer.from(response.data).toString('base64');

        return {
            inlineData: {
                data: base64Data,
                mimeType: contentType || 'application/octet-stream', // Provide a default if missing
            },
        };
    } catch (error) {
         console.error(`Error fetching image from ${url}: ${error.message}`);
         if (axios.isAxiosError(error)) {
             if (error.response) {
                 throw new Error(`Failed to fetch image: Server responded with status ${error.response.status}`);
             } else if (error.request) {
                  throw new Error(`Failed to fetch image: No response received (Timeout or network issue)`);
             } else {
                 throw new Error(`Failed to fetch image: Request setup error (${error.message})`);
             }
         } else {
             throw error; // Re-throw other errors
         }
    }
}


const reviewProductWithGemini = async (product) => {
    if (!visionModel) {
        console.log("Gemini Vision model not available. Skipping review, defaulting to 'pending'.");
        return { status: 'pending', reason: 'Gemini Vision service unavailable' };
    }

    // --- UPDATED: Destructure imageUrl2 ---
    const { name, category, price, specifications, imageUrl, imageUrl2, shortDescription } = product;
    // --- END UPDATED ---

    let imagePart;
    let imagePart2 = null; // Initialize second image part as null

    try {
        // Process first image (required)
        imagePart = await urlToGenerativePart(imageUrl);
        if (!imagePart) throw new Error("Primary image processing failed.");
        console.log(`Successfully prepared primary image part for ${name} from ${imageUrl}`);

        // --- UPDATED: Process second image (optional) ---
        if (imageUrl2) {
            try {
                imagePart2 = await urlToGenerativePart(imageUrl2);
                if (!imagePart2) throw new Error("Second image processing failed unexpectedly.");
                 console.log(`Successfully prepared second image part for ${name} from ${imageUrl2}`);
            } catch (image2Error) {
                console.warn(`Could not process second image for "${name}" (${imageUrl2}): ${image2Error.message}. Proceeding with primary image only.`);
                // Note: We are choosing *not* to reject if only the second image fails.
                // If the second image MUST be valid, you could reject here:
                // return { status: 'rejected', reason: `Second Image Error: ${image2Error.message}` };
            }
        }
        // --- END UPDATED ---

    } catch (imageError) {
        console.error(`Cannot review product "${name}" due to critical image processing error: ${imageError.message}`);
        // Reject if the primary image fails
        return { status: 'rejected', reason: `Image Error: ${imageError.message}` };
    }


    // --- UPDATED: Construct Text Prompt Part (Mention potential second image) ---
    const textPrompt = `
        Analyze the following product details AND the provided image(s) for an e-commerce store. Act as a strict content moderator.

        **Instructions:**
        1. Examine the IMAGE CONTENT closely (check BOTH images if a second one is provided).
        2. Examine the TEXT DETAILS (Name, Category, Short Description, Price, Specifications).
        3. Verify if the image(s) VISUALLY MATCH the product described by the text (name, category, short description). Are they clearly the item described?
        4. Check BOTH image(s) and text for:
            - Explicit content (nudity, graphic violence).
            - Depictions of weapons (unless clearly a toy and stated category is 'Toys').
            - Illegal items or substances.
            - Hateful symbols or hate speech.
            - Any generally unsafe or harmful content.
        5. Check if the text details seem legitimate:
            - Is the name/description sensible? Avoid gibberish or clearly misleading text.
            - Is the price reasonable for the category (reject absurd prices like ₹1 for a car, but allow discounts)?
            - Does the category make sense for the name/image?
        6. **SAFETY IS PARAMOUNT**: If unsure, lean towards rejection, especially for safety concerns (weapons, explicit, illegal).
        7. Use ONLY the required response format.

        **Product Details (Text):**
        - Name: ${name}
        - Category: ${category}
        - Short Description: ${shortDescription || 'Not provided'}
        - Price: ₹${price?.toFixed(2) || 'N/A'}
        - Specifications: ${specifications || 'Not provided'}
        - Primary Image URL: ${imageUrl}
        - Second Image URL: ${imageUrl2 || 'Not provided'} <%# Mention second URL %>

        **Analysis Task:** Based on BOTH the text analysis AND image content analysis (considering both images if provided):
        - Respond with "APPROVE" if the product (image(s) and text) seems legitimate, safe, accurately described, and the image(s) clearly match the text description.
        - Respond with "REJECT: [BRIEF REASON]" if ANY issues are found (safety violation in image/text, image mismatch, misleading text, nonsensical entry, absurd price, etc.). Example Reasons: "Image contains prohibited items", "Text contains inappropriate language", "Image does not match product description", "Price is nonsensical".

        Your response:`;
    // --- END UPDATED ---

    const textPart = { text: textPrompt };

    // --- UPDATED: Prepare content parts array (include imagePart2 if it exists) ---
    const contentParts = [textPart, imagePart];
    if (imagePart2) {
        contentParts.push(imagePart2);
    }
    // --- END UPDATED ---

    // --- Call Gemini API ---
    try {
        console.log(`Sending product "${name}" (${imagePart2 ? '2 images' : '1 image'}) for Gemini Vision review...`);
        const result = await visionModel.generateContent(
            contentParts, // Use the dynamic array
            { safetySettings } // Apply safety settings
        );
        const response = result?.response;

        // Check for safety blocks first
        if (!response || response.promptFeedback?.blockReason) {
           const blockReason = response?.promptFeedback?.blockReason || 'Unknown safety reason';
           const safetyRatings = response?.promptFeedback?.safetyRatings || [];
           console.warn(`Gemini review for "${name}" blocked. Reason: ${blockReason}. Ratings: ${JSON.stringify(safetyRatings)}`);
           return { status: 'rejected', reason: `Content blocked by AI safety filters (${blockReason}).` };
        }

        const reviewText = response?.text()?.trim().toUpperCase() || '';
        console.log(`Gemini Vision Review Raw Response for "${name}": ${reviewText}`);

        // Process the response text
        if (reviewText.startsWith('APPROVE')) {
            console.log(`Gemini Vision approved product: ${name}`);
            return { status: 'approved', reason: null };
        } else if (reviewText.startsWith('REJECT')) {
            const reason = reviewText.split(':')[1]?.trim() || 'Rejected by AI model (no specific reason provided).';
            console.log(`Gemini Vision rejected product: ${name}. Reason: ${reason}`);
            return { status: 'rejected', reason: reason };
        } else {
            // Handle cases where the model might not return exactly APPROVE or REJECT
            console.warn(`Unexpected Gemini Vision response format for "${name}": ${reviewText}. Defaulting to pending.`);
            // You might want to log the full response here for debugging: console.log(JSON.stringify(response));
            return { status: 'pending', reason: 'AI review result unclear.' };
        }

    } catch (error) {
        // Handle API call errors
        console.error(`Error during Gemini Vision API call for product "${name}":`, error);
        let reason = 'AI review failed due to an API error.';
        // Check if the error message indicates a safety issue (this might vary depending on the SDK version)
        if (error.message && (error.message.includes('SAFETY') || error.message.includes('blocked'))) {
            reason = 'Content potentially blocked by safety filters during API call.';
        } else if (error.message) {
            // Provide a snippet of the error message for context
            reason = `AI API Error: ${error.message.substring(0, 100)}${error.message.length > 100 ? '...' : ''}`;
        }
        // It's often safer to reject if the AI review fails catastrophically
        return { status: 'rejected', reason: reason };
    }
};

module.exports = { reviewProductWithGemini };

views/admin/dashboard.ejs:
<%- include('../partials/header', { title: 'Admin Dashboard' }) %>

<div class="admin-dashboard-container">
    <h1>Admin Dashboard</h1>
    <p class="text-muted mb-3">System-wide management access. Welcome, <%= currentUser.name %>!</p>

    <div class="admin-actions-grid">
         <a href="/admin/upload-product" class="admin-action-card">
            <i class="fas fa-upload text-primary"></i>
            <h3>Upload Product (as Admin)</h3>
            <p>Add a product directly to the system.</p>
        </a>
         <a href="/admin/manage-products" class="admin-action-card">
            <i class="fas fa-edit text-success"></i>
            <h3>Manage All Products</h3>
            <p>View, edit, remove products from any seller.</p>
         </a>
        <a href="/admin/manage-orders" class="admin-action-card">
             <i class="fas fa-clipboard-list text-info"></i>
             <h3>Manage All Orders</h3>
             <p>View, confirm delivery, or cancel any customer order.</p>
        </a>
        <a href="/admin/manage-users" class="admin-action-card">
             <i class="fas fa-users-cog text-warning"></i>
             <h3>Manage Users</h3>
             <p>Update roles (User, Seller, Admin), remove users.</p>
        </a>

         <a href="/admin/manage-banners" class="admin-action-card">
             <i class="fas fa-images text-secondary"></i>
             <h3>Manage Banners</h3>
             <p>Update the promotional banners on the homepage.</p>
         </a>

         <%# The "My Admin Profile" card linking to /user/profile has been removed %>

    </div>
</div>

 <%- include('../partials/footer') %>

views/admin/manage-banners.ejs:
<%# views/admin/manage-banners.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Enter direct URLs for the images. Banners will appear on the homepage if URLs are provided.</p>

    <form action="/admin/manage-banners" method="POST" class="form-submit-spinner">
        <% bannerConfig.banners.forEach((banner, index) => { %>
            <fieldset class="mb-4 border p-3 rounded"> <%# Group banner fields %>
                <legend class="h5">Banner <%= index + 1 %></legend>
                <div class="form-group">
                    <label for="imageUrl<%= index + 1 %>">Image URL <%= index + 1 %>:</label>
                    <input type="url" id="imageUrl<%= index + 1 %>" name="imageUrl<%= index + 1 %>" class="form-control" value="<%= banner.imageUrl %>" placeholder="https://example.com/banner<%= index + 1 %>.jpg">
                    <% if (banner.imageUrl) { %>
                        <img src="<%= banner.imageUrl %>" alt="Banner <%= index + 1 %> Preview" style="max-width: 200px; max-height: 75px; margin-top: 10px; border: 1px solid #ddd; padding: 2px; object-fit: contain;">
                    <% } else { %>
                         <small class="d-block mt-1 text-muted">No image set</small>
                    <% } %>
                </div>
                <div class="form-group">
                    <label for="linkUrl<%= index + 1 %>">Link URL <%= index + 1 %> (Optional):</label>
                    <input type="url" id="linkUrl<%= index + 1 %>" name="linkUrl<%= index + 1 %>" class="form-control" value="<%= banner.linkUrl %>" placeholder="https://example.com/category/offers">
                    <% if (banner.linkUrl) { %>
                       <small class="d-block mt-1 text-muted">Clicks to: <%= banner.linkUrl %></small>
                   <% } %>
                </div>
                <div class="form-group">
                    <label for="title<%= index + 1 %>">Title/Alt Text <%= index + 1 %> (Optional):</label>
                    <input type="text" id="title<%= index + 1 %>" name="title<%= index + 1 %>" class="form-control" value="<%= banner.title %>" placeholder="e.g., Special Summer Sale">
                </div>
             </fieldset>
        <% }) %>

        <button type="submit" class="btn btn-primary"><i class="fas fa-save"></i> Save Banners</button>
        <a href="/admin/dashboard" class="btn btn-secondary">Back to Dashboard</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/admin/edit-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p>Admin editing view for product originally uploaded by <%= product.sellerId ? product.sellerId.email : 'Unknown Seller' %>.</p>

    <form action="/admin/manage-products/update/<%= product._id %>" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= product.name %>" required>
        </div>
        <div class="form-group">
            <label for="shortDescription">Short Description (Optional):</label>
            <textarea id="shortDescription" name="shortDescription" class="form-control" rows="2"><%= product.shortDescription || '' %></textarea>
        </div>
        <div class="form-group">
            <label for="category">Category:</label>
            <select id="category" name="category" class="form-control" required>
                <option value="" disabled <%= !product.category ? 'selected' : '' %>>Select a Category</option>
                <% if (typeof categories !== 'undefined') { %>
                    <% categories.forEach(cat => { %>
                        <option value="<%= cat.name %>" <%= (product.category === cat.name) ? 'selected' : '' %>><%= cat.name %></option>
                    <% }) %>
                <% } %>
            </select>
        </div>
        <div class="form-group">
            <label for="price">Price (₹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= product.price %>" required>
        </div>
        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= product.stock %>" required>
        </div>
        <div class="form-group">
            <label for="imageUrl">Image URL (Primary):</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" value="<%= product.imageUrl %>" required>
            <% if (product.imageUrl) { %>
                <img src="<%= product.imageUrl %>" alt="Current Image" style="max-width: 100px; margin-top: 5px; border:1px solid #ccc; padding:2px;">
            <% } %>
        </div>
        <!-- --- UPDATED: Add Second Image URL Input --- -->
        <div class="form-group">
            <label for="imageUrl2">Second Image URL (Optional):</label>
            <input type="url"
                   id="imageUrl2"
                   name="imageUrl2"
                   class="form-control"
                   placeholder="https://example.com/image_alt.jpg"
                   value="<%= (typeof product !== 'undefined' && product.imageUrl2) ? product.imageUrl2 : '' %>">
             <%# Preview for edit forms %>
             <% if (typeof product !== 'undefined' && product.imageUrl2) { %>
                <img src="<%= product.imageUrl2 %>" alt="Current Second Image" style="max-width: 100px; margin-top: 5px; border:1px solid #ccc; padding:2px;">
             <% } %>
        </div>
        <!-- --- END UPDATED --- -->
        <div class="form-group">
            <label for="specifications">Specifications:</label>
            <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= product.specifications %></textarea>
        </div>

        <hr>
        <h4>Admin Review Control</h4>

        <div class="form-group">
            <label for="reviewStatus">Review Status:</label>
            <select id="reviewStatus" name="reviewStatus" class="form-control" onchange="toggleRejectionReason(this.value)">
                <option value="pending" <%= product.reviewStatus === 'pending' ? 'selected' : '' %>>Pending</option>
                <option value="approved" <%= product.reviewStatus === 'approved' ? 'selected' : '' %>>Approved</option>
                <option value="rejected" <%= product.reviewStatus === 'rejected' ? 'selected' : '' %>>Rejected</option>
            </select>
        </div>
        <div class="form-group" id="rejectionReasonGroup" <%= product.reviewStatus !== 'rejected' ? 'style="display: none;"' : '' %>>
            <label for="rejectionReason">Rejection Reason (Required if Rejected):</label>
            <textarea id="rejectionReason" name="rejectionReason" rows="3" class="form-control"><%= product.rejectionReason || '' %></textarea>
        </div>

        <button type="submit" class="btn btn-primary">Update Product (Admin)</button>
        <a href="/admin/manage-products" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<script>
    function toggleRejectionReason(status) {
        const reasonGroup = document.getElementById('rejectionReasonGroup');
        if (status === 'rejected') {
            reasonGroup.style.display = 'block';
        } else {
            reasonGroup.style.display = 'none';
        }
    }
    document.addEventListener('DOMContentLoaded', () => {
        // Ensure the rejection reason field visibility is set correctly on page load
        const initialStatus = document.getElementById('reviewStatus').value;
        toggleRejectionReason(initialStatus);
    });
</script>

<%- include('../partials/footer') %>


views/admin/manage-orders.ejs:
<%# views/admin/manage-orders.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container order-manage-page">
    <h1><%= title %></h1>

    <%# --- ADD FILTER INPUT --- %>
    <div class="form-group mb-3">
        <label for="order-filter-input" class="visually-hidden">Filter Orders:</label>
        <input type="text" id="order-filter-input" class="form-control" placeholder="Type to filter orders (ID, Name, Email, Product, Status...)" aria-label="Filter Orders">
    </div>
    <%# --- END FILTER INPUT --- %>

    <% if (orders.length > 0) { %>
        <div class="table-container">
            <table class="data-table order-table" id="admin-order-table"> <%# Added ID %>
                <thead>
                    <tr>
                        <th>Details</th>
                        <th>Customer & Shipping Address</th>
                        <th>Items</th>
                        <th>Total</th>
                        <th>Status</th>
                        <th class="actions-cell">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% orders.forEach(order => { %>
                        <%# Added class="order-row" %>
                        <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %> order-row" data-order-id="<%= order._id %>">
                            <td data-label="Details">
                                <strong>ID:</strong> <%= order._id %><br>
                                <small class="text-muted"><%= formatDateIST(order.orderDate) %></small><br>
                                <% if (order.products && order.products.length > 0 && order.products[0].productId && order.products[0].productId.sellerId) { %>
                                    <small class="text-muted">Contains items from seller(s)</small>
                                <% } %>
                            </td>
                            <td data-label="Customer & Shipping Address">
                                <%# Customer Info %>
                                <div>
                                    <strong>Customer:</strong> <%= order.userId?.name || order.shippingAddress.name || '[Name Missing]' %><br>
                                    <small class="text-muted"><%= order.userEmail || order.userId?.email || '[Email Missing]' %></small>
                                </div>
                                <%# Full Shipping Address %>
                                <div class="mt-2 pt-2 border-top">
                                    <strong>Shipping To:</strong><br>
                                    <strong><%= order.shippingAddress.name %></strong><br>
                                    Ph: <%= order.shippingAddress.phone %><br>
                                    <% if (order.shippingAddress.landmarkNearby) { %>
                                        <%= order.shippingAddress.landmarkNearby %>,<br>
                                    <% } %>
                                    <%= order.shippingAddress.cityVillage %>,<br>
                                    <% if (order.shippingAddress.mandal) { %>
                                        <%= order.shippingAddress.mandal %>,<br>
                                    <% } %>
                                     <% if (order.shippingAddress.district) { %>
                                        <%= order.shippingAddress.district %>,<br>
                                    <% } %>
                                    <% if (order.shippingAddress.state) { %>
                                        <%= order.shippingAddress.state %> -
                                    <% } %>
                                    <%= order.shippingAddress.pincode %>
                                </div>
                            </td>
                            <td data-label="Items">
                                <div class="order-items-summary">
                                    <%- order.itemsSummary %>
                                </div>
                                <% if (order.products && order.products.length > 0) { %>
                                    <div class="order-items-images">
                                        <% order.products.forEach(item => { %>
                                            <% if (item.productId && item.productId._id && item.productId.imageUrl) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" title="View <%= item.productId.name || 'Product' %>">
                                                    <img src="<%= item.productId.imageUrl %>"
                                                         alt="<%= item.productId.name || 'Product Image' %>"
                                                         class="order-item-thumbnail" loading="lazy">
                                                </a>
                                            <% } else if (item.productId && item.productId._id) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" class="order-item-thumbnail-placeholder" title="View <%= item.productId.name || 'Product' %>">[No Img]</a>
                                            <% } else { %>
                                                <span class="order-item-thumbnail-placeholder" title="Product data missing">[N/A]</span>
                                            <% } %>
                                        <% }) %>
                                    </div>
                                <% } %>
                            </td>
                            <td data-label="Total" class="order-total"><strong>₹<%= order.totalAmount.toFixed(2) %></strong></td>
                            <td data-label="Status" class="order-status-cell">
                                <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span>
                                <% if(order.status === 'Cancelled' && order.cancellationReason) { %><br><small class="text-danger mt-1 d-block">Reason: <%= order.cancellationReason %></small><% } %>
                                <% if(order.status === 'Delivered' && order.receivedByDate) { %><br><small class="text-success mt-1 d-block">Delivered:<br><%= formatDateIST(order.receivedByDate) %></small><% } %>
                                <% if (order.showDeliveryOtp) { %>
                                  <div class="delivery-otp-display mt-1">
                                    <p>Customer OTP Sent</p>
                                    <small class="text-muted">Ask customer for code: <strong class="delivery-otp-code">****<%= order.orderOTP ? order.orderOTP.slice(-2) : 'XX' %></strong></small>
                                     <% if (order.orderOTPExpires) { %>
                                         <small class="text-muted d-block">Expires: <%= formatDateIST(order.orderOTPExpires) %></small>
                                     <% } %>
                                  </div>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Admin Direct Delivery Confirmation %>
                                <% if (order.canBeDirectlyDeliveredByAdmin) { %>
                                    <div class="action-group mb-2">
                                        <p class="action-group-title">Direct Delivery:</p>
                                        <% if (!order.showDeliveryOtp) { %>
                                            <form action="/admin/orders/<%= order._id %>/send-direct-delivery-otp" method="POST" class="inline-form form-submit-spinner mb-1">
                                                <button type="submit" class="btn btn-warning btn-sm w-100 w-md-auto" title="Send OTP to customer for admin delivery">
                                                    <i class="fas fa-mobile-alt"></i> Send OTP
                                                </button>
                                            </form>
                                        <% } %>
                                        <form action="/admin/orders/<%= order._id %>/confirm-direct-delivery" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                            <input type="text" name="otp" placeholder="Enter OTP" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit OTP from customer">
                                            <button type="submit" class="btn btn-success btn-sm" title="Confirm direct delivery">
                                                <i class="fas fa-check-double"></i> Confirm
                                            </button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Admin Order Cancellation %>
                                <% if (order.canBeCancelledByAdmin) { %>
                                    <div class="action-group">
                                        <form action="/admin/orders/<%= order._id %>/cancel" method="POST" class="cancel-delivery-form form-submit-spinner" onsubmit="return confirm('ADMIN ACTION: Are you sure you want to cancel order <%= order._id %>? This cannot be undone.');">
                                            <label for="reason-<%= order._id %>" class="action-group-title">Cancel Order:</label>
                                            <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm d-block mb-1">
                                                <option value="" disabled selected>Select Admin Reason...</option>
                                                <% if (typeof cancellationReasons !== 'undefined' && cancellationReasons.length > 0) { %>
                                                    <% cancellationReasons.forEach(reason => { %>
                                                        <option value="<%= reason %>"><%= reason %></option>
                                                    <% }) %>
                                                <% } else { %>
                                                     <option value="Other (Admin)" selected>Other (Admin)</option> <%# Fallback %>
                                                <% } %>
                                            </select>
                                            <button type="submit" class="btn btn-danger btn-sm w-100 w-md-auto"><i class="fas fa-ban"></i> Cancel Order</button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Fallback for no actions %>
                                <% if (!order.canBeDirectlyDeliveredByAdmin && !order.canBeCancelledByAdmin) { %>
                                    <small class="text-muted no-actions-text">
                                        <% if (order.status === 'Delivered') { %>Completed<% } else if (order.status === 'Cancelled') { %>Cancelled<% } else { %>No admin actions<% } %>
                                    </small>
                                <% } %>
                            </td>
                        </tr>
                    <% }) %>
                    <%# --- ADD NO RESULTS ROW --- %>
                    <tr id="no-admin-orders-found" class="hidden">
                         <td colspan="6" class="text-center text-muted p-3">No orders match your filter.</td>
                    </tr>
                    <%# --- END NO RESULTS ROW --- %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="alert alert-info">No orders received yet.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/admin/manage-products.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Showing all products from all sellers.</p>

    <%# --- ADD FILTER INPUT --- %>
    <div class="form-group mb-3"> <%# Added mb-3 for spacing %>
        <label for="admin-product-filter-input" class="visually-hidden">Filter Products:</label>
        <input type="text" id="admin-product-filter-input" class="form-control" placeholder="Type to filter products (Name, Category, Seller, Status...)" aria-label="Filter Products">
    </div>
    <%# --- END FILTER INPUT --- %>

    <% if (products.length > 0) { %>
        <div class="table-container card">
             <%# --- Added ID to table --- %>
            <table class="data-table" id="admin-product-table">
                <thead>
                    <tr>
                        <th>Image</th>
                        <th>Name / Category</th>
                        <th>Seller</th>
                        <th>Price / Stock</th>
                        <th>Status</th>
                        <th>Reason</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% products.forEach(product => {
                        const productNameEsc = product.name.replace(/'/g, "\\'");
                        const sellerEmail = product.sellerId?.email || product.sellerEmail || 'Unknown';
                        const sellerEmailEsc = sellerEmail.replace(/'/g, "\\'");
                    %>
                        <%# --- Added class="product-row" --- %>
                        <tr class="status-<%= product.reviewStatus %> product-row" data-product-id="<%= product._id %>">
                            <td data-label="Image">
                                <a href="/products/<%= product._id %>">
                                    <img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="table-img">
                                </a>
                            </td>
                            <td data-label="Name / Category">
                                <%= product.name %><br>
                                <small class="text-muted"><%= product.category %></small>
                            </td>
                            <td data-label="Seller"><%= sellerEmail %></td>
                            <td data-label="Price / Stock">
                                ₹<%= product.price.toFixed(2) %><br>
                                <small>Stock: <%= product.stock %></small>
                            </td>
                            <td data-label="Status">
                                <span class="status-badge status-<%= product.reviewStatus %> text-capitalize">
                                    <%= product.reviewStatus %>
                                </span>
                            </td>
                            <td data-label="Reason">
                                <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %>
                                    <small class="text-danger" title="Rejection Reason"><%= product.rejectionReason %></small>
                                <% } else { %>
                                    <span class="text-muted">--</span>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <a href="/admin/manage-products/edit/<%= product._id %>" class="btn btn-text btn-sm" title="Edit Product (Admin)">
                                    <i class="fas fa-edit"></i> Edit
                                </a>
                                <form action="/admin/manage-products/remove/<%= product._id %>" method="POST" class="inline-form form-submit-spinner"
                                    onsubmit="return confirmAdminRemove('<%= productNameEsc %>', '<%= sellerEmailEsc %>')">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove Product (Admin)">
                                        <i class="fas fa-trash"></i> Remove
                                    </button>
                                </form>
                            </td>
                        </tr>
                    <% }) %>
                     <%# --- ADD NO RESULTS ROW --- %>
                     <tr id="no-admin-products-found" class="hidden">
                         <td colspan="7" class="text-center text-muted p-3">No products match your filter.</td> <%# Adjusted colspan %>
                     </tr>
                     <%# --- END NO RESULTS ROW --- %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="text-muted mt-3">No products found in the system.</p>
    <% } %>
</div>

<script>
    function confirmAdminRemove(productName, sellerEmail) {
        return confirm(`ADMIN ACTION: Remove product ${productName} (Seller: ${sellerEmail})?`);
    }
</script>

<%- include('../partials/footer') %>


views/admin/manage-users.ejs:
<%# views/admin/manage-users.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1><%= title %></h1>

    <%# --- ADD FILTER INPUT --- %>
    <div class="form-group mb-3">
        <label for="user-filter-input" class="visually-hidden">Filter Users:</label>
        <input type="text" id="user-filter-input" class="form-control" placeholder="Type to filter users (Name, Email, Role...)" aria-label="Filter Users">
    </div>
    <%# --- END FILTER INPUT --- %>

    <% if (users.length > 0) { %>
        <div class="table-container card">
            <%# --- ADDED ID to table --- %>
            <table class="data-table" id="admin-user-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Email / Phone</th>
                        <th>Role</th>
                        <th>Registered On</th>
                        <th>Verified</th>
                        <th class="actions-cell" style="text-align: right;">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% users.forEach(user => { %>
                        <%# --- ADDED class="user-row" --- %>
                        <tr class="user-row" data-user-id="<%= user._id %>">
                            <td data-label="Name"><%= user.name %></td>
                            <td data-label="Email / Phone">
                                <%= user.email %>
                                <% if (user.address && user.address.phone) { %>
                                    <br><small>(Ph: <%= user.address.phone %>)</small>
                                <% } %>
                            </td>
                            <td data-label="Role">
                                <form action="/admin/users/<%= user._id %>/update-role" method="POST" class="inline-form form-submit-spinner">
                                    <select name="role" onchange="this.form.submit()" class="form-control form-control-sm" style="display: inline-block; width: auto; vertical-align: middle;"> <%# Inline style for select %>
                                        <option value="user" <%= user.role === 'user' ? 'selected' : '' %>>User</option>
                                        <option value="seller" <%= user.role === 'seller' ? 'selected' : '' %>>Seller</option> <%# ADD SELLER %>
                                        <option value="admin" <%= user.role === 'admin' ? 'selected' : '' %>>Admin</option>
                                    </select>
                                    <noscript><button type="submit" class="btn btn-sm btn-primary ml-1">Update</button></noscript> <%# Fallback button %>
                                </form>
                            </td>
                            <td data-label="Registered On"><small><%= formatDateIST(user.createdAt) %></small></td>
                            <td data-label="Verified"><%= user.isVerified ? 'Yes' : 'No' %></td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Prevent removing self or last admin in controller logic %>
                                <form action="/admin/users/<%= user._id %>/remove" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('ADMIN ACTION: Are you sure you want to remove user <%= user.email %>? This is irreversible.');">
                                    <button type="submit" class="btn btn-danger btn-sm"><i class="fas fa-user-times"></i> Remove</button>
                                </form>
                            </td>
                        </tr>
                    <% }) %>
                    <%# --- ADD NO RESULTS ROW --- %>
                    <tr id="no-admin-users-found" class="hidden">
                         <td colspan="6" class="text-center text-muted p-3">No users match your filter.</td> <%# Adjusted colspan to 6 %>
                    </tr>
                    <%# --- END NO RESULTS ROW --- %>
                </tbody>
            </table>
        </div>
    <% } else { %>
        <p class="text-muted mt-3">No other registered users found.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/admin/upload-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container">
    <h1>Admin: Upload New Product</h1>
    <p class="text-muted small mb-3">Product will be submitted for automatic review upon upload.</p>

    <form action="/admin/upload-product" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= typeof product !== 'undefined' ? product.name : '' %>" required>
        </div>
        <div class="form-group">
            <label for="shortDescription">Short Description (Optional):</label>
            <textarea id="shortDescription" name="shortDescription" class="form-control" rows="2"><%= typeof product !== 'undefined' ? product.shortDescription : '' %></textarea>
        </div>
        <div class="form-group">
            <label for="category">Category:</label>
            <select id="category" name="category" class="form-control" required>
                <option value="" disabled <%= !(typeof product !== 'undefined' && product.category) ? 'selected' : '' %>>Select a Category</option>
                <% if (typeof categories !== 'undefined') { %>
                    <% categories.forEach(cat => { %>
                        <option value="<%= cat.name %>" <%= (typeof product !== 'undefined' && product.category === cat.name) ? 'selected' : '' %>><%= cat.name %></option>
                    <% }) %>
                <% } %>
            </select>
        </div>
        <div class="form-group">
            <label for="price">Price (₹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= typeof product !== 'undefined' ? product.price : '' %>" required>
        </div>
        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= typeof product !== 'undefined' ? product.stock : '' %>" required>
        </div>
        <div class="form-group">
            <label for="imageUrl">Image URL (Primary):</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" placeholder="https://example.com/image.jpg" value="<%= typeof product !== 'undefined' ? product.imageUrl : '' %>" required>
        </div>
        <!-- --- UPDATED: Add Second Image URL Input --- -->
        <div class="form-group">
            <label for="imageUrl2">Second Image URL (Optional):</label>
            <input type="url"
                   id="imageUrl2"
                   name="imageUrl2"
                   class="form-control"
                   placeholder="https://example.com/image_alt.jpg"
                   value="<%= (typeof product !== 'undefined' && product.imageUrl2) ? product.imageUrl2 : '' %>">
        </div>
        <!-- --- END UPDATED --- -->
        <div class="form-group">
            <label for="specifications">Specifications (Optional):</label>
            <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= typeof product !== 'undefined' ? product.specifications : '' %></textarea>
        </div>
        <button type="submit" class="btn btn-primary">Upload & Submit for Review</button>
        <a href="/admin/dashboard" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/auth/forgot-password.ejs:
<%- include('../partials/header', { title: 'Forgot Password' }) %>

<div class="auth-container">
    <h1>Forgot Password</h1>
    <p>Enter your email address below. If an account exists, we'll send an OTP to verify your request.</p>

    <form action="/auth/forgot-password" method="POST" class="auth-form">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required>
        </div>
        <button type="submit" class="btn btn-primary">Send Reset OTP</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>


views/auth/login.ejs:
<%- include('../partials/header', { title: 'Login' }) %>

<div class="auth-container">
    <h1>Login</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/login" method="POST" class="auth-form form-submit-spinner">
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" required autocomplete="current-password">
        </div>
        <button type="submit" class="btn btn-primary">Login</button>
    </form>
    <div class="auth-links">
        <p><a href="/auth/forgot-password">Forgot Password?</a></p>
        <p>Don't have an account? <a href="/auth/register">Register here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/register.ejs:
<%- include('../partials/header', { title: 'Register' }) %>

<div class="auth-container">
    <h1>Register</h1>

    <%# --- Spinner Class Added --- %>
    <form action="/auth/register" method="POST" class="auth-form form-submit-spinner">
         <div class="form-group">
            <label for="name">Name:</label>
            <input type="text" id="name" name="name" required autocomplete="name">
        </div>
        <div class="form-group">
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required autocomplete="email">
        </div>
        <div class="form-group">
            <label for="password">Password:</label>
            <input type="password" id="password" name="password" minlength="6" required autocomplete="new-password">
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required autocomplete="new-password">
        </div>
        <button type="submit" class="btn btn-primary">Register</button>
    </form>
    <div class="auth-links">
        <p>Already have an account? <a href="/auth/login">Login here</a></p>
    </div>
</div>

<%- include('../partials/footer') %>

views/auth/reset-password.ejs:
<%- include('../partials/header', { title: 'Reset Password' }) %>

<div class="auth-container">
    <h1>Reset Password</h1>
    <p>Enter your new password below.</p>

    <form action="/auth/reset-password/<%= token %>" method="POST" class="auth-form">
        <div class="form-group">
            <label for="password">New Password:</label>
            <input type="password" id="password" name="password" minlength="6" required>
        </div>
        <div class="form-group">
            <label for="confirmPassword">Confirm New Password:</label>
            <input type="password" id="confirmPassword" name="confirmPassword" minlength="6" required>
        </div>
        <button type="submit" class="btn btn-primary">Reset Password</button>
    </form>
     <div class="auth-links">
        <p><a href="/auth/login">Back to Login</a></p>
    </div>
</div>

<%- include('../partials/footer') %>


views/auth/verify-otp.ejs:
<%- include('../partials/header', { title: title || 'Verify OTP' }) %>

<div class="auth-container">
    <h1>Verify OTP</h1>
    <p>An OTP has been sent to <strong><%= email %></strong>. Please enter it below.</p>

    <%# --- Spinner Class Added & Input Attributes Updated --- %>
    <form action="/auth/verify-otp" method="POST" class="auth-form form-submit-spinner">
         <input type="hidden" name="email" value="<%= email %>">
        <div class="form-group">
            <label for="otp">OTP Code:</label>
            <input type="text" <%# Changed type to text for better compatibility %>
                   id="otp"
                   name="otp"
                   required
                   pattern="\d{6}" <%# Ensures exactly 6 digits %>
                   maxlength="6"  <%# Limits input length %>
                   inputmode="numeric" <%# Suggests numeric keyboard on mobile %>
                   autocomplete="one-time-code" <%# Helps password managers/browsers %>
                   title="Enter the 6-digit OTP code received"> <%# Clear hint %>
        </div>
        <button type="submit" class="btn btn-primary">Verify OTP</button>
    </form>
    <div class="auth-links">
        <p>Didn't receive the OTP?</p>
        <form action="/auth/resend-otp" method="POST" style="display:inline;" class="form-submit-spinner">
             <input type="hidden" name="email" value="<%= email %>">
             <button type="submit" class="btn btn-secondary btn-sm">Resend OTP</button>
         </form>
    </div>
</div>

<%- include('../partials/footer') %>

views/partials/footer.ejs:
    </main> <%# End Main Content Area %>

    <footer class="app-footer desktop-only">
        <p>© <%= new Date().getFullYear() %> ProShop. All rights reserved.</p>
    </footer>

    <script src="/js/main.js"></script>

</body>
</html>

views/partials/header.ejs:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <% const pageTitle = typeof title !== 'undefined' ? title + ' - miniapp' : 'miniapp'; %>
  <% const siteName = typeof defaultSiteName !== 'undefined' ? defaultSiteName : 'miniapp'; %>
  <% const currentMetaTitle = typeof metaTitle !== 'undefined' ? metaTitle : pageTitle; %>
  <% const currentMetaDesc = typeof metaDescription !== 'undefined' ? metaDescription : 'Check out our products on ' + siteName; %>
  <% const currentMetaImage = typeof metaImageUrl !== 'undefined' ? metaImageUrl : '/images/default-logo.png'; %>
  <% const currentMetaUrl = typeof fullUrl !== 'undefined' ? fullUrl : ''; %>
  <% const currentMetaType = typeof metaType !== 'undefined' ? metaType : 'website'; %>

  <%# --- REMOVED the problematic EJS block that tried to set res.locals --- %>

  <title><%= pageTitle %></title>
  <meta name="description" content="<%= currentMetaDesc %>">
  <meta property="og:title" content="<%= currentMetaTitle %>" />
  <meta property="og:description" content="<%= currentMetaDesc %>" />
  <meta property="og:image" content="<%= currentMetaImage %>" />
  <% if (currentMetaUrl) { %><meta property="og:url" content="<%= currentMetaUrl %>" /><% } %>
  <meta property="og:type" content="<%= currentMetaType %>" />
  <meta property="og:site_name" content="<%= siteName %>" />
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="<%= currentMetaTitle %>">
  <meta name="twitter:description" content="<%= currentMetaDesc %>">
  <meta name="twitter:image" content="<%= currentMetaImage %>">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <header class="app-header">
    <nav class="navbar">
      <div class="nav-left">
        <a href="/" class="app-logo">
          <i class="fas fa-shopping-bag"></i>
          <span class="app-name">miniapp</span>
        </a>
      </div>

      <div class="search-container-dynamic" id="dynamic-search-container">
          <form action="/products" method="GET" class="search-form-dynamic" id="dynamic-search-form">
              <input type="search"
                     id="search-input-dynamic"
                     name="search"
                     placeholder="Search products..."
                     aria-label="Search Products"
                     autocomplete="off">
              <button type="submit" class="search-submit-btn-dynamic" aria-label="Submit Search">
                  <i class="fas fa-search"></i>
              </button>
          </form>
           <div class="suggestions-dropdown" id="suggestions-dropdown">
              <%# Suggestions will be populated here by JS %>
          </div>
      </div>

      <div class="nav-right">
          <button class="nav-link search-toggle-btn" id="search-toggle-btn" aria-label="Toggle Search Bar">
              <i class="fas fa-search"></i>
              <span>Search</span>
          </button>

        <% if (currentUser) { %>
          <a href="/" class="nav-link <%= currentUrl === '/' ? 'active' : '' %>" title="Home Page">
            <i class="fas fa-home"></i> <span>Home</span>
          </a>
          <a href="/user/cart" class="nav-link nav-link-cart <%= currentUrl === '/user/cart' ? 'active' : '' %>" title="Cart Page">
            <i class="fas fa-shopping-cart"></i>
            <span class="cart-badge <%= cartItemCount > 0 ? '' : 'hide' %>"><%= cartItemCount %></span>
            <span>Cart</span>
          </a>
          <a href="/user/profile" class="profile-avatar-link <%= currentUrl === '/user/profile' ? 'active' : '' %>" title="My Profile Page">
            <span class="profile-avatar-initials"><%= userInitials %></span>
          </a>
        <% } else { %>
          <a href="/auth/login" class="btn btn-login-register">
            <i class="fas fa-sign-in-alt"></i> Login / Register
          </a>
        <% } %>
      </div>
    </nav>
  </header>

  <%- include('messages') %>

  <main class="container">

views/partials/messages.ejs:
<%# views/partials/messages.ejs %>

<%# --- NEW: Toast Container --- %>
<div class="toast-container">
    <% if (success_msg && success_msg.length > 0) { %>
      <div class="toast toast-success" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-body">
          <%= success_msg %>
          <button type="button" class="toast-close-btn" aria-label="Close">×</button>
        </div>
      </div>
    <% } %>

    <% if (error_msg && error_msg.length > 0) { %>
       <div class="toast toast-danger" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-body">
          <%= error_msg %>
           <button type="button" class="toast-close-btn" aria-label="Close">×</button>
        </div>
      </div>
    <% } %>

    <% if (error && typeof error !== 'undefined' && error.length > 0) { %>
      <div class="toast toast-danger" role="alert" aria-live="assertive" aria-atomic="true">
         <div class="toast-body">
           <%= error %>
            <button type="button" class="toast-close-btn" aria-label="Close">×</button>
         </div>
       </div>
    <% } %>

    <%# Add other flash message types (info, warning) here if needed %>

</div>
<%# --- End Toast Container --- %>

<%# The old alert divs are removed %>

views/products/detail.ejs:
<%# views/products/detail.ejs %>
<%- include('../partials/header', {
    title: product.name,
    metaTitle: product.name + ' - ' + defaultSiteName,
    metaDescription: (product.shortDescription || `Check out ${product.name} on miniapp. Available now for ₹${product.price.toFixed(2)}.`).substring(0, 157) + '...',
    metaImageUrl: product.imageUrl, // Use primary image for meta tags
    metaUrl: fullUrl,
    metaType: 'product'
}) %>

<div class="product-detail-container">

   <%# --- Status Banner (No changes needed) --- %>
   <% if (!isApproved && (isAdminView || isOwnerView)) { %>
     <div class="alert alert-<%= product.reviewStatus === 'rejected' ? 'danger' : 'warning' %> mb-3" role="alert">
       <strong>Status:</strong> <span class="text-capitalize fw-bold"><%= product.reviewStatus %></span>
       <% if (product.reviewStatus === 'rejected' && product.rejectionReason) { %>
         <br><strong>Reason:</strong> <%= product.rejectionReason %>
       <% } else if (product.reviewStatus === 'pending') { %>
          - This product is awaiting review and is not visible to customers.
       <% } %>
       <% if (isOwnerView && product.reviewStatus !== 'approved') { %>
          <br><a href="/seller/products/edit/<%= product._id %>" class="alert-link">Edit and Resubmit for Review</a>
        <% } else if (isAdminView && product.reviewStatus !== 'approved') { %>
           <br><a href="/admin/manage-products/edit/<%= product._id %>" class="alert-link">Admin: Edit Status/Details</a>
       <% } %>
     </div>
   <% } else if (!isApproved && !isAdminView && !isOwnerView) { %>
      <div class="alert alert-danger">This product is currently unavailable.</div>
      </div> <%# Close container early if unavailable %>
      <%- include('../partials/footer') %>
      <% return; %>
   <% } %>

   <div class="product-detail-main">
        <%# --- UPDATED: Image Display Logic --- %>
        <div class="product-detail-image-section" data-product-image-slider> <%# Added data attribute %>
            <%# --- ADDED WRAPPER --- %>
            <div class="product-image-slides-wrapper" data-product-slides-wrapper>
                <%# Slide for Primary Image %>
                <div class="product-image-slide" data-product-slide> <%# Remove active class %>
                    <img src="<%= product.imageUrl %>" alt="<%= product.name %> - Image 1" class="product-detail-image">
                </div>
                <%# Slide for Second Image (if exists) %>
                <% if (product.imageUrl2) { %>
                    <div class="product-image-slide" data-product-slide> <%# Remove active class %>
                         <img src="<%= product.imageUrl2 %>" alt="<%= product.name %> - Image 2" class="product-detail-image">
                    </div>
                <% } %>
                 <%# JS will add clones here if imageUrl2 exists %>
            </div>
            <%# --- END ADDED WRAPPER --- %>

            <%# Navigation Arrows (only if imageUrl2 exists) - Hidden initially by CSS %>
            <% if (product.imageUrl2) { %>
                <button class="product-image-nav product-image-prev" data-product-image-nav="prev" aria-label="Previous Image">‹</button>
                <button class="product-image-nav product-image-next" data-product-image-nav="next" aria-label="Next Image">›</button>
            <% } %>

            <%# Navigation Dots (only if imageUrl2 exists) - Hidden initially by CSS %>
            <% if (product.imageUrl2) { %>
                 <div class="product-image-dots">
                     <button class="product-image-dot" data-product-image-dot="0" aria-label="Go to image 1"></button> <%# Remove active class %>
                     <button class="product-image-dot" data-product-image-dot="1" aria-label="Go to image 2"></button> <%# Remove active class %>
                 </div>
            <% } %>
        </div>
        <%# --- END UPDATED --- %>

       <div class="product-detail-info">
            <h1><%= product.name %></h1>
            <% if (product.shortDescription) { %>
              <p class="product-short-description text-muted mb-2"><%= product.shortDescription %></p>
            <% } %>
            <p class="detail-price">₹<%= product.price.toFixed(2) %></p>
            <p class="detail-stock">
                <% if (product.stock > 0) { %>
                    Available Stock : <%= product.stock %>
                <% } else { %>
                    <span class="text-danger fw-bold">Out of Stock</span>
                <% } %>
            </p>

            <%# Share Button %>
            <div class="share-section mt-2">
                 <button id="share-product-btn" class="btn btn-outline-secondary btn-sm"
                         data-title="<%= product.name %>"
                         data-text="Check out this product: <%= product.name %>"
                         data-url="<%= fullUrl %>">
                     <i class="fas fa-share-alt"></i> Share
                 </button>
                 <div id="fallback-share-links" class="fallback-share-links hidden">
                     <small>Share via:</small>
                     <a href="https://www.facebook.com/sharer/sharer.php?u=<%= encodeURIComponent(fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Facebook"><i class="fab fa-facebook-square"></i></a>
                     <a href="https://twitter.com/intent/tweet?url=<%= encodeURIComponent(fullUrl) %>&text=<%= encodeURIComponent('Check out this product: ' + product.name) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on Twitter"><i class="fab fa-twitter-square"></i></a>
                     <a href="https://api.whatsapp.com/send?text=<%= encodeURIComponent('Check out this product: ' + product.name + ' ' + fullUrl) %>" target="_blank" rel="noopener noreferrer" aria-label="Share on WhatsApp"><i class="fab fa-whatsapp-square"></i></a>
                     <a href="mailto:?subject=<%= encodeURIComponent('Check out this product: ' + product.name) %>&body=<%= encodeURIComponent('I thought you might like this product:\n\n' + product.name + '\n' + fullUrl) %>" aria-label="Share via Email"><i class="fas fa-envelope-square"></i></a>
                 </div>
             </div>

            <%# Rating Display %>
            <div class="mb-3 mt-2">
                 <% if (product.numReviews > 0) { %>
                     <p class="detail-rating">
                         Rating:
                        <% for(let i=1; i<=5; i++) { %><i class="fas fa-star<%= i <= product.averageRating ? '' : (i - 0.5 <= product.averageRating ? '-half-alt' : '-regular') %>"></i><% } %>
                         (<%= product.numReviews %> reviews) | <%= product.orderCount %> Ordered
                     </p>
                 <% } else { %>
                     <p class="detail-rating">No reviews yet | <%= product.orderCount %> Ordered</p>
                 <% } %>
             </div>

           <%# Conditional Purchase Actions %>
           <% if (isApproved) { %>
               <div class="product-actions">
                   <form action="/user/cart/add" method="POST" style="display: inline-block; margin-right: 10px;" class="form-submit-spinner">
                      <input type="hidden" name="productId" value="<%= product._id %>">
                       <div class="quantity-selector mb-2 d-inline-flex align-items-center">
                           <label for="quantity" class="me-1 mb-0 text-muted small">Qty:</label> <%# Made smaller %>
                           <input type="number" id="quantity" name="quantity" value="1" min="1" max="<%= product.stock %>" required aria-label="Quantity" class="form-control form-control-sm" style="width: 65px;"> <%# Adjusted width %>
                       </div>
                       <button type="submit" class="btn btn-primary btn-sm" <%= product.stock <= 0 ? 'disabled' : '' %>>
                           <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                       </button>
                  </form>
                    <% if (product.stock > 0) { %>
                    <form action="/user/cart/add?redirectTo=checkout" method="POST" style="display: inline-block;" class="form-submit-spinner">
                          <input type="hidden" name="productId" value="<%= product._id %>">
                          <input type="hidden" name="quantity" value="1"> <%# Default Buy Now to 1 %>
                         <button type="submit" class="btn btn-success btn-sm">Buy Now</button>
                       </form>
                    <% } else {%>
                      <button class="btn btn-success btn-sm" disabled>Buy Now</button>
                    <% } %>
               </div>
            <% } else { %>
                <div class="product-actions">
                     <button class="btn btn-primary btn-sm" disabled><i class="fas fa-cart-plus"></i> Add to Cart</button>
                     <button class="btn btn-success btn-sm" disabled>Buy Now</button>
                     <p class="text-muted small mt-2">This product is currently under review or unavailable.</p>
                 </div>
            <% } %>

            <%# Specifications %>
            <div class="product-specifications mt-3">
                 <h3>Specifications</h3>
                 <pre class="border p-2 bg-light small"><%= product.specifications || 'No specifications provided.' %></pre>
            </div>

            <%# Seller Info %>
            <p class="small text-muted mt-3">Seller Info : <%= product.sellerEmail || 'Unknown Seller' %></p>
       </div> <%# End product-detail-info %>
    </div> <%# End product-detail-main %>

   <%# Conditional Rating Section %>
   <div class="product-rating-section mt-4 border-top pt-3">
        <h3>Rate This Product</h3>
        <% if (isApproved) { %>
            <% if (userCanRate) { %>
                <form action="/products/<%= product._id %>/rate" method="POST" class="form-submit-spinner">
                    <div class="rating-stars">
                        <% for (let i = 5; i >= 1; i--) { %><input type="radio" id="star<%= i %>" name="rating" value="<%= i %>" <%= userRating === i ? 'checked' : '' %> required><label for="star<%= i %>" title="<%= i %> stars"><i class="fas fa-star"></i></label><% } %>
                    </div>
                    <button type="submit" class="btn btn-primary btn-sm">Submit Rating</button>
                </form>
            <% } else { %>
               <p><a href="/auth/login?returnTo=<%= encodeURIComponent(currentUrl) %>">Login</a> to rate this product.</p>
            <% } %>
         <% } else { %>
             <p class="text-muted">Rating is unavailable until the product is approved.</p>
         <% } %>
   </div>

    <%# Rating Stats Display %>
    <div class="rating-stats-container mt-4 border-top pt-3">
        <h3>Ratings & Reviews Summary</h3>
         <% if (totalRatings > 0) { %>
             <div class="rating-summary mb-3">
                 <div class="rating-average">
                     <span class="rating-average-value"><%= product.averageRating.toFixed(1) %></span> <i class="fas fa-star text-warning"></i>
                 </div>
                 <div class="rating-total text-muted small">
                     Based on <%= totalRatings %> Rating<%= totalRatings !== 1 ? 's' : '' %>
                 </div>
             </div>
            <div class="rating-bars">
                <% for (let i = 5; i >= 1; i--) {
                      const count = ratingCounts[i] || 0;
                      const percentage = totalRatings > 0 ? (count / totalRatings) * 100 : 0;
                 %>
                     <div class="rating-bar-row">
                         <span class="rating-bar-label small"><%= i %> <i class="fas fa-star text-warning"></i></span>
                         <div class="rating-bar-progress progress" style="height: 8px;">
                             <div class="rating-bar-fill progress-bar bg-success" role="progressbar" data-width="<%= percentage.toFixed(1) %>" aria-valuenow="<%= percentage.toFixed(1) %>" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"></div>
                         </div>
                         <span class="rating-bar-count small text-muted"><%= count %></span>
                     </div>
                 <% } %>
            </div>
        <% } else { %>
            <p>No ratings yet for this product.</p>
         <% } %>
    </div>

</div> <%# End product-detail-container %>

<%- include('../partials/footer') %>

views/products/index.ejs:
<%# views/products/index.ejs %>
<%- include('../partials/header', { title: title }) %>

<%# --- Category Icons Section (Uses new CSS) --- %>
<% if (typeof displayCategories !== 'undefined' && displayCategories.length > 0) { %>
    <div class="category-icons-section mb-4">
        <div class="category-grid">
            <% displayCategories.forEach(cat => { %>
                <% let categoryUrl = '/?category=' + encodeURIComponent(cat.name); %>
                <%# Keep search term if user is filtering category *after* a search %>
                <% if (typeof searchTerm !== 'undefined' && searchTerm) { categoryUrl += '&search=' + encodeURIComponent(searchTerm); } %>
                <a href="<%= categoryUrl %>"
                   class="category-item <%= (typeof selectedCategory !== 'undefined' && selectedCategory === cat.name) ? 'active' : '' %>"
                   title="Shop <%= cat.name %>">
                    <div class="category-icon-wrapper">
                         <img src="<%= cat.iconUrl %>"
                              alt="<%= cat.name %> Icon"
                              class="category-icon"
                              loading="lazy">
                    </div>
                    <span class="category-name"><%= cat.name %></span>
                </a>
            <% }) %>
        </div>
    </div>
<% } %>
<%# --- End: Category Icons Section --- %>


<%# --- Conditionally Display Banner Slider --- %>
<%# Only show the banner if NO category is selected AND NO search term is present %>
<% if (!selectedCategory && (!searchTerm || searchTerm.trim() === '')) { %>
    <% if (typeof homepageBanners !== 'undefined' && homepageBanners.length > 0) { %>
        <div class="banner-slider-container mb-4" data-slider-container>
            <%# --- ADDED WRAPPER --- %>
            <div class="banner-slides-wrapper" data-slides-wrapper>
                <% homepageBanners.forEach((banner, index) => { %>
                    <%# Slide content remains the same, REMOVE active class %>
                    <div class="banner-slide" data-slide>
                        <% if (banner.linkUrl) { %>
                            <a href="<%= banner.linkUrl %>" rel="noopener noreferrer" class="banner-link">
                                <img src="<%= banner.imageUrl %>"
                                     alt="<%= banner.title || `Promotional Banner ${index + 1}` %>"
                                     class="banner-image"
                                     loading="lazy">
                            </a>
                        <% } else { %>
                            <img src="<%= banner.imageUrl %>"
                                 alt="<%= banner.title || `Promotional Banner ${index + 1}` %>"
                                 class="banner-image"
                                 loading="lazy">
                        <% } %>
                    </div>
                <% }) %>
                 <%# JS will add cloned slides here %>
            </div>
            <%# --- END ADDED WRAPPER --- %>

            <%# Optional: Navigation Arrows (keep outside wrapper) - Hidden initially by CSS %>
            <% if (homepageBanners.length > 1) { %>
                <button class="banner-nav banner-prev" data-slider-prev aria-label="Previous Banner"><i class="fas fa-chevron-left"></i></button>
                <button class="banner-nav banner-next" data-slider-next aria-label="Next Banner"><i class="fas fa-chevron-right"></i></button>
            <% } %>

            <%# Optional: Navigation Dots (keep outside wrapper) - Hidden initially by CSS %>
             <% if (homepageBanners.length > 1) { %>
                <div class="banner-dots" data-slider-dots>
                    <% homepageBanners.forEach((_, index) => { %>
                         <%# Remove active class, JS will handle it %>
                        <button class="banner-dot" data-slide-to="<%= index %>" aria-label="Go to banner <%= index + 1 %>"></button>
                    <% }) %>
                </div>
            <% } %>
        </div>
    <% } %>
<% } %>
<%# --- End: Homepage Banner Slider Section --- %>


<div class="product-index-container">
     <%# Display title based on filter/search %>
     <% if (selectedCategory) { %>
         <h1 class="mb-3"><%= selectedCategory %> Products</h1>
     <% } else if (searchTerm) { %>
         <h1 class="mb-3">Search Results for "<%= searchTerm %>"</h1>
     <% } else { %>
          <%# Only show "New Launches" if neither category nor search is active %>
          <h1 class="mb-3">New Launches</h1>
     <% } %>


    <%# Check if products array exists and has items %>
    <% if (typeof products !== 'undefined' && products.length > 0) { %>
        <div class="product-grid">
            <% products.forEach(product => { %>
                <%# Ensure product and its properties exist before accessing %>
                <% if (product && product._id && product.name && product.imageUrl && typeof product.price !== 'undefined' && typeof product.stock !== 'undefined') { %>
                    <div class="product-card">
                        <a href="/products/<%= product._id %>" class="product-link">
                            <img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="product-image" loading="lazy"> <%# Added lazy loading %>
                            <div class="product-info">
                                <h3 class="product-name"><%= product.name %></h3>
                                <p class="product-price">₹<%= (typeof product.price === 'number' ? product.price : 0).toFixed(2) %></p>
                                <p class="product-stock">Stock: <%= product.stock %></p>
                                <%# Display Rating %>
                                <% const numReviews = product.numReviews || 0; %>
                                <% const averageRating = product.averageRating || 0; %>
                                <% if (numReviews > 0) { %>
                                     <p class="product-rating">
                                        <% for(let i=1; i<=5; i++) { %>
                                            <i class="fas fa-star<%= i <= averageRating ? '' : (i - 0.5 <= averageRating ? '-half-alt' : '-regular') %>"></i>
                                        <% } %>
                                        (<%= numReviews %>)
                                     </p>
                                <% } else { %>
                                    <p class="product-rating" style="height: 1.2em;"> </p> <%# Keep space for alignment if no rating %>
                                <% } %>
                            </div>
                        </a>
                         <form action="/user/cart/add" method="POST" class="add-to-cart-form form-submit-spinner">
                             <input type="hidden" name="productId" value="<%= product._id %>">
                             <input type="hidden" name="quantity" value="1">
                            <button type="submit" class="btn btn-primary btn-add-to-cart" <%= product.stock <= 0 ? 'disabled' : '' %>>
                                <i class="fas fa-cart-plus"></i> <%= product.stock <= 0 ? 'Out of Stock' : 'Add to Cart' %>
                             </button>
                        </form>
                    </div>
                <% } %>
            <% }) %>
        </div>
    <% } else { %>
         <%# Display message if no products match filters or none exist %>
         <p class="alert alert-info mt-3"> <%# Added margin-top %>
             <% if (typeof searchTerm !== 'undefined' && searchTerm) { %>
                 No products found matching your search "<%= searchTerm %>". <a href="/" class="alert-link">Check back soon!</a>
             <% } else if (typeof selectedCategory !== 'undefined' && selectedCategory) { %>
                 No products found in the category "<%= selectedCategory %>". <a href="/" class="alert-link">Check back soon!</a>
             <% } else { %>
                 No products are currently available. Check back soon!
             <% } %>
         </p>
    <% } %>

</div>
<%- include('../partials/footer') %>

views/seller/dashboard.ejs:
<%- include('../partials/header', { title: 'Seller Dashboard' }) %>

<div class="admin-dashboard-container"> <%# Re-use admin style container %>
    <h1>Seller Dashboard</h1>
    <p class="text-muted mb-3">Manage your products and orders.</p>

    <div class="admin-actions-grid"> <%# Re-use admin style grid %>
         <a href="/seller/products/upload" class="admin-action-card">
            <i class="fas fa-upload text-primary"></i> <%# Added color class %>
            <h3>Upload Product</h3>
            <p>Add a new product to your listings.</p>
        </a>
         <a href="/seller/products" class="admin-action-card">
            <i class="fas fa-edit text-success"></i> <%# Added color class %>
            <h3>Manage Products</h3>
            <p>View status, edit, or remove your products.</p>
         </a>
        <a href="/seller/orders" class="admin-action-card">
             <i class="fas fa-clipboard-list text-info"></i> <%# Added color class %>
             <h3>Manage Orders</h3>
             <p>View and manage orders containing your products.</p>
        </a>

        <%# The "My Profile" card linking to /user/profile has been removed %>

    </div>
</div>

<%- include('../partials/footer') %>

views/seller/edit-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1><%= title %></h1>
    <p class="text-muted small mb-3">Updating the product will reset its status to 'pending' and trigger a new review.</p>

     <form action="/seller/products/update/<%= product._id %>" method="POST" class="form-submit-spinner">
         <div class="alert alert-<%= product.reviewStatus === 'approved' ? 'success' : (product.reviewStatus === 'rejected' ? 'danger' : 'warning') %>" role="alert">
           <strong>Current Status:</strong> <span class="text-capitalize"><%= product.reviewStatus %></span>
           <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %>
            <br><strong>Rejection Reason:</strong> <%= product.rejectionReason %>
           <% } %>
         </div>

        <div class="form-group">
             <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= product.name %>" required>
         </div>
        <div class="form-group">
            <label for="shortDescription">Short Description (Optional):</label>
            <textarea id="shortDescription" name="shortDescription" class="form-control" rows="2"><%= product.shortDescription || '' %></textarea>
        </div>
        <div class="form-group">
            <label for="category">Category:</label>
            <select id="category" name="category" class="form-control" required>
                <option value="" disabled <%= !product.category ? 'selected' : '' %>>Select a Category</option>
                <% if (typeof categories !== 'undefined') { %>
                    <% categories.forEach(cat => { %>
                        <option value="<%= cat.name %>" <%= (product.category === cat.name) ? 'selected' : '' %>><%= cat.name %></option>
                    <% }) %>
                <% } %>
            </select>
        </div>
         <div class="form-group">
            <label for="price">Price (₹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= product.price %>" required>
         </div>
        <div class="form-group">
             <label for="stock">Stock Quantity:</label>
             <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= product.stock %>" required>
        </div>
         <div class="form-group">
             <label for="imageUrl">Image URL (Primary):</label>
             <input type="url" id="imageUrl" name="imageUrl" class="form-control" value="<%= product.imageUrl %>" required>
             <% if(product.imageUrl) { %>
                <img src="<%= product.imageUrl %>" alt="Current Image" style="max-width: 100px; margin-top: 5px; border: 1px solid #ddd; padding: 2px;">
             <% } %>
         </div>
         <!-- --- UPDATED: Add Second Image URL Input --- -->
         <div class="form-group">
             <label for="imageUrl2">Second Image URL (Optional):</label>
             <input type="url"
                    id="imageUrl2"
                    name="imageUrl2"
                    class="form-control"
                    placeholder="https://example.com/image_alt.jpg"
                    value="<%= (typeof product !== 'undefined' && product.imageUrl2) ? product.imageUrl2 : '' %>">
              <%# Preview for edit forms %>
              <% if (typeof product !== 'undefined' && product.imageUrl2) { %>
                 <img src="<%= product.imageUrl2 %>" alt="Current Second Image" style="max-width: 100px; margin-top: 5px; border:1px solid #ccc; padding:2px;">
              <% } %>
         </div>
         <!-- --- END UPDATED --- -->
         <div class="form-group">
             <label for="specifications">Specifications (Optional):</label>
             <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= product.specifications %></textarea>
        </div>
         <button type="submit" class="btn btn-primary">Update & Resubmit for Review</button>
         <a href="/seller/products" class="btn btn-secondary">Cancel</a>
    </form>
 </div>

 <%- include('../partials/footer') %>

views/seller/manage-orders.ejs:
<%# views/seller/manage-orders.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container order-manage-page">
    <h1>Manage Your Orders</h1>
    <p class="text-muted small mb-3">Showing orders that contain one or more of your products.</p>

    <%# --- ADD FILTER INPUT --- %>
    <div class="form-group mb-3">
        <label for="order-filter-input" class="visually-hidden">Filter Orders:</label>
        <input type="text" id="order-filter-input" class="form-control" placeholder="Type to filter orders (ID, Name, Email, Product, Status...)" aria-label="Filter Orders">
    </div>
    <%# --- END FILTER INPUT --- %>


    <% if (message) { %>
        <p class="alert alert-info"><%= message %></p>
    <% } %>

    <% if (orders.length > 0) { %>
        <div class="table-container">
            <table class="data-table order-table" id="seller-order-table"> <%# Added ID %>
                <thead>
                    <tr>
                        <th>Order ID / Date</th>
                        <th>Customer / Address</th>
                        <th>Items (Your items highlighted)</th>
                        <th>Total</th>
                        <th>Status</th>
                        <th class="actions-cell">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <% orders.forEach(order => { %>
                         <%# Added class="order-row" %>
                        <tr class="status-<%= order.status.toLowerCase().replace(/ /g, '-') %> order-row" data-order-id="<%= order._id %>">
                            <td data-label="Order ID / Date">
                                <%= order._id %><br>
                                <small class="text-muted"><%= formatDateIST(order.orderDate) %></small>
                            </td>
                            <td data-label="Customer / Address">
                                <strong><%= order.shippingAddress.name %></strong><br>
                                <small class="text-muted"><%= order.userEmail || order.userId?.email %></small><br>
                                <small class="text-muted"><%= order.shippingAddress.cityVillage %>, <%= order.shippingAddress.pincode %></small><br>
                                <small><strong>Ph:</strong> <%= order.shippingAddress.phone %></small>
                            </td>
                            <td data-label="Items">
                                <div class="order-items-summary">
                                    <%- order.itemsSummary %>
                                </div>
                                <% if (order.products && order.products.length > 0) { %>
                                    <div class="order-items-images">
                                        <% order.products.forEach(item => { %>
                                            <% if (item.productId && item.productId._id && item.productId.imageUrl) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" title="View <%= item.productId.name || 'Product' %>">
                                                    <img src="<%= item.productId.imageUrl %>"
                                                         alt="<%= item.productId.name || 'Product Image' %>"
                                                         class="order-item-thumbnail" loading="lazy">
                                                </a>
                                            <% } else if (item.productId && item.productId._id) { %>
                                                <a href="/products/<%= item.productId._id %>" target="_blank" class="order-item-thumbnail-placeholder" title="View <%= item.productId.name || 'Product' %>">[No Img]</a>
                                            <% } else { %>
                                                <span class="order-item-thumbnail-placeholder" title="Product data missing">[N/A]</span>
                                            <% } %>
                                        <% }) %>
                                    </div>
                                <% } %>
                            </td>
                            <td data-label="Total" class="order-total"><strong>₹<%= order.totalAmount.toFixed(2) %></strong></td>
                            <td data-label="Status" class="order-status-cell">
                                <span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span>
                                <% if(order.status === 'Cancelled' && order.cancellationReason) { %>
                                    <br><small class="text-danger mt-1 d-block">Reason:<br><%= order.cancellationReason %></small>
                                <% } %>
                                <% if(order.status === 'Delivered' && order.receivedByDate) { %><br><small class="text-success mt-1 d-block">Delivered:<br><%= formatDateIST(order.receivedByDate) %></small><% } %>
                                <% if (order.showDeliveryOtp && order.status === 'Pending') { %>
                                  <div class="delivery-otp-display mt-1">
                                    <p>Customer OTP Sent</p>
                                    <small class="text-muted">Ask customer for code: <strong class="delivery-otp-code">****<%= order.orderOTP ? order.orderOTP.slice(-2) : 'XX' %></strong></small>
                                  </div>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                                <%# Seller Direct Delivery Confirmation %>
                                <% if (order.canBeDirectlyDeliveredBySeller) { %>
                                    <div class="action-group mb-2">
                                        <p class="action-group-title">Confirm Delivery:</p>
                                        <% if (!order.showDeliveryOtp) { %>
                                            <form action="/seller/orders/<%= order._id %>/send-otp" method="POST" class="inline-form form-submit-spinner mb-1">
                                                <button type="submit" class="btn btn-warning btn-sm w-100 w-md-auto" title="Send OTP to customer to confirm delivery">
                                                    <i class="fas fa-mobile-alt"></i> Send OTP
                                                </button>
                                            </form>
                                        <% } %>
                                        <form action="/seller/orders/<%= order._id %>/confirm-delivery" method="POST" class="inline-form verify-otp-form form-submit-spinner">
                                            <input type="text" name="otp" placeholder="Enter OTP" required pattern="\d{6}" maxlength="6" inputmode="numeric" title="Enter 6-digit OTP from customer">
                                            <button type="submit" class="btn btn-success btn-sm" title="Confirm delivery using customer's OTP">
                                                <i class="fas fa-check-double"></i> Confirm
                                            </button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Seller Order Cancellation Form %>
                                <% if (order.canBeCancelledBySeller) { %>
                                    <div class="action-group">
                                        <form action="/seller/orders/<%= order._id %>/cancel" method="POST" class="cancel-delivery-form form-submit-spinner" onsubmit="return confirm('SELLER ACTION: Are you sure you want to cancel your items in order <%= order._id %>? This action cannot be undone.');">
                                            <label for="reason-<%= order._id %>" class="action-group-title">Cancel Your Items:</label>
                                            <select name="reason" id="reason-<%= order._id %>" required class="form-control form-control-sm d-block mb-1">
                                                <option value="" disabled selected>Select Seller Reason...</option>
                                                <% if (typeof sellerCancellationReasons !== 'undefined' && sellerCancellationReasons.length > 0) { %>
                                                    <% sellerCancellationReasons.forEach(reason => { %>
                                                        <option value="<%= reason %>"><%= reason %></option>
                                                    <% }) %>
                                                <% } else { %>
                                                    <option value="Other Reason (Seller)" selected>Other Reason (Seller)</option> <%# Fallback %>
                                                <% } %>
                                            </select>
                                            <button type="submit" class="btn btn-danger btn-sm w-100 w-md-auto"><i class="fas fa-ban"></i> Cancel Items</button>
                                        </form>
                                    </div>
                                <% } %>

                                <%# Fallback for no actions %>
                                <% if (!order.canBeDirectlyDeliveredBySeller && !order.canBeCancelledBySeller) { %>
                                     <small class="text-muted no-actions-text">
                                         <% if (order.status === 'Delivered') { %>Completed<% } else if (order.status === 'Cancelled') { %>Cancelled<% } else { %>No actions available<% } %>
                                    </small>
                                <% } %>
                            </td>
                        </tr>
                    <% }) %>
                    <%# --- ADD NO RESULTS ROW --- %>
                    <tr id="no-seller-orders-found" class="hidden">
                        <td colspan="6" class="text-center text-muted p-3">No orders match your filter.</td>
                    </tr>
                    <%# --- END NO RESULTS ROW --- %>
                </tbody>
            </table>
        </div>
    <% } else if (!message) { %>
        <p class="alert alert-info">No orders containing your products found.</p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/seller/manage-products.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1>Manage Your Products</h1>
    <a href="/seller/products/upload" class="btn btn-primary mb-3"><i class="fas fa-plus"></i> Upload New Product</a>

    <%# --- ADD FILTER INPUT --- %>
    <div class="form-group mb-3"> <%# Added mb-3 for spacing %>
        <label for="seller-product-filter-input" class="visually-hidden">Filter Your Products:</label>
        <input type="text" id="seller-product-filter-input" class="form-control" placeholder="Type to filter your products (Name, Category, Status...)" aria-label="Filter Your Products">
    </div>
    <%# --- END FILTER INPUT --- %>

   <% if (products.length > 0) { %>
       <div class="table-container card">
           <%# --- Added ID to table --- %>
           <table class="data-table" id="seller-product-table">
               <thead>
                   <tr>
                       <th>Image</th>
                       <th>Name</th>
                       <th>Price</th>
                       <th>Stock</th>
                       <th>Status</th>
                       <th>Reason</th>
                       <th class="actions-cell" style="text-align: right;">Actions</th>
                   </tr>
                </thead>
                <tbody>
                   <% products.forEach(product => { %>
                       <%# --- Added class="product-row" --- %>
                       <tr class="status-<%= product.reviewStatus %> product-row" data-product-id="<%= product._id %>">
                           <td data-label="Image"><a href="/products/<%= product._id %>"><img src="<%= product.imageUrl %>" alt="<%= product.name %>" class="table-img"></a></td>
                            <td data-label="Name"><%= product.name %><br><small class="text-muted"><%= product.category %></small></td>
                            <td data-label="Price">₹<%= product.price.toFixed(2) %></td>
                            <td data-label="Stock"><%= product.stock %></td>
                            <td data-label="Status">
                                <span class="status-badge status-<%= product.reviewStatus %> text-capitalize">
                                    <%= product.reviewStatus %>
                                </span>
                            </td>
                             <td data-label="Reason">
                                <% if(product.reviewStatus === 'rejected' && product.rejectionReason) { %>
                                    <small class="text-danger"><%= product.rejectionReason %></small>
                                <% } else { %>
                                    <span class="text-muted">--</span>
                                <% } %>
                            </td>
                            <td data-label="Actions" class="actions-cell">
                               <%# Edit button always available, triggers re-review %>
                               <a href="/seller/products/edit/<%= product._id %>" class="btn btn-text btn-sm" title="Edit Product"><i class="fas fa-edit"></i> Edit</a>

                               <form action="/seller/products/remove/<%= product._id %>" method="POST" class="inline-form form-submit-spinner" onsubmit="return confirm('Are you sure you want to permanently remove this product: <%= product.name %>?');">
                                    <button type="submit" class="btn btn-text btn-danger btn-sm" title="Remove Product"><i class="fas fa-trash"></i> Remove</button>
                               </form>
                           </td>
                        </tr>
                    <% }) %>
                     <%# --- ADD NO RESULTS ROW --- %>
                     <tr id="no-seller-products-found" class="hidden">
                         <td colspan="7" class="text-center text-muted p-3">No products match your filter.</td> <%# Adjusted colspan %>
                     </tr>
                     <%# --- END NO RESULTS ROW --- %>
               </tbody>
            </table>
       </div>
   <% } else { %>
        <p class="text-muted mt-3">You haven't uploaded any products yet. <a href="/seller/products/upload">Upload your first product!</a></p>
   <% } %>
</div>

<%- include('../partials/footer') %>

views/seller/upload-product.ejs:
<%- include('../partials/header', { title: title }) %>

<div class="admin-manage-container"> <%# Reuse admin style %>
    <h1>Upload New Product</h1>
    <p class="text-muted small mb-3">Your product will be submitted for automatic review upon upload.</p>

    <form action="/seller/products/upload" method="POST" class="form-submit-spinner">
        <div class="form-group">
            <label for="name">Product Name:</label>
            <input type="text" id="name" name="name" class="form-control" value="<%= typeof product !== 'undefined' ? product.name : '' %>" required>
        </div>
        <div class="form-group">
            <label for="shortDescription">Short Description (Optional):</label>
            <textarea id="shortDescription" name="shortDescription" class="form-control" rows="2"><%= typeof product !== 'undefined' ? product.shortDescription : '' %></textarea>
        </div>
        <div class="form-group">
            <label for="category">Category:</label>
            <select id="category" name="category" class="form-control" required>
                 <option value="" disabled <%= !(typeof product !== 'undefined' && product.category) ? 'selected' : '' %>>Select a Category</option>
                <% if (typeof categories !== 'undefined') { %>
                    <% categories.forEach(cat => { %>
                        <option value="<%= cat.name %>" <%= (typeof product !== 'undefined' && product.category === cat.name) ? 'selected' : '' %>><%= cat.name %></option>
                    <% }) %>
                <% } %>
            </select>
        </div>
        <div class="form-group">
            <label for="price">Price (₹):</label>
            <input type="number" id="price" name="price" class="form-control" step="0.01" min="0" value="<%= typeof product !== 'undefined' ? product.price : '' %>" required>
        </div>
        <div class="form-group">
            <label for="stock">Stock Quantity:</label>
            <input type="number" id="stock" name="stock" class="form-control" min="0" value="<%= typeof product !== 'undefined' ? product.stock : '' %>" required>
        </div>
        <div class="form-group">
            <label for="imageUrl">Image URL (Primary):</label>
            <input type="url" id="imageUrl" name="imageUrl" class="form-control" placeholder="https://example.com/image.jpg" value="<%= typeof product !== 'undefined' ? product.imageUrl : '' %>" required>
        </div>
        <!-- --- UPDATED: Add Second Image URL Input --- -->
        <div class="form-group">
            <label for="imageUrl2">Second Image URL (Optional):</label>
            <input type="url"
                   id="imageUrl2"
                   name="imageUrl2"
                   class="form-control"
                   placeholder="https://example.com/image_alt.jpg"
                   value="<%= (typeof product !== 'undefined' && product.imageUrl2) ? product.imageUrl2 : '' %>">
        </div>
        <!-- --- END UPDATED --- -->
        <div class="form-group">
            <label for="specifications">Specifications (Optional):</label>
            <textarea id="specifications" name="specifications" class="form-control" rows="5"><%= typeof product !== 'undefined' ? product.specifications : '' %></textarea>
        </div>
        <button type="submit" class="btn btn-primary">Upload & Submit for Review</button>
        <a href="/seller/dashboard" class="btn btn-secondary">Cancel</a>
    </form>
</div>

<%- include('../partials/footer') %>

views/user/cart.ejs:
<%# views/user/cart.ejs %>
<%- include('../partials/header', { title: 'Shopping Cart' }) %>

<div class="cart-container">
    <h1>Your Shopping Cart</h1>

    <% if (cart.length > 0) { %>
        <div class="cart-items">
            <% cart.forEach(item => { %>
                <div class="cart-item" data-product-id="<%= item.productId %>">
                    <div class="cart-item-image">
                        <a href="/products/<%= item.productId %>"><img src="<%= item.imageUrl %>" alt="<%= item.name %>"></a>
                    </div>
                    <div class="cart-item-details">
                        <h3 class="cart-item-name"><%= item.name %></h3>
                        <p class="cart-item-price">₹<%= (typeof item.price === 'number' ? item.price : 0).toFixed(2) %></p>
                        <p class="cart-item-stock">Stock: <%= item.stock %></p>
                    </div>
                    <div class="cart-item-quantity">
                        <label for="quantity-<%= item.productId %>" class="visually-hidden">Quantity for <%= item.name %></label> <%# Added visually-hidden label %>
                        <input type="number"
                               id="quantity-<%= item.productId %>"
                               class="quantity-input" <%# Use class for consistency %>
                               name="quantity"
                               value="<%= item.quantity %>"
                               min="0"
                               max="<%= item.stock %>"
                               data-product-id="<%= item.productId %>"
                               data-item-price="<%= item.price %>"
                               aria-label="Quantity for <%= item.name %>">
                        <button class="btn btn-secondary btn-sm btn-update-qty" data-product-id="<%= item.productId %>">Add</button> <%# Spinner handled by AJAX logic %>
                     </div>
                     <div class="cart-item-subtotal">
                         Total: ₹<span class="item-subtotal-value"><%= (typeof item.subtotal === 'number' ? item.subtotal : 0).toFixed(2) %></span>
                    </div>
                    <div class="cart-item-remove">
                        <form action="/user/cart/remove/<%= item.productId %>" method="POST" class="form-submit-spinner">
                            <button type="submit" class="btn btn-danger btn-sm">× Remove</button>
                         </form>
                     </div>
                </div>
            <% }) %>
        </div>

         <div class="cart-summary">
             <h2>Cart Total: ₹<span id="cart-total-value"><%= (typeof cartTotal === 'number' ? cartTotal : 0).toFixed(2) %></span></h2>
             <%# --- ADDED ID and loading state attributes --- %>
             <a href="/user/checkout"
                id="btn-proceed-checkout" <%# ADDED ID %>
                class="btn btn-success btn-checkout"
                data-loading-text="<i class='fas fa-spinner fa-spin'></i> Proceeding..." <%# ADDED loading text data attribute %>
                >Proceed to Checkout</a>
        </div>

    <% } else { %>
        <%# Updated empty cart message to use alert style %>
        <p class="alert alert-info mt-3">Your cart is empty. <a href="/" class="alert-link">Continue Shopping</a></p>
    <% } %>
</div>

 <%- include('../partials/footer') %>

views/user/checkout.ejs:
<%# views/user/checkout.ejs %>
<%- include('../partials/header', { title: 'Checkout' }) %>

<div class="checkout-container">
    <h1>Checkout</h1>

    <div class="checkout-grid">
        <div class="checkout-address">
            <h2>Shipping Address</h2>
            <%# Display Saved Address %>
            <div class="saved-address <%= (!userAddress || !userAddress.name) ? 'hidden' : '' %>">
                <% if (userAddress && userAddress.name) { %>
                    <p class="mb-1"><strong><%= userAddress.name %></strong></p>
                    <p class="mb-1"><%= userAddress.phone %></p>
                    <p class="mb-1">
                        <%# Display House/Area first %>
                        <%= userAddress.cityVillage ? userAddress.cityVillage + ', ' : '' %>
                        <%# Landmark Optional %>
                        <%= userAddress.landmarkNearby ? userAddress.landmarkNearby + ', ' : '' %>
                        <%# Locality %>
                        <%= userAddress.locality ? userAddress.locality + ', ' : '' %>
                        <%# Derived Fields %>
                        <%= userAddress.mandal ? userAddress.mandal + ', ' : '' %>
                        <%= userAddress.district ? userAddress.district + ', ' : '' %>
                        <%= userAddress.state ? userAddress.state + ' - ' : '' %>
                        <%= userAddress.pincode %>
                    </p>
                    <button type="button" id="edit-address-btn" class="btn btn-secondary btn-sm mt-2">Edit Address</button>
                <% } else { %>
                    <%# This part is less likely needed if checkout requires address, but keep for robustness %>
                    <p class="text-muted">No address found. Please add one below.</p>
                <% } %>
            </div>

            <%# Address Form %>
            <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (userAddress && userAddress.name) ? 'hidden' : '' %> form-submit-spinner">
                 <h3 class="h5"><%= (userAddress && userAddress.name) ? 'Edit Address' : 'Add Shipping Address' %></h3>
                 <input type="hidden" name="source" value="checkout">

                 <div class="form-group">
                     <label for="checkout-name-addr" class="form-label small">Full Name:</label>
                     <input type="text" id="checkout-name-addr" name="name" class="form-control" value="<%= addressFormData?.name || userAddress?.name || '' %>" required autocomplete="name">
                 </div>
                 <div class="form-group">
                     <label for="checkout-phone" class="form-label small">Phone Number:</label>
                     <input type="tel" id="checkout-phone" name="phone" class="form-control" value="<%= addressFormData?.phone || userAddress?.phone || '' %>" required pattern="\d{10,15}" minlength="10" maxlength="15" title="Enter 10 to 15 digit phone number" autocomplete="tel">
                 </div>
                 <div class="form-group">
                    <label for="checkout-pincode" class="form-label small">Pincode:</label>
                    <input type="text"
                           id="checkout-pincode"
                           name="pincode"
                           class="form-control pincode-input"
                           data-target-prefix="checkout"
                           value="<%= addressFormData?.pincode || userAddress?.pincode || '' %>"
                           required pattern="\d{6}" maxlength="6" inputmode="numeric"
                           title="Enter 6-digit Pincode" autocomplete="postal-code">
                    <small class="pincode-status text-muted"></small>
                </div>

                <%# --- NEW: Locality Dropdown --- %>
                <div class="form-group">
                    <label for="checkout-locality" class="form-label small">Locality / Post Office:</label>
                    <select id="checkout-locality"
                            name="locality"
                            class="form-control"
                            required
                            disabled
                            data-saved-value="<%= addressFormData?.locality || userAddress?.locality || '' %>">
                        <option value="" selected disabled>Enter Pincode First</option>
                        <%# Options will be populated by JavaScript %>
                    </select>
                    <small class="locality-status text-muted"></small>
                </div>
                <%# --- End: Locality Dropdown --- %>

                <%# Auto-filled Fields Container %>
                <div class="auto-filled-fields-container mb-2" id="checkout-auto-filled-fields"
                     style="<%= (addressFormData?.state || userAddress?.state) ? 'display: block;' : 'display: none;' %>">
                    <div class="form-group">
                       <label for="checkout-mandal" class="form-label small">Mandal / Taluk:</label>
                       <input type="text" id="checkout-mandal" class="form-control auto-filled-field" value="<%= addressFormData?.mandal || userAddress?.mandal || '' %>" readonly tabindex="-1">
                   </div>
                    <div class="form-group">
                       <label for="checkout-district" class="form-label small">District:</label>
                       <input type="text" id="checkout-district" class="form-control auto-filled-field" value="<%= addressFormData?.district || userAddress?.district || '' %>" readonly tabindex="-1">
                   </div>
                   <div class="form-group">
                       <label for="checkout-state" class="form-label small">State:</label>
                       <input type="text" id="checkout-state" class="form-control auto-filled-field" value="<%= addressFormData?.state || userAddress?.state || '' %>" readonly tabindex="-1">
                   </div>
                </div>

                <%# Hidden Inputs to Submit Derived Data %>
                <input type="hidden" id="checkout-mandal-hidden" name="mandal" value="<%= addressFormData?.mandal || userAddress?.mandal || '' %>">
                <input type="hidden" id="checkout-district-hidden" name="district" value="<%= addressFormData?.district || userAddress?.district || '' %>">
                <input type="hidden" id="checkout-state-hidden" name="state" value="<%= addressFormData?.state || userAddress?.state || '' %>">

                <div class="form-group">
                    <label for="checkout-cityVillage" class="form-label small">House No. / Building / Area:</label>
                    <input type="text" id="checkout-cityVillage" name="cityVillage" class="form-control" value="<%= addressFormData?.cityVillage || userAddress?.cityVillage || '' %>" required autocomplete="address-line1" placeholder="E.g., #123, Green Apartments">
                </div>
                 <div class="form-group">
                    <label for="checkout-landmarkNearby" class="form-label small">Landmark (Optional):</label>
                    <input type="text" id="checkout-landmarkNearby" name="landmarkNearby" class="form-control" value="<%= addressFormData?.landmarkNearby || userAddress?.landmarkNearby || '' %>" autocomplete="address-line2" placeholder="E.g., Near City Hospital">
                 </div>
                <button type="submit" class="btn btn-primary me-2">Save Address</button>
                 <button type="button" id="cancel-edit-btn" class="btn btn-secondary <%= (!userAddress || !userAddress.name) ? 'hidden' : '' %>">Cancel Edit</button>
             </form>
        </div>

         <div class="checkout-summary">
             <h2>Order Summary</h2>
             <div class="checkout-items">
                 <% items.forEach(item => { %>
                    <div class="checkout-item">
                         <a href="/products/<%= item.productId %>" class="checkout-item-image">
                            <img src="<%= item.imageUrl %>" alt="<%= item.name %>">
                        </a>
                        <div class="checkout-item-info">
                             <%= item.name %> (Qty: <%= item.quantity %>)
                        </div>
                        <div class="checkout-item-price">₹<%= item.itemTotal.toFixed(2) %></div>
                     </div>
                <% }) %>
            </div>
            <hr>
            <div class="checkout-totals">
                <p>Subtotal: <span>₹<%= subTotal.toFixed(2) %></span></p>
                 <p>Shipping: <span>FREE</span></p>
                <hr>
                 <p><strong>Total: <span>₹<%= totalAmount.toFixed(2) %></span></strong></p>
            </div>

            <div class="checkout-payment">
                <h3>Payment Method</h3>
                 <div class="payment-option selected">
                     <input type="radio" id="cod" name="paymentMethodValue" value="COD" checked disabled>
                     <label for="cod"><i class="fas fa-money-bill-wave"></i> Cash on Delivery (COD)</label>
                 </div>
            </div>

            <form action="/orders/place" method="POST" class="place-order-form form-submit-spinner">
                 <input type="hidden" name="paymentMethod" value="COD">
                 <%# Check for existing user address OR addressFormData (if redirected after error) %>
                 <button type="submit" class="btn btn-success btn-block btn-place-order" <%= (!userAddress || !userAddress.name) && !addressFormData ? 'disabled' : '' %>>
                    Place Order
                 </button>
                 <% if ((!userAddress || !userAddress.name) && !addressFormData) { %>
                    <p class="text-danger small mt-1">Please add/save your shipping address first.</p>
                 <% } %>
             </form>
         </div>
    </div>
</div>

<%- include('../partials/footer') %>

views/user/my-orders.ejs:
<%# views/user/my-orders.ejs %>
<%- include('../partials/header', { title: 'My Orders' }) %>

<div class="my-orders-container">
    <h1>My Orders</h1>

    <% if (orders.length > 0) { %>
        <div class="order-list">
            <% orders.forEach(order => { %>
                <div class="order-card status-<%= order.status.toLowerCase().replace(/ /g, '-') %> mb-3"> <%# Add mb-3 for spacing %>
                     <div class="order-header">
                         <div><strong>Order ID:</strong><br><%= order._id %></div>
                         <div><strong>Placed on:</strong><br><%= formatDateIST(order.orderDate) %></div>
                         <div><strong>Total:</strong><br>₹<%= order.totalAmount.toFixed(2) %></div>
                         <div><strong>Status:</strong><br><span class="status-badge status-<%= order.status.toLowerCase().replace(/ /g, '-') %>"><%= order.status %></span></div>
                     </div>
                    <div class="order-body">
                         <%# Simplified item display (text) %>
                         <p class="mb-1"><strong>Items:</strong></p>
                         <div class="order-items-list mb-2">
                            <% order.products.forEach((item, index) => { %>
                                <small><%= item.name || '[Product Name Missing]' %> (Qty: <%= item.quantity %>) <% if(index < order.products.length - 1) { %> | <% } %></small>
                            <% }) %>
                         </div>

                         <%# --- NEW: Display Product Images --- %>
                         <div class="order-items-images mt-2">
                            <% order.products.forEach(item => { %>
                                <%# Check if product was populated and has necessary info %>
                                <% if (item.productId && item.productId._id && item.imageUrl) { %>
                                    <a href="/products/<%= item.productId._id %>" title="View <%= item.name || 'Product' %>">
                                        <img src="<%= item.imageUrl %>"
                                             alt="<%= item.name || 'Product Image' %>"
                                             class="order-item-thumbnail">
                                    </a>
                                <% } else if (item.productId && item.productId._id) { %>
                                    <%# Fallback if image URL is missing but product exists %>
                                    <a href="/products/<%= item.productId._id %>" class="order-item-thumbnail-placeholder" title="View <%= item.name || 'Product' %>">[No Img]</a>
                                <% } else { %>
                                    <%# Very basic fallback if productId is missing entirely %>
                                    <span class="order-item-thumbnail-placeholder">[Item NA]</span>
                                <% } %>
                            <% }) %>
                         </div>
                         <%# --- End: Display Product Images --- %>

                        <div class="order-details mt-3"> <%# Add margin-top for spacing %>
                             <p class="mb-1"><strong>Shipping To:</strong> <%= order.shippingAddress.name %>, <%= order.shippingAddress.cityVillage %>, Pin: <%= order.shippingAddress.pincode %></p>
                             <% if (order.status === 'Delivered' && order.receivedByDate) { %>
                                <p class="text-success mb-1"><small><strong>Delivered On:</strong> <%= formatDateIST(order.receivedByDate) %></small></p>
                              <% } %>
                              <%# Display cancellation reason if present %>
                              <% if (order.status === 'Cancelled' && order.cancellationReason) { %>
                                <p class="text-danger mb-1"><small><strong>Reason:</strong> <%= order.cancellationReason %></small></p>
                              <% } %>

                              <%# Display Delivery OTP for Customer %>
                              <% if (order.showDeliveryOtp) { %>
                                <div class="delivery-otp-display mt-2 p-2 border rounded bg-light">
                                    <p class="mb-1">
                                        <strong>Delivery OTP:</strong>
                                        <strong class="delivery-otp-code ms-1"><%= order.orderOTP %></strong> <%# Display full OTP %>
                                    </p>
                                    <small class="text-muted d-block">Provide this code to the delivery person (Seller/Admin).</small>
                                    <% if (order.orderOTPExpires) { %>
                                        <small class="text-muted d-block">Expires: <%= formatDateIST(order.orderOTPExpires) %></small>
                                    <% } %>
                                </div>
                              <% } %>
                              <%# End: Display Delivery OTP %>
                         </div>
                    </div>
                     <div class="order-actions text-end p-2 border-top"> <%# Adjusted padding/border %>
                        <% if (order.isCancellable) { %>
                            <form action="/orders/cancel/<%= order._id %>" method="POST" onsubmit="return confirm('Are you sure you want to cancel this order?');" class="form-submit-spinner d-inline-block">
                                <button type="submit" class="btn btn-danger btn-sm">Cancel Order</button>
                             </form>
                         <% } else if (order.status === 'Pending' && !order.showDeliveryOtp && order.cancellationAllowedUntil && new Date(order.cancellationAllowedUntil).getTime() < Date.now()) { %>
                             <small class="text-muted">Cancellation window closed.</small>
                         <% } else if (order.status === 'Pending' && !order.showDeliveryOtp) { %>
                            <small class="text-muted">Processing...</small>
                        <% } else if (order.status === 'Pending' && order.showDeliveryOtp) { %>
                             <small class="text-info">Awaiting delivery confirmation...</small>
                         <% } else if (order.status === 'Delivered') { %>
                              <small class="text-success">Order Completed.</small>
                         <% } else if (order.status === 'Cancelled') { %>
                              <small class="text-danger">Order Cancelled.</small>
                         <% } %>
                     </div>
                </div>
            <% }) %>
        </div>
    <% } else { %>
        <p>You haven't placed any orders yet. <a href="/">Start Shopping!</a></p>
    <% } %>
</div>

<%- include('../partials/footer') %>

views/user/profile.ejs:
<%# views/user/profile.ejs %>
<%- include('../partials/header', { title: title }) %>

<div class="profile-container">
    <%# --- Combine Welcome and Name Edit --- %>
    <div class="profile-header mb-4 d-flex align-items-center justify-content-center flex-wrap">
        <h1 class="mb-0 me-3">My Profile</h1>
        <div class="d-flex align-items-center">
            <span id="saved-name-display" class="fs-5 me-2">Hi, <strong id="display-user-name"><%= user.name %></strong></span>
            <button type="button" id="edit-name-btn" class="btn btn-text btn-sm" title="Edit Name"><i class="fas fa-edit"></i></button>
            <form action="/user/profile/update-name" method="POST" id="name-form" class="hidden inline-form align-items-center ms-2 form-submit-spinner">
                <label for="name-input" class="visually-hidden">New Name:</label>
                <input type="text" id="name-input" name="name" class="form-control form-control-sm me-2" value="<%= user.name %>" required minlength="2" placeholder="Enter new name">
                <button type="submit" class="btn btn-primary btn-sm me-1">Save</button>
                <button type="button" id="cancel-edit-name-btn" class="btn btn-secondary btn-sm">Cancel</button>
            </form>
        </div>
    </div>
    <p class="text-muted text-center small mb-3">Email: <strong><%= user.email %></strong></p>

    <%# --- My Orders Section --- %>
    <div class="profile-section orders-section mb-4">
        <h2>My Orders</h2>
        <div class="d-flex flex-wrap gap-2">
            <a href="/orders/my-orders" class="btn btn-secondary">
                <i class="fas fa-box"></i> View My Orders
            </a>
        </div>
    </div>

    <%# --- Conditional Dashboards Section --- %>
    <div class="profile-section dashboards-section mb-4">
        <h2>Dashboards</h2>
        <div class="d-flex flex-wrap gap-2">
            <% if (user.role === 'admin') { %>
                <a href="/admin/dashboard" class="btn btn-info"><i class="fas fa-user-shield"></i> Admin Dashboard</a>
            <% } %>
            <% if (user.role === 'seller') { %>
                <a href="/seller/dashboard" class="btn btn-success"><i class="fas fa-store"></i> Seller Dashboard</a>
            <% } %>
            <% if (user.role === 'user') { %>
                <p class="mb-0 align-self-center">Standard User Account</p>
            <% } %>
        </div>
    </div>

    <%# --- Address Management Section --- %>
    <div class="profile-section address-section mb-4">
        <h2>My Address</h2>
        <%# Display Saved Address %>
        <div id="saved-address-display" class="<%= (!user.address || !user.address.name) ? 'hidden' : '' %>">
            <% if (user.address && user.address.name) { %>
                <p class="mb-1"><strong><%= user.address.name %></strong></p>
                <p class="mb-1"><%= user.address.phone %></p>
                <p class="mb-1">
                    <%# Display House/Area first %>
                    <%= user.address.cityVillage ? user.address.cityVillage + ', ' : '' %>
                    <%# Landmark Optional %>
                    <%= user.address.landmarkNearby ? user.address.landmarkNearby + ', ' : '' %>
                    <%# Locality %>
                    <%= user.address.locality ? user.address.locality + ', ' : '' %>
                    <%# Derived Fields %>
                    <%= user.address.mandal ? user.address.mandal + ', ' : '' %>
                    <%= user.address.district ? user.address.district + ', ' : '' %>
                    <%= user.address.state ? user.address.state + ' - ' : '' %>
                    <%= user.address.pincode %>
                </p>
                <button type="button" id="edit-address-btn" class="btn btn-outline-secondary btn-sm mt-2">Edit Address</button>
            <% } else { %>
                <p class="text-muted">No address saved yet.</p>
                <button type="button" id="add-address-btn" class="btn btn-outline-primary btn-sm mt-2 hidden">Add Address</button>
            <% } %>
        </div>

        <%# Address Form %>
        <form action="/user/address/save" method="POST" id="address-form" class="address-form <%= (user.address && user.address.name) ? 'hidden' : '' %> form-submit-spinner mt-3">
            <h3 class="h5"><%= (user.address && user.address.name) ? 'Edit Address' : 'Add Address' %></h3>
            <input type="hidden" name="source" value="profile">

            <div class="form-group">
                <label for="profile-name-addr" class="form-label small">Full Name:</label>
                <input type="text" id="profile-name-addr" name="name" class="form-control" value="<%= addressFormData?.name || user.address?.name || '' %>" required autocomplete="name">
            </div>
            <div class="form-group">
                <label for="profile-phone" class="form-label small">Phone Number:</label>
                <input type="tel" id="profile-phone" name="phone" class="form-control" value="<%= addressFormData?.phone || user.address?.phone || '' %>" required pattern="\d{10,15}" minlength="10" maxlength="15" title="Enter 10 to 15 digit phone number" autocomplete="tel">
            </div>
            <div class="form-group">
                <label for="profile-pincode" class="form-label small">Pincode:</label>
                <input type="text"
                       id="profile-pincode"
                       name="pincode"
                       class="form-control pincode-input"
                       data-target-prefix="profile"
                       value="<%= addressFormData?.pincode || user.address?.pincode || '' %>"
                       required pattern="\d{6}" maxlength="6" inputmode="numeric"
                       title="Enter 6-digit Pincode" autocomplete="postal-code">
                <small class="pincode-status text-muted"></small>
            </div>

            <%# --- NEW: Locality Dropdown --- %>
            <div class="form-group">
                <label for="profile-locality" class="form-label small">Locality / Post Office:</label>
                <%# Populate dataset if editing/repopulating for JS pre-selection %>
                <select id="profile-locality"
                        name="locality"
                        class="form-control"
                        required
                        disabled
                        data-saved-value="<%= addressFormData?.locality || user.address?.locality || '' %>">
                    <option value="" selected disabled>Enter Pincode First</option>
                    <%# Options will be populated by JavaScript %>
                </select>
                <small class="locality-status text-muted"></small>
            </div>
            <%# --- End: Locality Dropdown --- %>

            <%# Auto-filled Fields Container %>
            <div class="auto-filled-fields-container mb-2" id="profile-auto-filled-fields"
                 style="<%= (addressFormData?.state || user.address?.state) ? 'display: block;' : 'display: none;' %>">
                <div class="form-group">
                    <label for="profile-mandal" class="form-label small">Mandal / Taluk:</label>
                    <input type="text" id="profile-mandal" class="form-control auto-filled-field" value="<%= addressFormData?.mandal || user.address?.mandal || '' %>" readonly tabindex="-1">
                </div>
                <div class="form-group">
                    <label for="profile-district" class="form-label small">District:</label>
                    <input type="text" id="profile-district" class="form-control auto-filled-field" value="<%= addressFormData?.district || user.address?.district || '' %>" readonly tabindex="-1">
                </div>
                <div class="form-group">
                    <label for="profile-state" class="form-label small">State:</label>
                    <input type="text" id="profile-state" class="form-control auto-filled-field" value="<%= addressFormData?.state || user.address?.state || '' %>" readonly tabindex="-1">
                </div>
            </div>

            <%# Hidden Inputs to Submit Derived Data %>
            <input type="hidden" id="profile-mandal-hidden" name="mandal" value="<%= addressFormData?.mandal || user.address?.mandal || '' %>">
            <input type="hidden" id="profile-district-hidden" name="district" value="<%= addressFormData?.district || user.address?.district || '' %>">
            <input type="hidden" id="profile-state-hidden" name="state" value="<%= addressFormData?.state || user.address?.state || '' %>">

            <div class="form-group">
                <label for="profile-cityVillage" class="form-label small">House No. / Building / Area:</label>
                <input type="text" id="profile-cityVillage" name="cityVillage" class="form-control" value="<%= addressFormData?.cityVillage || user.address?.cityVillage || '' %>" required autocomplete="address-line1" placeholder="E.g., #123, Green Apartments">
            </div>
            <div class="form-group">
                <label for="profile-landmarkNearby" class="form-label small">Landmark (Optional):</label>
                <input type="text" id="profile-landmarkNearby" name="landmarkNearby" class="form-control" value="<%= addressFormData?.landmarkNearby || user.address?.landmarkNearby || '' %>" autocomplete="address-line2" placeholder="E.g., Near City Hospital">
            </div>
            <button type="submit" class="btn btn-primary me-2">Save Address</button>
            <button type="button" id="cancel-edit-btn" class="btn btn-secondary <%= (!user.address || !user.address.name) ? 'hidden' : '' %>">Cancel Edit</button>
        </form>
    </div>

    <%# --- Logout Section --- %>
    <div class="profile-section logout-section mt-4 pt-3 border-top">
        <h2>Account Actions</h2>
        <form action="/auth/logout" method="POST" class="form-submit-spinner">
            <button type="submit" class="btn btn-danger"><i class="fas fa-sign-out-alt"></i> Logout</button>
        </form>
    </div>

</div>
<%- include('../partials/footer') %>

views/error.ejs:
<%- include('./partials/header', { title: 'Error' }) %>

<div class="error-container container">
    <h1>Error <%= typeof statusCode !== 'undefined' ? statusCode : '' %></h1>
    <p class="lead text-danger"><%= message %></p>

    <%# Use NODE_ENV from res.locals now %>
    <% if (NODE_ENV === 'development' && typeof stack !== 'undefined' && stack) { %>
        <details style="white-space: pre-wrap; margin-top: 20px; background: #f1f1f1; padding: 10px; border-radius: 5px; font-size: 0.8em;">
            <summary>Stack Trace (Development Mode)</summary>
            <code><%= stack %></code>
        </details>
    <% } %>

    <p style="margin-top: 20px;"><a href="/" class="btn btn-primary">Go back to Home</a></p>
</div>

<%- include('./partials/footer') %>

.env:
NODE_ENV=development
PORT=3000
MONGO_URI=mongodb+srv://ecommerce:ecommerce@cluster0.jcfuk.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0
SESSION_SECRET=e6142a6d230d0445c9b050af41bfd1e53ece6270797e546fbdaa97af20f3b77e # Use a strong, random secret
SESSION_MAX_AGE=86400000 # 1 day in milliseconds

# Email Configuration
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USER=ayyappanallamothu4@gmail.com
MAIL_PASS=yxor nmot lxmq skyc # Use an App Password if using Gmail 2FA
MAIL_FROM='"Surya Ecom" <ayyappanallamothu4@gmail.com>' # Ensure format is correct

# --- NEW: Add your Gemini API Key ---
GEMINI_API_KEY=AIzaSyCX31vkQ9Qf7t-ytSeDZUGR8hK4XZUHQT0

server.js:
// server.js
require('dotenv').config();
const express = require('express');
const path = require('path');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const flash = require('connect-flash');
const methodOverride = require('method-override');

const connectDB = require('./config/database');
const mainRouter = require('./routes/index');
const { notFound, errorHandler } = require('./middleware/errorMiddleware');
const { categories: siteCategories } = require('./config/categories');

connectDB();

const app = express();


app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));


app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));
app.use(methodOverride('_method'));


app.use(
  session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({
        mongoUrl: process.env.MONGO_URI,
        collectionName: 'sessions'
    }),
    cookie: {
        maxAge: parseInt(process.env.SESSION_MAX_AGE || '86400000', 10),
        httpOnly: true
        // secure: process.env.NODE_ENV === 'production',
        // sameSite: 'lax'
    }
  })
);


app.use(flash());


// Middleware to set res.locals
app.use((req, res, next) => {

  // Flash messages
  res.locals.success_msg = req.flash('success_msg');
  res.locals.error_msg = req.flash('error_msg');
  res.locals.error = req.flash('error'); // For general errors if needed

  // Current user info
  res.locals.currentUser = req.session.user || null;

  // URL info
  res.locals.currentUrl = req.originalUrl;
  res.locals.fullUrl = `${req.protocol}://${req.get('host')}${req.originalUrl}`;

  // Cart info
  res.locals.cartItemCount = req.session.user?.cart?.reduce((count, item) => count + (item.quantity || 0), 0) || 0;

  // User Initials calculation
  let userInitials = '??';
  if (req.session.user && req.session.user.name) {
    try {
      const nameParts = req.session.user.name.trim().split(' ');
      if (nameParts.length > 1 && nameParts[0] && nameParts[1]) {
          userInitials = (nameParts[0][0] + nameParts[nameParts.length - 1][0]).toUpperCase();
      } else if (nameParts.length === 1 && nameParts[0].length >= 2) {
          userInitials = nameParts[0].substring(0, 2).toUpperCase();
      } else if (nameParts.length === 1 && nameParts[0].length === 1) {
           userInitials = (nameParts[0][0] + nameParts[0][0]).toUpperCase();
      }
       else if (req.session.user.email) {
            const emailPrefix = req.session.user.email.split('@')[0];
            if (emailPrefix.length >= 2) { userInitials = emailPrefix.substring(0, 2).toUpperCase(); }
            else if (emailPrefix.length === 1) { userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase(); }
       }
    } catch (e) {
      console.error("Error generating initials:", e);
       if (req.session.user.email) {
            const emailPrefix = req.session.user.email.split('@')[0];
            if (emailPrefix.length >= 2) { userInitials = emailPrefix.substring(0, 2).toUpperCase(); }
            else if (emailPrefix.length === 1) { userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase(); }
       }
    }
  } else if (req.session.user && req.session.user.email) {
        const emailPrefix = req.session.user.email.split('@')[0];
        if (emailPrefix.length >= 2) { userInitials = emailPrefix.substring(0, 2).toUpperCase(); }
        else if (emailPrefix.length === 1) { userInitials = emailPrefix.toUpperCase() + emailPrefix.toUpperCase(); }
  }
  res.locals.userInitials = userInitials;

  // Date Formatter Helper
  res.locals.formatDateIST = (dateInput) => {
      if (!dateInput) return 'N/A';
      try {
          const date = new Date(dateInput);
          if (isNaN(date.getTime())) { return 'Invalid Date'; }
          const options = { timeZone: 'Asia/Kolkata', year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true };
          return date.toLocaleString('en-IN', options);
      } catch (error) {
          console.error("Error formatting date to IST:", error, "Input:", dateInput);
          return 'Date Error';
      }
  };

  // Site Defaults
  res.locals.defaultSiteName = 'miniapp';
  res.locals.NODE_ENV = process.env.NODE_ENV;
  res.locals.siteCategories = siteCategories;

  // **** ADDED: Handle addressFormData ****
  // Assign from session if exists, otherwise null. This makes it available to all templates.
  res.locals.addressFormData = req.session?.addressFormData || null;
  // Clean up session immediately after assigning to locals
  if (req.session?.addressFormData) {
      delete req.session.addressFormData;
  }
  // **** END: Handle addressFormData ****

  next(); // Proceed to the next middleware/route handler
});


// --- Routes ---
app.use('/', mainRouter);


// --- Error Handling ---
app.use(notFound);
app.use(errorHandler);


// --- Server Start ---
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});